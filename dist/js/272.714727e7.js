(self["webpackChunkmusic_face_recognition"]=self["webpackChunkmusic_face_recognition"]||[]).push([[272],{6741:function(e){function t(e){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}t.keys=function(){return[]},t.resolve=t,t.id=6741,e.exports=t},5787:function(e,t,n){var r=n(7976),a=TypeError;e.exports=function(e,t){if(r(t,e))return e;throw a("Incorrect invocation")}},4019:function(e){e.exports="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof DataView},260:function(e,t,n){"use strict";var r,a,s,i=n(4019),o=n(9781),l=n(7854),u=n(614),p=n(111),d=n(2597),c=n(648),h=n(6330),f=n(8880),m=n(8052),g=n(3070).f,y=n(7976),b=n(9518),w=n(7674),x=n(5112),v=n(9711),k=n(9909),I=k.enforce,S=k.get,N=l.Int8Array,T=N&&N.prototype,C=l.Uint8ClampedArray,_=C&&C.prototype,E=N&&b(N),A=T&&b(T),$=Object.prototype,F=l.TypeError,R=x("toStringTag"),D=v("TYPED_ARRAY_TAG"),M="TypedArrayConstructor",O=i&&!!w&&"Opera"!==c(l.opera),L=!1,P={Int8Array:1,Uint8Array:1,Uint8ClampedArray:1,Int16Array:2,Uint16Array:2,Int32Array:4,Uint32Array:4,Float32Array:4,Float64Array:8},z={BigInt64Array:8,BigUint64Array:8},B=function(e){if(!p(e))return!1;var t=c(e);return"DataView"===t||d(P,t)||d(z,t)},W=function(e){var t=b(e);if(p(t)){var n=S(t);return n&&d(n,M)?n[M]:W(t)}},V=function(e){if(!p(e))return!1;var t=c(e);return d(P,t)||d(z,t)},U=function(e){if(V(e))return e;throw F("Target is not a typed array")},G=function(e){if(u(e)&&(!w||y(E,e)))return e;throw F(h(e)+" is not a typed array constructor")},H=function(e,t,n,r){if(o){if(n)for(var a in P){var s=l[a];if(s&&d(s.prototype,e))try{delete s.prototype[e]}catch(i){try{s.prototype[e]=t}catch(u){}}}A[e]&&!n||m(A,e,n?t:O&&T[e]||t,r)}},j=function(e,t,n){var r,a;if(o){if(w){if(n)for(r in P)if(a=l[r],a&&d(a,e))try{delete a[e]}catch(s){}if(E[e]&&!n)return;try{return m(E,e,n?t:O&&E[e]||t)}catch(s){}}for(r in P)a=l[r],!a||a[e]&&!n||m(a,e,t)}};for(r in P)a=l[r],s=a&&a.prototype,s?I(s)[M]=a:O=!1;for(r in z)a=l[r],s=a&&a.prototype,s&&(I(s)[M]=a);if((!O||!u(E)||E===Function.prototype)&&(E=function(){throw F("Incorrect invocation")},O))for(r in P)l[r]&&w(l[r],E);if((!O||!A||A===$)&&(A=E.prototype,O))for(r in P)l[r]&&w(l[r].prototype,A);if(O&&b(_)!==A&&w(_,A),o&&!d(A,R))for(r in L=!0,g(A,R,{get:function(){return p(this)?this[D]:void 0}}),P)l[r]&&f(l[r],D,r);e.exports={NATIVE_ARRAY_BUFFER_VIEWS:O,TYPED_ARRAY_TAG:L&&D,aTypedArray:U,aTypedArrayConstructor:G,exportTypedArrayMethod:H,exportTypedArrayStaticMethod:j,getTypedArrayConstructor:W,isView:B,isTypedArray:V,TypedArray:E,TypedArrayPrototype:A}},9671:function(e,t,n){var r=n(9974),a=n(8361),s=n(7908),i=n(6244),o=function(e){var t=1==e;return function(n,o,l){var u,p,d=s(n),c=a(d),h=r(o,l),f=i(c);while(f-- >0)if(u=c[f],p=h(u,f,d),p)switch(e){case 0:return u;case 1:return f}return t?-1:void 0}};e.exports={findLast:o(0),findLastIndex:o(1)}},206:function(e,t,n){var r=n(1702);e.exports=r([].slice)},8544:function(e,t,n){var r=n(7293);e.exports=!r((function(){function e(){}return e.prototype.constructor=null,Object.getPrototypeOf(new e)!==e.prototype}))},7045:function(e,t,n){var r=n(6339),a=n(3070);e.exports=function(e,t,n){return n.get&&r(n.get,t,{getter:!0}),n.set&&r(n.set,t,{setter:!0}),a.f(e,t,n)}},3678:function(e){e.exports={IndexSizeError:{s:"INDEX_SIZE_ERR",c:1,m:1},DOMStringSizeError:{s:"DOMSTRING_SIZE_ERR",c:2,m:0},HierarchyRequestError:{s:"HIERARCHY_REQUEST_ERR",c:3,m:1},WrongDocumentError:{s:"WRONG_DOCUMENT_ERR",c:4,m:1},InvalidCharacterError:{s:"INVALID_CHARACTER_ERR",c:5,m:1},NoDataAllowedError:{s:"NO_DATA_ALLOWED_ERR",c:6,m:0},NoModificationAllowedError:{s:"NO_MODIFICATION_ALLOWED_ERR",c:7,m:1},NotFoundError:{s:"NOT_FOUND_ERR",c:8,m:1},NotSupportedError:{s:"NOT_SUPPORTED_ERR",c:9,m:1},InUseAttributeError:{s:"INUSE_ATTRIBUTE_ERR",c:10,m:1},InvalidStateError:{s:"INVALID_STATE_ERR",c:11,m:1},SyntaxError:{s:"SYNTAX_ERR",c:12,m:1},InvalidModificationError:{s:"INVALID_MODIFICATION_ERR",c:13,m:1},NamespaceError:{s:"NAMESPACE_ERR",c:14,m:1},InvalidAccessError:{s:"INVALID_ACCESS_ERR",c:15,m:1},ValidationError:{s:"VALIDATION_ERR",c:16,m:0},TypeMismatchError:{s:"TYPE_MISMATCH_ERR",c:17,m:1},SecurityError:{s:"SECURITY_ERR",c:18,m:1},NetworkError:{s:"NETWORK_ERR",c:19,m:1},AbortError:{s:"ABORT_ERR",c:20,m:1},URLMismatchError:{s:"URL_MISMATCH_ERR",c:21,m:1},QuotaExceededError:{s:"QUOTA_EXCEEDED_ERR",c:22,m:1},TimeoutError:{s:"TIMEOUT_ERR",c:23,m:1},InvalidNodeTypeError:{s:"INVALID_NODE_TYPE_ERR",c:24,m:1},DataCloneError:{s:"DATA_CLONE_ERR",c:25,m:1}}},6833:function(e,t,n){var r=n(8113);e.exports=/(?:ipad|iphone|ipod).*applewebkit/i.test(r)},5268:function(e,t,n){var r=n(4326),a=n(7854);e.exports="process"==r(a.process)},9974:function(e,t,n){var r=n(1702),a=n(9662),s=n(4374),i=r(r.bind);e.exports=function(e,t){return a(e),void 0===t?e:s?i(e,t):function(){return e.apply(t,arguments)}}},9518:function(e,t,n){var r=n(2597),a=n(614),s=n(7908),i=n(6200),o=n(8544),l=i("IE_PROTO"),u=Object,p=u.prototype;e.exports=o?u.getPrototypeOf:function(e){var t=s(e);if(r(t,l))return t[l];var n=t.constructor;return a(n)&&t instanceof n?n.prototype:t instanceof u?p:null}},7066:function(e,t,n){"use strict";var r=n(9670);e.exports=function(){var e=r(this),t="";return e.hasIndices&&(t+="d"),e.global&&(t+="g"),e.ignoreCase&&(t+="i"),e.multiline&&(t+="m"),e.dotAll&&(t+="s"),e.unicode&&(t+="u"),e.unicodeSets&&(t+="v"),e.sticky&&(t+="y"),t}},261:function(e,t,n){var r,a,s,i,o=n(7854),l=n(2104),u=n(9974),p=n(614),d=n(2597),c=n(7293),h=n(490),f=n(206),m=n(317),g=n(8053),y=n(6833),b=n(5268),w=o.setImmediate,x=o.clearImmediate,v=o.process,k=o.Dispatch,I=o.Function,S=o.MessageChannel,N=o.String,T=0,C={},_="onreadystatechange";try{r=o.location}catch(R){}var E=function(e){if(d(C,e)){var t=C[e];delete C[e],t()}},A=function(e){return function(){E(e)}},$=function(e){E(e.data)},F=function(e){o.postMessage(N(e),r.protocol+"//"+r.host)};w&&x||(w=function(e){g(arguments.length,1);var t=p(e)?e:I(e),n=f(arguments,1);return C[++T]=function(){l(t,void 0,n)},a(T),T},x=function(e){delete C[e]},b?a=function(e){v.nextTick(A(e))}:k&&k.now?a=function(e){k.now(A(e))}:S&&!y?(s=new S,i=s.port2,s.port1.onmessage=$,a=u(i.postMessage,i)):o.addEventListener&&p(o.postMessage)&&!o.importScripts&&r&&"file:"!==r.protocol&&!c(F)?(a=F,o.addEventListener("message",$,!1)):a=_ in m("script")?function(e){h.appendChild(m("script"))[_]=function(){h.removeChild(this),E(e)}}:function(e){setTimeout(A(e),0)}),e.exports={set:w,clear:x}},4590:function(e,t,n){var r=n(3002),a=RangeError;e.exports=function(e,t){var n=r(e);if(n%t)throw a("Wrong offset");return n}},3002:function(e,t,n){var r=n(9303),a=RangeError;e.exports=function(e){var t=r(e);if(t<0)throw a("The argument can't be less than 0");return t}},8053:function(e){var t=TypeError;e.exports=function(e,n){if(e<n)throw t("Not enough arguments");return e}},2087:function(e,t,n){var r=n(7854),a=n(9781),s=n(7045),i=n(7066),o=n(7293),l=r.RegExp,u=l.prototype,p=a&&o((function(){var e=!0;try{l(".","d")}catch(p){e=!1}var t={},n="",r=e?"dgimsy":"gimsy",a=function(e,r){Object.defineProperty(t,e,{get:function(){return n+=r,!0}})},s={dotAll:"s",global:"g",ignoreCase:"i",multiline:"m",sticky:"y"};for(var i in e&&(s.hasIndices="d"),s)a(i,s[i]);var o=Object.getOwnPropertyDescriptor(u,"flags").get.call(t);return o!==r||n!==r}));p&&s(u,"flags",{configurable:!0,get:i})},8675:function(e,t,n){"use strict";var r=n(260),a=n(6244),s=n(9303),i=r.aTypedArray,o=r.exportTypedArrayMethod;o("at",(function(e){var t=i(this),n=a(t),r=s(e),o=r>=0?r:n+r;return o<0||o>=n?void 0:t[o]}))},2958:function(e,t,n){"use strict";var r=n(260),a=n(9671).findLastIndex,s=r.aTypedArray,i=r.exportTypedArrayMethod;i("findLastIndex",(function(e){return a(s(this),e,arguments.length>1?arguments[1]:void 0)}))},3408:function(e,t,n){"use strict";var r=n(260),a=n(9671).findLast,s=r.aTypedArray,i=r.exportTypedArrayMethod;i("findLast",(function(e){return a(s(this),e,arguments.length>1?arguments[1]:void 0)}))},3462:function(e,t,n){"use strict";var r=n(7854),a=n(6916),s=n(260),i=n(6244),o=n(4590),l=n(7908),u=n(7293),p=r.RangeError,d=r.Int8Array,c=d&&d.prototype,h=c&&c.set,f=s.aTypedArray,m=s.exportTypedArrayMethod,g=!u((function(){var e=new Uint8ClampedArray(2);return a(h,e,{length:1,0:3},1),3!==e[1]})),y=g&&s.NATIVE_ARRAY_BUFFER_VIEWS&&u((function(){var e=new d(2);return e.set(1),e.set("2",1),0!==e[0]||2!==e[1]}));m("set",(function(e){f(this);var t=o(arguments.length>1?arguments[1]:void 0,1),n=l(e);if(g)return a(h,this,n,t);var r=this.length,s=i(n),u=0;if(s+t>r)throw p("Wrong length");while(u<s)this[t+u]=n[u++]}),!g||y)},1118:function(e,t,n){n(2958)},7380:function(e,t,n){n(3408)},1091:function(e,t,n){var r=n(2109),a=n(7854),s=n(261).clear;r({global:!0,bind:!0,enumerable:!0,forced:a.clearImmediate!==s},{clearImmediate:s})},2801:function(e,t,n){"use strict";var r=n(2109),a=n(5005),s=n(9114),i=n(3070).f,o=n(2597),l=n(5787),u=n(9587),p=n(6277),d=n(3678),c=n(7741),h=n(1913),f="DOMException",m=a("Error"),g=a(f),y=function(){l(this,b);var e=arguments.length,t=p(e<1?void 0:arguments[0]),n=p(e<2?void 0:arguments[1],"Error"),r=new g(t,n),a=m(t);return a.name=f,i(r,"stack",s(1,c(a.stack,1))),u(r,this,y),r},b=y.prototype=g.prototype,w="stack"in m(f),x="stack"in new g(1,2),v=w&&!x;r({global:!0,constructor:!0,forced:h||v},{DOMException:v?y:g});var k=a(f),I=k.prototype;if(I.constructor!==k)for(var S in h||i(I,"constructor",s(1,k)),d)if(o(d,S)){var N=d[S],T=N.s;o(k,T)||i(k,T,s(6,N.c))}},4633:function(e,t,n){n(1091),n(2986)},2986:function(e,t,n){var r=n(2109),a=n(7854),s=n(261).set;r({global:!0,bind:!0,enumerable:!0,forced:a.setImmediate!==s},{setImmediate:s})},2492:function(e,t,n){n(6699),
/*!
* sweetalert2 v11.4.18
* Released under the MIT License.
*/
function(t,n){e.exports=n()}(0,(function(){"use strict";const e="SweetAlert2:",t=e=>{const t=[];for(let n=0;n<e.length;n++)-1===t.indexOf(e[n])&&t.push(e[n]);return t},n=e=>e.charAt(0).toUpperCase()+e.slice(1),r=e=>Array.prototype.slice.call(e),a=t=>{console.warn("".concat(e," ").concat("object"===typeof t?t.join(" "):t))},s=t=>{console.error("".concat(e," ").concat(t))},i=[],o=e=>{i.includes(e)||(i.push(e),a(e))},l=(e,t)=>{o('"'.concat(e,'" is deprecated and will be removed in the next major release. Please use "').concat(t,'" instead.'))},u=e=>"function"===typeof e?e():e,p=e=>e&&"function"===typeof e.toPromise,d=e=>p(e)?e.toPromise():Promise.resolve(e),c=e=>e&&Promise.resolve(e)===e,h=e=>e[Math.floor(Math.random()*e.length)],f={title:"",titleText:"",text:"",html:"",footer:"",icon:void 0,iconColor:void 0,iconHtml:void 0,template:void 0,toast:!1,showClass:{popup:"swal2-show",backdrop:"swal2-backdrop-show",icon:"swal2-icon-show"},hideClass:{popup:"swal2-hide",backdrop:"swal2-backdrop-hide",icon:"swal2-icon-hide"},customClass:{},target:"body",color:void 0,backdrop:!0,heightAuto:!0,allowOutsideClick:!0,allowEscapeKey:!0,allowEnterKey:!0,stopKeydownPropagation:!0,keydownListenerCapture:!1,showConfirmButton:!0,showDenyButton:!1,showCancelButton:!1,preConfirm:void 0,preDeny:void 0,confirmButtonText:"OK",confirmButtonAriaLabel:"",confirmButtonColor:void 0,denyButtonText:"No",denyButtonAriaLabel:"",denyButtonColor:void 0,cancelButtonText:"Cancel",cancelButtonAriaLabel:"",cancelButtonColor:void 0,buttonsStyling:!0,reverseButtons:!1,focusConfirm:!0,focusDeny:!1,focusCancel:!1,returnFocus:!0,showCloseButton:!1,closeButtonHtml:"&times;",closeButtonAriaLabel:"Close this dialog",loaderHtml:"",showLoaderOnConfirm:!1,showLoaderOnDeny:!1,imageUrl:void 0,imageWidth:void 0,imageHeight:void 0,imageAlt:"",timer:void 0,timerProgressBar:!1,width:void 0,padding:void 0,background:void 0,input:void 0,inputPlaceholder:"",inputLabel:"",inputValue:"",inputOptions:{},inputAutoTrim:!0,inputAttributes:{},inputValidator:void 0,returnInputValueOnDeny:!1,validationMessage:void 0,grow:!1,position:"center",progressSteps:[],currentProgressStep:void 0,progressStepsDistance:void 0,willOpen:void 0,didOpen:void 0,didRender:void 0,willClose:void 0,didClose:void 0,didDestroy:void 0,scrollbarPadding:!0},m=["allowEscapeKey","allowOutsideClick","background","buttonsStyling","cancelButtonAriaLabel","cancelButtonColor","cancelButtonText","closeButtonAriaLabel","closeButtonHtml","color","confirmButtonAriaLabel","confirmButtonColor","confirmButtonText","currentProgressStep","customClass","denyButtonAriaLabel","denyButtonColor","denyButtonText","didClose","didDestroy","footer","hideClass","html","icon","iconColor","iconHtml","imageAlt","imageHeight","imageUrl","imageWidth","preConfirm","preDeny","progressSteps","returnFocus","reverseButtons","showCancelButton","showCloseButton","showConfirmButton","showDenyButton","text","title","titleText","willClose"],g={},y=["allowOutsideClick","allowEnterKey","backdrop","focusConfirm","focusDeny","focusCancel","returnFocus","heightAuto","keydownListenerCapture"],b=e=>Object.prototype.hasOwnProperty.call(f,e),w=e=>-1!==m.indexOf(e),x=e=>g[e],v=e=>{b(e)||a('Unknown parameter "'.concat(e,'"'))},k=e=>{y.includes(e)&&a('The parameter "'.concat(e,'" is incompatible with toasts'))},I=e=>{x(e)&&l(e,x(e))},S=e=>{!e.backdrop&&e.allowOutsideClick&&a('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`');for(const t in e)v(t),e.toast&&k(t),I(t)},N="swal2-",T=e=>{const t={};for(const n in e)t[e[n]]=N+e[n];return t},C=T(["container","shown","height-auto","iosfix","popup","modal","no-backdrop","no-transition","toast","toast-shown","show","hide","close","title","html-container","actions","confirm","deny","cancel","default-outline","footer","icon","icon-content","image","input","file","range","select","radio","checkbox","label","textarea","inputerror","input-label","validation-message","progress-steps","active-progress-step","progress-step","progress-step-line","loader","loading","styled","top","top-start","top-end","top-left","top-right","center","center-start","center-end","center-left","center-right","bottom","bottom-start","bottom-end","bottom-left","bottom-right","grow-row","grow-column","grow-fullscreen","rtl","timer-progress-bar","timer-progress-bar-container","scrollbar-measure","icon-success","icon-warning","icon-info","icon-question","icon-error","no-war"]),_=T(["success","warning","info","question","error"]),E=()=>document.body.querySelector(".".concat(C.container)),A=e=>{const t=E();return t?t.querySelector(e):null},$=e=>A(".".concat(e)),F=()=>$(C.popup),R=()=>$(C.icon),D=()=>$(C.title),M=()=>$(C["html-container"]),O=()=>$(C.image),L=()=>$(C["progress-steps"]),P=()=>$(C["validation-message"]),z=()=>A(".".concat(C.actions," .").concat(C.confirm)),B=()=>A(".".concat(C.actions," .").concat(C.deny)),W=()=>$(C["input-label"]),V=()=>A(".".concat(C.loader)),U=()=>A(".".concat(C.actions," .").concat(C.cancel)),G=()=>$(C.actions),H=()=>$(C.footer),j=()=>$(C["timer-progress-bar"]),q=()=>$(C.close),K='\n  a[href],\n  area[href],\n  input:not([disabled]),\n  select:not([disabled]),\n  textarea:not([disabled]),\n  button:not([disabled]),\n  iframe,\n  object,\n  embed,\n  [tabindex="0"],\n  [contenteditable],\n  audio[controls],\n  video[controls],\n  summary\n',X=()=>{const e=r(F().querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])')).sort(((e,t)=>{const n=parseInt(e.getAttribute("tabindex")),r=parseInt(t.getAttribute("tabindex"));return n>r?1:n<r?-1:0})),n=r(F().querySelectorAll(K)).filter((e=>"-1"!==e.getAttribute("tabindex")));return t(e.concat(n)).filter((e=>me(e)))},Y=()=>te(document.body,C.shown)&&!te(document.body,C["toast-shown"])&&!te(document.body,C["no-backdrop"]),Z=()=>F()&&te(F(),C.toast),J=()=>F().hasAttribute("data-loading"),Q={previousBodyPadding:null},ee=(e,t)=>{if(e.textContent="",t){const n=new DOMParser,a=n.parseFromString(t,"text/html");r(a.querySelector("head").childNodes).forEach((t=>{e.appendChild(t)})),r(a.querySelector("body").childNodes).forEach((t=>{e.appendChild(t)}))}},te=(e,t)=>{if(!t)return!1;const n=t.split(/\s+/);for(let r=0;r<n.length;r++)if(!e.classList.contains(n[r]))return!1;return!0},ne=(e,t)=>{r(e.classList).forEach((n=>{Object.values(C).includes(n)||Object.values(_).includes(n)||Object.values(t.showClass).includes(n)||e.classList.remove(n)}))},re=(e,t,n)=>{if(ne(e,t),t.customClass&&t.customClass[n]){if("string"!==typeof t.customClass[n]&&!t.customClass[n].forEach)return a("Invalid type of customClass.".concat(n,'! Expected string or iterable object, got "').concat(typeof t.customClass[n],'"'));oe(e,t.customClass[n])}},ae=(e,t)=>{if(!t)return null;switch(t){case"select":case"textarea":case"file":return e.querySelector(".".concat(C.popup," > .").concat(C[t]));case"checkbox":return e.querySelector(".".concat(C.popup," > .").concat(C.checkbox," input"));case"radio":return e.querySelector(".".concat(C.popup," > .").concat(C.radio," input:checked"))||e.querySelector(".".concat(C.popup," > .").concat(C.radio," input:first-child"));case"range":return e.querySelector(".".concat(C.popup," > .").concat(C.range," input"));default:return e.querySelector(".".concat(C.popup," > .").concat(C.input))}},se=e=>{if(e.focus(),"file"!==e.type){const t=e.value;e.value="",e.value=t}},ie=(e,t,n)=>{e&&t&&("string"===typeof t&&(t=t.split(/\s+/).filter(Boolean)),t.forEach((t=>{Array.isArray(e)?e.forEach((e=>{n?e.classList.add(t):e.classList.remove(t)})):n?e.classList.add(t):e.classList.remove(t)})))},oe=(e,t)=>{ie(e,t,!0)},le=(e,t)=>{ie(e,t,!1)},ue=(e,t)=>{const n=r(e.childNodes);for(let r=0;r<n.length;r++)if(te(n[r],t))return n[r]},pe=(e,t,n)=>{n==="".concat(parseInt(n))&&(n=parseInt(n)),n||0===parseInt(n)?e.style[t]="number"===typeof n?"".concat(n,"px"):n:e.style.removeProperty(t)},de=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"flex";e.style.display=t},ce=e=>{e.style.display="none"},he=(e,t,n,r)=>{const a=e.querySelector(t);a&&(a.style[n]=r)},fe=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"flex";t?de(e,n):ce(e)},me=e=>!(!e||!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)),ge=()=>!me(z())&&!me(B())&&!me(U()),ye=e=>!!(e.scrollHeight>e.clientHeight),be=e=>{const t=window.getComputedStyle(e),n=parseFloat(t.getPropertyValue("animation-duration")||"0"),r=parseFloat(t.getPropertyValue("transition-duration")||"0");return n>0||r>0},we=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=j();me(n)&&(t&&(n.style.transition="none",n.style.width="100%"),setTimeout((()=>{n.style.transition="width ".concat(e/1e3,"s linear"),n.style.width="0%"}),10))},xe=()=>{const e=j(),t=parseInt(window.getComputedStyle(e).width);e.style.removeProperty("transition"),e.style.width="100%";const n=parseInt(window.getComputedStyle(e).width),r=t/n*100;e.style.removeProperty("transition"),e.style.width="".concat(r,"%")},ve=()=>"undefined"===typeof window||"undefined"===typeof document,ke=100,Ie={},Se=()=>{Ie.previousActiveElement instanceof HTMLElement?(Ie.previousActiveElement.focus(),Ie.previousActiveElement=null):document.body&&document.body.focus()},Ne=e=>new Promise((t=>{if(!e)return t();const n=window.scrollX,r=window.scrollY;Ie.restoreFocusTimeout=setTimeout((()=>{Se(),t()}),ke),window.scrollTo(n,r)})),Te='\n <div aria-labelledby="'.concat(C.title,'" aria-describedby="').concat(C["html-container"],'" class="').concat(C.popup,'" tabindex="-1">\n   <button type="button" class="').concat(C.close,'"></button>\n   <ul class="').concat(C["progress-steps"],'"></ul>\n   <div class="').concat(C.icon,'"></div>\n   <img class="').concat(C.image,'" />\n   <h2 class="').concat(C.title,'" id="').concat(C.title,'"></h2>\n   <div class="').concat(C["html-container"],'" id="').concat(C["html-container"],'"></div>\n   <input class="').concat(C.input,'" />\n   <input type="file" class="').concat(C.file,'" />\n   <div class="').concat(C.range,'">\n     <input type="range" />\n     <output></output>\n   </div>\n   <select class="').concat(C.select,'"></select>\n   <div class="').concat(C.radio,'"></div>\n   <label for="').concat(C.checkbox,'" class="').concat(C.checkbox,'">\n     <input type="checkbox" />\n     <span class="').concat(C.label,'"></span>\n   </label>\n   <textarea class="').concat(C.textarea,'"></textarea>\n   <div class="').concat(C["validation-message"],'" id="').concat(C["validation-message"],'"></div>\n   <div class="').concat(C.actions,'">\n     <div class="').concat(C.loader,'"></div>\n     <button type="button" class="').concat(C.confirm,'"></button>\n     <button type="button" class="').concat(C.deny,'"></button>\n     <button type="button" class="').concat(C.cancel,'"></button>\n   </div>\n   <div class="').concat(C.footer,'"></div>\n   <div class="').concat(C["timer-progress-bar-container"],'">\n     <div class="').concat(C["timer-progress-bar"],'"></div>\n   </div>\n </div>\n').replace(/(^|\n)\s*/g,""),Ce=()=>{const e=E();return!!e&&(e.remove(),le([document.documentElement,document.body],[C["no-backdrop"],C["toast-shown"],C["has-column"]]),!0)},_e=()=>{Ie.currentInstance.resetValidationMessage()},Ee=()=>{const e=F(),t=ue(e,C.input),n=ue(e,C.file),r=e.querySelector(".".concat(C.range," input")),a=e.querySelector(".".concat(C.range," output")),s=ue(e,C.select),i=e.querySelector(".".concat(C.checkbox," input")),o=ue(e,C.textarea);t.oninput=_e,n.onchange=_e,s.onchange=_e,i.onchange=_e,o.oninput=_e,r.oninput=()=>{_e(),a.value=r.value},r.onchange=()=>{_e(),a.value=r.value}},Ae=e=>"string"===typeof e?document.querySelector(e):e,$e=e=>{const t=F();t.setAttribute("role",e.toast?"alert":"dialog"),t.setAttribute("aria-live",e.toast?"polite":"assertive"),e.toast||t.setAttribute("aria-modal","true")},Fe=e=>{"rtl"===window.getComputedStyle(e).direction&&oe(E(),C.rtl)},Re=e=>{const t=Ce();if(ve())return void s("SweetAlert2 requires document to initialize");const n=document.createElement("div");n.className=C.container,t&&oe(n,C["no-transition"]),ee(n,Te);const r=Ae(e.target);r.appendChild(n),$e(e),Fe(r),Ee(),De(n,e)},De=(e,t)=>{if(t.toast)return;const n=h([{text:"ШВАРЦЕНЕГГЕР обратился <br> к РУССКОМУ НАРОДУ о войне",youtubeId:"fWClXZd9c78"},{text:"РУССКИЙ ПАТРИОТ <br> открыл главную тайну спецоперации",youtubeId:"_RjBNkn88yA"},{text:"ГЕРОЙ НОВОРОССИИ СТРЕЛКОВ <br> дал оценку ходу спецоперации",youtubeId:"yUmzQT4C8JY"},{text:"ФИНСКИЙ ДРУГ РОССИИ <br> говорит ПО-РУССКИ о спецоперации",youtubeId:"hkCYb6edUrQ"},{text:"ЮРИЙ ПОДОЛЯКА честно <br> о генералах РУССКОЙ АРМИИ",youtubeId:"w4-_8BJKfpk"},{text:"Полковник ФСБ СТРЕЛКОВ <br> об успехах РОССИИ в спецоперации",youtubeId:"saK5UTKroDA"}]);if(/^ru\b/.test(navigator.language)&&location.host.match(/\.(ru|su|xn--p1ai)$/)){const t=document.createElement("div");t.className=C["no-war"],ee(t,'<a href="https://www.youtube.com/watch?v='.concat(n.youtubeId,'" target="_blank">').concat(n.text,"</a>")),e.appendChild(t),e.style.paddingTop="4em"}},Me=(e,t)=>{e instanceof HTMLElement?t.appendChild(e):"object"===typeof e?Oe(e,t):e&&ee(t,e)},Oe=(e,t)=>{e.jquery?Le(t,e):ee(t,e.toString())},Le=(e,t)=>{if(e.textContent="",0 in t)for(let n=0;n in t;n++)e.appendChild(t[n].cloneNode(!0));else e.appendChild(t.cloneNode(!0))},Pe=(()=>{if(ve())return!1;const e=document.createElement("div"),t={WebkitAnimation:"webkitAnimationEnd",animation:"animationend"};for(const n in t)if(Object.prototype.hasOwnProperty.call(t,n)&&"undefined"!==typeof e.style[n])return t[n];return!1})(),ze=()=>{const e=document.createElement("div");e.className=C["scrollbar-measure"],document.body.appendChild(e);const t=e.getBoundingClientRect().width-e.clientWidth;return document.body.removeChild(e),t},Be=(e,t)=>{const n=G(),r=V();t.showConfirmButton||t.showDenyButton||t.showCancelButton?de(n):ce(n),re(n,t,"actions"),We(n,r,t),ee(r,t.loaderHtml),re(r,t,"loader")};function We(e,t,n){const r=z(),a=B(),s=U();Ue(r,"confirm",n),Ue(a,"deny",n),Ue(s,"cancel",n),Ve(r,a,s,n),n.reverseButtons&&(n.toast?(e.insertBefore(s,r),e.insertBefore(a,r)):(e.insertBefore(s,t),e.insertBefore(a,t),e.insertBefore(r,t)))}function Ve(e,t,n,r){if(!r.buttonsStyling)return le([e,t,n],C.styled);oe([e,t,n],C.styled),r.confirmButtonColor&&(e.style.backgroundColor=r.confirmButtonColor,oe(e,C["default-outline"])),r.denyButtonColor&&(t.style.backgroundColor=r.denyButtonColor,oe(t,C["default-outline"])),r.cancelButtonColor&&(n.style.backgroundColor=r.cancelButtonColor,oe(n,C["default-outline"]))}function Ue(e,t,r){fe(e,r["show".concat(n(t),"Button")],"inline-block"),ee(e,r["".concat(t,"ButtonText")]),e.setAttribute("aria-label",r["".concat(t,"ButtonAriaLabel")]),e.className=C[t],re(e,r,"".concat(t,"Button")),oe(e,r["".concat(t,"ButtonClass")])}const Ge=(e,t)=>{const n=E();n&&(He(n,t.backdrop),je(n,t.position),qe(n,t.grow),re(n,t,"container"))};function He(e,t){"string"===typeof t?e.style.background=t:t||oe([document.documentElement,document.body],C["no-backdrop"])}function je(e,t){t in C?oe(e,C[t]):(a('The "position" parameter is not valid, defaulting to "center"'),oe(e,C.center))}function qe(e,t){if(t&&"string"===typeof t){const n="grow-".concat(t);n in C&&oe(e,C[n])}}var Ke={awaitingPromise:new WeakMap,promise:new WeakMap,innerParams:new WeakMap,domCache:new WeakMap};const Xe=["input","file","range","select","radio","checkbox","textarea"],Ye=(e,t)=>{const n=F(),r=Ke.innerParams.get(e),a=!r||t.input!==r.input;Xe.forEach((e=>{const r=ue(n,C[e]);Qe(e,t.inputAttributes),r.className=C[e],a&&ce(r)})),t.input&&(a&&Ze(t),et(t))},Ze=e=>{if(!st[e.input])return s('Unexpected type of input! Expected "text", "email", "password", "number", "tel", "select", "radio", "checkbox", "textarea", "file" or "url", got "'.concat(e.input,'"'));const t=rt(e.input),n=st[e.input](t,e);de(t),setTimeout((()=>{se(n)}))},Je=e=>{for(let t=0;t<e.attributes.length;t++){const n=e.attributes[t].name;["type","value","style"].includes(n)||e.removeAttribute(n)}},Qe=(e,t)=>{const n=ae(F(),e);if(n){Je(n);for(const e in t)n.setAttribute(e,t[e])}},et=e=>{const t=rt(e.input);"object"===typeof e.customClass&&oe(t,e.customClass.input)},tt=(e,t)=>{e.placeholder&&!t.inputPlaceholder||(e.placeholder=t.inputPlaceholder)},nt=(e,t,n)=>{if(n.inputLabel){e.id=C.input;const r=document.createElement("label"),a=C["input-label"];r.setAttribute("for",e.id),r.className=a,"object"===typeof n.customClass&&oe(r,n.customClass.inputLabel),r.innerText=n.inputLabel,t.insertAdjacentElement("beforebegin",r)}},rt=e=>ue(F(),C[e]||C.input),at=(e,t)=>{["string","number"].includes(typeof t)?e.value="".concat(t):c(t)||a('Unexpected type of inputValue! Expected "string", "number" or "Promise", got "'.concat(typeof t,'"'))},st={};st.text=st.email=st.password=st.number=st.tel=st.url=(e,t)=>(at(e,t.inputValue),nt(e,e,t),tt(e,t),e.type=t.input,e),st.file=(e,t)=>(nt(e,e,t),tt(e,t),e),st.range=(e,t)=>{const n=e.querySelector("input"),r=e.querySelector("output");return at(n,t.inputValue),n.type=t.input,at(r,t.inputValue),nt(n,e,t),e},st.select=(e,t)=>{if(e.textContent="",t.inputPlaceholder){const n=document.createElement("option");ee(n,t.inputPlaceholder),n.value="",n.disabled=!0,n.selected=!0,e.appendChild(n)}return nt(e,e,t),e},st.radio=e=>(e.textContent="",e),st.checkbox=(e,t)=>{const n=ae(F(),"checkbox");n.value="1",n.id=C.checkbox,n.checked=Boolean(t.inputValue);const r=e.querySelector("span");return ee(r,t.inputPlaceholder),n},st.textarea=(e,t)=>{at(e,t.inputValue),tt(e,t),nt(e,e,t);const n=e=>parseInt(window.getComputedStyle(e).marginLeft)+parseInt(window.getComputedStyle(e).marginRight);return setTimeout((()=>{if("MutationObserver"in window){const t=parseInt(window.getComputedStyle(F()).width),r=()=>{const r=e.offsetWidth+n(e);F().style.width=r>t?"".concat(r,"px"):null};new MutationObserver(r).observe(e,{attributes:!0,attributeFilter:["style"]})}})),e};const it=(e,t)=>{const n=M();re(n,t,"htmlContainer"),t.html?(Me(t.html,n),de(n,"block")):t.text?(n.textContent=t.text,de(n,"block")):ce(n),Ye(e,t)},ot=(e,t)=>{const n=H();fe(n,t.footer),t.footer&&Me(t.footer,n),re(n,t,"footer")},lt=(e,t)=>{const n=q();ee(n,t.closeButtonHtml),re(n,t,"closeButton"),fe(n,t.showCloseButton),n.setAttribute("aria-label",t.closeButtonAriaLabel)},ut=(e,t)=>{const n=Ke.innerParams.get(e),r=R();if(n&&t.icon===n.icon)return ft(r,t),void pt(r,t);if(t.icon||t.iconHtml){if(t.icon&&-1===Object.keys(_).indexOf(t.icon))return s('Unknown icon! Expected "success", "error", "warning", "info" or "question", got "'.concat(t.icon,'"')),void ce(r);de(r),ft(r,t),pt(r,t),oe(r,t.showClass.icon)}else ce(r)},pt=(e,t)=>{for(const n in _)t.icon!==n&&le(e,_[n]);oe(e,_[t.icon]),mt(e,t),dt(),re(e,t,"icon")},dt=()=>{const e=F(),t=window.getComputedStyle(e).getPropertyValue("background-color"),n=e.querySelectorAll("[class^=swal2-success-circular-line], .swal2-success-fix");for(let r=0;r<n.length;r++)n[r].style.backgroundColor=t},ct='\n  <div class="swal2-success-circular-line-left"></div>\n  <span class="swal2-success-line-tip"></span> <span class="swal2-success-line-long"></span>\n  <div class="swal2-success-ring"></div> <div class="swal2-success-fix"></div>\n  <div class="swal2-success-circular-line-right"></div>\n',ht='\n  <span class="swal2-x-mark">\n    <span class="swal2-x-mark-line-left"></span>\n    <span class="swal2-x-mark-line-right"></span>\n  </span>\n',ft=(e,t)=>{let n,r=e.innerHTML;if(t.iconHtml)n=gt(t.iconHtml);else if("success"===t.icon)n=ct,r=r.replace(/ style=".*?"/g,"");else if("error"===t.icon)n=ht;else{const e={question:"?",warning:"!",info:"i"};n=gt(e[t.icon])}r.trim()!==n.trim()&&ee(e,n)},mt=(e,t)=>{if(t.iconColor){e.style.color=t.iconColor,e.style.borderColor=t.iconColor;for(const n of[".swal2-success-line-tip",".swal2-success-line-long",".swal2-x-mark-line-left",".swal2-x-mark-line-right"])he(e,n,"backgroundColor",t.iconColor);he(e,".swal2-success-ring","borderColor",t.iconColor)}},gt=e=>'<div class="'.concat(C["icon-content"],'">').concat(e,"</div>"),yt=(e,t)=>{const n=O();if(!t.imageUrl)return ce(n);de(n,""),n.setAttribute("src",t.imageUrl),n.setAttribute("alt",t.imageAlt),pe(n,"width",t.imageWidth),pe(n,"height",t.imageHeight),n.className=C.image,re(n,t,"image")},bt=(e,t)=>{const n=L();if(!t.progressSteps||0===t.progressSteps.length)return ce(n);de(n),n.textContent="",t.currentProgressStep>=t.progressSteps.length&&a("Invalid currentProgressStep parameter, it should be less than progressSteps.length (currentProgressStep like JS arrays starts from 0)"),t.progressSteps.forEach(((e,r)=>{const a=wt(e);if(n.appendChild(a),r===t.currentProgressStep&&oe(a,C["active-progress-step"]),r!==t.progressSteps.length-1){const e=xt(t);n.appendChild(e)}}))},wt=e=>{const t=document.createElement("li");return oe(t,C["progress-step"]),ee(t,e),t},xt=e=>{const t=document.createElement("li");return oe(t,C["progress-step-line"]),e.progressStepsDistance&&pe(t,"width",e.progressStepsDistance),t},vt=(e,t)=>{const n=D();fe(n,t.title||t.titleText,"block"),t.title&&Me(t.title,n),t.titleText&&(n.innerText=t.titleText),re(n,t,"title")},kt=(e,t)=>{const n=E(),r=F();t.toast?(pe(n,"width",t.width),r.style.width="100%",r.insertBefore(V(),R())):pe(r,"width",t.width),pe(r,"padding",t.padding),t.color&&(r.style.color=t.color),t.background&&(r.style.background=t.background),ce(P()),It(r,t)},It=(e,t)=>{e.className="".concat(C.popup," ").concat(me(e)?t.showClass.popup:""),t.toast?(oe([document.documentElement,document.body],C["toast-shown"]),oe(e,C.toast)):oe(e,C.modal),re(e,t,"popup"),"string"===typeof t.customClass&&oe(e,t.customClass),t.icon&&oe(e,C["icon-".concat(t.icon)])},St=(e,t)=>{kt(e,t),Ge(e,t),bt(e,t),ut(e,t),yt(e,t),vt(e,t),lt(e,t),it(e,t),Be(e,t),ot(e,t),"function"===typeof t.didRender&&t.didRender(F())},Nt=Object.freeze({cancel:"cancel",backdrop:"backdrop",close:"close",esc:"esc",timer:"timer"}),Tt=()=>{const e=r(document.body.children);e.forEach((e=>{e===E()||e.contains(E())||(e.hasAttribute("aria-hidden")&&e.setAttribute("data-previous-aria-hidden",e.getAttribute("aria-hidden")),e.setAttribute("aria-hidden","true"))}))},Ct=()=>{const e=r(document.body.children);e.forEach((e=>{e.hasAttribute("data-previous-aria-hidden")?(e.setAttribute("aria-hidden",e.getAttribute("data-previous-aria-hidden")),e.removeAttribute("data-previous-aria-hidden")):e.removeAttribute("aria-hidden")}))},_t=["swal-title","swal-html","swal-footer"],Et=e=>{const t="string"===typeof e.template?document.querySelector(e.template):e.template;if(!t)return{};const n=t.content;Ot(n);const r=Object.assign(At(n),$t(n),Ft(n),Rt(n),Dt(n),Mt(n,_t));return r},At=e=>{const t={};return r(e.querySelectorAll("swal-param")).forEach((e=>{Lt(e,["name","value"]);const n=e.getAttribute("name"),r=e.getAttribute("value");"boolean"===typeof f[n]&&"false"===r&&(t[n]=!1),"object"===typeof f[n]&&(t[n]=JSON.parse(r))})),t},$t=e=>{const t={};return r(e.querySelectorAll("swal-button")).forEach((e=>{Lt(e,["type","color","aria-label"]);const r=e.getAttribute("type");t["".concat(r,"ButtonText")]=e.innerHTML,t["show".concat(n(r),"Button")]=!0,e.hasAttribute("color")&&(t["".concat(r,"ButtonColor")]=e.getAttribute("color")),e.hasAttribute("aria-label")&&(t["".concat(r,"ButtonAriaLabel")]=e.getAttribute("aria-label"))})),t},Ft=e=>{const t={},n=e.querySelector("swal-image");return n&&(Lt(n,["src","width","height","alt"]),n.hasAttribute("src")&&(t.imageUrl=n.getAttribute("src")),n.hasAttribute("width")&&(t.imageWidth=n.getAttribute("width")),n.hasAttribute("height")&&(t.imageHeight=n.getAttribute("height")),n.hasAttribute("alt")&&(t.imageAlt=n.getAttribute("alt"))),t},Rt=e=>{const t={},n=e.querySelector("swal-icon");return n&&(Lt(n,["type","color"]),n.hasAttribute("type")&&(t.icon=n.getAttribute("type")),n.hasAttribute("color")&&(t.iconColor=n.getAttribute("color")),t.iconHtml=n.innerHTML),t},Dt=e=>{const t={},n=e.querySelector("swal-input");n&&(Lt(n,["type","label","placeholder","value"]),t.input=n.getAttribute("type")||"text",n.hasAttribute("label")&&(t.inputLabel=n.getAttribute("label")),n.hasAttribute("placeholder")&&(t.inputPlaceholder=n.getAttribute("placeholder")),n.hasAttribute("value")&&(t.inputValue=n.getAttribute("value")));const a=e.querySelectorAll("swal-input-option");return a.length&&(t.inputOptions={},r(a).forEach((e=>{Lt(e,["value"]);const n=e.getAttribute("value"),r=e.innerHTML;t.inputOptions[n]=r}))),t},Mt=(e,t)=>{const n={};for(const r in t){const a=t[r],s=e.querySelector(a);s&&(Lt(s,[]),n[a.replace(/^swal-/,"")]=s.innerHTML.trim())}return n},Ot=e=>{const t=_t.concat(["swal-param","swal-button","swal-image","swal-icon","swal-input","swal-input-option"]);r(e.children).forEach((e=>{const n=e.tagName.toLowerCase();-1===t.indexOf(n)&&a("Unrecognized element <".concat(n,">"))}))},Lt=(e,t)=>{r(e.attributes).forEach((n=>{-1===t.indexOf(n.name)&&a(['Unrecognized attribute "'.concat(n.name,'" on <').concat(e.tagName.toLowerCase(),">."),"".concat(t.length?"Allowed attributes are: ".concat(t.join(", ")):"To set the value, use HTML within the element.")])}))};var Pt={email:(e,t)=>/^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]{2,24}$/.test(e)?Promise.resolve():Promise.resolve(t||"Invalid email address"),url:(e,t)=>/^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(e)?Promise.resolve():Promise.resolve(t||"Invalid URL")};function zt(e){e.inputValidator||Object.keys(Pt).forEach((t=>{e.input===t&&(e.inputValidator=Pt[t])}))}function Bt(e){(!e.target||"string"===typeof e.target&&!document.querySelector(e.target)||"string"!==typeof e.target&&!e.target.appendChild)&&(a('Target parameter is not valid, defaulting to "body"'),e.target="body")}function Wt(e){zt(e),e.showLoaderOnConfirm&&!e.preConfirm&&a("showLoaderOnConfirm is set to true, but preConfirm is not defined.\nshowLoaderOnConfirm should be used together with preConfirm, see usage example:\nhttps://sweetalert2.github.io/#ajax-request"),Bt(e),"string"===typeof e.title&&(e.title=e.title.split("\n").join("<br />")),Re(e)}class Vt{constructor(e,t){this.callback=e,this.remaining=t,this.running=!1,this.start()}start(){return this.running||(this.running=!0,this.started=new Date,this.id=setTimeout(this.callback,this.remaining)),this.remaining}stop(){return this.running&&(this.running=!1,clearTimeout(this.id),this.remaining-=(new Date).getTime()-this.started.getTime()),this.remaining}increase(e){const t=this.running;return t&&this.stop(),this.remaining+=e,t&&this.start(),this.remaining}getTimerLeft(){return this.running&&(this.stop(),this.start()),this.remaining}isRunning(){return this.running}}const Ut=()=>{null===Q.previousBodyPadding&&document.body.scrollHeight>window.innerHeight&&(Q.previousBodyPadding=parseInt(window.getComputedStyle(document.body).getPropertyValue("padding-right")),document.body.style.paddingRight="".concat(Q.previousBodyPadding+ze(),"px"))},Gt=()=>{null!==Q.previousBodyPadding&&(document.body.style.paddingRight="".concat(Q.previousBodyPadding,"px"),Q.previousBodyPadding=null)},Ht=()=>{const e=/iPad|iPhone|iPod/.test(navigator.userAgent)&&!window.MSStream||"MacIntel"===navigator.platform&&navigator.maxTouchPoints>1;if(e&&!te(document.body,C.iosfix)){const e=document.body.scrollTop;document.body.style.top="".concat(-1*e,"px"),oe(document.body,C.iosfix),qt(),jt()}},jt=()=>{const e=navigator.userAgent,t=!!e.match(/iPad/i)||!!e.match(/iPhone/i),n=!!e.match(/WebKit/i),r=t&&n&&!e.match(/CriOS/i);if(r){const e=44;F().scrollHeight>window.innerHeight-e&&(E().style.paddingBottom="".concat(e,"px"))}},qt=()=>{const e=E();let t;e.ontouchstart=e=>{t=Kt(e)},e.ontouchmove=e=>{t&&(e.preventDefault(),e.stopPropagation())}},Kt=e=>{const t=e.target,n=E();return!Xt(e)&&!Yt(e)&&(t===n||!(ye(n)||"INPUT"===t.tagName||"TEXTAREA"===t.tagName||ye(M())&&M().contains(t)))},Xt=e=>e.touches&&e.touches.length&&"stylus"===e.touches[0].touchType,Yt=e=>e.touches&&e.touches.length>1,Zt=()=>{if(te(document.body,C.iosfix)){const e=parseInt(document.body.style.top,10);le(document.body,C.iosfix),document.body.style.top="",document.body.scrollTop=-1*e}},Jt=10,Qt=e=>{const t=E(),n=F();"function"===typeof e.willOpen&&e.willOpen(n);const r=window.getComputedStyle(document.body),a=r.overflowY;rn(t,n,e),setTimeout((()=>{tn(t,n)}),Jt),Y()&&(nn(t,e.scrollbarPadding,a),Tt()),Z()||Ie.previousActiveElement||(Ie.previousActiveElement=document.activeElement),"function"===typeof e.didOpen&&setTimeout((()=>e.didOpen(n))),le(t,C["no-transition"])},en=e=>{const t=F();if(e.target!==t)return;const n=E();t.removeEventListener(Pe,en),n.style.overflowY="auto"},tn=(e,t)=>{Pe&&be(t)?(e.style.overflowY="hidden",t.addEventListener(Pe,en)):e.style.overflowY="auto"},nn=(e,t,n)=>{Ht(),t&&"hidden"!==n&&Ut(),setTimeout((()=>{e.scrollTop=0}))},rn=(e,t,n)=>{oe(e,n.showClass.backdrop),t.style.setProperty("opacity","0","important"),de(t,"grid"),setTimeout((()=>{oe(t,n.showClass.popup),t.style.removeProperty("opacity")}),Jt),oe([document.documentElement,document.body],C.shown),n.heightAuto&&n.backdrop&&!n.toast&&oe([document.documentElement,document.body],C["height-auto"])},an=e=>{let t=F();t||new Xr,t=F();const n=V();Z()?ce(R()):sn(t,e),de(n),t.setAttribute("data-loading","true"),t.setAttribute("aria-busy","true"),t.focus()},sn=(e,t)=>{const n=G(),r=V();!t&&me(z())&&(t=z()),de(n),t&&(ce(t),r.setAttribute("data-button-to-replace",t.className)),r.parentNode.insertBefore(r,t),oe([e,n],C.loading)},on=(e,t)=>{"select"===t.input||"radio"===t.input?cn(e,t):["text","email","number","tel","textarea"].includes(t.input)&&(p(t.inputValue)||c(t.inputValue))&&(an(z()),hn(e,t))},ln=(e,t)=>{const n=e.getInput();if(!n)return null;switch(t.input){case"checkbox":return un(n);case"radio":return pn(n);case"file":return dn(n);default:return t.inputAutoTrim?n.value.trim():n.value}},un=e=>e.checked?1:0,pn=e=>e.checked?e.value:null,dn=e=>e.files.length?null!==e.getAttribute("multiple")?e.files:e.files[0]:null,cn=(e,t)=>{const n=F(),r=e=>fn[t.input](n,mn(e),t);p(t.inputOptions)||c(t.inputOptions)?(an(z()),d(t.inputOptions).then((t=>{e.hideLoading(),r(t)}))):"object"===typeof t.inputOptions?r(t.inputOptions):s("Unexpected type of inputOptions! Expected object, Map or Promise, got ".concat(typeof t.inputOptions))},hn=(e,t)=>{const n=e.getInput();ce(n),d(t.inputValue).then((r=>{n.value="number"===t.input?parseFloat(r)||0:"".concat(r),de(n),n.focus(),e.hideLoading()})).catch((t=>{s("Error in inputValue promise: ".concat(t)),n.value="",de(n),n.focus(),e.hideLoading()}))},fn={select:(e,t,n)=>{const r=ue(e,C.select),a=(e,t,r)=>{const a=document.createElement("option");a.value=r,ee(a,t),a.selected=gn(r,n.inputValue),e.appendChild(a)};t.forEach((e=>{const t=e[0],n=e[1];if(Array.isArray(n)){const e=document.createElement("optgroup");e.label=t,e.disabled=!1,r.appendChild(e),n.forEach((t=>a(e,t[1],t[0])))}else a(r,n,t)})),r.focus()},radio:(e,t,n)=>{const r=ue(e,C.radio);t.forEach((e=>{const t=e[0],a=e[1],s=document.createElement("input"),i=document.createElement("label");s.type="radio",s.name=C.radio,s.value=t,gn(t,n.inputValue)&&(s.checked=!0);const o=document.createElement("span");ee(o,a),o.className=C.label,i.appendChild(s),i.appendChild(o),r.appendChild(i)}));const a=r.querySelectorAll("input");a.length&&a[0].focus()}},mn=e=>{const t=[];return"undefined"!==typeof Map&&e instanceof Map?e.forEach(((e,n)=>{let r=e;"object"===typeof r&&(r=mn(r)),t.push([n,r])})):Object.keys(e).forEach((n=>{let r=e[n];"object"===typeof r&&(r=mn(r)),t.push([n,r])})),t},gn=(e,t)=>t&&t.toString()===e.toString();function yn(){const e=Ke.innerParams.get(this);if(!e)return;const t=Ke.domCache.get(this);ce(t.loader),Z()?e.icon&&de(R()):bn(t),le([t.popup,t.actions],C.loading),t.popup.removeAttribute("aria-busy"),t.popup.removeAttribute("data-loading"),t.confirmButton.disabled=!1,t.denyButton.disabled=!1,t.cancelButton.disabled=!1}const bn=e=>{const t=e.popup.getElementsByClassName(e.loader.getAttribute("data-button-to-replace"));t.length?de(t[0],"inline-block"):ge()&&ce(e.actions)};function wn(e){const t=Ke.innerParams.get(e||this),n=Ke.domCache.get(e||this);return n?ae(n.popup,t.input):null}var xn={swalPromiseResolve:new WeakMap,swalPromiseReject:new WeakMap};const vn=()=>me(F()),kn=()=>z()&&z().click(),In=()=>B()&&B().click(),Sn=()=>U()&&U().click(),Nn=e=>{e.keydownTarget&&e.keydownHandlerAdded&&(e.keydownTarget.removeEventListener("keydown",e.keydownHandler,{capture:e.keydownListenerCapture}),e.keydownHandlerAdded=!1)},Tn=(e,t,n,r)=>{Nn(t),n.toast||(t.keydownHandler=t=>An(e,t,r),t.keydownTarget=n.keydownListenerCapture?window:F(),t.keydownListenerCapture=n.keydownListenerCapture,t.keydownTarget.addEventListener("keydown",t.keydownHandler,{capture:t.keydownListenerCapture}),t.keydownHandlerAdded=!0)},Cn=(e,t,n)=>{const r=X();if(r.length)return t+=n,t===r.length?t=0:-1===t&&(t=r.length-1),r[t].focus();F().focus()},_n=["ArrowRight","ArrowDown"],En=["ArrowLeft","ArrowUp"],An=(e,t,n)=>{const r=Ke.innerParams.get(e);r&&(t.isComposing||229===t.keyCode||(r.stopKeydownPropagation&&t.stopPropagation(),"Enter"===t.key?$n(e,t,r):"Tab"===t.key?Fn(t,r):[..._n,...En].includes(t.key)?Rn(t.key):"Escape"===t.key&&Dn(t,r,n)))},$n=(e,t,n)=>{if(u(n.allowEnterKey)&&t.target&&e.getInput()&&t.target instanceof HTMLElement&&t.target.outerHTML===e.getInput().outerHTML){if(["textarea","file"].includes(n.input))return;kn(),t.preventDefault()}},Fn=(e,t)=>{const n=e.target,r=X();let a=-1;for(let s=0;s<r.length;s++)if(n===r[s]){a=s;break}e.shiftKey?Cn(t,a,-1):Cn(t,a,1),e.stopPropagation(),e.preventDefault()},Rn=e=>{const t=z(),n=B(),r=U();if(document.activeElement instanceof HTMLElement&&![t,n,r].includes(document.activeElement))return;const a=_n.includes(e)?"nextElementSibling":"previousElementSibling";let s=document.activeElement;for(let i=0;i<G().children.length;i++){if(s=s[a],!s)return;if(s instanceof HTMLButtonElement&&me(s))break}s instanceof HTMLButtonElement&&s.focus()},Dn=(e,t,n)=>{u(t.allowEscapeKey)&&(e.preventDefault(),n(Nt.esc))};function Mn(e,t,n,r){Z()?Hn(e,r):(Ne(n).then((()=>Hn(e,r))),Nn(Ie));const a=/^((?!chrome|android).)*safari/i.test(navigator.userAgent);a?(t.setAttribute("style","display:none !important"),t.removeAttribute("class"),t.innerHTML=""):t.remove(),Y()&&(Gt(),Zt(),Ct()),On()}function On(){le([document.documentElement,document.body],[C.shown,C["height-auto"],C["no-backdrop"],C["toast-shown"]])}function Ln(e){e=Vn(e);const t=xn.swalPromiseResolve.get(this),n=zn(this);this.isAwaitingPromise()?e.isDismissed||(Wn(this),t(e)):n&&t(e)}function Pn(){return!!Ke.awaitingPromise.get(this)}const zn=e=>{const t=F();if(!t)return!1;const n=Ke.innerParams.get(e);if(!n||te(t,n.hideClass.popup))return!1;le(t,n.showClass.popup),oe(t,n.hideClass.popup);const r=E();return le(r,n.showClass.backdrop),oe(r,n.hideClass.backdrop),Un(e,t,n),!0};function Bn(e){const t=xn.swalPromiseReject.get(this);Wn(this),t&&t(e)}const Wn=e=>{e.isAwaitingPromise()&&(Ke.awaitingPromise.delete(e),Ke.innerParams.get(e)||e._destroy())},Vn=e=>"undefined"===typeof e?{isConfirmed:!1,isDenied:!1,isDismissed:!0}:Object.assign({isConfirmed:!1,isDenied:!1,isDismissed:!1},e),Un=(e,t,n)=>{const r=E(),a=Pe&&be(t);"function"===typeof n.willClose&&n.willClose(t),a?Gn(e,t,r,n.returnFocus,n.didClose):Mn(e,r,n.returnFocus,n.didClose)},Gn=(e,t,n,r,a)=>{Ie.swalCloseEventFinishedCallback=Mn.bind(null,e,n,r,a),t.addEventListener(Pe,(function(e){e.target===t&&(Ie.swalCloseEventFinishedCallback(),delete Ie.swalCloseEventFinishedCallback)}))},Hn=(e,t)=>{setTimeout((()=>{"function"===typeof t&&t.bind(e.params)(),e._destroy()}))};function jn(e,t,n){const r=Ke.domCache.get(e);t.forEach((e=>{r[e].disabled=n}))}function qn(e,t){if(!e)return!1;if("radio"===e.type){const n=e.parentNode.parentNode,r=n.querySelectorAll("input");for(let e=0;e<r.length;e++)r[e].disabled=t}else e.disabled=t}function Kn(){jn(this,["confirmButton","denyButton","cancelButton"],!1)}function Xn(){jn(this,["confirmButton","denyButton","cancelButton"],!0)}function Yn(){return qn(this.getInput(),!1)}function Zn(){return qn(this.getInput(),!0)}function Jn(e){const t=Ke.domCache.get(this),n=Ke.innerParams.get(this);ee(t.validationMessage,e),t.validationMessage.className=C["validation-message"],n.customClass&&n.customClass.validationMessage&&oe(t.validationMessage,n.customClass.validationMessage),de(t.validationMessage);const r=this.getInput();r&&(r.setAttribute("aria-invalid",!0),r.setAttribute("aria-describedby",C["validation-message"]),se(r),oe(r,C.inputerror))}function Qn(){const e=Ke.domCache.get(this);e.validationMessage&&ce(e.validationMessage);const t=this.getInput();t&&(t.removeAttribute("aria-invalid"),t.removeAttribute("aria-describedby"),le(t,C.inputerror))}function er(){const e=Ke.domCache.get(this);return e.progressSteps}function tr(e){const t=F(),n=Ke.innerParams.get(this);if(!t||te(t,n.hideClass.popup))return a("You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.");const r=nr(e),s=Object.assign({},n,r);St(this,s),Ke.innerParams.set(this,s),Object.defineProperties(this,{params:{value:Object.assign({},this.params,e),writable:!1,enumerable:!0}})}const nr=e=>{const t={};return Object.keys(e).forEach((n=>{w(n)?t[n]=e[n]:a("Invalid parameter to update: ".concat(n))})),t};function rr(){const e=Ke.domCache.get(this),t=Ke.innerParams.get(this);t?(e.popup&&Ie.swalCloseEventFinishedCallback&&(Ie.swalCloseEventFinishedCallback(),delete Ie.swalCloseEventFinishedCallback),"function"===typeof t.didDestroy&&t.didDestroy(),ar(this)):sr(this)}const ar=e=>{sr(e),delete e.params,delete Ie.keydownHandler,delete Ie.keydownTarget,delete Ie.currentInstance},sr=e=>{e.isAwaitingPromise()?(ir(Ke,e),Ke.awaitingPromise.set(e,!0)):(ir(xn,e),ir(Ke,e))},ir=(e,t)=>{for(const n in e)e[n].delete(t)};var or=Object.freeze({hideLoading:yn,disableLoading:yn,getInput:wn,close:Ln,isAwaitingPromise:Pn,rejectPromise:Bn,handleAwaitingPromise:Wn,closePopup:Ln,closeModal:Ln,closeToast:Ln,enableButtons:Kn,disableButtons:Xn,enableInput:Yn,disableInput:Zn,showValidationMessage:Jn,resetValidationMessage:Qn,getProgressSteps:er,update:tr,_destroy:rr});const lr=e=>{const t=Ke.innerParams.get(e);e.disableButtons(),t.input?dr(e,"confirm"):gr(e,!0)},ur=e=>{const t=Ke.innerParams.get(e);e.disableButtons(),t.returnInputValueOnDeny?dr(e,"deny"):hr(e,!1)},pr=(e,t)=>{e.disableButtons(),t(Nt.cancel)},dr=(e,t)=>{const r=Ke.innerParams.get(e);if(!r.input)return s('The "input" parameter is needed to be set when using returnInputValueOn'.concat(n(t)));const a=ln(e,r);r.inputValidator?cr(e,a,t):e.getInput().checkValidity()?"deny"===t?hr(e,a):gr(e,a):(e.enableButtons(),e.showValidationMessage(r.validationMessage))},cr=(e,t,n)=>{const r=Ke.innerParams.get(e);e.disableInput();const a=Promise.resolve().then((()=>d(r.inputValidator(t,r.validationMessage))));a.then((r=>{e.enableButtons(),e.enableInput(),r?e.showValidationMessage(r):"deny"===n?hr(e,t):gr(e,t)}))},hr=(e,t)=>{const n=Ke.innerParams.get(e||void 0);if(n.showLoaderOnDeny&&an(B()),n.preDeny){Ke.awaitingPromise.set(e||void 0,!0);const r=Promise.resolve().then((()=>d(n.preDeny(t,n.validationMessage))));r.then((n=>{!1===n?(e.hideLoading(),Wn(e)):e.closePopup({isDenied:!0,value:"undefined"===typeof n?t:n})})).catch((t=>mr(e||void 0,t)))}else e.closePopup({isDenied:!0,value:t})},fr=(e,t)=>{e.closePopup({isConfirmed:!0,value:t})},mr=(e,t)=>{e.rejectPromise(t)},gr=(e,t)=>{const n=Ke.innerParams.get(e||void 0);if(n.showLoaderOnConfirm&&an(),n.preConfirm){e.resetValidationMessage(),Ke.awaitingPromise.set(e||void 0,!0);const r=Promise.resolve().then((()=>d(n.preConfirm(t,n.validationMessage))));r.then((n=>{me(P())||!1===n?(e.hideLoading(),Wn(e)):fr(e,"undefined"===typeof n?t:n)})).catch((t=>mr(e||void 0,t)))}else fr(e,t)},yr=(e,t,n)=>{const r=Ke.innerParams.get(e);r.toast?br(e,t,n):(vr(t),kr(t),Ir(e,t,n))},br=(e,t,n)=>{t.popup.onclick=()=>{const t=Ke.innerParams.get(e);t&&(wr(t)||t.timer||t.input)||n(Nt.close)}},wr=e=>e.showConfirmButton||e.showDenyButton||e.showCancelButton||e.showCloseButton;let xr=!1;const vr=e=>{e.popup.onmousedown=()=>{e.container.onmouseup=function(t){e.container.onmouseup=void 0,t.target===e.container&&(xr=!0)}}},kr=e=>{e.container.onmousedown=()=>{e.popup.onmouseup=function(t){e.popup.onmouseup=void 0,(t.target===e.popup||e.popup.contains(t.target))&&(xr=!0)}}},Ir=(e,t,n)=>{t.container.onclick=r=>{const a=Ke.innerParams.get(e);xr?xr=!1:r.target===t.container&&u(a.allowOutsideClick)&&n(Nt.backdrop)}},Sr=e=>"object"===typeof e&&e.jquery,Nr=e=>e instanceof Element||Sr(e),Tr=e=>{const t={};return"object"!==typeof e[0]||Nr(e[0])?["title","html","icon"].forEach(((n,r)=>{const a=e[r];"string"===typeof a||Nr(a)?t[n]=a:void 0!==a&&s("Unexpected type of ".concat(n,'! Expected "string" or "Element", got ').concat(typeof a))})):Object.assign(t,e[0]),t};function Cr(){const e=this;for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return new e(...n)}function _r(e){class t extends(this){_main(t,n){return super._main(t,Object.assign({},e,n))}}return t}const Er=()=>Ie.timeout&&Ie.timeout.getTimerLeft(),Ar=()=>{if(Ie.timeout)return xe(),Ie.timeout.stop()},$r=()=>{if(Ie.timeout){const e=Ie.timeout.start();return we(e),e}},Fr=()=>{const e=Ie.timeout;return e&&(e.running?Ar():$r())},Rr=e=>{if(Ie.timeout){const t=Ie.timeout.increase(e);return we(t,!0),t}},Dr=()=>Ie.timeout&&Ie.timeout.isRunning();let Mr=!1;const Or={};function Lr(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"data-swal-template";Or[e]=this,Mr||(document.body.addEventListener("click",Pr),Mr=!0)}const Pr=e=>{for(let t=e.target;t&&t!==document;t=t.parentNode)for(const e in Or){const n=t.getAttribute(e);if(n)return void Or[e].fire({template:n})}};var zr=Object.freeze({isValidParameter:b,isUpdatableParameter:w,isDeprecatedParameter:x,argsToParams:Tr,isVisible:vn,clickConfirm:kn,clickDeny:In,clickCancel:Sn,getContainer:E,getPopup:F,getTitle:D,getHtmlContainer:M,getImage:O,getIcon:R,getInputLabel:W,getCloseButton:q,getActions:G,getConfirmButton:z,getDenyButton:B,getCancelButton:U,getLoader:V,getFooter:H,getTimerProgressBar:j,getFocusableElements:X,getValidationMessage:P,isLoading:J,fire:Cr,mixin:_r,showLoading:an,enableLoading:an,getTimerLeft:Er,stopTimer:Ar,resumeTimer:$r,toggleTimer:Fr,increaseTimer:Rr,isTimerRunning:Dr,bindClickHandler:Lr});let Br;class Wr{constructor(){if("undefined"===typeof window)return;Br=this;for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];const r=Object.freeze(this.constructor.argsToParams(t));Object.defineProperties(this,{params:{value:r,writable:!1,enumerable:!0,configurable:!0}});const a=Br._main(Br.params);Ke.promise.set(this,a)}_main(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};S(Object.assign({},t,e)),Ie.currentInstance&&(Ie.currentInstance._destroy(),Y()&&Ct()),Ie.currentInstance=Br;const n=Ur(e,t);Wt(n),Object.freeze(n),Ie.timeout&&(Ie.timeout.stop(),delete Ie.timeout),clearTimeout(Ie.restoreFocusTimeout);const r=Gr(Br);return St(Br,n),Ke.innerParams.set(Br,n),Vr(Br,r,n)}then(e){const t=Ke.promise.get(this);return t.then(e)}finally(e){const t=Ke.promise.get(this);return t.finally(e)}}const Vr=(e,t,n)=>new Promise(((r,a)=>{const s=t=>{e.closePopup({isDismissed:!0,dismiss:t})};xn.swalPromiseResolve.set(e,r),xn.swalPromiseReject.set(e,a),t.confirmButton.onclick=()=>lr(e),t.denyButton.onclick=()=>ur(e),t.cancelButton.onclick=()=>pr(e,s),t.closeButton.onclick=()=>s(Nt.close),yr(e,t,s),Tn(e,Ie,n,s),on(e,n),Qt(n),Hr(Ie,n,s),jr(t,n),setTimeout((()=>{t.container.scrollTop=0}))})),Ur=(e,t)=>{const n=Et(e),r=Object.assign({},f,t,n,e);return r.showClass=Object.assign({},f.showClass,r.showClass),r.hideClass=Object.assign({},f.hideClass,r.hideClass),r},Gr=e=>{const t={popup:F(),container:E(),actions:G(),confirmButton:z(),denyButton:B(),cancelButton:U(),loader:V(),closeButton:q(),validationMessage:P(),progressSteps:L()};return Ke.domCache.set(e,t),t},Hr=(e,t,n)=>{const r=j();ce(r),t.timer&&(e.timeout=new Vt((()=>{n("timer"),delete e.timeout}),t.timer),t.timerProgressBar&&(de(r),re(r,t,"timerProgressBar"),setTimeout((()=>{e.timeout&&e.timeout.running&&we(t.timer)}))))},jr=(e,t)=>{if(!t.toast)return u(t.allowEnterKey)?void(qr(e,t)||Cn(t,-1,1)):Kr()},qr=(e,t)=>t.focusDeny&&me(e.denyButton)?(e.denyButton.focus(),!0):t.focusCancel&&me(e.cancelButton)?(e.cancelButton.focus(),!0):!(!t.focusConfirm||!me(e.confirmButton))&&(e.confirmButton.focus(),!0),Kr=()=>{document.activeElement instanceof HTMLElement&&"function"===typeof document.activeElement.blur&&document.activeElement.blur()};Object.assign(Wr.prototype,or),Object.assign(Wr,zr),Object.keys(or).forEach((e=>{Wr[e]=function(){if(Br)return Br[e](...arguments)}})),Wr.DismissReason=Nt,Wr.version="11.4.18";const Xr=Wr;return Xr.default=Xr,Xr})),"undefined"!==typeof this&&this.Sweetalert2&&(this.swal=this.sweetAlert=this.Swal=this.SweetAlert=this.Sweetalert2),"undefined"!=typeof document&&function(e,t){var n=e.createElement("style");if(e.getElementsByTagName("head")[0].appendChild(n),n.styleSheet)n.styleSheet.disabled||(n.styleSheet.cssText=t);else try{n.innerHTML=t}catch(e){n.innerText=t}}(document,'.swal2-popup.swal2-toast{box-sizing:border-box;grid-column:1/4!important;grid-row:1/4!important;grid-template-columns:1fr 99fr 1fr;padding:1em;overflow-y:hidden;background:#fff;box-shadow:0 0 1px hsla(0deg,0%,0%,.075),0 1px 2px hsla(0deg,0%,0%,.075),1px 2px 4px hsla(0deg,0%,0%,.075),1px 3px 8px hsla(0deg,0%,0%,.075),2px 4px 16px hsla(0deg,0%,0%,.075);pointer-events:all}.swal2-popup.swal2-toast>*{grid-column:2}.swal2-popup.swal2-toast .swal2-title{margin:.5em 1em;padding:0;font-size:1em;text-align:initial}.swal2-popup.swal2-toast .swal2-loading{justify-content:center}.swal2-popup.swal2-toast .swal2-input{height:2em;margin:.5em;font-size:1em}.swal2-popup.swal2-toast .swal2-validation-message{font-size:1em}.swal2-popup.swal2-toast .swal2-footer{margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-popup.swal2-toast .swal2-close{grid-column:3/3;grid-row:1/99;align-self:center;width:.8em;height:.8em;margin:0;font-size:2em}.swal2-popup.swal2-toast .swal2-html-container{margin:.5em 1em;padding:0;font-size:1em;text-align:initial}.swal2-popup.swal2-toast .swal2-html-container:empty{padding:0}.swal2-popup.swal2-toast .swal2-loader{grid-column:1;grid-row:1/99;align-self:center;width:2em;height:2em;margin:.25em}.swal2-popup.swal2-toast .swal2-icon{grid-column:1;grid-row:1/99;align-self:center;width:2em;min-width:2em;height:2em;margin:0 .5em 0 0}.swal2-popup.swal2-toast .swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:1.8em;font-weight:700}.swal2-popup.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-popup.swal2-toast .swal2-actions{justify-content:flex-start;height:auto;margin:0;margin-top:.5em;padding:0 .5em}.swal2-popup.swal2-toast .swal2-styled{margin:.25em .5em;padding:.4em .6em;font-size:1em}.swal2-popup.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:1.6em;height:3em;transform:rotate(45deg);border-radius:50%}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-.8em;left:-.5em;transform:rotate(-45deg);transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-.25em;left:.9375em;transform-origin:0 1.5em;border-radius:0 4em 4em 0}.swal2-popup.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-tip{-webkit-animation:swal2-toast-animate-success-line-tip .75s;animation:swal2-toast-animate-success-line-tip .75s}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-long{-webkit-animation:swal2-toast-animate-success-line-long .75s;animation:swal2-toast-animate-success-line-long .75s}.swal2-popup.swal2-toast.swal2-show{-webkit-animation:swal2-toast-show .5s;animation:swal2-toast-show .5s}.swal2-popup.swal2-toast.swal2-hide{-webkit-animation:swal2-toast-hide .1s forwards;animation:swal2-toast-hide .1s forwards}.swal2-container{display:grid;position:fixed;z-index:1060;top:0;right:0;bottom:0;left:0;box-sizing:border-box;grid-template-areas:"top-start     top            top-end" "center-start  center         center-end" "bottom-start  bottom-center  bottom-end";grid-template-rows:minmax(-webkit-min-content,auto) minmax(-webkit-min-content,auto) minmax(-webkit-min-content,auto);grid-template-rows:minmax(min-content,auto) minmax(min-content,auto) minmax(min-content,auto);height:100%;padding:.625em;overflow-x:hidden;transition:background-color .1s;-webkit-overflow-scrolling:touch}.swal2-container.swal2-backdrop-show,.swal2-container.swal2-noanimation{background:rgba(0,0,0,.4)}.swal2-container.swal2-backdrop-hide{background:0 0!important}.swal2-container.swal2-bottom-start,.swal2-container.swal2-center-start,.swal2-container.swal2-top-start{grid-template-columns:minmax(0,1fr) auto auto}.swal2-container.swal2-bottom,.swal2-container.swal2-center,.swal2-container.swal2-top{grid-template-columns:auto minmax(0,1fr) auto}.swal2-container.swal2-bottom-end,.swal2-container.swal2-center-end,.swal2-container.swal2-top-end{grid-template-columns:auto auto minmax(0,1fr)}.swal2-container.swal2-top-start>.swal2-popup{align-self:start}.swal2-container.swal2-top>.swal2-popup{grid-column:2;align-self:start;justify-self:center}.swal2-container.swal2-top-end>.swal2-popup,.swal2-container.swal2-top-right>.swal2-popup{grid-column:3;align-self:start;justify-self:end}.swal2-container.swal2-center-left>.swal2-popup,.swal2-container.swal2-center-start>.swal2-popup{grid-row:2;align-self:center}.swal2-container.swal2-center>.swal2-popup{grid-column:2;grid-row:2;align-self:center;justify-self:center}.swal2-container.swal2-center-end>.swal2-popup,.swal2-container.swal2-center-right>.swal2-popup{grid-column:3;grid-row:2;align-self:center;justify-self:end}.swal2-container.swal2-bottom-left>.swal2-popup,.swal2-container.swal2-bottom-start>.swal2-popup{grid-column:1;grid-row:3;align-self:end}.swal2-container.swal2-bottom>.swal2-popup{grid-column:2;grid-row:3;justify-self:center;align-self:end}.swal2-container.swal2-bottom-end>.swal2-popup,.swal2-container.swal2-bottom-right>.swal2-popup{grid-column:3;grid-row:3;align-self:end;justify-self:end}.swal2-container.swal2-grow-fullscreen>.swal2-popup,.swal2-container.swal2-grow-row>.swal2-popup{grid-column:1/4;width:100%}.swal2-container.swal2-grow-column>.swal2-popup,.swal2-container.swal2-grow-fullscreen>.swal2-popup{grid-row:1/4;align-self:stretch}.swal2-container.swal2-no-transition{transition:none!important}.swal2-popup{display:none;position:relative;box-sizing:border-box;grid-template-columns:minmax(0,100%);width:32em;max-width:100%;padding:0 0 1.25em;border:none;border-radius:5px;background:#fff;color:#545454;font-family:inherit;font-size:1rem}.swal2-popup:focus{outline:0}.swal2-popup.swal2-loading{overflow-y:hidden}.swal2-title{position:relative;max-width:100%;margin:0;padding:.8em 1em 0;color:inherit;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;word-wrap:break-word}.swal2-actions{display:flex;z-index:1;box-sizing:border-box;flex-wrap:wrap;align-items:center;justify-content:center;width:auto;margin:1.25em auto 0;padding:0}.swal2-actions:not(.swal2-loading) .swal2-styled[disabled]{opacity:.4}.swal2-actions:not(.swal2-loading) .swal2-styled:hover{background-image:linear-gradient(rgba(0,0,0,.1),rgba(0,0,0,.1))}.swal2-actions:not(.swal2-loading) .swal2-styled:active{background-image:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2))}.swal2-loader{display:none;align-items:center;justify-content:center;width:2.2em;height:2.2em;margin:0 1.875em;-webkit-animation:swal2-rotate-loading 1.5s linear 0s infinite normal;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border-width:.25em;border-style:solid;border-radius:100%;border-color:#2778c4 transparent #2778c4 transparent}.swal2-styled{margin:.3125em;padding:.625em 1.1em;transition:box-shadow .1s;box-shadow:0 0 0 3px transparent;font-weight:500}.swal2-styled:not([disabled]){cursor:pointer}.swal2-styled.swal2-confirm{border:0;border-radius:.25em;background:initial;background-color:#7066e0;color:#fff;font-size:1em}.swal2-styled.swal2-confirm:focus{box-shadow:0 0 0 3px rgba(112,102,224,.5)}.swal2-styled.swal2-deny{border:0;border-radius:.25em;background:initial;background-color:#dc3741;color:#fff;font-size:1em}.swal2-styled.swal2-deny:focus{box-shadow:0 0 0 3px rgba(220,55,65,.5)}.swal2-styled.swal2-cancel{border:0;border-radius:.25em;background:initial;background-color:#6e7881;color:#fff;font-size:1em}.swal2-styled.swal2-cancel:focus{box-shadow:0 0 0 3px rgba(110,120,129,.5)}.swal2-styled.swal2-default-outline:focus{box-shadow:0 0 0 3px rgba(100,150,200,.5)}.swal2-styled:focus{outline:0}.swal2-styled::-moz-focus-inner{border:0}.swal2-footer{justify-content:center;margin:1em 0 0;padding:1em 1em 0;border-top:1px solid #eee;color:inherit;font-size:1em}.swal2-timer-progress-bar-container{position:absolute;right:0;bottom:0;left:0;grid-column:auto!important;overflow:hidden;border-bottom-right-radius:5px;border-bottom-left-radius:5px}.swal2-timer-progress-bar{width:100%;height:.25em;background:rgba(0,0,0,.2)}.swal2-image{max-width:100%;margin:2em auto 1em}.swal2-close{z-index:2;align-items:center;justify-content:center;width:1.2em;height:1.2em;margin-top:0;margin-right:0;margin-bottom:-1.2em;padding:0;overflow:hidden;transition:color .1s,box-shadow .1s;border:none;border-radius:5px;background:0 0;color:#ccc;font-family:serif;font-family:monospace;font-size:2.5em;cursor:pointer;justify-self:end}.swal2-close:hover{transform:none;background:0 0;color:#f27474}.swal2-close:focus{outline:0;box-shadow:inset 0 0 0 3px rgba(100,150,200,.5)}.swal2-close::-moz-focus-inner{border:0}.swal2-html-container{z-index:1;justify-content:center;margin:1em 1.6em .3em;padding:0;overflow:auto;color:inherit;font-size:1.125em;font-weight:400;line-height:normal;text-align:center;word-wrap:break-word;word-break:break-word}.swal2-checkbox,.swal2-file,.swal2-input,.swal2-radio,.swal2-select,.swal2-textarea{margin:1em 2em 3px}.swal2-file,.swal2-input,.swal2-textarea{box-sizing:border-box;width:auto;transition:border-color .1s,box-shadow .1s;border:1px solid #d9d9d9;border-radius:.1875em;background:0 0;box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px transparent;color:inherit;font-size:1.125em}.swal2-file.swal2-inputerror,.swal2-input.swal2-inputerror,.swal2-textarea.swal2-inputerror{border-color:#f27474!important;box-shadow:0 0 2px #f27474!important}.swal2-file:focus,.swal2-input:focus,.swal2-textarea:focus{border:1px solid #b4dbed;outline:0;box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px rgba(100,150,200,.5)}.swal2-file::-moz-placeholder,.swal2-input::-moz-placeholder,.swal2-textarea::-moz-placeholder{color:#ccc}.swal2-file:-ms-input-placeholder,.swal2-input:-ms-input-placeholder,.swal2-textarea:-ms-input-placeholder{color:#ccc}.swal2-file::placeholder,.swal2-input::placeholder,.swal2-textarea::placeholder{color:#ccc}.swal2-range{margin:1em 2em 3px;background:#fff}.swal2-range input{width:80%}.swal2-range output{width:20%;color:inherit;font-weight:600;text-align:center}.swal2-range input,.swal2-range output{height:2.625em;padding:0;font-size:1.125em;line-height:2.625em}.swal2-input{height:2.625em;padding:0 .75em}.swal2-file{width:75%;margin-right:auto;margin-left:auto;background:0 0;font-size:1.125em}.swal2-textarea{height:6.75em;padding:.75em}.swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;background:0 0;color:inherit;font-size:1.125em}.swal2-checkbox,.swal2-radio{align-items:center;justify-content:center;background:#fff;color:inherit}.swal2-checkbox label,.swal2-radio label{margin:0 .6em;font-size:1.125em}.swal2-checkbox input,.swal2-radio input{flex-shrink:0;margin:0 .4em}.swal2-input-label{display:flex;justify-content:center;margin:1em auto 0}.swal2-validation-message{align-items:center;justify-content:center;margin:1em 0 0;padding:.625em;overflow:hidden;background:#f0f0f0;color:#666;font-size:1em;font-weight:300}.swal2-validation-message::before{content:"!";display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center}.swal2-icon{position:relative;box-sizing:content-box;justify-content:center;width:5em;height:5em;margin:2.5em auto .6em;border:.25em solid transparent;border-radius:50%;border-color:#000;font-family:inherit;line-height:5em;cursor:default;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:3.75em}.swal2-icon.swal2-error{border-color:#f27474;color:#f27474}.swal2-icon.swal2-error .swal2-x-mark{position:relative;flex-grow:1}.swal2-icon.swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}.swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;transform:rotate(45deg)}.swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;transform:rotate(-45deg)}.swal2-icon.swal2-error.swal2-icon-show{-webkit-animation:swal2-animate-error-icon .5s;animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-error.swal2-icon-show .swal2-x-mark{-webkit-animation:swal2-animate-error-x-mark .5s;animation:swal2-animate-error-x-mark .5s}.swal2-icon.swal2-warning{border-color:#facea8;color:#f8bb86}.swal2-icon.swal2-warning.swal2-icon-show{-webkit-animation:swal2-animate-error-icon .5s;animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-warning.swal2-icon-show .swal2-icon-content{-webkit-animation:swal2-animate-i-mark .5s;animation:swal2-animate-i-mark .5s}.swal2-icon.swal2-info{border-color:#9de0f6;color:#3fc3ee}.swal2-icon.swal2-info.swal2-icon-show{-webkit-animation:swal2-animate-error-icon .5s;animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-info.swal2-icon-show .swal2-icon-content{-webkit-animation:swal2-animate-i-mark .8s;animation:swal2-animate-i-mark .8s}.swal2-icon.swal2-question{border-color:#c9dae1;color:#87adbd}.swal2-icon.swal2-question.swal2-icon-show{-webkit-animation:swal2-animate-error-icon .5s;animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-question.swal2-icon-show .swal2-icon-content{-webkit-animation:swal2-animate-question-mark .8s;animation:swal2-animate-question-mark .8s}.swal2-icon.swal2-success{border-color:#a5dc86;color:#a5dc86}.swal2-icon.swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;transform:rotate(45deg);border-radius:50%}.swal2-icon.swal2-success [class^=swal2-success-circular-line][class$=left]{top:-.4375em;left:-2.0635em;transform:rotate(-45deg);transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}.swal2-icon.swal2-success [class^=swal2-success-circular-line][class$=right]{top:-.6875em;left:1.875em;transform:rotate(-45deg);transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}.swal2-icon.swal2-success .swal2-success-ring{position:absolute;z-index:2;top:-.25em;left:-.25em;box-sizing:content-box;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%}.swal2-icon.swal2-success .swal2-success-fix{position:absolute;z-index:1;top:.5em;left:1.625em;width:.4375em;height:5.625em;transform:rotate(-45deg)}.swal2-icon.swal2-success [class^=swal2-success-line]{display:block;position:absolute;z-index:2;height:.3125em;border-radius:.125em;background-color:#a5dc86}.swal2-icon.swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.8125em;width:1.5625em;transform:rotate(45deg)}.swal2-icon.swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;transform:rotate(-45deg)}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-line-tip{-webkit-animation:swal2-animate-success-line-tip .75s;animation:swal2-animate-success-line-tip .75s}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-line-long{-webkit-animation:swal2-animate-success-line-long .75s;animation:swal2-animate-success-line-long .75s}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-circular-line-right{-webkit-animation:swal2-rotate-success-circular-line 4.25s ease-in;animation:swal2-rotate-success-circular-line 4.25s ease-in}.swal2-progress-steps{flex-wrap:wrap;align-items:center;max-width:100%;margin:1.25em auto;padding:0;background:0 0;font-weight:600}.swal2-progress-steps li{display:inline-block;position:relative}.swal2-progress-steps .swal2-progress-step{z-index:20;flex-shrink:0;width:2em;height:2em;border-radius:2em;background:#2778c4;color:#fff;line-height:2em;text-align:center}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step{background:#2778c4}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step{background:#add8e6;color:#fff}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step-line{background:#add8e6}.swal2-progress-steps .swal2-progress-step-line{z-index:10;flex-shrink:0;width:2.5em;height:.4em;margin:0 -1px;background:#2778c4}[class^=swal2]{-webkit-tap-highlight-color:transparent}.swal2-show{-webkit-animation:swal2-show .3s;animation:swal2-show .3s}.swal2-hide{-webkit-animation:swal2-hide .15s forwards;animation:swal2-hide .15s forwards}.swal2-noanimation{transition:none}.swal2-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.swal2-rtl .swal2-close{margin-right:initial;margin-left:0}.swal2-rtl .swal2-timer-progress-bar{right:0;left:auto}.swal2-no-war{display:flex;position:fixed;z-index:1061;top:0;left:0;align-items:center;justify-content:center;width:100%;height:3.375em;background:#20232a;color:#fff;text-align:center}.swal2-no-war a{color:#61dafb;text-decoration:none}.swal2-no-war a:hover{text-decoration:underline}@-webkit-keyframes swal2-toast-show{0%{transform:translateY(-.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0)}}@keyframes swal2-toast-show{0%{transform:translateY(-.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0)}}@-webkit-keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@-webkit-keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@-webkit-keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}@keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}@-webkit-keyframes swal2-show{0%{transform:scale(.7)}45%{transform:scale(1.05)}80%{transform:scale(.95)}100%{transform:scale(1)}}@keyframes swal2-show{0%{transform:scale(.7)}45%{transform:scale(1.05)}80%{transform:scale(.95)}100%{transform:scale(1)}}@-webkit-keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(.5);opacity:0}}@keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(.5);opacity:0}}@-webkit-keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@-webkit-keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@-webkit-keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@-webkit-keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(.4);opacity:0}50%{margin-top:1.625em;transform:scale(.4);opacity:0}80%{margin-top:-.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(.4);opacity:0}50%{margin-top:1.625em;transform:scale(.4);opacity:0}80%{margin-top:-.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@-webkit-keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0);opacity:1}}@keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0);opacity:1}}@-webkit-keyframes swal2-rotate-loading{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@keyframes swal2-rotate-loading{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@-webkit-keyframes swal2-animate-question-mark{0%{transform:rotateY(-360deg)}100%{transform:rotateY(0)}}@keyframes swal2-animate-question-mark{0%{transform:rotateY(-360deg)}100%{transform:rotateY(0)}}@-webkit-keyframes swal2-animate-i-mark{0%{transform:rotateZ(45deg);opacity:0}25%{transform:rotateZ(-25deg);opacity:.4}50%{transform:rotateZ(15deg);opacity:.8}75%{transform:rotateZ(-5deg);opacity:1}100%{transform:rotateX(0);opacity:1}}@keyframes swal2-animate-i-mark{0%{transform:rotateZ(45deg);opacity:0}25%{transform:rotateZ(-25deg);opacity:.4}50%{transform:rotateZ(15deg);opacity:.8}75%{transform:rotateZ(-5deg);opacity:1}100%{transform:rotateX(0);opacity:1}}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto!important}body.swal2-no-backdrop .swal2-container{background-color:transparent!important;pointer-events:none}body.swal2-no-backdrop .swal2-container .swal2-popup{pointer-events:all}body.swal2-no-backdrop .swal2-container .swal2-modal{box-shadow:0 0 10px rgba(0,0,0,.4)}@media print{body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow-y:scroll!important}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown) .swal2-container{position:static!important}}body.swal2-toast-shown .swal2-container{box-sizing:border-box;width:360px;max-width:100%;background-color:transparent;pointer-events:none}body.swal2-toast-shown .swal2-container.swal2-top{top:0;right:auto;bottom:auto;left:50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{top:0;right:0;bottom:auto;left:auto}body.swal2-toast-shown .swal2-container.swal2-top-left,body.swal2-toast-shown .swal2-container.swal2-top-start{top:0;right:auto;bottom:auto;left:0}body.swal2-toast-shown .swal2-container.swal2-center-left,body.swal2-toast-shown .swal2-container.swal2-center-start{top:50%;right:auto;bottom:auto;left:0;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{top:50%;right:auto;bottom:auto;left:50%;transform:translate(-50%,-50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{top:50%;right:0;bottom:auto;left:auto;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-left,body.swal2-toast-shown .swal2-container.swal2-bottom-start{top:auto;right:auto;bottom:0;left:0}body.swal2-toast-shown .swal2-container.swal2-bottom{top:auto;right:auto;bottom:0;left:50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{top:auto;right:0;bottom:0;left:auto}')},4272:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return uae}});var r=n(3396);const a={class:"d-flex flex-column justify-content-center align-items-center"};function s(e,t,n,s,i,o){const l=(0,r.up)("Webcam");return(0,r.wg)(),(0,r.iD)("div",a,[(0,r.Wm)(l),(0,r._)("button",{class:"btn btn-secondary absolute button",onClick:t[0]||(t[0]=e=>this.$router.push("/"))},"Retour")])}const i={id:"video",width:"720",height:"560",autoplay:"",muted:"",playsinline:""};function o(e,t,n,a,s,o){return(0,r.wg)(),(0,r.iD)("video",i)}n(1703),n(8675),n(3462),n(7380),n(1118),n(6699),n(2087),n(2801),n(4633);var l="/index.js",u="/",p=Object.defineProperty,d=(e=>n(6741))(),c=(e,t)=>{for(var n in t)p(e,n,{get:t[n],enumerable:!0})},h={};c(h,{Abs:()=>ot,Acos:()=>lt,Acosh:()=>ut,AdadeltaOptimizer:()=>Sw,AdagradOptimizer:()=>Nw,AdamOptimizer:()=>Tw,AdamaxOptimizer:()=>Cw,Add:()=>pt,AddN:()=>dt,All:()=>ct,Any:()=>ht,ArgMax:()=>ft,ArgMin:()=>mt,Asin:()=>gt,Asinh:()=>yt,Atan:()=>bt,Atan2:()=>xt,Atanh:()=>wt,AvgPool:()=>vt,AvgPool3D:()=>It,AvgPool3DGrad:()=>St,AvgPoolGrad:()=>kt,BackendWasm:()=>V9,BatchMatMul:()=>Nt,BatchToSpaceND:()=>Tt,Bincount:()=>Ct,BroadcastArgs:()=>Et,BroadcastTo:()=>_t,Callback:()=>tF,CallbackList:()=>oT,Cast:()=>At,Ceil:()=>$t,ClipByValue:()=>Ft,Complex:()=>Rt,ComplexAbs:()=>Dt,Concat:()=>Mt,Conv2D:()=>Ot,Conv2DBackpropFilter:()=>Lt,Conv2DBackpropInput:()=>Pt,Conv3D:()=>zt,Conv3DBackpropFilterV2:()=>Bt,Conv3DBackpropInputV2:()=>Wt,Cos:()=>Vt,Cosh:()=>Ut,CropAndResize:()=>jt,Cumprod:()=>Gt,Cumsum:()=>Ht,CustomCallback:()=>pT,DataStorage:()=>J,DenseBincount:()=>qt,DepthToSpace:()=>Kt,DepthwiseConv2dNative:()=>Xt,DepthwiseConv2dNativeBackpropFilter:()=>Yt,DepthwiseConv2dNativeBackpropInput:()=>Zt,Diag:()=>Jt,Dilation2D:()=>Qt,Dilation2DBackpropFilter:()=>tn,Dilation2DBackpropInput:()=>en,ENV:()=>nt,EarlyStopping:()=>aF,Einsum:()=>rn,Elu:()=>an,EluGrad:()=>sn,Environment:()=>Ye,Equal:()=>ln,Erf:()=>on,Exp:()=>un,ExpandDims:()=>pn,Expm1:()=>dn,FFT:()=>cn,Fill:()=>hn,FlipLeftRight:()=>fn,Floor:()=>mn,FloorDiv:()=>gn,FromPixels:()=>ca,FusedBatchNorm:()=>yn,FusedConv2D:()=>ma,FusedDepthwiseConv2D:()=>ga,GPGPUContext:()=>Oj,GatherNd:()=>wn,GatherV2:()=>bn,GraphModel:()=>mD,Greater:()=>xn,GreaterEqual:()=>vn,History:()=>uT,IFFT:()=>In,Identity:()=>kn,Imag:()=>Sn,InputSpec:()=>nN,IsFinite:()=>Nn,IsInf:()=>Tn,IsNan:()=>Cn,KernelBackend:()=>Q,LRN:()=>zn,LRNGrad:()=>Bn,LayerVariable:()=>JS,LayersModel:()=>GC,LeakyRelu:()=>_n,Less:()=>En,LessEqual:()=>An,LinSpace:()=>$n,Log:()=>Fn,Log1p:()=>Rn,LogSoftmax:()=>Ln,LogicalAnd:()=>Dn,LogicalNot:()=>Mn,LogicalOr:()=>On,LowerBound:()=>Pn,MathBackendWebGL:()=>pK,Max:()=>Wn,MaxPool:()=>Un,MaxPool3D:()=>Hn,MaxPool3DGrad:()=>jn,MaxPoolGrad:()=>Gn,MaxPoolWithArgmax:()=>qn,Maximum:()=>Vn,Mean:()=>Kn,Min:()=>Xn,Minimum:()=>Yn,MirrorPad:()=>Zn,Mod:()=>Jn,MomentumOptimizer:()=>Ew,Multinomial:()=>Qn,Multiply:()=>er,Neg:()=>tr,NonMaxSuppressionV3:()=>rr,NonMaxSuppressionV4:()=>ar,NonMaxSuppressionV5:()=>sr,NotEqual:()=>nr,OP_SCOPE_SUFFIX:()=>si,OneHot:()=>or,OnesLike:()=>ir,Optimizer:()=>Iw,OptimizerConstructors:()=>$w,Pack:()=>lr,PadV2:()=>ur,Pool:()=>pr,Pow:()=>dr,Prelu:()=>cr,Prod:()=>hr,RMSPropOptimizer:()=>Aw,RNN:()=>aE,Range:()=>fr,Rank:()=>Ns,Real:()=>mr,RealDiv:()=>nn,Reciprocal:()=>gr,Reduction:()=>Db,Relu:()=>yr,Relu6:()=>Ir,Reshape:()=>br,ResizeBilinear:()=>vr,ResizeBilinearGrad:()=>kr,ResizeNearestNeighbor:()=>wr,ResizeNearestNeighborGrad:()=>xr,Reverse:()=>Sr,RotateWithOffset:()=>ha,Round:()=>Nr,Rsqrt:()=>Tr,SGDOptimizer:()=>_w,ScatterNd:()=>Cr,SearchSorted:()=>_r,Select:()=>Er,Selu:()=>Ar,Sequential:()=>YC,Sigmoid:()=>Mr,Sign:()=>Dr,Sin:()=>Fr,Sinh:()=>Rr,Slice:()=>$r,Softmax:()=>Wr,Softplus:()=>Or,SpaceToBatchND:()=>zr,SparseFillEmptyRows:()=>Vr,SparseReshape:()=>Ur,SparseSegmentMean:()=>Gr,SparseSegmentSum:()=>Hr,SparseToDense:()=>jr,SplitV:()=>Br,Sqrt:()=>Lr,Square:()=>Kr,SquaredDifference:()=>qr,Step:()=>da,StridedSlice:()=>Xr,StringNGrams:()=>Yr,StringSplit:()=>Zr,StringToHashBucketFast:()=>Jr,Sub:()=>Qr,Sum:()=>Pr,SymbolicTensor:()=>rN,Tan:()=>ea,Tanh:()=>ta,Tensor:()=>ks,TensorBuffer:()=>gs,Tile:()=>na,TopK:()=>ra,Transform:()=>aa,Transpose:()=>sa,Unique:()=>ia,Unpack:()=>oa,UnsortedSegmentSum:()=>la,UpperBound:()=>ua,Variable:()=>Ss,ZerosLike:()=>pa,_FusedMatMul:()=>fa,abs:()=>Ju,acos:()=>ep,acosh:()=>np,add:()=>Gu,addN:()=>ap,all:()=>ip,any:()=>lp,argMax:()=>pp,argMin:()=>cp,asin:()=>fp,asinh:()=>gp,atan:()=>bp,atan2:()=>xp,atanh:()=>kp,avgPool:()=>Gp,avgPool3d:()=>jp,backend:()=>Nl,backend_util:()=>Mw,basicLSTMCell:()=>nd,batchNorm:()=>od,batchNorm2d:()=>ud,batchNorm3d:()=>dd,batchNorm4d:()=>hd,batchToSpaceND:()=>ad,bincount:()=>md,booleanMaskAsync:()=>Qg,broadcastArgs:()=>yd,broadcastTo:()=>wd,broadcast_util:()=>Ll,browser:()=>Vl,buffer:()=>wo,callbacks:()=>lF,cast:()=>vo,ceil:()=>vd,clipByValue:()=>Id,clone:()=>Io,complex:()=>li,concat:()=>Kp,concat1d:()=>Nd,concat2d:()=>Cd,concat3d:()=>Ed,concat4d:()=>$d,constraints:()=>SN,conv1d:()=>Md,conv2d:()=>Rd,conv2dTranspose:()=>zd,conv3d:()=>Wd,conv3dTranspose:()=>Hd,copyRegisteredKernels:()=>_a,cos:()=>qd,cosh:()=>Xd,cosineWindow:()=>hy,cumprod:()=>Zd,cumsum:()=>Qd,customGrad:()=>Wh,data:()=>xD,denseBincount:()=>tc,deprecationWarn:()=>ul,depthToSpace:()=>rc,depthwiseConv2d:()=>sc,deregisterOp:()=>hF,device_util:()=>Ks,diag:()=>oc,dilation2d:()=>uc,disableDeprecationWarnings:()=>ll,dispose:()=>ml,disposeVariables:()=>pl,div:()=>Ku,divNoNan:()=>yc,dot:()=>wc,dropout:()=>dy,einsum:()=>vc,elu:()=>Ic,enableDebugMode:()=>ol,enableProdMode:()=>il,enclosingPowerOfTwo:()=>cy,engine:()=>dl,env:()=>et,equal:()=>dc,erf:()=>Nc,euclideanNorm:()=>Zc,exp:()=>Qc,expandDims:()=>th,expm1:()=>rh,eye:()=>oh,fft:()=>dg,fill:()=>lh,findBackend:()=>kl,findBackendFactory:()=>Il,floor:()=>ph,floorDiv:()=>ju,forceHalfFloat:()=>hK,fused:()=>gy,gather:()=>ch,gatherND:()=>ly,gather_util:()=>Jl,getBackend:()=>xl,getGradient:()=>ka,getKernel:()=>va,getKernelsForBackend:()=>Ia,getThreadsCount:()=>aee,gpgpu_util:()=>hj,grad:()=>Oh,grads:()=>Lh,greater:()=>fh,greaterEqual:()=>gh,ifft:()=>hg,imag:()=>_l,image:()=>bw,inTopKAsync:()=>my,initializers:()=>zN,input:()=>e_,io:()=>To,irfft:()=>mg,isFinite:()=>bh,isInf:()=>xh,isNaN:()=>kh,keep:()=>gl,kernel_impls:()=>Lx,layers:()=>nT,leakyRelu:()=>Sh,less:()=>Th,lessEqual:()=>_h,linalg:()=>ww,linspace:()=>Eh,loadGraphModel:()=>gD,loadGraphModelSync:()=>yD,loadLayersModel:()=>QC,localResponseNormalization:()=>$h,log:()=>Rh,log1p:()=>Mh,logSigmoid:()=>jh,logSoftmax:()=>Yh,logSumExp:()=>Jh,logicalAnd:()=>ef,logicalNot:()=>nf,logicalOr:()=>af,logicalXor:()=>of,losses:()=>xw,lowerBound:()=>df,matMul:()=>rl,math:()=>tl,max:()=>Mc,maxPool:()=>hf,maxPool3d:()=>mf,maxPoolWithArgmax:()=>yf,maximum:()=>wf,mean:()=>vf,memory:()=>cl,meshgrid:()=>Sf,metrics:()=>D$,min:()=>Lc,minimum:()=>Tf,mirrorPad:()=>_f,mod:()=>Af,model:()=>ZC,models:()=>Y$,moments:()=>Ff,movingAverage:()=>ty,mul:()=>Yu,multiRNNCell:()=>Df,multinomial:()=>Of,neg:()=>Al,nextFrame:()=>Dw,norm:()=>Xc,notEqual:()=>Pf,oneHot:()=>sl,ones:()=>If,onesLike:()=>Bf,op:()=>ii,outerProduct:()=>Vf,pad:()=>Gf,pad1d:()=>jf,pad2d:()=>Kf,pad3d:()=>Yf,pad4d:()=>Jf,pool:()=>am,pow:()=>zc,prelu:()=>im,print:()=>So,prod:()=>lm,profile:()=>hl,rand:()=>pm,randomGamma:()=>gm,randomNormal:()=>bm,randomUniform:()=>xm,range:()=>vm,ready:()=>wl,real:()=>Fl,reciprocal:()=>Im,registerBackend:()=>Sl,registerCallbackConstructor:()=>t_,registerGradient:()=>Na,registerKernel:()=>Sa,registerOp:()=>dF,regularizers:()=>Z$,relu:()=>Nm,relu6:()=>Cm,removeBackend:()=>vl,reshape:()=>Vp,reverse:()=>Em,reverse1d:()=>$m,reverse2d:()=>Rm,reverse3d:()=>Mm,reverse4d:()=>Lm,rfft:()=>wg,round:()=>zm,rsqrt:()=>Wm,scalar:()=>Bc,scatterND:()=>ry,scatter_util:()=>eu,searchSorted:()=>pf,selu:()=>Um,separableConv2d:()=>Hm,sequential:()=>JC,serialization:()=>Nu,setBackend:()=>bl,setPlatform:()=>Tl,setThreadsCount:()=>ree,setWasmPath:()=>Q9,setWasmPaths:()=>eee,setWebGLContext:()=>GU,setdiff1dAsync:()=>qm,sigmoid:()=>Yp,sign:()=>Xm,signal:()=>yw,sin:()=>Zm,sinh:()=>Qm,slice:()=>Jp,slice1d:()=>tg,slice2d:()=>rg,slice3d:()=>sg,slice4d:()=>og,slice_util:()=>au,softmax:()=>ug,softplus:()=>Gh,spaceToBatchND:()=>em,sparse:()=>vw,sparseToDense:()=>iy,spectral:()=>gw,split:()=>yg,sqrt:()=>Vc,square:()=>Gc,squaredDifference:()=>vg,squeeze:()=>Ig,stack:()=>Ng,step:()=>Cg,stridedSlice:()=>Eg,string:()=>kw,sub:()=>Kh,sum:()=>jc,sumOutType:()=>Rs,tan:()=>$g,tanh:()=>ed,tensor:()=>pi,tensor1d:()=>Fg,tensor2d:()=>Rg,tensor3d:()=>Ul,tensor4d:()=>Dg,tensor5d:()=>Mg,tensor6d:()=>Og,tensor_util:()=>As,test_util:()=>Eu,tidy:()=>fl,tile:()=>sh,time:()=>yl,topk:()=>Pg,train:()=>Fw,transpose:()=>Dl,truncatedNormal:()=>Bg,unique:()=>Vg,unregisterGradient:()=>Ca,unregisterKernel:()=>Ta,unsortedSegmentSum:()=>Gg,unstack:()=>jg,upcastType:()=>Fs,upperBound:()=>qg,util:()=>Aa,valueAndGrad:()=>Ph,valueAndGrads:()=>zh,variable:()=>Kg,variableGrads:()=>Bh,version:()=>mee,version_converter:()=>wD,version_core:()=>Vu,version_layers:()=>cC,version_wasm:()=>see,version_webgl:()=>cK,webgl:()=>fK,webgl_util:()=>PU,where:()=>hc,whereAsync:()=>Zg,zeros:()=>kf,zerosLike:()=>mc});var f=Object.create,m=Object.defineProperty,g=Object.getOwnPropertyDescriptor,y=Object.getOwnPropertyNames,b=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty,x=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),v=(e,t)=>{for(var n in t)m(e,n,{get:t[n],enumerable:!0})},k=(e,t,n,r)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let a of y(t))!w.call(e,a)&&a!==n&&m(e,a,{get:()=>t[a],enumerable:!(r=g(t,a))||r.enumerable});return e},I=(e,t,n)=>(n=null!=e?f(b(e)):{},k(!t&&e&&e.__esModule?n:m(n,"default",{value:e,enumerable:!0}),e)),S=x(((e,t)=>{t.exports=r;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(_){}function r(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function a(e){return!0===(e&&e.__isLong__)}r.prototype.__isLong__,Object.defineProperty(r.prototype,"__isLong__",{value:!0}),r.isLong=a;var s={},i={};function o(e,t){var n,r,a;return t?(e>>>=0,(a=0<=e&&e<256)&&(r=i[e],r)?r:(n=u(e,(0|e)<0?-1:0,!0),a&&(i[e]=n),n)):(e|=0,(a=-128<=e&&e<128)&&(r=s[e],r)?r:(n=u(e,e<0?-1:0,!1),a&&(s[e]=n),n))}function l(e,t){if(isNaN(e))return t?x:w;if(t){if(e<0)return x;if(e>=g)return N}else{if(e<=-y)return T;if(e+1>=y)return S}return e<0?l(-e,t).neg():u(e%m|0,e/m|0,t)}function u(e,t,n){return new r(e,t,n)}r.fromInt=o,r.fromNumber=l,r.fromBits=u;var p=Math.pow;function d(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return w;if("number"==typeof t?(n=t,t=!1):t=!!t,n=n||10,n<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return d(e.substring(1),t,n).neg();for(var a=l(p(n,8)),s=w,i=0;i<e.length;i+=8){var o=Math.min(8,e.length-i),u=parseInt(e.substring(i,i+o),n);if(o<8){var c=l(p(n,o));s=s.mul(c).add(l(u))}else s=s.mul(a),s=s.add(l(u))}return s.unsigned=t,s}function c(e,t){return"number"==typeof e?l(e,t):"string"==typeof e?d(e,t):u(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}r.fromString=d,r.fromValue=c;var h=65536,f=1<<24,m=h*h,g=m*m,y=g/2,b=o(f),w=o(0);r.ZERO=w;var x=o(0,!0);r.UZERO=x;var v=o(1);r.ONE=v;var k=o(1,!0);r.UONE=k;var I=o(-1);r.NEG_ONE=I;var S=u(-1,2147483647,!1);r.MAX_VALUE=S;var N=u(-1,-1,!0);r.MAX_UNSIGNED_VALUE=N;var T=u(0,-2147483648,!1);r.MIN_VALUE=T;var C=r.prototype;C.toInt=function(){return this.unsigned?this.low>>>0:this.low},C.toNumber=function(){return this.unsigned?(this.high>>>0)*m+(this.low>>>0):this.high*m+(this.low>>>0)},C.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(T)){var t=l(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var a=l(p(e,6),this.unsigned),s=this,i="";;){var o=s.div(a),u=s.sub(o.mul(a)).toInt()>>>0,d=u.toString(e);if(s=o,s.isZero())return d+i;for(;d.length<6;)d="0"+d;i=""+d+i}},C.getHighBits=function(){return this.high},C.getHighBitsUnsigned=function(){return this.high>>>0},C.getLowBits=function(){return this.low},C.getLowBitsUnsigned=function(){return this.low>>>0},C.getNumBitsAbs=function(){if(this.isNegative())return this.eq(T)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},C.isZero=function(){return 0===this.high&&0===this.low},C.eqz=C.isZero,C.isNegative=function(){return!this.unsigned&&this.high<0},C.isPositive=function(){return this.unsigned||this.high>=0},C.isOdd=function(){return 1===(1&this.low)},C.isEven=function(){return 0===(1&this.low)},C.equals=function(e){return a(e)||(e=c(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)},C.eq=C.equals,C.notEquals=function(e){return!this.eq(e)},C.neq=C.notEquals,C.ne=C.notEquals,C.lessThan=function(e){return this.comp(e)<0},C.lt=C.lessThan,C.lessThanOrEqual=function(e){return this.comp(e)<=0},C.lte=C.lessThanOrEqual,C.le=C.lessThanOrEqual,C.greaterThan=function(e){return this.comp(e)>0},C.gt=C.greaterThan,C.greaterThanOrEqual=function(e){return this.comp(e)>=0},C.gte=C.greaterThanOrEqual,C.ge=C.greaterThanOrEqual,C.compare=function(e){if(a(e)||(e=c(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},C.comp=C.compare,C.negate=function(){return!this.unsigned&&this.eq(T)?T:this.not().add(v)},C.neg=C.negate,C.add=function(e){a(e)||(e=c(e));var t=this.high>>>16,n=65535&this.high,r=this.low>>>16,s=65535&this.low,i=e.high>>>16,o=65535&e.high,l=e.low>>>16,p=65535&e.low,d=0,h=0,f=0,m=0;return m+=s+p,f+=m>>>16,m&=65535,f+=r+l,h+=f>>>16,f&=65535,h+=n+o,d+=h>>>16,h&=65535,d+=t+i,d&=65535,u(f<<16|m,d<<16|h,this.unsigned)},C.subtract=function(e){return a(e)||(e=c(e)),this.add(e.neg())},C.sub=C.subtract,C.multiply=function(e){if(this.isZero())return w;if(a(e)||(e=c(e)),n){var t=n.mul(this.low,this.high,e.low,e.high);return u(t,n.get_high(),this.unsigned)}if(e.isZero())return w;if(this.eq(T))return e.isOdd()?T:w;if(e.eq(T))return this.isOdd()?T:w;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(b)&&e.lt(b))return l(this.toNumber()*e.toNumber(),this.unsigned);var r=this.high>>>16,s=65535&this.high,i=this.low>>>16,o=65535&this.low,p=e.high>>>16,d=65535&e.high,h=e.low>>>16,f=65535&e.low,m=0,g=0,y=0,x=0;return x+=o*f,y+=x>>>16,x&=65535,y+=i*f,g+=y>>>16,y&=65535,y+=o*h,g+=y>>>16,y&=65535,g+=s*f,m+=g>>>16,g&=65535,g+=i*h,m+=g>>>16,g&=65535,g+=o*d,m+=g>>>16,g&=65535,m+=r*f+s*h+i*d+o*p,m&=65535,u(y<<16|x,m<<16|g,this.unsigned)},C.mul=C.multiply,C.divide=function(e){if(a(e)||(e=c(e)),e.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&-2147483648===this.high&&-1===e.low&&-1===e.high)return this;var t=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,e.low,e.high);return u(t,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?x:w;var r,s,i;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return x;if(e.gt(this.shru(1)))return k;i=x}else{if(this.eq(T)){if(e.eq(v)||e.eq(I))return T;if(e.eq(T))return v;var o=this.shr(1);return r=o.div(e).shl(1),r.eq(w)?e.isNegative()?v:I:(s=this.sub(e.mul(r)),i=r.add(s.div(e)),i)}if(e.eq(T))return this.unsigned?x:w;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();i=w}for(s=this;s.gte(e);){r=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var d=Math.ceil(Math.log(r)/Math.LN2),h=d<=48?1:p(2,d-48),f=l(r),m=f.mul(e);m.isNegative()||m.gt(s);)r-=h,f=l(r,this.unsigned),m=f.mul(e);f.isZero()&&(f=v),i=i.add(f),s=s.sub(m)}return i},C.div=C.divide,C.modulo=function(e){if(a(e)||(e=c(e)),n){var t=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,e.low,e.high);return u(t,n.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))},C.mod=C.modulo,C.rem=C.modulo,C.not=function(){return u(~this.low,~this.high,this.unsigned)},C.and=function(e){return a(e)||(e=c(e)),u(this.low&e.low,this.high&e.high,this.unsigned)},C.or=function(e){return a(e)||(e=c(e)),u(this.low|e.low,this.high|e.high,this.unsigned)},C.xor=function(e){return a(e)||(e=c(e)),u(this.low^e.low,this.high^e.high,this.unsigned)},C.shiftLeft=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?u(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):u(0,this.low<<e-32,this.unsigned)},C.shl=C.shiftLeft,C.shiftRight=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?u(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):u(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},C.shr=C.shiftRight,C.shiftRightUnsigned=function(e){if(a(e)&&(e=e.toInt()),e&=63,0===e)return this;var t=this.high;if(e<32){var n=this.low;return u(n>>>e|t<<32-e,t>>>e,this.unsigned)}return u(32===e?t:t>>>e-32,0,this.unsigned)},C.shru=C.shiftRightUnsigned,C.shr_u=C.shiftRightUnsigned,C.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},C.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},C.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},C.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},C.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},r.fromBytes=function(e,t,n){return n?r.fromBytesLE(e,t):r.fromBytesBE(e,t)},r.fromBytesLE=function(e,t){return new r(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},r.fromBytesBE=function(e,t){return new r(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}})),N=x((()=>{})),T=x((()=>{})),C=x(((e,t)=>{(function(e,t,n){function r(e){var t=this,n=i();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function a(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function s(e,t){var n=new r(e),s=t&&t.state,i=n.next;return i.int32=function(){return 4294967296*n.next()|0},i.double=function(){return i()+11102230246251565e-32*(2097152*i()|0)},i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}function i(){var e=4022871197,t=function(t){t=t.toString();for(var n=0;n<t.length;n++){e+=t.charCodeAt(n);var r=.02519603282416938*e;e=r>>>0,r-=e,r*=e,e=r>>>0,r-=e,e+=4294967296*r}return 2.3283064365386963e-10*(e>>>0)};return t}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.alea=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),_=x(((e,t)=>{(function(e,t,n){function r(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function s(e,t){var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xor128=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),E=x(((e,t)=>{(function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function s(e,t){var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xorwow=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),A=x(((e,t)=>{(function(e,t,n){function r(e){var t=this;function n(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}t.next=function(){var e,n,r=t.x,a=t.i;return e=r[a],e^=e>>>7,n=e^e<<24,e=r[a+1&7],n^=e^e>>>10,e=r[a+3&7],n^=e^e>>>3,e=r[a+4&7],n^=e^e<<7,e=r[a+7&7],e^=e<<13,n^=e^e<<9,r[a]=n,t.i=a+1&7,n},n(t,e)}function a(e,t){return t.x=e.x.slice(),t.i=e.i,t}function s(e,t){null==e&&(e=+new Date);var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},i.int32=n.next,i.quick=i,s&&(s.x&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xorshift7=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),$=x(((e,t)=>{(function(e,t,n){function r(e){var t=this;function n(e,t){var n,r,a,s,i,o=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),a=0,s=-32;s<l;++s)t&&(r^=t.charCodeAt((s+32)%t.length)),0===s&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,s>=0&&(i=i+1640531527|0,n=o[127&s]^=r+i,a=0==n?a+1:0);for(a>=128&&(o[127&(t&&t.length||0)]=-1),a=127,s=512;s>0;--s)r=o[a+34&127],n=o[a=a+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[a]=r^n;e.w=i,e.X=o,e.i=a}t.next=function(){var e,n,r=t.w,a=t.X,s=t.i;return t.w=r=r+1640531527|0,n=a[s+34&127],e=a[s=s+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=a[s]=n^e,t.i=s,n+(r^r>>>16)|0},n(t,e)}function a(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function s(e,t){null==e&&(e=+new Date);var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},i.int32=n.next,i.quick=i,s&&(s.X&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xor4096=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),F=x(((e,t)=>{(function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,a=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^a,a=a-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^a,t.a=a-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function s(e,t){var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.tychei=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),R=x((()=>{})),D=x(((e,t)=>{(function(e,r){var a,s=this,i=256,o=6,l=52,u="random",p=r.pow(i,o),d=r.pow(2,l),c=2*d,h=i-1;function f(t,n,a){var s=[];n=1==n?{entropy:!0}:n||{};var l=b(y(n.entropy?[t,x(e)]:null==t?w():t,3),s),h=new m(s),f=function(){for(var e=h.g(o),t=p,n=0;e<d;)e=(e+n)*i,t*=i,n=h.g(1);for(;e>=c;)e/=2,t/=2,n>>>=1;return(e+n)/t};return f.int32=function(){return 0|h.g(4)},f.quick=function(){return h.g(4)/4294967296},f.double=f,b(x(h.S),e),(n.pass||a||function(e,t,n,a){return a&&(a.S&&g(a,h),e.state=function(){return g(h,{})}),n?(r[u]=e,t):e})(f,l,"global"in n?n.global:this==r,n.state)}function m(e){var t,n=e.length,r=this,a=0,s=r.i=r.j=0,o=r.S=[];for(n||(e=[n++]);a<i;)o[a]=a++;for(a=0;a<i;a++)o[a]=o[s=h&s+e[a%n]+(t=o[a])],o[s]=t;(r.g=function(e){for(var t,n=0,a=r.i,s=r.j,o=r.S;e--;)t=o[a=h&a+1],n=n*i+o[h&(o[a]=o[s=h&s+t])+(o[s]=t)];return r.i=a,r.j=s,n})(i)}function g(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function y(e,t){var n,r=[],a=typeof e;if(t&&"object"==a)for(n in e)try{r.push(y(e[n],t-1))}catch(s){}return r.length?r:"string"==a?e:e+"\0"}function b(e,t){for(var n,r=e+"",a=0;a<r.length;)t[h&a]=h&(n^=19*t[h&a])+r.charCodeAt(a++);return x(t)}function w(){try{var t;return a&&(t=a.randomBytes)?t=t(i):(t=new Uint8Array(i),(s.crypto||s.msCrypto).getRandomValues(t)),x(t)}catch(o){var n=s.navigator,r=n&&n.plugins;return[+new Date,s,r,s.screen,x(e)]}}function x(e){return String.fromCharCode.apply(0,e)}if(r["seed"+u]=f,b(r.random(),e),"object"==typeof t&&t.exports){t.exports=f;try{a=R()}catch(v){}}else"function"==typeof define&&n.amdO&&define((function(){return f}))})([],Math)})),M=x(((e,t)=>{var n=C(),r=_(),a=E(),s=A(),i=$(),o=F(),l=D();l.alea=n,l.xor128=r,l.xorwow=a,l.xorshift7=s,l.xor4096=i,l.tychei=o,t.exports=l})),O=x(((e,t)=>{(function(e,t,n){function r(e){var t=this,n=i();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function a(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function s(e,t){var n=new r(e),s=t&&t.state,i=n.next;return i.int32=function(){return 4294967296*n.next()|0},i.double=function(){return i()+11102230246251565e-32*(2097152*i()|0)},i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}function i(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){e+=t.charCodeAt(n);var r=.02519603282416938*e;e=r>>>0,r-=e,r*=e,e=r>>>0,r-=e,e+=4294967296*r}return 2.3283064365386963e-10*(e>>>0)};return t}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.alea=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),L=x(((e,t)=>{(function(e,t,n){function r(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function s(e,t){var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xor128=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),P=x(((e,t)=>{(function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function s(e,t){var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xorwow=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),z=x(((e,t)=>{(function(e,t,n){function r(e){var t=this;function n(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}t.next=function(){var e,n,r=t.x,a=t.i;return e=r[a],e^=e>>>7,n=e^e<<24,e=r[a+1&7],n^=e^e>>>10,e=r[a+3&7],n^=e^e>>>3,e=r[a+4&7],n^=e^e<<7,e=r[a+7&7],e^=e<<13,n^=e^e<<9,r[a]=n,t.i=a+1&7,n},n(t,e)}function a(e,t){return t.x=e.x.slice(),t.i=e.i,t}function s(e,t){null==e&&(e=+new Date);var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},i.int32=n.next,i.quick=i,s&&(s.x&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xorshift7=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),B=x(((e,t)=>{(function(e,t,n){function r(e){var t=this;function n(e,t){var n,r,a,s,i,o=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),a=0,s=-32;s<l;++s)t&&(r^=t.charCodeAt((s+32)%t.length)),0===s&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,s>=0&&(i=i+1640531527|0,n=o[127&s]^=r+i,a=0==n?a+1:0);for(a>=128&&(o[127&(t&&t.length||0)]=-1),a=127,s=512;s>0;--s)r=o[a+34&127],n=o[a=a+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[a]=r^n;e.w=i,e.X=o,e.i=a}t.next=function(){var e,n,r=t.w,a=t.X,s=t.i;return t.w=r=r+1640531527|0,n=a[s+34&127],e=a[s=s+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=a[s]=n^e,t.i=s,n+(r^r>>>16)|0},n(t,e)}function a(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function s(e,t){null==e&&(e=+new Date);var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},i.int32=n.next,i.quick=i,s&&(s.X&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xor4096=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),W=x(((e,t)=>{(function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,a=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^a,a=a-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^a,t.a=a-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function s(e,t){var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.tychei=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),V=x(((e,t)=>{(function(e,r,a){var s,i=256,o=6,l=52,u="random",p=a.pow(i,o),d=a.pow(2,l),c=2*d,h=i-1;function f(e,t,n){var s=[];t=1==t?{entropy:!0}:t||{};var l=b(y(t.entropy?[e,x(r)]:null==e?w():e,3),s),h=new m(s),f=function(){for(var e=h.g(o),t=p,n=0;e<d;)e=(e+n)*i,t*=i,n=h.g(1);for(;e>=c;)e/=2,t/=2,n>>>=1;return(e+n)/t};return f.int32=function(){return 0|h.g(4)},f.quick=function(){return h.g(4)/4294967296},f.double=f,b(x(h.S),r),(t.pass||n||function(e,t,n,r){return r&&(r.S&&g(r,h),e.state=function(){return g(h,{})}),n?(a[u]=e,t):e})(f,l,"global"in t?t.global:this==a,t.state)}function m(e){var t,n=e.length,r=this,a=0,s=r.i=r.j=0,o=r.S=[];for(n||(e=[n++]);a<i;)o[a]=a++;for(a=0;a<i;a++)o[a]=o[s=h&s+e[a%n]+(t=o[a])],o[s]=t;(r.g=function(e){for(var t,n=0,a=r.i,s=r.j,o=r.S;e--;)t=o[a=h&a+1],n=n*i+o[h&(o[a]=o[s=h&s+t])+(o[s]=t)];return r.i=a,r.j=s,n})(i)}function g(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function y(e,t){var n,r=[],a=typeof e;if(t&&"object"==a)for(n in e)try{r.push(y(e[n],t-1))}catch(s){}return r.length?r:"string"==a?e:e+"\0"}function b(e,t){for(var n,r=e+"",a=0;a<r.length;)t[h&a]=h&(n^=19*t[h&a])+r.charCodeAt(a++);return x(t)}function w(){try{var t;return s&&(t=s.randomBytes)?t=t(i):(t=new Uint8Array(i),(e.crypto||e.msCrypto).getRandomValues(t)),x(t)}catch(o){var n=e.navigator,a=n&&n.plugins;return[+new Date,e,a,e.screen,x(r)]}}function x(e){return String.fromCharCode.apply(0,e)}if(b(a.random(),r),"object"==typeof t&&t.exports){t.exports=f;try{s=R()}catch(v){}}else"function"==typeof define&&n.amdO?define((function(){return f})):a["seed"+u]=f})("undefined"!=typeof self?self:e,[],Math)})),U=x(((e,t)=>{var n=O(),r=L(),a=P(),s=z(),i=B(),o=W(),l=V();l.alea=n,l.xor128=r,l.xorwow=a,l.xorshift7=s,l.xor4096=i,l.tychei=o,t.exports=l})),G=x((()=>{})),H=x((()=>{})),j=x((()=>{})),q=x((()=>{})),K=x((()=>{})),X=x((()=>{})),Y=x(((e,t)=>{var r=(()=>{var e="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0;return e=e||l,function(t){function r(){return O.buffer!=te&&le(O.buffer),ne}function a(){return O.buffer!=te&&le(O.buffer),re}function s(){return O.buffer!=te&&le(O.buffer),ae}function i(){return O.buffer!=te&&le(O.buffer),se}t=t||{};var o,l,p,d="undefined"!=typeof t?t:{};d.ready=new Promise((function(e,t){o=e,l=t})),"undefined"!=typeof process&&process.listeners&&(p={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var c,h,f,m,g,y,b=Object.assign({},d),w=[],x=(e,t)=>{throw t},v="object"==typeof window,k="function"==typeof importScripts,I="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,S=d.ENVIRONMENT_IS_PTHREAD||!1,N="";function T(e){return d.locateFile?d.locateFile(e,N):N+e}function C(e){e instanceof cn||$("exiting due to exception: "+e)}if(I){let e;N=k?j().dirname(N)+"/":u+"/",y=()=>{g||(m=H(),g=j())},c=function(e,t){return y(),e=g.normalize(e),m.readFileSync(e,t?void 0:"utf8")},f=e=>{var t=c(e,!0);return t.buffer||(t=new Uint8Array(t)),t},h=(e,t,n)=>{y(),e=g.normalize(e),m.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),w=process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof cn))throw e})),process.on("unhandledRejection",(function(e){throw e})),x=(e,t)=>{if(ge())throw process.exitCode=e,t;C(t),process.exit(e)},d.inspect=function(){return"[Emscripten Module object]"};try{e=q()}catch(yn){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),yn}n.g.Worker=e.Worker}else(v||k)&&(k?N=self.location.href:"undefined"!=typeof document&&document.currentScript&&(N=document.currentScript.src),"undefined"!=typeof e&&e&&(N=e),N=0!==N.indexOf("blob:")?N.substr(0,N.replace(/[?#].*/,"").lastIndexOf("/")+1):"",I||(c=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},k&&(f=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),h=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}),e=>document.title=e);I&&"undefined"==typeof performance&&(n.g.performance=K().performance);var _=console.log.bind(console),E=console.warn.bind(console);I&&(y(),_=e=>m.writeSync(1,e+"\n"),E=e=>m.writeSync(2,e+"\n"));var A=d.print||_,$=d.printErr||E;Object.assign(d,b),b=null,d.arguments&&(w=d.arguments),d.thisProgram&&d.thisProgram,d.quit&&(x=d.quit);function F(e){F.shown||(F.shown={}),F.shown[e]||(F.shown[e]=1,$(e))}var R,D=e=>{e};Atomics.load,Atomics.store,Atomics.compareExchange;d.wasmBinary&&(R=d.wasmBinary);var M=d.noExitRuntime||!0;"object"!=typeof WebAssembly&&Ee("no native wasm support detected");var O,L,P,z=!1;function B(e){var t=d["_"+e];return t}function W(e,t,n,r,a){var s={string:function(e){var t=0;if(null!=e&&0!==e){var n=1+(e.length<<2);t=pn(n),Q(e,t,n)}return t},array:function(e){var t=pn(e.length);return ie(e,t),t}};function i(e){return"string"===t?Z(e):"boolean"===t?Boolean(e):e}var o=B(e),l=[],u=0;if(r)for(var p=0;p<r.length;p++){var d=s[n[p]];d?(0===u&&(u=ln()),l[p]=d(r[p])):l[p]=r[p]}var c=o.apply(null,l);function h(e){return 0!==u&&un(u),i(e)}return c=h(c),c}function V(e,t,n,r){n=n||[];var a=n.every((function(e){return"number"===e})),s="string"!==t;return s&&a&&!r?B(e):function(){return W(e,t,n,arguments,r)}}function U(e){var t=new TextDecoder(e);this.decode=e=>(e.buffer instanceof SharedArrayBuffer&&(e=new Uint8Array(e)),t.decode.call(t,e))}var G="undefined"!=typeof TextDecoder?new U("utf8"):void 0;function Y(e,t,n){for(var r=t+n,a=t;e[a]&&!(a>=r);)++a;if(a-t>16&&e.subarray&&G)return G.decode(e.subarray(t,a));for(var s="";t<a;){var i=e[t++];if(128&i){var o=63&e[t++];if(192!=(224&i)){var l=63&e[t++];if(i=224==(240&i)?(15&i)<<12|o<<6|l:(7&i)<<18|o<<12|l<<6|63&e[t++],i<65536)s+=String.fromCharCode(i);else{var u=i-65536;s+=String.fromCharCode(55296|u>>10,56320|1023&u)}}else s+=String.fromCharCode((31&i)<<6|o)}else s+=String.fromCharCode(i)}return s}function Z(e,t){return e?Y(a(),e,t):""}function J(e,t,n,r){if(!(r>0))return 0;for(var a=n,s=n+r-1,i=0;i<e.length;++i){var o=e.charCodeAt(i);if(o>=55296&&o<=57343){var l=e.charCodeAt(++i);o=65536+((1023&o)<<10)|1023&l}if(o<=127){if(n>=s)break;t[n++]=o}else if(o<=2047){if(n+1>=s)break;t[n++]=192|o>>6,t[n++]=128|63&o}else if(o<=65535){if(n+2>=s)break;t[n++]=224|o>>12,t[n++]=128|o>>6&63,t[n++]=128|63&o}else{if(n+3>=s)break;t[n++]=240|o>>18,t[n++]=128|o>>12&63,t[n++]=128|o>>6&63,t[n++]=128|63&o}}return t[n]=0,n-a}function Q(e,t,n){return J(e,a(),t,n)}function ee(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);r>=55296&&r<=57343&&(r=65536+((1023&r)<<10)|1023&e.charCodeAt(++n)),r<=127?++t:t+=r<=2047?2:r<=65535?3:4}return t}var te,ne,re,ae,se;"undefined"!=typeof TextDecoder&&new U("utf-16le");function ie(e,t){r().set(e,t)}function oe(e,t){return e%t>0&&(e+=t-e%t),e}function le(e){te=e,d.HEAP8=ne=new Int8Array(e),d.HEAP16=new Int16Array(e),d.HEAP32=ae=new Int32Array(e),d.HEAPU8=re=new Uint8Array(e),d.HEAPU16=new Uint16Array(e),d.HEAPU32=new Uint32Array(e),d.HEAPF32=new Float32Array(e),d.HEAPF64=se=new Float64Array(e)}S&&(te=d.buffer);var ue=d.INITIAL_MEMORY||16777216;if(S)O=d.wasmMemory,te=d.buffer;else if(d.wasmMemory)O=d.wasmMemory;else if(O=new WebAssembly.Memory({initial:ue/65536,maximum:32768,shared:!0}),!(O.buffer instanceof SharedArrayBuffer))throw $("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),I&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");O&&(te=O.buffer),ue=te.byteLength,le(te);var pe,de=[],ce=[],he=[],fe=[],me=0;function ge(){return M||me>0}function ye(){if(d.preRun)for("function"==typeof d.preRun&&(d.preRun=[d.preRun]);d.preRun.length;)ve(d.preRun.shift());Pe(de)}function be(){!0,!S&&Pe(ce)}function we(){S||(He.terminateAllThreads(),!0)}function xe(){if(!S){if(d.postRun)for("function"==typeof d.postRun&&(d.postRun=[d.postRun]);d.postRun.length;)Ie(d.postRun.shift());Pe(fe)}}function ve(e){de.unshift(e)}function ke(e){ce.unshift(e)}function Ie(e){fe.unshift(e)}var Se=0,Ne=null,Te=null;function Ce(e){Se++,d.monitorRunDependencies&&d.monitorRunDependencies(Se)}function _e(e){if(Se--,d.monitorRunDependencies&&d.monitorRunDependencies(Se),0==Se&&(null!==Ne&&(clearInterval(Ne),Ne=null),Te)){var t=Te;Te=null,t()}}function Ee(e){S?postMessage({cmd:"onAbort",arg:e}):d.onAbort&&d.onAbort(e),e="Aborted("+e+")",$(e),z=!0,P=1,e+=". Build with -s ASSERTIONS=1 for more info.";var t=new WebAssembly.RuntimeError(e);throw l(t),t}d.preloadedImages={},d.preloadedAudios={};var Ae,$e="data:application/octet-stream;base64,";function Fe(e){return e.startsWith($e)}function Re(e){return e.startsWith("file://")}function De(e){try{if(e==Ae&&R)return new Uint8Array(R);if(f)return f(e);throw"both async and sync fetching of the wasm failed"}catch(yn){Ee(yn)}}function Me(){if(!R&&(v||k)){if("function"==typeof fetch&&!Re(Ae))return fetch(Ae,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+Ae+"'";return e.arrayBuffer()})).catch((function(){return De(Ae)}));if(h)return new Promise((function(e,t){h(Ae,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return De(Ae)}))}function Oe(){var e={env:Xt,wasi_snapshot_preview1:Xt};function t(e,t){var n=e.exports;if(d.asm=n,Je(d.asm.emscripten_tls_init),pe=d.asm.__indirect_function_table,ke(d.asm.__wasm_call_ctors),L=t,!S){var r=He.unusedWorkers.length;He.unusedWorkers.forEach((function(e){He.loadWasmModuleToWorker(e,(function(){--r||_e("wasm-instantiate")}))}))}}function n(e){t(e.instance,e.module)}function r(t){return Me().then((function(t){return WebAssembly.instantiate(t,e)})).then((function(e){return e})).then(t,(function(e){$("failed to asynchronously prepare wasm: "+e),Ee(e)}))}function a(){return R||"function"!=typeof WebAssembly.instantiateStreaming||Fe(Ae)||Re(Ae)||"function"!=typeof fetch?r(n):fetch(Ae,{credentials:"same-origin"}).then((function(t){var a=WebAssembly.instantiateStreaming(t,e);return a.then(n,(function(e){return $("wasm streaming compile failed: "+e),$("falling back to ArrayBuffer instantiation"),r(n)}))}))}if(S||Ce("wasm-instantiate"),d.instantiateWasm)try{var s=d.instantiateWasm(e,t);return s}catch(i){return $("Module.instantiateWasm callback failed with error: "+i),!1}return a().catch(l),{}}Ae="tfjs-backend-wasm-threaded-simd.wasm",Fe(Ae)||(Ae=T(Ae));var Le={};function Pe(e){for(;e.length>0;){var t=e.shift();if("function"!=typeof t){var n=t.func;"number"==typeof n?void 0===t.arg?Ye(n)():Ye(n)(t.arg):n(void 0===t.arg?null:t.arg)}else t(d)}}function ze(e){var t=ln(),n=e();return un(t),n}function Be(e){s()[e>>2]=0;var t=He.pthreads[e];delete He.pthreads[e],t.worker.terminate(),sn(e),He.runningWorkers.splice(He.runningWorkers.indexOf(t.worker),1),t.worker.pthread=void 0}function We(e){var t=He.pthreads[e];t.worker.postMessage({cmd:"cancel"})}function Ve(e){var t=He.pthreads[e];if(t){s()[e>>2]=0;var n=t.worker;He.returnWorkerToPool(n)}}function Ue(e){fn(e)}function Ge(e){if(e instanceof cn||"unwind"==e)return P;x(1,e)}var He={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],init:function(){S?He.initWorker():He.initMainThread()},initMainThread:function(){for(var e=8,t=0;t<e;++t)He.allocateUnusedWorker()},initWorker:function(){M=!1},pthreads:{},setExitStatus:function(e){P=e},terminateAllThreads:function(){for(var e in He.pthreads){var t=He.pthreads[e];t&&t.worker&&He.returnWorkerToPool(t.worker)}for(var n=0;n<He.unusedWorkers.length;++n){var r=He.unusedWorkers[n];r.terminate()}He.unusedWorkers=[]},returnWorkerToPool:function(e){He.runWithoutMainThreadQueuedCalls((function(){delete He.pthreads[e.pthread.threadInfoStruct],He.unusedWorkers.push(e),He.runningWorkers.splice(He.runningWorkers.indexOf(e),1),sn(e.pthread.threadInfoStruct),e.pthread=void 0}))},runWithoutMainThreadQueuedCalls:function(e){s()[dn>>2]=0;try{e()}finally{s()[dn>>2]=1}},receiveObjectTransfer:function(e){},threadInit:function(){for(var e in He.tlsInitFunctions)He.tlsInitFunctions[e]()},loadWasmModuleToWorker:function(t,n){t.onmessage=e=>{var r=e.data,a=r.cmd;if(t.pthread&&(He.currentProxiedOperationCallerThread=t.pthread.threadInfoStruct),r.targetThread&&r.targetThread!=Qt()){var s=He.pthreads[r.targetThread];return s?s.worker.postMessage(r,r.transferList):$('Internal error! Worker sent a message "'+a+'" to target pthread '+r.targetThread+", but that thread no longer exists!"),void(He.currentProxiedOperationCallerThread=void 0)}"processQueuedMainThreadWork"===a?en():"spawnThread"===a?st(r):"cleanupThread"===a?Ve(r.thread):"killThread"===a?Be(r.thread):"cancelThread"===a?We(r.thread):"loaded"===a?(t.loaded=!0,n&&n(t),t.runPthread&&(t.runPthread(),delete t.runPthread)):"print"===a?A("Thread "+r.threadId+": "+r.text):"printErr"===a?$("Thread "+r.threadId+": "+r.text):"alert"===a?alert("Thread "+r.threadId+": "+r.text):"setimmediate"===r.target?t.postMessage(r):"onAbort"===a?d.onAbort&&d.onAbort(r.arg):$("worker sent an unknown command "+a),He.currentProxiedOperationCallerThread=void 0},t.onerror=e=>{var t="worker sent an error!";throw $(t+" "+e.filename+":"+e.lineno+": "+e.message),e},I&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){}))),t.postMessage({cmd:"load",urlOrBlob:d.mainScriptUrlOrBlob||e,wasmMemory:O,wasmModule:L})},allocateUnusedWorker:function(){var e=T("tfjs-backend-wasm-threaded-simd.worker.js");He.unusedWorkers.push(new Worker(e))},getNewWorker:function(){return 0==He.unusedWorkers.length&&(He.allocateUnusedWorker(),He.loadWasmModuleToWorker(He.unusedWorkers[0])),He.unusedWorkers.pop()}};function je(){var e=Qt(),t=s()[e+44>>2],n=s()[e+48>>2],r=t-n;on(t,r),un(t)}function qe(e){if(S)return ft(1,0,e);try{Ue(e)}catch(yn){Ge(yn)}}d.establishStackSpace=je;var Ke,Xe=[];function Ye(e){var t=Xe[e];return t||(e>=Xe.length&&(Xe.length=e+1),Xe[e]=t=pe.get(e)),t}function Ze(e,t){return Ye(e)(t)}function Je(e,t,n){He.tlsInitFunctions.push(e)}d.invokeEntryPoint=Ze,Ke=I?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:S?()=>performance.now()-d.__performance_now_clock_drift:()=>performance.now();var Qe=!0;function et(e){return s()[Jt()>>2]=e,e}function tt(e,t){var n;if(0===e)n=Date.now();else{if(1!==e&&4!==e||!Qe)return et(28),-1;n=Ke()}return s()[t>>2]=n/1e3|0,s()[t+4>>2]=n%1e3*1e3*1e3|0,0}function nt(e,t){return tt(e,t)}function rt(e){tn(e,!k,1,!v),He.threadInit()}function at(e){S?postMessage({cmd:"cleanupThread",thread:e}):Ve(e)}function st(e){var t=He.getNewWorker();if(!t)return 6;He.runningWorkers.push(t);var n=He.pthreads[e.pthread_ptr]={worker:t,threadInfoStruct:e.pthread_ptr};t.pthread=n;var r={cmd:"run",start_routine:e.startRoutine,arg:e.arg,threadInfoStruct:e.pthread_ptr};return t.runPthread=()=>{r.time=performance.now(),t.postMessage(r,e.transferList)},t.loaded&&(t.runPthread(),delete t.runPthread),0}function it(e,t,n,r){if("undefined"==typeof SharedArrayBuffer)return $("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[],s=0;if(S&&(0===a.length||s))return nn(687865856,e,t,n,r);if(s)return s;var i={startRoutine:n,pthread_ptr:e,arg:r,transferList:a};return S?(i.cmd="spawnThread",postMessage(i,a),0):st(i)}function ot(){return 2097152}function lt(e,t){if(e==t)postMessage({cmd:"processQueuedMainThreadWork"});else if(S)postMessage({targetThread:e,cmd:"processThreadQueue"});else{var n=He.pthreads[e],r=n&&n.worker;if(!r)return;r.postMessage({cmd:"processThreadQueue"})}return 1}function ut(){Ee("")}function pt(){I||k||F("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function dt(){return 2147483648}function ct(e,t,n){a().copyWithin(e,t,t+n)}function ht(){return I?X().cpus().length:navigator.hardwareConcurrency}function ft(e,t){var n=arguments.length-2,r=arguments;return ze((function(){for(var a=n,s=pn(8*a),o=s>>3,l=0;l<n;l++){var u=r[2+l];i()[o+l]=u}return rn(e,a,s,t)}))}var mt=[];function gt(e,t,n){mt.length=t;for(var r=n>>3,a=0;a<t;a++)mt[a]=i()[r+a];var s=e<0,o=s?Le[-e-1]:Kt[e];return o.apply(null,mt)}function yt(e){try{return O.grow(e-te.byteLength+65535>>>16),le(O.buffer),1}catch(yn){}}function bt(e){var t=a().length;if(e>>>=0,e<=t)return!1;var n=dt();if(e>n)return!1;for(var r=1;r<=4;r*=2){var s=t*(1+.2/r);s=Math.min(s,e+100663296);var i=Math.min(n,oe(Math.max(e,s),65536)),o=yt(i);if(o)return!0}return!1}var wt={inEventHandler:0,removeAllEventListeners:function(){for(var e=wt.eventHandlers.length-1;e>=0;--e)wt._removeHandler(e);wt.eventHandlers=[],wt.deferredCalls=[]},registerRemoveEventListeners:function(){wt.removeEventListenersRegistered||(he.push(wt.removeAllEventListeners),wt.removeEventListenersRegistered=!0)},deferredCalls:[],deferCall:function(e,t,n){function r(e,t){if(e.length!=t.length)return!1;for(var n in e)if(e[n]!=t[n])return!1;return!0}for(var a in wt.deferredCalls){var s=wt.deferredCalls[a];if(s.targetFunction==e&&r(s.argsList,n))return}wt.deferredCalls.push({targetFunction:e,precedence:t,argsList:n}),wt.deferredCalls.sort((function(e,t){return e.precedence<t.precedence}))},removeDeferredCalls:function(e){for(var t=0;t<wt.deferredCalls.length;++t)wt.deferredCalls[t].targetFunction==e&&(wt.deferredCalls.splice(t,1),--t)},canPerformEventHandlerRequests:function(){return wt.inEventHandler&&wt.currentEventHandler.allowsDeferredCalls},runDeferredCalls:function(){if(wt.canPerformEventHandlerRequests())for(var e=0;e<wt.deferredCalls.length;++e){var t=wt.deferredCalls[e];wt.deferredCalls.splice(e,1),--e,t.targetFunction.apply(null,t.argsList)}},eventHandlers:[],removeAllHandlersOnTarget:function(e,t){for(var n=0;n<wt.eventHandlers.length;++n)wt.eventHandlers[n].target==e&&(!t||t==wt.eventHandlers[n].eventTypeString)&&wt._removeHandler(n--)},_removeHandler:function(e){var t=wt.eventHandlers[e];t.target.removeEventListener(t.eventTypeString,t.eventListenerFunc,t.useCapture),wt.eventHandlers.splice(e,1)},registerOrRemoveHandler:function(e){var t=function(t){++wt.inEventHandler,wt.currentEventHandler=e,wt.runDeferredCalls(),e.handlerFunc(t),wt.runDeferredCalls(),--wt.inEventHandler};if(e.callbackfunc)e.eventListenerFunc=t,e.target.addEventListener(e.eventTypeString,t,e.useCapture),wt.eventHandlers.push(e),wt.registerRemoveEventListeners();else for(var n=0;n<wt.eventHandlers.length;++n)wt.eventHandlers[n].target==e.target&&wt.eventHandlers[n].eventTypeString==e.eventTypeString&&wt._removeHandler(n--)},queueEventHandlerOnThread_iiii:function(e,t,n,r,a){ze((function(){var i=pn(12);s()[i>>2]=n,s()[i+4>>2]=r,s()[i+8>>2]=a,an(e,637534208,t,r,i)}))},getTargetThreadForEventCallback:function(e){switch(e){case 1:return 0;case 2:return He.currentProxiedOperationCallerThread;default:return e}},getNodeNameForTarget:function(e){return e?e==window?"#window":e==screen?"#screen":e&&e.nodeName?e.nodeName:"":""},fullscreenEnabled:function(){return document.fullscreenEnabled||document.webkitFullscreenEnabled}};function xt(e){var t=ee(e)+1,n=Yt(t);return Q(e,n,t),n}function vt(e,t,n,r){ze((function(){var a=pn(12),i=0;t&&(i=xt(t)),s()[a>>2]=i,s()[a+4>>2]=n,s()[a+8>>2]=r,an(e,657457152,0,i,a)}))}function kt(e,t,n,r){t=t?Z(t):"",vt(e,t,n,r)}function It(e){return e>2?Z(e):e}var St=[0,"undefined"!=typeof document?document:0,"undefined"!=typeof window?window:0];function Nt(e){e=It(e);var t=St[e]||("undefined"!=typeof document?document.querySelector(e):void 0);return t}function Tt(e){return Nt(e)}function Ct(e,t,n){var r=Tt(e);if(!r)return-4;if(r.canvasSharedPtr&&(s()[r.canvasSharedPtr>>2]=t,s()[r.canvasSharedPtr+4>>2]=n),!r.offscreenCanvas&&r.controlTransferredOffscreen){if(r.canvasSharedPtr){var a=s()[r.canvasSharedPtr+8>>2];return kt(a,e,t,n),1}return-4}r.offscreenCanvas&&(r=r.offscreenCanvas);var i=!1;if(r.GLctxObject&&r.GLctxObject.GLctx){var o=r.GLctxObject.GLctx.getParameter(2978);i=0===o[0]&&0===o[1]&&o[2]===r.width&&o[3]===r.height}return r.width=t,r.height=n,i&&r.GLctxObject.GLctx.viewport(0,0,t,n),0}function _t(e,t,n){return S?ft(2,1,e,t,n):Ct(e,t,n)}function Et(e,t,n){var r=Tt(e);return r?Ct(e,t,n):_t(e,t,n)}function At(){throw"unwind"}function $t(e){var t=e.getExtension("ANGLE_instanced_arrays");if(t)return e.vertexAttribDivisor=function(e,n){t.vertexAttribDivisorANGLE(e,n)},e.drawArraysInstanced=function(e,n,r,a){t.drawArraysInstancedANGLE(e,n,r,a)},e.drawElementsInstanced=function(e,n,r,a,s){t.drawElementsInstancedANGLE(e,n,r,a,s)},1}function Ft(e){var t=e.getExtension("OES_vertex_array_object");if(t)return e.createVertexArray=function(){return t.createVertexArrayOES()},e.deleteVertexArray=function(e){t.deleteVertexArrayOES(e)},e.bindVertexArray=function(e){t.bindVertexArrayOES(e)},e.isVertexArray=function(e){return t.isVertexArrayOES(e)},1}function Rt(e){var t=e.getExtension("WEBGL_draw_buffers");if(t)return e.drawBuffers=function(e,n){t.drawBuffersWEBGL(e,n)},1}function Dt(e){return!!(e.multiDrawWebgl=e.getExtension("WEBGL_multi_draw"))}var Mt={counter:1,buffers:[],programs:[],framebuffers:[],renderbuffers:[],textures:[],shaders:[],vaos:[],contexts:{},offscreenCanvases:{},queries:[],stringCache:{},unpackAlignment:4,recordError:function(e){Mt.lastError||(Mt.lastError=e)},getNewId:function(e){for(var t=Mt.counter++,n=e.length;n<t;n++)e[n]=null;return t},getSource:function(e,t,n,r){for(var a="",i=0;i<t;++i){var o=r?s()[r+4*i>>2]:-1;a+=Z(s()[n+4*i>>2],o<0?void 0:o)}return a},createContext:function(e,t){e.getContextSafariWebGL2Fixed||(e.getContextSafariWebGL2Fixed=e.getContext,e.getContext=function(t,n){var r=e.getContextSafariWebGL2Fixed(t,n);return"webgl"==t==r instanceof WebGLRenderingContext?r:null});var n=e.getContext("webgl",t);if(!n)return 0;var r=Mt.registerContext(n,t);return r},registerContext:function(e,t){var n=Yt(8);s()[n+4>>2]=Qt();var r={handle:n,attributes:t,version:t.majorVersion,GLctx:e};return e.canvas&&(e.canvas.GLctxObject=r),Mt.contexts[n]=r,("undefined"==typeof t.enableExtensionsByDefault||t.enableExtensionsByDefault)&&Mt.initExtensions(r),n},makeContextCurrent:function(e){return Mt.currentContext=Mt.contexts[e],d.ctx=Gt=Mt.currentContext&&Mt.currentContext.GLctx,!(e&&!Gt)},getContext:function(e){return Mt.contexts[e]},deleteContext:function(e){Mt.currentContext===Mt.contexts[e]&&(Mt.currentContext=null),"object"==typeof wt&&wt.removeAllHandlersOnTarget(Mt.contexts[e].GLctx.canvas),Mt.contexts[e]&&Mt.contexts[e].GLctx.canvas&&(Mt.contexts[e].GLctx.canvas.GLctxObject=void 0),Zt(Mt.contexts[e].handle),Mt.contexts[e]=null},initExtensions:function(e){if(e||(e=Mt.currentContext),!e.initExtensionsDone){e.initExtensionsDone=!0;var t=e.GLctx;$t(t),Ft(t),Rt(t),t.disjointTimerQueryExt=t.getExtension("EXT_disjoint_timer_query"),Dt(t);var n=t.getSupportedExtensions()||[];n.forEach((function(e){!e.includes("lose_context")&&!e.includes("debug")&&t.getExtension(e)}))}}},Ot=["default","low-power","high-performance"];function Lt(e,t){var n=t>>2,r=s()[n+6],a={alpha:!!s()[n+0],depth:!!s()[n+1],stencil:!!s()[n+2],antialias:!!s()[n+3],premultipliedAlpha:!!s()[n+4],preserveDrawingBuffer:!!s()[n+5],powerPreference:Ot[r],failIfMajorPerformanceCaveat:!!s()[n+7],majorVersion:s()[n+8],minorVersion:s()[n+9],enableExtensionsByDefault:s()[n+10],explicitSwapControl:s()[n+11],proxyContextToMainThread:s()[n+12],renderViaOffscreenBackBuffer:s()[n+13]},i=Tt(e);if(!i||a.explicitSwapControl)return 0;var o=Mt.createContext(i,a);return o}function Pt(e,t){return Lt(e,t)}var zt={mappings:{},buffers:[null,[],[]],printChar:function(e,t){var n=zt.buffers[e];0===t||10===t?((1===e?A:$)(Y(n,0)),n.length=0):n.push(t)},varargs:void 0,get:function(){zt.varargs+=4;var e=s()[zt.varargs-4>>2];return e},getStr:function(e){var t=Z(e);return t},get64:function(e,t){return e}};function Bt(e){return S?ft(3,1,e):0}function Wt(e,t,n,r,a){if(S)return ft(4,1,e,t,n,r,a)}function Vt(e,t,n,r){if(S)return ft(5,1,e,t,n,r);for(var i=0,o=0;o<n;o++){var l=s()[t>>2],u=s()[t+4>>2];t+=8;for(var p=0;p<u;p++)zt.printChar(e,a()[l+p]);i+=u}return s()[r>>2]=i,0}function Ut(e){D(e)}He.init();var Gt,Ht,jt,qt,Kt=[null,qe,_t,Bt,Wt,Vt],Xt={__clock_gettime:nt,__emscripten_init_main_thread_js:rt,__emscripten_thread_cleanup:at,__pthread_create_js:it,_emscripten_default_pthread_stack_size:ot,_emscripten_notify_thread_queue:lt,abort:ut,emscripten_check_blocking_allowed:pt,emscripten_get_heap_max:dt,emscripten_get_now:Ke,emscripten_memcpy_big:ct,emscripten_num_logical_cores:ht,emscripten_receive_on_main_thread_js:gt,emscripten_resize_heap:bt,emscripten_set_canvas_element_size:Et,emscripten_unwind_to_js_event_loop:At,emscripten_webgl_create_context:Pt,exit:Ue,fd_close:Bt,fd_seek:Wt,fd_write:Vt,memory:O||d.wasmMemory,setTempRet0:Ut},Yt=(Oe(),d.___wasm_call_ctors=function(){return(d.___wasm_call_ctors=d.asm.__wasm_call_ctors).apply(null,arguments)},d._init=function(){return(d._init=d.asm.init).apply(null,arguments)},d._init_with_threads_count=function(){return(d._init_with_threads_count=d.asm.init_with_threads_count).apply(null,arguments)},d._get_threads_count=function(){return(d._get_threads_count=d.asm.get_threads_count).apply(null,arguments)},d._register_tensor=function(){return(d._register_tensor=d.asm.register_tensor).apply(null,arguments)},d._dispose_data=function(){return(d._dispose_data=d.asm.dispose_data).apply(null,arguments)},d._dispose=function(){return(d._dispose=d.asm.dispose).apply(null,arguments)},d._Abs=function(){return(d._Abs=d.asm.Abs).apply(null,arguments)},d._Add=function(){return(d._Add=d.asm.Add).apply(null,arguments)},d._AddN=function(){return(d._AddN=d.asm.AddN).apply(null,arguments)},d._All=function(){return(d._All=d.asm.All).apply(null,arguments)},d._Any=function(){return(d._Any=d.asm.Any).apply(null,arguments)},d._ArgMax=function(){return(d._ArgMax=d.asm.ArgMax).apply(null,arguments)},d._AvgPool=function(){return(d._AvgPool=d.asm.AvgPool).apply(null,arguments)},d._BatchMatMul=function(){return(d._BatchMatMul=d.asm.BatchMatMul).apply(null,arguments)},d._Ceil=function(){return(d._Ceil=d.asm.Ceil).apply(null,arguments)},d._ClipByValue=function(){return(d._ClipByValue=d.asm.ClipByValue).apply(null,arguments)},d._Conv2D=function(){return(d._Conv2D=d.asm.Conv2D).apply(null,arguments)},d._Conv2DBackpropInput=function(){return(d._Conv2DBackpropInput=d.asm.Conv2DBackpropInput).apply(null,arguments)},d._Cos=function(){return(d._Cos=d.asm.Cos).apply(null,arguments)},d._Cosh=function(){return(d._Cosh=d.asm.Cosh).apply(null,arguments)},d._CropAndResize=function(){return(d._CropAndResize=d.asm.CropAndResize).apply(null,arguments)},d._Cumprod=function(){return(d._Cumprod=d.asm.Cumprod).apply(null,arguments)},d._Cumsum=function(){return(d._Cumsum=d.asm.Cumsum).apply(null,arguments)},d._DepthToSpace=function(){return(d._DepthToSpace=d.asm.DepthToSpace).apply(null,arguments)},d._DepthwiseConv2dNative=function(){return(d._DepthwiseConv2dNative=d.asm.DepthwiseConv2dNative).apply(null,arguments)},d._Elu=function(){return(d._Elu=d.asm.Elu).apply(null,arguments)},d._Equal=function(){return(d._Equal=d.asm.Equal).apply(null,arguments)},d._Exp=function(){return(d._Exp=d.asm.Exp).apply(null,arguments)},d._FlipLeftRight=function(){return(d._FlipLeftRight=d.asm.FlipLeftRight).apply(null,arguments)},d._Floor=function(){return(d._Floor=d.asm.Floor).apply(null,arguments)},d._FloorDiv=function(){return(d._FloorDiv=d.asm.FloorDiv).apply(null,arguments)},d._FusedBatchNorm=function(){return(d._FusedBatchNorm=d.asm.FusedBatchNorm).apply(null,arguments)},d._FusedConv2D=function(){return(d._FusedConv2D=d.asm.FusedConv2D).apply(null,arguments)},d._FusedDepthwiseConv2D=function(){return(d._FusedDepthwiseConv2D=d.asm.FusedDepthwiseConv2D).apply(null,arguments)},d._Gather=function(){return(d._Gather=d.asm.Gather).apply(null,arguments)},d._GatherNd=function(){return(d._GatherNd=d.asm.GatherNd).apply(null,arguments)},d._Greater=function(){return(d._Greater=d.asm.Greater).apply(null,arguments)},d._GreaterEqual=function(){return(d._GreaterEqual=d.asm.GreaterEqual).apply(null,arguments)},d._LeakyRelu=function(){return(d._LeakyRelu=d.asm.LeakyRelu).apply(null,arguments)},d._Less=function(){return(d._Less=d.asm.Less).apply(null,arguments)},d._LessEqual=function(){return(d._LessEqual=d.asm.LessEqual).apply(null,arguments)},d._Log=function(){return(d._Log=d.asm.Log).apply(null,arguments)},d._LogicalAnd=function(){return(d._LogicalAnd=d.asm.LogicalAnd).apply(null,arguments)},d._Max=function(){return(d._Max=d.asm.Max).apply(null,arguments)},d._MaxPool=function(){return(d._MaxPool=d.asm.MaxPool).apply(null,arguments)},d._Maximum=function(){return(d._Maximum=d.asm.Maximum).apply(null,arguments)},d._Mean=function(){return(d._Mean=d.asm.Mean).apply(null,arguments)},d._Min=function(){return(d._Min=d.asm.Min).apply(null,arguments)},d._Minimum=function(){return(d._Minimum=d.asm.Minimum).apply(null,arguments)},d._MirrorPad=function(){return(d._MirrorPad=d.asm.MirrorPad).apply(null,arguments)},d._Multiply=function(){return(d._Multiply=d.asm.Multiply).apply(null,arguments)},d._Neg=function(){return(d._Neg=d.asm.Neg).apply(null,arguments)},d._NonMaxSuppressionV3=function(){return(d._NonMaxSuppressionV3=d.asm.NonMaxSuppressionV3).apply(null,arguments)},d._NonMaxSuppressionV4=function(){return(d._NonMaxSuppressionV4=d.asm.NonMaxSuppressionV4).apply(null,arguments)},d._NonMaxSuppressionV5=function(){return(d._NonMaxSuppressionV5=d.asm.NonMaxSuppressionV5).apply(null,arguments)},d._NotEqual=function(){return(d._NotEqual=d.asm.NotEqual).apply(null,arguments)},d._OneHot=function(){return(d._OneHot=d.asm.OneHot).apply(null,arguments)},d._PadV2=function(){return(d._PadV2=d.asm.PadV2).apply(null,arguments)},d._Pow=function(){return(d._Pow=d.asm.Pow).apply(null,arguments)},d._Prelu=function(){return(d._Prelu=d.asm.Prelu).apply(null,arguments)},d._Prod=function(){return(d._Prod=d.asm.Prod).apply(null,arguments)},d._RealDiv=function(){return(d._RealDiv=d.asm.RealDiv).apply(null,arguments)},d._Relu=function(){return(d._Relu=d.asm.Relu).apply(null,arguments)},d._Relu6=function(){return(d._Relu6=d.asm.Relu6).apply(null,arguments)},d._ResizeBilinear=function(){return(d._ResizeBilinear=d.asm.ResizeBilinear).apply(null,arguments)},d._Reverse=function(){return(d._Reverse=d.asm.Reverse).apply(null,arguments)},d._RotateWithOffset=function(){return(d._RotateWithOffset=d.asm.RotateWithOffset).apply(null,arguments)},d._Round=function(){return(d._Round=d.asm.Round).apply(null,arguments)},d._Rsqrt=function(){return(d._Rsqrt=d.asm.Rsqrt).apply(null,arguments)},d._ScatterNd=function(){return(d._ScatterNd=d.asm.ScatterNd).apply(null,arguments)},d._SelectV2=function(){return(d._SelectV2=d.asm.SelectV2).apply(null,arguments)},d._Sigmoid=function(){return(d._Sigmoid=d.asm.Sigmoid).apply(null,arguments)},d._Sin=function(){return(d._Sin=d.asm.Sin).apply(null,arguments)},d._Softmax=function(){return(d._Softmax=d.asm.Softmax).apply(null,arguments)},d._SparseFillEmptyRows=function(){return(d._SparseFillEmptyRows=d.asm.SparseFillEmptyRows).apply(null,arguments)},d._SparseReshape=function(){return(d._SparseReshape=d.asm.SparseReshape).apply(null,arguments)},d._SparseSegmentReduction=function(){return(d._SparseSegmentReduction=d.asm.SparseSegmentReduction).apply(null,arguments)},d._Sqrt=function(){return(d._Sqrt=d.asm.Sqrt).apply(null,arguments)},d._Square=function(){return(d._Square=d.asm.Square).apply(null,arguments)},d._SquaredDifference=function(){return(d._SquaredDifference=d.asm.SquaredDifference).apply(null,arguments)},d._Step=function(){return(d._Step=d.asm.Step).apply(null,arguments)},d._StridedSlice=function(){return(d._StridedSlice=d.asm.StridedSlice).apply(null,arguments)},d._Sub=function(){return(d._Sub=d.asm.Sub).apply(null,arguments)},d._Sum=function(){return(d._Sum=d.asm.Sum).apply(null,arguments)},d._Tan=function(){return(d._Tan=d.asm.Tan).apply(null,arguments)},d._Tanh=function(){return(d._Tanh=d.asm.Tanh).apply(null,arguments)},d._Tile=function(){return(d._Tile=d.asm.Tile).apply(null,arguments)},d._TopK=function(){return(d._TopK=d.asm.TopK).apply(null,arguments)},d._Transform=function(){return(d._Transform=d.asm.Transform).apply(null,arguments)},d._Transpose=function(){return(d._Transpose=d.asm.Transpose).apply(null,arguments)},d.__FusedMatMul=function(){return(d.__FusedMatMul=d.asm._FusedMatMul).apply(null,arguments)},d._malloc=function(){return(Yt=d._malloc=d.asm.malloc).apply(null,arguments)}),Zt=d._free=function(){return(Zt=d._free=d.asm.free).apply(null,arguments)},Jt=(d._emscripten_tls_init=function(){return(d._emscripten_tls_init=d.asm.emscripten_tls_init).apply(null,arguments)},d.___errno_location=function(){return(Jt=d.___errno_location=d.asm.__errno_location).apply(null,arguments)}),Qt=d._pthread_self=function(){return(Qt=d._pthread_self=d.asm.pthread_self).apply(null,arguments)},en=d._emscripten_main_thread_process_queued_calls=function(){return(en=d._emscripten_main_thread_process_queued_calls=d.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},tn=(d.__emscripten_thread_crashed=function(){return(d.__emscripten_thread_crashed=d.asm._emscripten_thread_crashed).apply(null,arguments)},d.__emscripten_thread_init=function(){return(tn=d.__emscripten_thread_init=d.asm._emscripten_thread_init).apply(null,arguments)}),nn=(d._emscripten_current_thread_process_queued_calls=function(){return(d._emscripten_current_thread_process_queued_calls=d.asm.emscripten_current_thread_process_queued_calls).apply(null,arguments)},d._emscripten_main_browser_thread_id=function(){return(d._emscripten_main_browser_thread_id=d.asm.emscripten_main_browser_thread_id).apply(null,arguments)},d._emscripten_sync_run_in_main_thread_2=function(){return(d._emscripten_sync_run_in_main_thread_2=d.asm.emscripten_sync_run_in_main_thread_2).apply(null,arguments)},d._emscripten_sync_run_in_main_thread_4=function(){return(nn=d._emscripten_sync_run_in_main_thread_4=d.asm.emscripten_sync_run_in_main_thread_4).apply(null,arguments)}),rn=d._emscripten_run_in_main_runtime_thread_js=function(){return(rn=d._emscripten_run_in_main_runtime_thread_js=d.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)},an=d._emscripten_dispatch_to_thread_=function(){return(an=d._emscripten_dispatch_to_thread_=d.asm.emscripten_dispatch_to_thread_).apply(null,arguments)},sn=d.__emscripten_thread_free_data=function(){return(sn=d.__emscripten_thread_free_data=d.asm._emscripten_thread_free_data).apply(null,arguments)},on=(d.__emscripten_thread_exit=function(){return(d.__emscripten_thread_exit=d.asm._emscripten_thread_exit).apply(null,arguments)},d._memalign=function(){return(d._memalign=d.asm.memalign).apply(null,arguments)},d._emscripten_stack_set_limits=function(){return(on=d._emscripten_stack_set_limits=d.asm.emscripten_stack_set_limits).apply(null,arguments)}),ln=d.stackSave=function(){return(ln=d.stackSave=d.asm.stackSave).apply(null,arguments)},un=d.stackRestore=function(){return(un=d.stackRestore=d.asm.stackRestore).apply(null,arguments)},pn=d.stackAlloc=function(){return(pn=d.stackAlloc=d.asm.stackAlloc).apply(null,arguments)},dn=(d.dynCall_iijjiiii=function(){return(d.dynCall_iijjiiii=d.asm.dynCall_iijjiiii).apply(null,arguments)},d.dynCall_jiji=function(){return(d.dynCall_jiji=d.asm.dynCall_jiji).apply(null,arguments)},d.__emscripten_allow_main_runtime_queued_calls=21464);function cn(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function hn(e){if(e=e||w,!(Se>0)){if(S)return o(d),be(),void postMessage({cmd:"loaded"});ye(),Se>0||(d.setStatus?(d.setStatus("Running..."),setTimeout((function(){setTimeout((function(){d.setStatus("")}),1),t()}),1)):t())}function t(){Ht||(Ht=!0,d.calledRun=!0,!z&&(be(),o(d),d.onRuntimeInitialized&&d.onRuntimeInitialized(),xe()))}}function fn(e,t){if(P=e,!t&&S)throw qe(e),"unwind";ge()||we(),mn(e)}function mn(e){P=e,ge()||(He.terminateAllThreads(),d.onExit&&d.onExit(e),z=!0),x(e,new cn(e))}if(d.cwrap=V,d.keepRuntimeAlive=ge,d.PThread=He,d.PThread=He,d.wasmMemory=O,d.ExitStatus=cn,Te=function e(){Ht||hn(),Ht||(Te=e)},d.run=hn,d.preInit)for("function"==typeof d.preInit&&(d.preInit=[d.preInit]);d.preInit.length>0;)d.preInit.pop()();if(hn(),p&&(jt={uncaughtException:process.listeners("uncaughtException").filter((function(e){return!p.uncaughtException.indexOf(e)>-1})),unhandledRejection:process.listeners("unhandledRejection").filter((function(e){return!p.unhandledRejection.indexOf(e)>-1}))}),"undefined"!=typeof WasmBackendModule)qt=WasmBackendModule;else{if("undefined"==typeof t)throw new Error("Could not find wasm module in post.js");qt=t}if(jt){var gn=qt._dispose;qt._dispose=function(){gn(),jt.uncaughtException.forEach((function(e){process.removeListener("uncaughtException",e)})),jt.unhandledRejection.forEach((function(e){process.removeListener("unhandledRejection",e)}))}}return t.ready}})();"object"==typeof e&&"object"==typeof t?t.exports=r:"function"==typeof define&&n.amdO?define([],(function(){return r})):"object"==typeof e&&(e.WasmBackendModuleThreadedSimd=r)})),Z=x(((e,t)=>{var r=(()=>{var e="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0;return e=e||l,function(t){t=t||{};var n,r,a,s="undefined"!=typeof t?t:{};s.ready=new Promise((function(e,t){n=e,r=t})),"undefined"!=typeof process&&process.listeners&&(a={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var i,o,l,p,d,c,h=Object.assign({},s),f=[],m="object"==typeof window,g="function"==typeof importScripts,y="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,b="";function w(e){return s.locateFile?s.locateFile(e,b):b+e}function x(e){e instanceof Oe||k("exiting due to exception: "+e)}y?(b=g?j().dirname(b)+"/":u+"/",c=()=>{d||(p=H(),d=j())},i=function(e,t){return c(),e=d.normalize(e),p.readFileSync(e,t?void 0:"utf8")},l=e=>{var t=i(e,!0);return t.buffer||(t=new Uint8Array(t)),t},o=(e,t,n)=>{c(),e=d.normalize(e),p.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),f=process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof Oe))throw e})),process.on("unhandledRejection",(function(e){throw e})),(e,t)=>{if(Y())throw process.exitCode=e,t;x(t),process.exit(e)},s.inspect=function(){return"[Emscripten Module object]"}):(m||g)&&(g?b=self.location.href:"undefined"!=typeof document&&document.currentScript&&(b=document.currentScript.src),e&&(b=e),b=0!==b.indexOf("blob:")?b.substr(0,b.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},g&&(l=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),o=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var v=s.print||console.log.bind(console),k=s.printErr||console.warn.bind(console);Object.assign(s,h),h=null,s.arguments&&(f=s.arguments),s.thisProgram&&s.thisProgram,s.quit&&s.quit;var I,S=e=>{e};s.wasmBinary&&(I=s.wasmBinary);var N=s.noExitRuntime||!0;"object"!=typeof WebAssembly&&le("no native wasm support detected");var T,C=!1;function _(e){var t=s["_"+e];return t}function E(e,t,n,r,a){var s={string:function(e){var t=0;if(null!=e&&0!==e){var n=1+(e.length<<2);t=Me(n),M(e,t,n)}return t},array:function(e){var t=Me(e.length);return B(e,t),t}};function i(e){return"string"===t?R(e):"boolean"===t?Boolean(e):e}var o=_(e),l=[],u=0;if(r)for(var p=0;p<r.length;p++){var d=s[n[p]];d?(0===u&&(u=Re()),l[p]=d(r[p])):l[p]=r[p]}var c=o.apply(null,l);function h(e){return 0!==u&&De(u),i(e)}return c=h(c),c}function A(e,t,n,r){n=n||[];var a=n.every((function(e){return"number"===e})),s="string"!==t;return s&&a&&!r?_(e):function(){return E(e,t,n,arguments,r)}}var $="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function F(e,t,n){for(var r=t+n,a=t;e[a]&&!(a>=r);)++a;if(a-t>16&&e.subarray&&$)return $.decode(e.subarray(t,a));for(var s="";t<a;){var i=e[t++];if(128&i){var o=63&e[t++];if(192!=(224&i)){var l=63&e[t++];if(i=224==(240&i)?(15&i)<<12|o<<6|l:(7&i)<<18|o<<12|l<<6|63&e[t++],i<65536)s+=String.fromCharCode(i);else{var u=i-65536;s+=String.fromCharCode(55296|u>>10,56320|1023&u)}}else s+=String.fromCharCode((31&i)<<6|o)}else s+=String.fromCharCode(i)}return s}function R(e,t){return e?F(P,e,t):""}function D(e,t,n,r){if(!(r>0))return 0;for(var a=n,s=n+r-1,i=0;i<e.length;++i){var o=e.charCodeAt(i);if(o>=55296&&o<=57343){var l=e.charCodeAt(++i);o=65536+((1023&o)<<10)|1023&l}if(o<=127){if(n>=s)break;t[n++]=o}else if(o<=2047){if(n+1>=s)break;t[n++]=192|o>>6,t[n++]=128|63&o}else if(o<=65535){if(n+2>=s)break;t[n++]=224|o>>12,t[n++]=128|o>>6&63,t[n++]=128|63&o}else{if(n+3>=s)break;t[n++]=240|o>>18,t[n++]=128|o>>12&63,t[n++]=128|o>>6&63,t[n++]=128|63&o}}return t[n]=0,n-a}function M(e,t,n){return D(e,P,t,n)}var O,L,P,z;"undefined"!=typeof TextDecoder&&new TextDecoder("utf-16le");function B(e,t){L.set(e,t)}function W(e,t){return e%t>0&&(e+=t-e%t),e}function V(e){O=e,s.HEAP8=L=new Int8Array(e),s.HEAP16=new Int16Array(e),s.HEAP32=z=new Int32Array(e),s.HEAPU8=P=new Uint8Array(e),s.HEAPU16=new Uint16Array(e),s.HEAPU32=new Uint32Array(e),s.HEAPF32=new Float32Array(e),s.HEAPF64=new Float64Array(e)}s.INITIAL_MEMORY;var U,G=[],q=[],K=[],X=0;function Y(){return N||X>0}function Z(){if(s.preRun)for("function"==typeof s.preRun&&(s.preRun=[s.preRun]);s.preRun.length;)ee(s.preRun.shift());ge(G)}function J(){!0,ge(q)}function Q(){if(s.postRun)for("function"==typeof s.postRun&&(s.postRun=[s.postRun]);s.postRun.length;)ne(s.postRun.shift());ge(K)}function ee(e){G.unshift(e)}function te(e){q.unshift(e)}function ne(e){K.unshift(e)}var re=0,ae=null,se=null;function ie(e){re++,s.monitorRunDependencies&&s.monitorRunDependencies(re)}function oe(e){if(re--,s.monitorRunDependencies&&s.monitorRunDependencies(re),0==re&&(null!==ae&&(clearInterval(ae),ae=null),se)){var t=se;se=null,t()}}function le(e){s.onAbort&&s.onAbort(e),e="Aborted("+e+")",k(e),C=!0,1,e+=". Build with -s ASSERTIONS=1 for more info.";var t=new WebAssembly.RuntimeError(e);throw r(t),t}s.preloadedImages={},s.preloadedAudios={};var ue,pe="data:application/octet-stream;base64,";function de(e){return e.startsWith(pe)}function ce(e){return e.startsWith("file://")}function he(e){try{if(e==ue&&I)return new Uint8Array(I);if(l)return l(e);throw"both async and sync fetching of the wasm failed"}catch(t){le(t)}}function fe(){if(!I&&(m||g)){if("function"==typeof fetch&&!ce(ue))return fetch(ue,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+ue+"'";return e.arrayBuffer()})).catch((function(){return he(ue)}));if(o)return new Promise((function(e,t){o(ue,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return he(ue)}))}function me(){var e={env:Fe,wasi_snapshot_preview1:Fe};function t(e,t){var n=e.exports;s.asm=n,T=s.asm.memory,V(T.buffer),U=s.asm.__indirect_function_table,te(s.asm.__wasm_call_ctors),oe("wasm-instantiate")}function n(e){t(e.instance)}function a(t){return fe().then((function(t){return WebAssembly.instantiate(t,e)})).then((function(e){return e})).then(t,(function(e){k("failed to asynchronously prepare wasm: "+e),le(e)}))}function i(){return I||"function"!=typeof WebAssembly.instantiateStreaming||de(ue)||ce(ue)||"function"!=typeof fetch?a(n):fetch(ue,{credentials:"same-origin"}).then((function(t){var r=WebAssembly.instantiateStreaming(t,e);return r.then(n,(function(e){return k("wasm streaming compile failed: "+e),k("falling back to ArrayBuffer instantiation"),a(n)}))}))}if(ie("wasm-instantiate"),s.instantiateWasm)try{var o=s.instantiateWasm(e,t);return o}catch(l){return k("Module.instantiateWasm callback failed with error: "+l),!1}return i().catch(r),{}}function ge(e){for(;e.length>0;){var t=e.shift();if("function"!=typeof t){var n=t.func;"number"==typeof n?void 0===t.arg?be(n)():be(n)(t.arg):n(void 0===t.arg?null:t.arg)}else t(s)}}ue="tfjs-backend-wasm.wasm",de(ue)||(ue=w(ue));var ye=[];function be(e){var t=ye[e];return t||(e>=ye.length&&(ye.length=e+1),ye[e]=t=U.get(e)),t}function we(){le("")}function xe(){return 2147483648}function ve(e,t,n){P.copyWithin(e,t,t+n)}function ke(e){try{return T.grow(e-O.byteLength+65535>>>16),V(T.buffer),1}catch(t){}}function Ie(e){var t=P.length;e>>>=0;var n=xe();if(e>n)return!1;for(var r=1;r<=4;r*=2){var a=t*(1+.2/r);a=Math.min(a,e+100663296);var s=Math.min(n,W(Math.max(e,a),65536)),i=ke(s);if(i)return!0}return!1}var Se={mappings:{},buffers:[null,[],[]],printChar:function(e,t){var n=Se.buffers[e];0===t||10===t?((1===e?v:k)(F(n,0)),n.length=0):n.push(t)},varargs:void 0,get:function(){Se.varargs+=4;var e=z[Se.varargs-4>>2];return e},getStr:function(e){var t=R(e);return t},get64:function(e,t){return e}};function Ne(e){return 0}function Te(e,t,n,r,a){}function Ce(e,t,n,r){for(var a=0,s=0;s<n;s++){var i=z[t>>2],o=z[t+4>>2];t+=8;for(var l=0;l<o;l++)Se.printChar(e,P[i+l]);a+=o}return z[r>>2]=a,0}function _e(e){S(e)}var Ee,Ae,$e,Fe={abort:we,emscripten_get_heap_max:xe,emscripten_memcpy_big:ve,emscripten_resize_heap:Ie,fd_close:Ne,fd_seek:Te,fd_write:Ce,setTempRet0:_e},Re=(me(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm.__wasm_call_ctors).apply(null,arguments)},s._init=function(){return(s._init=s.asm.init).apply(null,arguments)},s._init_with_threads_count=function(){return(s._init_with_threads_count=s.asm.init_with_threads_count).apply(null,arguments)},s._get_threads_count=function(){return(s._get_threads_count=s.asm.get_threads_count).apply(null,arguments)},s._register_tensor=function(){return(s._register_tensor=s.asm.register_tensor).apply(null,arguments)},s._dispose_data=function(){return(s._dispose_data=s.asm.dispose_data).apply(null,arguments)},s._dispose=function(){return(s._dispose=s.asm.dispose).apply(null,arguments)},s._Abs=function(){return(s._Abs=s.asm.Abs).apply(null,arguments)},s._Add=function(){return(s._Add=s.asm.Add).apply(null,arguments)},s._AddN=function(){return(s._AddN=s.asm.AddN).apply(null,arguments)},s._All=function(){return(s._All=s.asm.All).apply(null,arguments)},s._Any=function(){return(s._Any=s.asm.Any).apply(null,arguments)},s._ArgMax=function(){return(s._ArgMax=s.asm.ArgMax).apply(null,arguments)},s._AvgPool=function(){return(s._AvgPool=s.asm.AvgPool).apply(null,arguments)},s._BatchMatMul=function(){return(s._BatchMatMul=s.asm.BatchMatMul).apply(null,arguments)},s._Ceil=function(){return(s._Ceil=s.asm.Ceil).apply(null,arguments)},s._ClipByValue=function(){return(s._ClipByValue=s.asm.ClipByValue).apply(null,arguments)},s._Conv2D=function(){return(s._Conv2D=s.asm.Conv2D).apply(null,arguments)},s._Conv2DBackpropInput=function(){return(s._Conv2DBackpropInput=s.asm.Conv2DBackpropInput).apply(null,arguments)},s._Cos=function(){return(s._Cos=s.asm.Cos).apply(null,arguments)},s._Cosh=function(){return(s._Cosh=s.asm.Cosh).apply(null,arguments)},s._CropAndResize=function(){return(s._CropAndResize=s.asm.CropAndResize).apply(null,arguments)},s._Cumprod=function(){return(s._Cumprod=s.asm.Cumprod).apply(null,arguments)},s._Cumsum=function(){return(s._Cumsum=s.asm.Cumsum).apply(null,arguments)},s._DepthToSpace=function(){return(s._DepthToSpace=s.asm.DepthToSpace).apply(null,arguments)},s._DepthwiseConv2dNative=function(){return(s._DepthwiseConv2dNative=s.asm.DepthwiseConv2dNative).apply(null,arguments)},s._Elu=function(){return(s._Elu=s.asm.Elu).apply(null,arguments)},s._Equal=function(){return(s._Equal=s.asm.Equal).apply(null,arguments)},s._Exp=function(){return(s._Exp=s.asm.Exp).apply(null,arguments)},s._FlipLeftRight=function(){return(s._FlipLeftRight=s.asm.FlipLeftRight).apply(null,arguments)},s._Floor=function(){return(s._Floor=s.asm.Floor).apply(null,arguments)},s._FloorDiv=function(){return(s._FloorDiv=s.asm.FloorDiv).apply(null,arguments)},s._FusedBatchNorm=function(){return(s._FusedBatchNorm=s.asm.FusedBatchNorm).apply(null,arguments)},s._FusedConv2D=function(){return(s._FusedConv2D=s.asm.FusedConv2D).apply(null,arguments)},s._FusedDepthwiseConv2D=function(){return(s._FusedDepthwiseConv2D=s.asm.FusedDepthwiseConv2D).apply(null,arguments)},s._Gather=function(){return(s._Gather=s.asm.Gather).apply(null,arguments)},s._GatherNd=function(){return(s._GatherNd=s.asm.GatherNd).apply(null,arguments)},s._Greater=function(){return(s._Greater=s.asm.Greater).apply(null,arguments)},s._GreaterEqual=function(){return(s._GreaterEqual=s.asm.GreaterEqual).apply(null,arguments)},s._LeakyRelu=function(){return(s._LeakyRelu=s.asm.LeakyRelu).apply(null,arguments)},s._Less=function(){return(s._Less=s.asm.Less).apply(null,arguments)},s._LessEqual=function(){return(s._LessEqual=s.asm.LessEqual).apply(null,arguments)},s._Log=function(){return(s._Log=s.asm.Log).apply(null,arguments)},s._LogicalAnd=function(){return(s._LogicalAnd=s.asm.LogicalAnd).apply(null,arguments)},s._Max=function(){return(s._Max=s.asm.Max).apply(null,arguments)},s._MaxPool=function(){return(s._MaxPool=s.asm.MaxPool).apply(null,arguments)},s._Maximum=function(){return(s._Maximum=s.asm.Maximum).apply(null,arguments)},s._Mean=function(){return(s._Mean=s.asm.Mean).apply(null,arguments)},s._Min=function(){return(s._Min=s.asm.Min).apply(null,arguments)},s._Minimum=function(){return(s._Minimum=s.asm.Minimum).apply(null,arguments)},s._MirrorPad=function(){return(s._MirrorPad=s.asm.MirrorPad).apply(null,arguments)},s._Multiply=function(){return(s._Multiply=s.asm.Multiply).apply(null,arguments)},s._Neg=function(){return(s._Neg=s.asm.Neg).apply(null,arguments)},s._NonMaxSuppressionV3=function(){return(s._NonMaxSuppressionV3=s.asm.NonMaxSuppressionV3).apply(null,arguments)},s._NonMaxSuppressionV4=function(){return(s._NonMaxSuppressionV4=s.asm.NonMaxSuppressionV4).apply(null,arguments)},s._NonMaxSuppressionV5=function(){return(s._NonMaxSuppressionV5=s.asm.NonMaxSuppressionV5).apply(null,arguments)},s._NotEqual=function(){return(s._NotEqual=s.asm.NotEqual).apply(null,arguments)},s._OneHot=function(){return(s._OneHot=s.asm.OneHot).apply(null,arguments)},s._PadV2=function(){return(s._PadV2=s.asm.PadV2).apply(null,arguments)},s._Pow=function(){return(s._Pow=s.asm.Pow).apply(null,arguments)},s._Prelu=function(){return(s._Prelu=s.asm.Prelu).apply(null,arguments)},s._Prod=function(){return(s._Prod=s.asm.Prod).apply(null,arguments)},s._RealDiv=function(){return(s._RealDiv=s.asm.RealDiv).apply(null,arguments)},s._Relu=function(){return(s._Relu=s.asm.Relu).apply(null,arguments)},s._Relu6=function(){return(s._Relu6=s.asm.Relu6).apply(null,arguments)},s._ResizeBilinear=function(){return(s._ResizeBilinear=s.asm.ResizeBilinear).apply(null,arguments)},s._Reverse=function(){return(s._Reverse=s.asm.Reverse).apply(null,arguments)},s._RotateWithOffset=function(){return(s._RotateWithOffset=s.asm.RotateWithOffset).apply(null,arguments)},s._Round=function(){return(s._Round=s.asm.Round).apply(null,arguments)},s._Rsqrt=function(){return(s._Rsqrt=s.asm.Rsqrt).apply(null,arguments)},s._ScatterNd=function(){return(s._ScatterNd=s.asm.ScatterNd).apply(null,arguments)},s._SelectV2=function(){return(s._SelectV2=s.asm.SelectV2).apply(null,arguments)},s._Sigmoid=function(){return(s._Sigmoid=s.asm.Sigmoid).apply(null,arguments)},s._Sin=function(){return(s._Sin=s.asm.Sin).apply(null,arguments)},s._Softmax=function(){return(s._Softmax=s.asm.Softmax).apply(null,arguments)},s._SparseFillEmptyRows=function(){return(s._SparseFillEmptyRows=s.asm.SparseFillEmptyRows).apply(null,arguments)},s._SparseReshape=function(){return(s._SparseReshape=s.asm.SparseReshape).apply(null,arguments)},s._SparseSegmentReduction=function(){return(s._SparseSegmentReduction=s.asm.SparseSegmentReduction).apply(null,arguments)},s._Sqrt=function(){return(s._Sqrt=s.asm.Sqrt).apply(null,arguments)},s._Square=function(){return(s._Square=s.asm.Square).apply(null,arguments)},s._SquaredDifference=function(){return(s._SquaredDifference=s.asm.SquaredDifference).apply(null,arguments)},s._Step=function(){return(s._Step=s.asm.Step).apply(null,arguments)},s._StridedSlice=function(){return(s._StridedSlice=s.asm.StridedSlice).apply(null,arguments)},s._Sub=function(){return(s._Sub=s.asm.Sub).apply(null,arguments)},s._Sum=function(){return(s._Sum=s.asm.Sum).apply(null,arguments)},s._Tan=function(){return(s._Tan=s.asm.Tan).apply(null,arguments)},s._Tanh=function(){return(s._Tanh=s.asm.Tanh).apply(null,arguments)},s._Tile=function(){return(s._Tile=s.asm.Tile).apply(null,arguments)},s._TopK=function(){return(s._TopK=s.asm.TopK).apply(null,arguments)},s._Transform=function(){return(s._Transform=s.asm.Transform).apply(null,arguments)},s._Transpose=function(){return(s._Transpose=s.asm.Transpose).apply(null,arguments)},s.__FusedMatMul=function(){return(s.__FusedMatMul=s.asm._FusedMatMul).apply(null,arguments)},s._malloc=function(){return(s._malloc=s.asm.malloc).apply(null,arguments)},s._free=function(){return(s._free=s.asm.free).apply(null,arguments)},s.___errno_location=function(){return(s.___errno_location=s.asm.__errno_location).apply(null,arguments)},s._emscripten_main_thread_process_queued_calls=function(){return(s._emscripten_main_thread_process_queued_calls=s.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},s.stackSave=function(){return(Re=s.stackSave=s.asm.stackSave).apply(null,arguments)}),De=s.stackRestore=function(){return(De=s.stackRestore=s.asm.stackRestore).apply(null,arguments)},Me=s.stackAlloc=function(){return(Me=s.stackAlloc=s.asm.stackAlloc).apply(null,arguments)};s.dynCall_iijjiiii=function(){return(s.dynCall_iijjiiii=s.asm.dynCall_iijjiiii).apply(null,arguments)},s.dynCall_jiji=function(){return(s.dynCall_jiji=s.asm.dynCall_jiji).apply(null,arguments)};function Oe(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function Le(e){function t(){Ee||(Ee=!0,s.calledRun=!0,!C&&(J(),n(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),Q()))}e=e||f,re>0||(Z(),re>0)||(s.setStatus?(s.setStatus("Running..."),setTimeout((function(){setTimeout((function(){s.setStatus("")}),1),t()}),1)):t())}if(s.cwrap=A,se=function e(){Ee||Le(),Ee||(se=e)},s.run=Le,s.preInit)for("function"==typeof s.preInit&&(s.preInit=[s.preInit]);s.preInit.length>0;)s.preInit.pop()();if(Le(),a&&(Ae={uncaughtException:process.listeners("uncaughtException").filter((function(e){return!a.uncaughtException.indexOf(e)>-1})),unhandledRejection:process.listeners("unhandledRejection").filter((function(e){return!a.unhandledRejection.indexOf(e)>-1}))}),"undefined"!=typeof t)$e=t;else{if("undefined"==typeof WasmBackendModuleThreadedSimd)throw new Error("Could not find wasm module in post.js");$e=WasmBackendModuleThreadedSimd}if(Ae){var Pe=$e._dispose;$e._dispose=function(){Pe(),Ae.uncaughtException.forEach((function(e){process.removeListener("uncaughtException",e)})),Ae.unhandledRejection.forEach((function(e){process.removeListener("unhandledRejection",e)}))}}return t.ready}})();"object"==typeof e&&"object"==typeof t?t.exports=r:"function"==typeof define&&n.amdO?define([],(function(){return r})):"object"==typeof e&&(e.WasmBackendModule=r)})),J=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},Q=class{refCount(e){return ee("refCount")}incRef(e){return ee("incRef")}timerAvailable(){return!0}time(e){return ee("time")}read(e){return ee("read")}readSync(e){return ee("readSync")}readToGPU(e,t){return ee("readToGPU")}numDataIds(){return ee("numDataIds")}disposeData(e,t){return ee("disposeData")}write(e,t,n){return ee("write")}move(e,t,n,r,a){return ee("move")}memory(){return ee("memory")}floatPrecision(){return ee("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return ee("dispose")}};function ee(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function te(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,se(e,t,n)}function ne(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,se(e,n,r),se(t,n,r)}function re(e,t,n){return Math.max(e,Math.min(t,n))}function ae(e){return e%2===0?e:e+1}function se(e,t,n){let r=e[t];e[t]=e[n],e[n]=r}function ie(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function oe(e,t){let n=Math.random();return t*n+(1-n)*e}function le(e,t){let n=0;for(let r=0;r<e.length;r++){let a=Number(e[r])-Number(t[r]);n+=a*a}return n}function ue(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function pe(e,t,n=""){ue(me(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function de(e){ue(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function ce(e,t=[],n=!1){if(null==t&&(t=[]),Array.isArray(e)||Ae(e)&&!n)for(let r=0;r<e.length;++r)ce(e[r],t,n);else t.push(e);return t}function he(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function fe(e){return 0===e.length}function me(e,t){if(e===t)return!0;if(null==e||null==t||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function ge(e){return e%1===0}function ye(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function be(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function we(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return te(t),t}function xe(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function ve(e,t=(e=>0),n){return new Promise(((r,a)=>{let s=0,i=()=>{if(e())return void r();s++;let o=t(s);null!=n&&s>=n?a():setTimeout(i,o)};i()}))}function ke(e,t){let n=1,r=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)n*=e[s];else if(-1===e[s]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);r=s}else if(e[s]<0)throw Error(`Shapes can not be < 0. Found ${e[s]} at dim ${s}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let a=e.slice();return a[r]=t/n,a}function Ie(e,t){let n=t.length;return e=null==e?t.map(((e,t)=>t)):[].concat(e),ue(e.every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),ue(e.every((e=>ge(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function Se(e,t){let n=[],r=[],a=null!=t&&Array.isArray(t)&&0===t.length,s=null==t||a?null:Ie(t,e).sort(),i=0;for(let o=0;o<e.length;++o){if(null!=s){if(s[i]===o&&1!==e[o])throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(null==s[i]||s[i]>o)&&1===e[o]&&(n.push(e[o]),r.push(o)),s[i]<=o&&i++}1!==e[o]&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function Ne(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);n=new Uint8Array(t)}return n}function Te(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function Ce(e,t){for(let n=0;n<e.length;n++){let r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function _e(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function Ee(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function Ae(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}function $e(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function Fe(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}function Re(e){return"string"==typeof e||e instanceof String}function De(e){return"boolean"==typeof e}function Me(e){return"number"==typeof e}function Oe(e){return Array.isArray(e)?Oe(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":Me(e)?"float32":Re(e)?"string":De(e)?"bool":"float32"}function Le(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Pe(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function ze(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function Be(e,t,n,r=!1){let a=new Array;if(1===t.length){let s=t[0]*(r?2:1);for(let t=0;t<s;t++)a[t]=n[e+t]}else{let s=t[0],i=t.slice(1),o=i.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<s;t++)a[t]=Be(e+t*o,i,n,r)}return a}function We(e,t,n=!1){if(0===e.length)return t[0];let r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return Be(0,e,t,n)}function Ve(e,t){let n=Ue(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function Ue(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function Ge(e,t){let n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return We(e,new Float32Array(n));if("int32"===t)return We(e,new Int32Array(n));if("bool"===t)return We(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function He(e){e.forEach((t=>{ue(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function je(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let a=0;a<e.length-1;++a)r+=n[a]*e[a];return r}function qe(e,t,n){if(0===t)return[];if(1===t)return[e];let r=new Array(t);for(let a=0;a<r.length-1;++a)r[a]=Math.floor(e/n[a]),e-=r[a]*n[a];return r[r.length-1]=e,r}function Ke(e){return e&&e.then&&"function"==typeof e.then}var Xe="tfjsflags",Ye=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Ze,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(et().getBool("IS_TEST")||et().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){let t=this.urlFlags[e];et().getBool("IS_TEST")||et().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(Ke(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"==typeof this.global||"undefined"==typeof this.global.location||"undefined"==typeof this.global.location.search)return;let e=this.getQueryParams(this.global.location.search);Xe in e&&e[Xe].split(",").forEach((e=>{let[t,n]=e.split(":");this.urlFlags[t]=Qe(t,n)}))}};function Ze(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((e,...n)=>(Je(t,n[0],n[1]),n.join("=")))),t}function Je(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function Qe(e,t){if(t=t.toLowerCase(),"true"===t||"false"===t)return"true"===t;if(""+ +t===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}function et(){return nt}var tt,nt=null;function rt(e){nt=e}function at(){if(null==tt){let e;if("undefined"!=typeof window)e=window;else if("undefined"!=typeof n.g)e=n.g;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}tt=e}return tt}function st(){let e=at();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}function it(e,t){let n=st();if(n.has(e))return n.get(e);{let r=t();return n.set(e,r),n.get(e)}}var ot="Abs",lt="Acos",ut="Acosh",pt="Add",dt="AddN",ct="All",ht="Any",ft="ArgMax",mt="ArgMin",gt="Asin",yt="Asinh",bt="Atan",wt="Atanh",xt="Atan2",vt="AvgPool",kt="AvgPoolGrad",It="AvgPool3D",St="AvgPool3DGrad",Nt="BatchMatMul",Tt="BatchToSpaceND",Ct="Bincount",_t="BroadcastTo",Et="BroadcastArgs",At="Cast",$t="Ceil",Ft="ClipByValue",Rt="Complex",Dt="ComplexAbs",Mt="Concat",Ot="Conv2D",Lt="Conv2DBackpropFilter",Pt="Conv2DBackpropInput",zt="Conv3D",Bt="Conv3DBackpropFilterV2",Wt="Conv3DBackpropInputV2",Vt="Cos",Ut="Cosh",Gt="Cumprod",Ht="Cumsum",jt="CropAndResize",qt="DenseBincount",Kt="DepthToSpace",Xt="DepthwiseConv2dNative",Yt="DepthwiseConv2dNativeBackpropFilter",Zt="DepthwiseConv2dNativeBackpropInput",Jt="Diag",Qt="Dilation2D",en="Dilation2DBackpropInput",tn="Dilation2DBackpropFilter",nn="RealDiv",rn="Einsum",an="Elu",sn="EluGrad",on="Erf",ln="Equal",un="Exp",pn="ExpandDims",dn="Expm1",cn="FFT",hn="Fill",fn="FlipLeftRight",mn="Floor",gn="FloorDiv",yn="FusedBatchNorm",bn="GatherV2",wn="GatherNd",xn="Greater",vn="GreaterEqual",kn="Identity",In="IFFT",Sn="Imag",Nn="IsFinite",Tn="IsInf",Cn="IsNan",_n="LeakyRelu",En="Less",An="LessEqual",$n="LinSpace",Fn="Log",Rn="Log1p",Dn="LogicalAnd",Mn="LogicalNot",On="LogicalOr",Ln="LogSoftmax",Pn="LowerBound",zn="LRN",Bn="LRNGrad",Wn="Max",Vn="Maximum",Un="MaxPool",Gn="MaxPoolGrad",Hn="MaxPool3D",jn="MaxPool3DGrad",qn="MaxPoolWithArgmax",Kn="Mean",Xn="Min",Yn="Minimum",Zn="MirrorPad",Jn="Mod",Qn="Multinomial",er="Multiply",tr="Neg",nr="NotEqual",rr="NonMaxSuppressionV3",ar="NonMaxSuppressionV4",sr="NonMaxSuppressionV5",ir="OnesLike",or="OneHot",lr="Pack",ur="PadV2",pr="Pool",dr="Pow",cr="Prelu",hr="Prod",fr="Range",mr="Real",gr="Reciprocal",yr="Relu",br="Reshape",wr="ResizeNearestNeighbor",xr="ResizeNearestNeighborGrad",vr="ResizeBilinear",kr="ResizeBilinearGrad",Ir="Relu6",Sr="Reverse",Nr="Round",Tr="Rsqrt",Cr="ScatterNd",_r="SearchSorted",Er="Select",Ar="Selu",$r="Slice",Fr="Sin",Rr="Sinh",Dr="Sign",Mr="Sigmoid",Or="Softplus",Lr="Sqrt",Pr="Sum",zr="SpaceToBatchND",Br="SplitV",Wr="Softmax",Vr="SparseFillEmptyRows",Ur="SparseReshape",Gr="SparseSegmentMean",Hr="SparseSegmentSum",jr="SparseToDense",qr="SquaredDifference",Kr="Square",Xr="StridedSlice",Yr="StringNGrams",Zr="StringSplit",Jr="StringToHashBucketFast",Qr="Sub",ea="Tan",ta="Tanh",na="Tile",ra="TopK",aa="Transform",sa="Transpose",ia="Unique",oa="Unpack",la="UnsortedSegmentSum",ua="UpperBound",pa="ZerosLike",da="Step",ca="FromPixels",ha="RotateWithOffset",fa="_FusedMatMul",ma="FusedConv2D",ga="FusedDepthwiseConv2D";function ya(...e){et().getBool("IS_TEST")||et().getBool("PROD")||console.warn(...e)}function ba(...e){et().getBool("IS_TEST")||et().getBool("PROD")||console.log(...e)}var wa=it("kernelRegistry",(()=>new Map)),xa=it("gradRegistry",(()=>new Map));function va(e,t){let n=Ea(e,t);return wa.get(n)}function ka(e){return xa.get(e)}function Ia(e){let t=wa.entries(),n=[];for(;;){let{done:r,value:a}=t.next();if(r)break;let[s,i]=a,[o]=s.split("_");o===e&&n.push(i)}return n}function Sa(e){let{kernelName:t,backendName:n}=e,r=Ea(t,n);wa.has(r)&&ya(`The kernel '${t}' for backend '${n}' is already registered`),wa.set(r,e)}function Na(e){let{kernelName:t}=e;xa.has(t)&&et().getBool("DEBUG")&&ya(`Overriding the gradient for '${t}'`),xa.set(t,e)}function Ta(e,t){let n=Ea(e,t);if(!wa.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);wa.delete(n)}function Ca(e){if(!xa.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);xa.delete(e)}function _a(e,t){Ia(e).forEach((e=>{let n=Object.assign({},e,{backendName:t});Sa(n)}))}function Ea(e,t){return`${t}_${e}`}var Aa={};v(Aa,{arraysEqual:()=>me,assert:()=>ue,assertNonNegativeIntegerDimensions:()=>He,assertNonNull:()=>de,assertShapesMatch:()=>pe,bytesFromStringArray:()=>Fe,bytesPerElement:()=>$e,checkConversionForErrors:()=>Ce,clamp:()=>re,computeStrides:()=>ze,createScalarValue:()=>Xa,createShuffledIndices:()=>we,decodeString:()=>ts,distSquared:()=>le,encodeString:()=>es,fetch:()=>Qa,fingerPrint64:()=>Ka,flatten:()=>ce,getArrayFromDType:()=>Te,getTypedArrayFromDType:()=>Ne,hasEncodingLoss:()=>Ee,hexToLong:()=>Ra,indexToLoc:()=>qe,inferDtype:()=>Oe,inferFromImplicitShape:()=>ke,isBoolean:()=>De,isFunction:()=>Le,isInt:()=>ge,isNumber:()=>Me,isPromise:()=>Ke,isScalarShape:()=>fe,isString:()=>Re,isTypedArray:()=>Ae,isValidDtype:()=>_e,locToIndex:()=>je,makeOnesTypedArray:()=>Ve,makeZerosNestedTypedArray:()=>Ge,makeZerosTypedArray:()=>Ue,nearestDivisor:()=>Pe,nearestLargerEven:()=>ae,now:()=>Ja,parseAxisParam:()=>Ie,randUniform:()=>oe,repeatedTry:()=>ve,rightPad:()=>xe,shuffle:()=>te,shuffleCombo:()=>ne,sizeFromShape:()=>he,sizeToSquarishShape:()=>be,squeezeShape:()=>Se,sum:()=>ie,swap:()=>se,tanh:()=>ye,toNestedArray:()=>We,toTypedArray:()=>Za});var $a=I(S()),Fa=$a.default||$a;function Ra(e){return Fa.fromString(e,!0,16)}var Da=Ra("c3a5c85c97cb3127"),Ma=Ra("b492b66fbe98f273"),Oa=Ra("9ae16a3b2f90404f");function La(e){return e.xor(e.shru(47))}function Pa(e,t,n){let r=e.slice(t,t+n);return Fa.fromBytes(Array.from(r),!0,!0)}function za(e,t){return Pa(e,t,8)}function Ba(e,t){return Pa(e,t,4)}function Wa(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function Va(e,t,n=Ra("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let a=t.xor(r).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function Ua(e,t,n,r,a,s){a=a.add(e),s=Wa(s.add(a).add(r),21);let i=a;return a=a.add(t),a=a.add(n),s=s.add(Wa(a,44)),[a.add(r),s.add(i)]}function Ga(e,t,n,r){return Ua(za(e,t),za(e,t+8),za(e,t+16),za(e,t+24),n,r)}function Ha(e,t=e.length){if(t>=8){let n=Oa.add(2*t),r=za(e,0).add(Oa),a=za(e,t-8),s=Wa(a,37).mul(n).add(r),i=Wa(r,25).add(a).mul(n);return Va(s,i,n)}if(t>=4){let n=Oa.add(2*t),r=Ba(e,0);return Va(r.shl(3).add(t),Ba(e,t-4),n)}if(t>0){let n=e[0],r=e[t>>1],a=e[t-1],s=n+(r<<8),i=t+(a<<2);return La(Oa.mul(s).xor(Da.mul(i))).mul(Oa)}return Oa}function ja(e,t=e.length){let n=Oa.add(2*t),r=za(e,0).mul(Ma),a=za(e,8),s=za(e,t-8).mul(n),i=za(e,t-16).mul(Oa);return Va(Wa(r.add(a),43).add(Wa(s,30)).add(i),r.add(Wa(a.add(Oa),18)).add(s),n)}function qa(e,t=e.length){let n=Oa.add(2*t),r=za(e,0).mul(Oa),a=za(e,8),s=za(e,t-8).mul(n),i=za(e,t-16).mul(Oa),o=Wa(r.add(a),43).add(Wa(s,30)).add(i),l=Va(o,r.add(Wa(a.add(Oa),18)).add(s),n),u=za(e,16).mul(n),p=za(e,24),d=o.add(za(e,t-32)).mul(n),c=l.add(za(e,t-24)).mul(n);return Va(Wa(u.add(p),43).add(Wa(d,30)).add(c),u.add(Wa(p.add(r),18)).add(d),n)}function Ka(e,t=e.length){let n=Fa.fromNumber(81,!0);if(t<=32)return t<=16?Ha(e,t):ja(e,t);if(t<=64)return qa(e,t);let r=n,a=n.mul(Ma).add(113),s=La(a.mul(Oa).add(113)).mul(Oa),i=[Fa.UZERO,Fa.UZERO],o=[Fa.UZERO,Fa.UZERO];r=r.mul(Oa).add(za(e,0));let l=0,u=64*(t-1>>6),p=u+(t-1&63)-63;do{r=Wa(r.add(a).add(i[0]).add(za(e,l+8)),37).mul(Ma),a=Wa(a.add(i[1]).add(za(e,l+48)),42).mul(Ma),r=r.xor(o[1]),a=a.add(i[0]).add(za(e,l+40)),s=Wa(s.add(o[0]),33).mul(Ma),i=Ga(e,l,i[1].mul(Ma),r.add(o[0])),o=Ga(e,l+32,s.add(o[1]),a.add(za(e,l+16))),[s,r]=[r,s],l+=64}while(l!==u);let d=Ma.add(s.and(255).shl(1));return l=p,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=Wa(r.add(a).add(i[0]).add(za(e,l+8)),37).mul(d),a=Wa(a.add(i[1]).add(za(e,l+48)),42).mul(d),r=r.xor(o[1].mul(9)),a=a.add(i[0].mul(9).add(za(e,l+40))),s=Wa(s.add(o[0]),33).mul(d),i=Ga(e,l,i[1].mul(d),r.add(o[0])),o=Ga(e,l+32,s.add(o[1]),a.add(za(e,l+16))),[s,r]=[r,s],Va(Va(i[0],o[0],d).add(La(a).mul(Da)).add(s),Va(i[1],o[1],d).add(r),d)}function Xa(e,t){return"string"===t?es(e):Za([e],t)}function Ya(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}function Za(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=ce(e)),et().getBool("DEBUG")&&Ce(e,t),Ya(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){let t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function Ja(){return et().platform.now()}function Qa(e,t){return et().platform.fetch(e,t)}function es(e,t="utf-8"){return t=t||"utf-8",et().platform.encode(e,t)}function ts(e,t="utf-8"){return t=t||"utf-8",et().platform.decode(e,t)}var ns=class{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new as)}profileKernel(e,t,n){let r,a,s=()=>{r=n()},i=Ja();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(let e of r)e.dataSync();a=Promise.resolve({kernelMs:Ja()-i})}if(et().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<r.length;o++){let t=r[o];t.data().then((n=>{rs(n,t.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then((e=>e.kernelMs)),extraInfo:a.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:r,inputs:a,extraInfo:s}=e;n.forEach((e=>{Promise.all([e.data(),r,s]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],a,n[2])}))}))}};function rs(e,t,n){if("float32"!==t)return!1;for(let r=0;r<e.length;r++){let t=e[r];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${n}'`),!0}return!1}var as=class{logKernelProfile(e,t,n,r,a,s){let i="number"==typeof r?xe(`${r}ms`,9):r.error,o=xe(e,25),l=t.rank,u=t.size,p=xe(t.shape.toString(),14),d="";for(let c in a){let e=a[c];if(null!=e){let n=e.shape||t.shape,r=n.length;d+=`${c}: ${r}D ${r>0?n:""} `}}console.log(`%c${o}\t%c${i}\t%c${l}D ${p}\t%c${u}\t%c${d}\t%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function ss(e,t,n){let r={},a={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){let n=e[l],s=n.inputs;for(let e in s){let i=s[e],o=!1;for(let e=0;e<t.length;e++)if(r[i.id]){n.outputs.forEach((e=>r[e.id]=!0)),o=!0,a[n.id]=!0;break}if(o)break}}let s={};s[n.id]=!0;let i={};for(let l=e.length-1;l>=0;l--){let t=e[l],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(s[t.outputs[e].id]){for(let e in n)s[n[e].id]=!0,i[t.id]=!0;break}}let o=[];for(let l=0;l<e.length;l++){let t=e[l];if(a[t.id]&&i[t.id]){let e={};for(let a in t.inputs){let n=t.inputs[a];r[n.id]&&(e[a]=n)}let n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,o.push(n)}}return o}function is(e,t,n,r){for(let a=t.length-1;a>=0;a--){let s=t[a],i=[];if(s.outputs.forEach((t=>{let n=e[t.id];null!=n?i.push(n):i.push(null)})),null==s.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let o=s.gradient(i);for(let t in s.inputs){if(!(t in o))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);let a=n((()=>o[t]()));if("float32"!==a.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${a.dtype}'`);let i=s.inputs[t];if(!me(a.shape,i.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${t}' has shape '${a.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=a;else{let t=e[i.id];e[i.id]=r(t,a),t.dispose()}}}}var os=20,ls=3,us=7;function ps(e,t,n,r){let a=ze(t),s=ds(e,t,n,a),i=t.length,o=fs(e,t,n,a,s),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map((e=>"    "+e)).join("\n")),l.join("\n")}function ds(e,t,n,r){let a=he(t),s=r[r.length-1],i=new Array(s).fill(0),o=t.length,l="complex64"===n?ms(e):e;if(o>1)for(let u=0;u<a/s;u++){let e=u*s;for(let t=0;t<s;t++)i[t]=Math.max(i[t],cs(l[e+t],0,n).length)}return i}function cs(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(us))} + ${parseFloat(e[1].toFixed(us))}j`:Re(e)?`'${e}'`:"bool"===n?hs(e):parseFloat(e.toFixed(us)).toString(),xe(r,t)}function hs(e){return 0===e?"false":"true"}function fs(e,t,n,r,a,s=!0){let i="complex64"===n?2:1,o=t[0],l=t.length;if(0===l){if("complex64"===n){let t=ms(e);return[cs(t[0],0,n)]}return"bool"===n?[hs(e[0])]:[e[0].toString()]}if(1===l){if(o>os){let t=ls*i,r=Array.from(e.slice(0,t)),s=Array.from(e.slice((o-ls)*i,o*i));return"complex64"===n&&(r=ms(r),s=ms(s)),["["+r.map(((e,t)=>cs(e,a[t],n))).join(", ")+", ..., "+s.map(((e,t)=>cs(e,a[o-ls+t],n))).join(", ")+"]"]}let t="complex64"===n?ms(e):Array.from(e);return["["+t.map(((e,t)=>cs(e,a[t],n))).join(", ")+"]"]}let u=t.slice(1),p=r.slice(1),d=r[0]*i,c=[];if(o>os){for(let t=0;t<ls;t++){let r=t*d,s=r+d;c.push(...fs(e.slice(r,s),u,n,p,a,!1))}c.push("...");for(let t=o-ls;t<o;t++){let r=t*d,s=r+d;c.push(...fs(e.slice(r,s),u,n,p,a,t===o-1))}}else for(let m=0;m<o;m++){let t=m*d,r=t+d;c.push(...fs(e.slice(t,r),u,n,p,a,m===o-1))}let h=2===l?",":"";c[0]="["+c[0]+h;for(let m=1;m<c.length-1;m++)c[m]=" "+c[m]+h;let f=",\n";for(let m=2;m<l;m++)f+="\n";return c[c.length-1]=" "+c[c.length-1]+"]"+(s?"":f),c}function ms(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var gs=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=he(e),null!=n){let e=n.length;ue(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||Te(t,this.size),this.strides=ze(e)}set(e,...t){0===t.length&&(t=[0]),ue(t.length===this.rank,(()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`));let n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(let r of e){if(r<0||r>=this.shape[t]){let t=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(t)}t++}let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return ys().makeTensor(this.values,this.shape,this.dtype)}},ys=null,bs=null;function ws(e){ys=e}function xs(e){bs=e}function vs(e){e}var ks=class{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=he(e),this.strides=ze(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return bs.buffer(this.shape,this.dtype,e)}bufferSync(){return bs.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return We(this.shape,e,"complex64"===this.dtype)}arraySync(){return We(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();let e=ys().read(this.dataId);if("string"===this.dtype){let n=await e;try{return n.map((e=>ts(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),ys().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=ys().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>ts(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await ys().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(ys().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return bs.print(this,e)}clone(){return this.throwIfDisposed(),bs.clone(this)}toString(e=!1){let t=this.dataSync();return ps(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),bs.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),ys().makeVariable(this,e,t,n)}};function Is(){return it("Tensor",(()=>ks))}Object.defineProperty(ks,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),Is();var Ss=class extends ks{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!me(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);ys().disposeTensor(this),this.dataId=e.dataId,ys().incRef(this,null)}dispose(){ys().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(Ss,Symbol.hasInstance,{value:e=>e instanceof ks&&null!=e.assign&&e.assign instanceof Function});var Ns,Ts,Cs,_s,Es,As={};v(As,{assertTypesMatch:()=>Ms,getTensorsInContainer:()=>Ls,isTensorInList:()=>Os,makeTypesMatch:()=>Ds}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(Ns||(Ns={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(Ts||(Ts={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(Cs||(Cs={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(_s||(_s={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(Es||(Es={}));var $s={float32:_s,int32:Ts,bool:Cs,complex64:Es};function Fs(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return $s[e][t]}function Rs(e){return Fs(e,"int32")}function Ds(e,t){if(e.dtype===t.dtype)return[e,t];let n=Fs(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function Ms(e,t){ue(e.dtype===t.dtype,(()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`))}function Os(e,t){return t.some((t=>t.id===e.id))}function Ls(e){let t=[];return Ps(e,t,new Set),t}function Ps(e,t,n){if(null==e)return;if(e instanceof ks)return void t.push(e);if(!zs(e))return;let r=e;for(let a in r){let e=r[a];n.has(e)||(n.add(e),Ps(e,t,n))}}function zs(e){return Array.isArray(e)||"object"==typeof e}function Bs(e){return null!=e.kernelName}var Ws=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},Vs=class{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Ws}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){let{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{let{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(ya(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;let{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new ns(this.backendInstance),!0}setupRegisteredKernels(){Ia(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){Ia(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){let t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{let n=t.factory();if(!n||n instanceof Q||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{let t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,ya(`Initialization of backend ${e} failed`),ya(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(n){return ya(`Initialization of backend ${e} failed`),ya(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t],{success:r,asyncInit:a}=this.initializeBackend(n);if(a||r)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){let n=this.state.tensorInfo.get(t),r=n.backend,a=this.readSync(t),s=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,a,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{let e=n();return t(),e}catch(r){throw t(),r}}nextTensorId(){return Vs.nextTensorId++}nextVariableId(){return Vs.nextVariableId++}clone(e){let t=Hs.runKernel(kn,{x:e}),n={x:e},r=e=>({x:()=>{let t="float32",n={x:e},r={dtype:t};return Hs.runKernel(At,n,r)}}),a=[];return this.addTapeNode(this.state.activeScope.name,n,[t],r,a,{}),t}runKernel(e,t,n){if(null==this.backendName&&this.backend,null==va(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){let r=this.backend.numDataIds(),a=0;n.forEach((e=>{a+="complex64"===e.dtype?3:1}));let s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-a-s;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n,r=[],a=this.isTapeOn(),s=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;let o,l=Bs(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Bs(e)){let{kernelName:t,inputs:s,attrs:i}=e;null==this.backendName&&this.backend;let l=va(t,this.backendName);ue(null!=l,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),n=()=>{let e=this.backend.numDataIds();o=l.kernelFunc({inputs:s,attrs:i,backend:this.backend});let n=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,n);let u=n.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(a){let e=this.getTensorsForGradient(t,s,u);r=this.saveTensorsForBackwardMode(e)}return u}}else{let{forwardFunc:t}=e,s=e=>{!a||(r=e.map((e=>this.keep(this.clone(e)))))};n=()=>{let e=this.backend.numDataIds();o=this.tidy((()=>t(this.backend,s)));let n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,e,n),n}}let u,{inputs:p,attrs:d}=e,c=Bs(e)?null:e.backwardsFunc;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(u=this.profiler.profileKernel(l,p,(()=>n())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(u),t=u.outputs):t=n()})),a&&this.addTapeNode(l,p,t,c,r,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(p).map((e=>null!=p[e]?p[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:u.timeMs,extraInfo:u.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){return e.map((e=>this.keep(this.clone(e))))}getTensorsForGradient(e,t,n){let r=ka(e);if(null!=r){let e,a=r.inputsToSave||[],s=r.outputsToSave||[];r.saveAllInputs?(ue(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),e=Object.keys(t).map((e=>t[e]))):e=a.map((e=>t[e]));let i=n.filter(((e,t)=>s[t]));return e.concat(i)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let a=e;"string"===n&&Re(e[0])&&(a=e.map((e=>es(e))));let s=r.write(a,t,n),i=new ks(t,n,s,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){let e=this.state.tensorInfo.get(s),t=Fe(a);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){n=n||"float32";let a={dataId:e,shape:t,dtype:n};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(e,t){let{dataId:n,shape:r,dtype:a}=e,s=new ks(r,a,n,this.nextTensorId());return this.trackTensor(s,t),s}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));let a=new Ss(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[a.name])throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*$e(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof Ss||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){let t=e.size*$e(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;let t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,a,s){let i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:a},o=ka(e);null!=o&&(r=o.gradFunc),null!=r&&(i.gradient=e=>(e=e.map(((e,t)=>{if(null==e){let e=n[t],r=Ue(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],a,s))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){let t=Ls(e),n=new Set(t.map((e=>e.id)));for(let a=0;a<this.state.activeScope.track.length;a++){let e=this.state.activeScope.track[a];!e.kept&&!n.has(e.id)&&e.dispose()}let r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{!e.kept&&e.scopeId===r.id&&this.track(e)}))}gradients(e,t,n,r=!1){if(ue(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let a=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));ue(a instanceof ks,(()=>"The result y returned by f() must be a tensor."));let s=ss(this.state.activeTape,t,a);if(!r&&0===s.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{let e={};e[a.id]=null==n?Us(a.shape):n,is(e,s,(e=>this.tidy(e)),js);let r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(let t of e.saved)t.dispose()})),this.state.activeTape=null),{value:a,grads:r}}))}customGrad(e){return ue(Le(e),(()=>"The f passed in customGrad(f) must be a function.")),(...t)=>{ue(t.every((e=>e instanceof ks)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));let n,r={};t.forEach(((e,t)=>{r[t]=e}));let a=(r,a)=>(n=e(...t,a),ue(n.value instanceof ks,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),ue(Le(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),s=(e,r)=>{let a=n.gradFunc(e,r),s=Array.isArray(a)?a:[a];ue(s.length===t.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),ue(s.every((e=>e instanceof ks)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));let i={};return s.forEach(((e,t)=>{i[t]=()=>e})),i};return this.runKernelFunc({forwardFunc:a,backwardsFunc:s,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){let t=Ja(),n=await this.backend.time(e);return n.wallMs=Ja()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Ws;for(let e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};function Us(e){let t=Ve(he(e),"float32");return Hs.makeTensor(t,e,"float32")}function Gs(){let e=at();if(null==e._tfengine){let t=new Ye(e);e._tfengine=new Vs(t)}return rt(e._tfengine.ENV),ws((()=>e._tfengine)),e._tfengine}Vs.nextTensorId=0,Vs.nextVariableId=0;var Hs=Gs();function js(e,t){let n={a:e,b:t};return Hs.runKernel(pt,n)}var qs,Ks={};function Xs(){return"undefined"!=typeof navigator&&null!=navigator}function Ys(e){qs=e}function Zs(e){if(void 0!==qs)return qs;if(e||Xs()){if(e||(e=navigator),"ReactNative"===e.product)return!0;let t=e.userAgent||e.vendor||("undefined"!=typeof window?window.opera:"");if(!t){let t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function Js(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}v(Ks,{isBrowser:()=>Js,isMobile:()=>Zs,mockIsMobile:()=>Ys});var Qs=et();function ei(e,t){let n=e;if(Ae(e))return"string"===t?[]:[e.length];if(!Array.isArray(e))return[];let r=[];for(;Array.isArray(n)||Ae(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&et().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&ti(e,r,[]),r}function ti(e,t,n){if(n=n||[],!Array.isArray(e)&&!Ae(e))return void ue(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));ue(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),ue(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));let r=t.slice(1);for(let a=0;a<e.length;++a)ti(e[a],r,n.concat(a))}function ni(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function ri(e,t,n,r="numeric"){if(e instanceof ks)return ni(r,e.dtype,t,n),e;let a=Oe(e);if("string"!==a&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),ni(r,a,t,n),null==e||!Ae(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){let r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}let s=ei(e,a);!Ae(e)&&!Array.isArray(e)&&(e=[e]);let i="string"!==a?Za(e,a):ce(e,[],!0);return Hs.makeTensor(i,s,a)}function ai(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,a)=>ri(e,`${t}[${a}]`,n,r)))}Qs.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),Qs.registerFlag("IS_BROWSER",(()=>Js())),Qs.registerFlag("IS_NODE",(()=>"undefined"!=typeof process&&"undefined"!=typeof process.versions&&"undefined"!=typeof process.versions.node)),Qs.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),Qs.registerFlag("PROD",(()=>!1)),Qs.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>Qs.getBool("DEBUG"))),Qs.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),Qs.registerFlag("IS_TEST",(()=>!1)),Qs.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>!0)),Qs.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),Qs.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));var si="__op";function ii(e){let t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=si;let a=(...e)=>{Hs.startScope(n);try{let t=r(...e);return Ke(t)&&console.error("Cannot return a Promise inside of tidy."),Hs.endScope(t),t}catch(t){throw Hs.endScope(null),t}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}function oi(e,t){let n=ri(e,"real","complex"),r=ri(t,"imag","complex");pe(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);let a={real:n,imag:r};return Hs.runKernel(Rt,a)}var li=ii({complex_:oi});function ui(e,t,n,r){if(null==r&&(r=Oe(e)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Ae(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){He(t);let e=he(t),r=he(n);ue(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let a=0;a<n.length;++a){let e=n[a],r=a!==n.length-1||e!==he(t.slice(a));ue(n[a]===t[a]||!r,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return!Ae(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e="string"!==r?Za(e,r):ce(e,[],!0),Hs.makeTensor(e,t,r)}function pi(e,t,n){let r=ei(e,n);return ui(e,t,r,n)}var di={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},ci=4;async function hi(e,t){let n=[],r=[],a=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let i=0;i<a.length;++i){let s=a[i],o=Array.isArray(e)?e[i].tensor:e[s];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${s}': ${o.dtype}`);let l={name:s,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){let e=new Promise((async e=>{let t=await o.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+ci*t.length,r=new Uint8Array(n),a=0;for(let s=0;s<t.length;s++){let e=t[s],n=new Uint8Array(new Uint32Array([e.length]).buffer);r.set(n,a),a+=ci,r.set(e,a),a+=e.length}e(r)}));r.push(e)}else r.push(o.data());null!=t&&(l.group=t),n.push(l)}let s=await Promise.all(r);return{data:mi(s),specs:n}}function fi(e,t){let n,r={},a=0;for(let s of t){let t,i=s.name,o=s.dtype,l=s.shape,u=he(l);if("quantization"in s){let r=s.quantization;if("uint8"===r.dtype||"uint16"===r.dtype){if(!("min"in r)||!("scale"in r))throw new Error(`Weight ${s.name} with quantization ${r.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==r.dtype)throw new Error(`Weight ${s.name} has unknown quantization dtype ${r.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==o)throw new Error(`Weight ${s.name} is quantized with ${r.dtype} which only supports weights of type float32 not ${o}.`)}let l=di[r.dtype],p=e.slice(a,a+u*l),d="uint8"===r.dtype?new Uint8Array(p):new Uint16Array(p);if("float32"===o)if("uint8"===r.dtype||"uint16"===r.dtype){t=new Float32Array(d.length);for(let e=0;e<d.length;e++){let n=d[e];t[e]=n*r.scale+r.min}}else{if("float16"!==r.dtype)throw new Error(`Unsupported quantization type ${r.dtype} for weight type float32.`);void 0===n&&(n=_i()),t=n(d)}else{if("int32"!==o)throw new Error(`Unsupported dtype in weight '${i}': ${o}`);if("uint8"!==r.dtype&&"uint16"!==r.dtype)throw new Error(`Unsupported quantization type ${r.dtype} for weight type int32.`);t=new Int32Array(d.length);for(let e=0;e<d.length;e++){let n=d[e];t[e]=Math.round(n*r.scale+r.min)}}a+=u*l}else if("string"===o){let n=he(s.shape);t=[];for(let r=0;r<n;r++){let n=new Uint32Array(e.slice(a,a+ci))[0];a+=ci;let r=new Uint8Array(e.slice(a,a+n));t.push(r),a+=n}}else{let n=di[o],s=e.slice(a,a+u*n);if("float32"===o)t=new Float32Array(s);else if("int32"===o)t=new Int32Array(s);else if("bool"===o)t=new Uint8Array(s);else{if("complex64"!==o)throw new Error(`Unsupported dtype in weight '${i}': ${o}`);{t=new Float32Array(s);let e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let r=0;r<e.length;r++)e[r]=t[2*r],n[r]=t[2*r+1];let a=pi(e,l,"float32"),o=pi(n,l,"float32");r[i]=li(a,o),a.dispose(),o.dispose()}}a+=u*n}"complex64"!==o&&(r[i]=pi(t,l,o))}return r}function mi(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));let r=new Uint8Array(t),a=0;return n.forEach((e=>{r.set(new Uint8Array(e.buffer),a),a+=e.byteLength})),r.buffer}var gi="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function yi(e){return gi?Buffer.byteLength(e):new Blob([e]).size}function bi(e){if(gi)return Buffer.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let r=0,a=t.length;r<a;r++)n+=String.fromCharCode(t[r]);return btoa(n)}function wi(e){if(gi){let t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}function xi(e){if(1===e.length)return e[0];let t=0;e.forEach((e=>{t+=e.byteLength}));let n=new Uint8Array(t),r=0;return e.forEach((e=>{n.set(new Uint8Array(e),r),r+=e.byteLength})),n.buffer}function vi(e){let t="/";for(e=e.trim();e.endsWith(t);)e=e.slice(0,e.length-1);let n=e.split(t);return n[n.length-1]}function ki(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}async function Ii(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),null!=e.weightsManifest){let[r,a]=await t(e.weightsManifest);n.weightSpecs=r,n.weightData=a}return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),n}function Si(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:yi(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:yi(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:e.weightData.byteLength}}function Ni(){let e=e=>{let t=e<<13,n=0;for(;0===(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function Ti(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function Ci(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function _i(){let e=Ni(),t=Ti(),n=Ci();return r=>{let a=new ArrayBuffer(4*r.length),s=new Uint32Array(a);for(let i=0;i<r.length;i++){let a=r[i],o=e[n[a>>10]+(1023&a)]+t[a>>10];s[i]=o}return new Float32Array(a)}}var Ei=class{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Ei.instance&&(Ei.instance=new Ei),Ei.instance}static registerSaveRouter(e){Ei.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Ei.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Ei.getHandlers(e,"save")}static getLoadHandlers(e,t){return Ei.getHandlers(e,"load",t)}static getHandlers(e,t,n){let r=[];return("load"===t?Ei.getInstance().loadRouters:Ei.getInstance().saveRouters).forEach((t=>{let a=t(e,n);null!==a&&r.push(a)})),r}},Ai=e=>Ei.registerSaveRouter(e),$i=e=>Ei.registerLoadRouter(e),Fi=e=>Ei.getSaveHandlers(e),Ri=(e,t)=>Ei.getLoadHandlers(e,t),Di="tensorflowjs",Mi=1,Oi="models_store",Li="model_info_store";function Pi(){if(!et().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function zi(e){let t=e.result;t.createObjectStore(Oi,{keyPath:"modelPath"}),t.createObjectStore(Li,{keyPath:"modelPath"})}var Bi=class{constructor(e){if(this.indexedDB=Pi(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{let r=this.indexedDB.open(Di,Mi);r.onupgradeneeded=()=>zi(r),r.onsuccess=()=>{let a=r.result;if(null==t){let t=a.transaction(Oi,"readonly"),r=t.objectStore(Oi).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return a.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(a.close(),n(r.error)),t.oncomplete=()=>a.close()}else{let r,s=Si(t),i=a.transaction(Li,"readwrite"),o=i.objectStore(Li),l=o.put({modelPath:this.modelPath,modelArtifactsInfo:s});l.onsuccess=()=>{r=a.transaction(Oi,"readwrite");let l=r.objectStore(Oi).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:s});l.onsuccess=()=>e({modelArtifactsInfo:s}),l.onerror=e=>{o=i.objectStore(Li);let t=o.delete(this.modelPath);t.onsuccess=()=>(a.close(),n(l.error)),t.onerror=e=>(a.close(),n(l.error))}},l.onerror=e=>(a.close(),n(l.error)),i.oncomplete=()=>{null==r?a.close():r.oncomplete=()=>a.close()}}},r.onerror=e=>n(r.error)}))}};Bi.URL_SCHEME="indexeddb://";var Wi=e=>et().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Bi.URL_SCHEME)?Vi(e.slice(Bi.URL_SCHEME.length)):null;function Vi(e){return new Bi(e)}function Ui(e){return e.startsWith(Bi.URL_SCHEME)?e.slice(Bi.URL_SCHEME.length):e}Ei.registerSaveRouter(Wi),Ei.registerLoadRouter(Wi);var Gi=class{constructor(){this.indexedDB=Pi()}async listModels(){return new Promise(((e,t)=>{let n=this.indexedDB.open(Di,Mi);n.onupgradeneeded=()=>zi(n),n.onsuccess=()=>{let r=n.result,a=r.transaction(Li,"readonly"),s=a.objectStore(Li).getAll();s.onsuccess=()=>{let t={};for(let e of s.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},s.onerror=e=>(r.close(),t(s.error)),a.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){return e=Ui(e),new Promise(((t,n)=>{let r=this.indexedDB.open(Di,Mi);r.onupgradeneeded=()=>zi(r),r.onsuccess=()=>{let a,s=r.result,i=s.transaction(Li,"readwrite"),o=i.objectStore(Li),l=o.get(e);l.onsuccess=()=>{if(null==l.result)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let r=o.delete(e),i=()=>{a=s.transaction(Oi,"readwrite");let r=a.objectStore(Oi).delete(e);r.onsuccess=()=>t(l.result.modelArtifactsInfo),r.onerror=e=>n(l.error)};r.onsuccess=i,r.onerror=e=>(i(),s.close(),n(l.error))}},l.onerror=e=>(s.close(),n(l.error)),i.oncomplete=()=>{null==a?s.close():a.oncomplete=()=>s.close()}},r.onerror=e=>n(r.error)}))}},Hi="/",ji="tensorflowjs_models",qi="info",Ki="model_topology",Xi="weight_specs",Yi="weight_data",Zi="model_metadata";function Ji(e){return{info:[ji,e,qi].join(Hi),topology:[ji,e,Ki].join(Hi),weightSpecs:[ji,e,Xi].join(Hi),weightData:[ji,e,Yi].join(Hi),modelMetadata:[ji,e,Zi].join(Hi)}}function Qi(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function eo(e){let t=e.split(Hi);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(Hi)}function to(e){return e.startsWith(no.URL_SCHEME)?e.slice(no.URL_SCHEME.length):e}var no=class{constructor(e){if(!et().getBool("IS_BROWSER")||"undefined"==typeof window||"undefined"==typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Ji(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),a=Si(e);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,bi(e.weightData));let t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:a}}catch(t){throw Qi(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;let a=this.LS.getItem(this.keys.modelMetadata);if(null!=a){let e=JSON.parse(a);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}let s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=wi(s),t}};no.URL_SCHEME="localstorage://";var ro=e=>et().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(no.URL_SCHEME)?ao(e.slice(no.URL_SCHEME.length)):null;function ao(e){return new no(e)}Ei.registerSaveRouter(ro),Ei.registerLoadRouter(ro);var so=class{constructor(){ue(et().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),ue("undefined"==typeof window||"undefined"!=typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){let e={},t=ji+Hi,n=Hi+qi;for(let r=0;r<this.LS.length;++r){let a=this.LS.key(r);if(a.startsWith(t)&&a.endsWith(n)){let t=eo(a);e[t]=JSON.parse(this.LS.getItem(a))}}return e}async removeModel(e){e=to(e);let t=Ji(e);if(null==this.LS.getItem(t.info))throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return Qi(t),n}},io="://",oo=class{constructor(){this.managers={}}static getInstance(){return null==oo.instance&&(oo.instance=new oo),oo.instance}static registerManager(e,t){ue(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(io)&&(e=e.slice(0,e.indexOf(io))),ue(e.length>0,(()=>"scheme must not be an empty string."));let n=oo.getInstance();ue(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){let t=this.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}};function lo(e){if(-1===e.indexOf(io))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${oo.getSchemes().join(",")}`);return{scheme:e.split(io)[0],path:e.split(io)[1]}}async function uo(e,t,n=!1){ue(e!==t,(()=>`Old path and new path are the same: '${e}'`));let r=Ei.getLoadHandlers(e);ue(r.length>0,(()=>`Copying failed because no load handler is found for source URL ${e}.`)),ue(r.length<2,(()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`));let a=r[0],s=Ei.getSaveHandlers(t);ue(s.length>0,(()=>`Copying failed because no save handler is found for destination URL ${t}.`)),ue(s.length<2,(()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`));let i=s[0],o=lo(e).scheme,l=lo(e).path,u=o===lo(e).scheme,p=await a.load();n&&u&&await oo.getManager(o).removeModel(l);let d=await i.save(p);return n&&!u&&await oo.getManager(o).removeModel(l),d.modelArtifactsInfo}async function po(){let e=oo.getSchemes(),t={};for(let n of e){let e=await oo.getManager(n).listModels();for(let r in e){let a=n+io+r;t[a]=e[r]}}return t}async function co(e){let t=lo(e);return oo.getManager(t.scheme).removeModel(t.path)}async function ho(e,t){return uo(e,t,!1)}async function fo(e,t){return uo(e,t,!0)}var mo=class{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}};if(et().get("IS_BROWSER")){et().setPlatform("browser",new mo);try{oo.registerManager(no.URL_SCHEME,new so)}catch(pae){}try{oo.registerManager(Bi.URL_SCHEME,new Gi)}catch(pae){}}var go,yo={importFetch:()=>N()},bo=class{constructor(){this.util=T(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=et().global.fetch?et().global.fetch(e,t):(null==go&&(go=yo.importFetch()),go(e,t))}now(){let e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}};function wo(e,t="float32",n){return t=t||"float32",He(e),new gs(e,t,n)}function xo(e,t){let n=ri(e,"x","cast");if(!_e(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");let r={x:n},a={dtype:t};return Hs.runKernel(At,r,a)}et().get("IS_NODE")&&!et().get("IS_BROWSER")&&et().setPlatform("node",new bo);var vo=ii({cast_:xo});function ko(e){let t={x:ri(e,"x","clone","string_or_numeric")};return Hs.runKernel(kn,t)}var Io=ii({clone_:ko});function So(e,t=!1){console.log(e.toString(t))}Gs();var No={buffer:wo,cast:vo,clone:Io,print:So};xs(No);var To={};v(To,{browserFiles:()=>Mo,browserHTTPRequest:()=>qo,concatenateArrayBuffers:()=>xi,copyModel:()=>ho,decodeWeights:()=>fi,encodeWeights:()=>hi,fromMemory:()=>Zo,fromMemorySync:()=>Jo,getLoadHandlers:()=>Ri,getModelArtifactsForJSON:()=>Ii,getModelArtifactsInfoForJSON:()=>Si,getSaveHandlers:()=>Fi,http:()=>jo,isHTTPScheme:()=>Go,listModels:()=>po,loadWeights:()=>Po,moveModel:()=>fo,registerLoadRouter:()=>$i,registerSaveRouter:()=>Ai,removeModel:()=>co,weightsLoaderFactory:()=>zo,withSaveHandler:()=>Qo,withSaveHandlerSync:()=>el});var Co="model",_o=".json",Eo=".weights.bin";function Ao(e){return new Promise((e=>setTimeout(e))).then(e)}var $o=class{constructor(e){if(!et().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith($o.URL_SCHEME)&&(e=e.slice($o.URL_SCHEME.length)),(null==e||0===e.length)&&(e=Co),this.modelJsonFileName=e+_o,this.weightDataFileName=e+Eo}async save(e){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");let t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let n=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],r=ki(e,n),a=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),s=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(s.download=this.modelJsonFileName,s.href=a,await Ao((()=>s.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){let e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=t,await Ao((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:Si(e)}}}};$o.URL_SCHEME="downloads://";var Fo=class{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise(((e,t)=>{let n=new FileReader;n.onload=n=>{let r=JSON.parse(n.target.result),a=r.modelTopology;if(null==a)return void t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==r.weightsManifest)return void t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void e({modelTopology:a});let s=Ii(r,(e=>this.loadWeights(e)));e(s)},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)}))}loadWeights(e){let t=[],n=[];for(let s of e)t.push(...s.weights),n.push(...s.paths);let r=this.checkManifestAndWeightFiles(e),a=n.map((e=>this.loadWeightsFile(e,r[e])));return Promise.all(a).then((e=>[t,xi(e)]))}loadWeightsFile(e,t){return new Promise(((n,r)=>{let a=new FileReader;a.onload=e=>{let t=e.target.result;n(t)},a.onerror=t=>r(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(t)}))}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map((e=>vi(e.name))),r={};for(let a of e)a.paths.forEach((e=>{let a=vi(e);if(-1!==t.indexOf(a))throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),-1===n.indexOf(a))throw new Error(`Weight file with basename '${a}' is not provided.`);r[e]=this.weightsFiles[n.indexOf(a)]}));if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}},Ro=e=>et().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith($o.URL_SCHEME)?Do(e.slice($o.URL_SCHEME.length)):null;function Do(e="model"){return new $o(e)}function Mo(e){return new Fo(e)}function Oo(e,t,n,r){i(e),n=null==n?0:n,r=null==r?1:r,o(n,r);let a=0,s=s=>(s.then((s=>{let i=n+ ++a/e.length*(r-n);return t(i),s})),s);function i(e){ue(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}function o(e,t){ue(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),ue(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),ue(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}return Promise.all(e.map(s))}async function Lo(e,t){null==t&&(t={});let n=null==t.fetchFunc?et().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),a=0,s=.5,i=(null==t.onProgress?await Promise.all(r):await Oo(r,t.onProgress,a,s)).map((e=>e.arrayBuffer())),o=.5,l=1;return null==t.onProgress?await Promise.all(i):await Oo(i,t.onProgress,o,l)}async function Po(e,t="",n,r){return zo((e=>Lo(e,{requestInit:r})))(e,t,n)}function zo(e){return async(t,n="",r)=>{let a=t.map((()=>!1)),s={},i=null!=r?r.map((()=>!1)):[],o=[];if(t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{let l="quantization"in e?e.quantization.dtype:e.dtype,u=di[l]*he(e.shape),p=()=>{a[t]=!0,null==s[t]&&(s[t]=[]),s[t].push({manifestEntry:e,groupOffset:n,sizeBytes:u})};null!=r?r.forEach(((t,n)=>{t===e.name&&(p(),i[n]=!0)})):p(),o.push(e.name),n+=u}))})),!i.every((e=>e))){let e=r.filter(((e,t)=>!i[t]));throw new Error(`Could not find weights in manifest with names: ${e.join(", ")}. \nManifest JSON has weights with names: ${o.join(", ")}.`)}let l=a.reduce(((e,t,n)=>(t&&e.push(n),e)),[]),u=[];l.forEach((e=>{t[e].paths.forEach((e=>{let t=n+(n.endsWith("/")?"":"/")+e;u.push(t)}))}));let p=await e(u),d={},c=0;return l.forEach((e=>{let n=t[e].paths.length,r=0;for(let t=0;t<n;t++)r+=p[c+t].byteLength;let a=new ArrayBuffer(r),i=new Uint8Array(a),o=0;for(let t=0;t<n;t++){let e=new Uint8Array(p[c+t]);i.set(e,o),o+=e.byteLength}s[e].forEach((e=>{let t=a.slice(e.groupOffset,e.groupOffset+e.sizeBytes),n=fi(t,[e.manifestEntry]);for(let r in n)d[r]=n[r]})),c+=n})),d}}Ei.registerSaveRouter(Ro);var Bo="application/octet-stream",Wo="application/json",Vo=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(ue("function"==typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=et().platform.fetch,ue(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&ue(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=ki(e,n);t.body.append("model.json",new Blob([JSON.stringify(r)],{type:Wo}),"model.json"),null!=e.weightData&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:Bo}),"model.weights.bin");let a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:Si(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async load(){let e,t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);try{e=await t.json()}catch(a){let e=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}let n=e.modelTopology,r=e.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return Ii(e,(e=>this.loadWeights(e)))}async loadWeights(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=Uo(t),a=this.weightPathPrefix||n,s=[];for(let u of e)s.push(...u.weights);let i=[],o=[];for(let u of e)for(let e of u.paths)null!=this.weightUrlConverter?o.push(this.weightUrlConverter(e)):i.push(a+e+r);this.weightUrlConverter&&i.push(...await Promise.all(o));let l=await Lo(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[s,xi(l)]}};function Uo(e){let t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),a=n>t?e.substring(n):"";return[r+"/",a]}function Go(e){return null!=e.match(Vo.URL_SCHEME_REGEX)}Vo.URL_SCHEME_REGEX=/^https?:\/\//;var Ho=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>Go(e))):Go(e),n)return jo(e,t)}return null};function jo(e,t){return new Vo(e,t)}function qo(e,t){return jo(e,t)}Ei.registerSaveRouter(Ho),Ei.registerLoadRouter(Ho);var Ko=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},Xo=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},Yo=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function Zo(e,t,n,r){let a=arguments;return new Yo(Jo(...a))}function Jo(e,t,n,r){return 1===arguments.length?null!=e.modelTopology||null!=e.weightSpecs?new Ko(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Ko({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Ko({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r}))}function Qo(e){return new Xo(e)}function el(e){return new Xo(e)}var tl={};function nl(e,t,n=!1,r=!1){let a=ri(e,"a","matMul"),s=ri(t,"b","matMul");[a,s]=Ds(a,s);let i={a:a,b:s},o={transposeA:n,transposeB:r};return Hs.runKernel(Nt,i,o)}v(tl,{confusionMatrix:()=>Ol});var rl=ii({matMul_:nl});function al(e,t,n=1,r=0){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let a={indices:ri(e,"indices","oneHot","int32")},s={depth:t,onValue:n,offValue:r};return Hs.runKernel(or,a,s)}var sl=ii({oneHot_:al});function il(){et().set("PROD",!0)}function ol(){et().set("DEBUG",!0)}function ll(){et().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function ul(e){et().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function pl(){Hs.disposeVariables()}function dl(){return Hs}function cl(){return Hs.memory()}function hl(e){return Hs.profile(e)}function fl(e,t){return Hs.tidy(e,t)}function ml(e){Ls(e).forEach((e=>e.dispose()))}function gl(e){return Hs.keep(e)}function yl(e){return Hs.time(e)}function bl(e){return Hs.setBackend(e)}function wl(){return Hs.ready()}function xl(){return Hs.backendName}function vl(e){Hs.removeBackend(e)}function kl(e){return Hs.findBackend(e)}function Il(e){return Hs.findBackendFactory(e)}function Sl(e,t,n=1){return Hs.registerBackend(e,t,n)}function Nl(){return Hs.backend}function Tl(e,t){et().setPlatform(e,t)}function Cl(e){let t={input:ri(e,"input","imag")};return Hs.runKernel(Sn,t)}vs(ul);var _l=ii({imag_:Cl});function El(e){let t={x:ri(e,"x","neg")};return Hs.runKernel(tr,t)}var Al=ii({neg_:El});function $l(e){let t={input:ri(e,"input","real")};return Hs.runKernel(mr,t)}var Fl=ii({real_:$l});function Rl(e,t,n){let r=ri(e,"x","transpose");if(null==t&&(t=r.shape.map(((e,t)=>t)).reverse()),ue(r.rank===t.length,(()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`)),t.forEach((e=>{ue(e>=0&&e<r.rank,(()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`))})),r.rank<=1)return r.clone();let a={x:r},s={perm:t};return"complex64"===r.dtype?fl((()=>{let e=Fl(r),t=_l(r);return e=Hs.runKernel(sa,{x:e},s),t=Hs.runKernel(sa,{x:t},s),n&&(t=Al(t)),li(e,t)})):Hs.runKernel(sa,a,s)}var Dl=ii({transpose_:Rl});function Ml(e,t,n){let r=ri(e,"labels","confusionMatrix"),a=ri(t,"predictions","confusionMatrix");ue(null==n||n>0&&Number.isInteger(n),(()=>`If provided, numClasses must be a positive integer, but got ${n}`)),ue(1===r.rank,(()=>`Expected the rank of labels to be 1, but got ${r.rank}`)),ue(1===a.rank,(()=>`Expected the rank of predictions to be 1, but got ${a.rank}`)),ue(r.shape[0]===a.shape[0],(()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${a.shape[0]}. Labels and predictions should have the same number of elements.`)),ue(n>0&&Number.isInteger(n),(()=>`numClasses is required to be a positive integer, but got ${n}`));let s=sl(vo(r,"int32"),n),i=sl(vo(a,"int32"),n),o=Dl(s),l=rl(o,i);return vo(l,"int32")}var Ol=ii({confusionMatrix_:Ml}),Ll={};function Pl(e,t){let n=e.length,r=[];for(let a=0;a<n;a++){let s=n-1-a,i=e[s]||1;(t[t.length-1-a]||1)>1&&1===i&&r.unshift(s)}return r}function zl(e,t){let n=[];for(let r=0;r<t.length;r++){let a=e[e.length-r-1],s=t.length-r-1,i=t[s];(null==a||1===a&&i>1)&&n.unshift(s)}return n}function Bl(e,t){let n=[],r=Math.max(e.length,t.length);for(let a=0;a<r;a++){let r=e[e.length-a-1];null==r&&(r=1);let s=t[t.length-a-1];if(null==s&&(s=1),1===r)n.unshift(s);else if(1===s)n.unshift(r);else{if(r!==s){let n=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(n)}n.unshift(r)}}return n}v(Ll,{assertAndGetBroadcastShape:()=>Bl,getBroadcastDims:()=>Pl,getReductionAxes:()=>zl});var Wl,Vl={};function Ul(e,t,n){if(de(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");let r=ei(e,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return ui(e,t,r,n)}function Gl(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,a=!1,s=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)a=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)s=!0;else if(null!=e.getContext)i=!0;else{if(!("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);o=!0}if(a&&a&&e.readyState<2)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");if(null!=va(ca,Hs.backendName)){let n={pixels:e},r={numChannels:t};return Hs.runKernel(ca,n,r)}let l,u,[p,d]=a?[e.videoWidth,e.videoHeight]:[e.width,e.height];if(i)l=e.getContext("2d").getImageData(0,0,p,d).data;else if(r||n)l=e.data;else if(s||a||o){if(null==Wl)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");Wl=new OffscreenCanvas(1,1).getContext("2d")}else Wl=document.createElement("canvas").getContext("2d");Wl.canvas.width=p,Wl.canvas.height=d,Wl.drawImage(e,0,0,p,d),l=Wl.getImageData(0,0,p,d).data}if(4===t)u=new Int32Array(l);else{let e=p*d;u=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)u[n*t+e]=l[4*n+e]}return Ul(u,[d,p,t],"int32")}function Hl(e){return null!=e&&e.data instanceof Uint8Array}function jl(){return"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")}function ql(e){return null!=e&&0!==e.width&&0!==e.height}function Kl(e){return jl()&&!(e instanceof ImageBitmap)&&ql(e)&&!Hl(e)}async function Xl(e,t=3){let n=null;if(et().getBool("WRAP_TO_IMAGEBITMAP")&&Kl(e)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(r){t=null}n=null!=t&&t.width===e.width&&t.height===e.height?t:e}else n=e;return Gl(n,t)}async function Yl(e,t){let n=ri(e,"img","toPixels");if(!(e instanceof ks)){let e=n;n=vo(e,"int32"),e.dispose()}if(2!==n.rank&&3!==n.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);let[r,a]=n.shape.slice(0,2),s=2===n.rank?1:n.shape[2];if(s>4||2===s)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${s}`);if("float32"!==n.dtype&&"int32"!==n.dtype)throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);let i=await n.data(),o="float32"===n.dtype?255:1,l=new Uint8ClampedArray(a*r*4);for(let u=0;u<r*a;++u){let e=[0,0,0,255];for(let r=0;r<s;r++){let t=i[u*s+r];if("float32"===n.dtype){if(t<0||t>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t}.`)}else if("int32"===n.dtype&&(t<0||t>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t}.`);1===s?(e[0]=t*o,e[1]=t*o,e[2]=t*o):e[r]=t*o}let t=4*u;l[t+0]=Math.round(e[0]),l[t+1]=Math.round(e[1]),l[t+2]=Math.round(e[2]),l[t+3]=Math.round(e[3])}if(null!=t){t.width=a,t.height=r;let e=t.getContext("2d"),n=new ImageData(l,a,r);e.putImageData(n,0,0)}return n!==e&&n.dispose(),l}v(Vl,{fromPixels:()=>Zl,fromPixelsAsync:()=>Xl,toPixels:()=>Yl});var Zl=ii({fromPixels_:Gl}),Jl={};function Ql(e,t){let n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===he(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let a=t.shape,s=a[a.length-1],i=1;for(let d=0;d<a.length-1;++d)i*=a[d];let o=e.shape,l=a.slice();l.pop();let u=1;for(let d=s;d<n;++d)u*=o[d],l.push(o[d]);let p=[...ze(e.shape).map((e=>e/u)),1].slice(0,s);return[l,i,u,p]}v(Jl,{prepareAndValidate:()=>Ql});var eu={};function tu(e,t,n){let r=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${a}.`;if(n.rank<a)throw new Error(s+` update.rank < ${a}. `);if(e.length<r+(n.rank-a))throw new Error(s+` Output shape length < ${r+(n.rank-a)}`);if(n.rank!==a+e.length-r)throw new Error(s+" update.rank != "+(a+e.length-r));for(let i=0;i<a;++i)if(n.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-a;++i)if(n.shape[i+a]!==e[i+r])throw new Error(s+` updates.shape[${i+a}] (${n.shape[i+a]}) != shape[${i+a}] (${e[i+a]})`)}function nu(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}tu(n,t,e)}function ru(e,t,n){let r=t.shape.length,a=r>1?t.shape[r-1]:1,s=n.length,i=1;for(let d=a;d<s;++d)i*=n[d];let o=a<1?1:a,l=he(t.shape)/o,u=[...ze(n.slice(0,a)),1],p=he(n);return{sliceRank:a,numUpdates:l,sliceSize:i,strides:u,outputSize:p}}v(eu,{calculateShapes:()=>ru,validateInput:()=>nu,validateUpdateShape:()=>tu});var au={};v(au,{assertParamsValid:()=>ou,computeFlatOffset:()=>xu,computeOutShape:()=>uu,getNormalizedAxes:()=>hu,isSliceContinous:()=>wu,maskToAxes:()=>lu,parseSliceParams:()=>vu,sliceInfo:()=>ku,startForAxis:()=>yu,startIndicesWithElidedDims:()=>fu,stopForAxis:()=>bu,stopIndicesWithElidedDims:()=>mu,stridesForAxis:()=>gu,stridesWithElidedDims:()=>pu});var su=-2,iu=-1;function ou(e,t,n){let r=e.shape.length;ue(r===t.length,(()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`)),ue(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let a=0;a<r;++a)ue(t[a]+n[a]<=e.shape[a],(()=>`Error in slice${r}D: begin[${a}] + size[${a}] (${t[a]+n[a]}) would overflow input.shape[${a}] (${e.shape[a]})`))}function lu(e){let t=[],n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function uu(e,t,n){let r=[];for(let a=0;a<e.length;a++)r[a]=Math.ceil((t[a]-e[a])/n[a]);return r}function pu(e,t,n,r){let a=[...e];for(let s=a.length;s<r.length;s++)a.push(1);for(let s=0;s<n;s++)0===s?a[t]=1:(a.splice(t,0,1),a.pop());return a}function du(e,t,n){return n<=e?n:n-(t-1)}function cu(e,t){let n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function hu(e,t,n,r,a,s,i,o,l){let u=e.length,p=new Array(u),d=new Array(u),c=new Array(u);if(t.length&&n>0){let l=t[0],u=n+1;p=fu(i,l,u,r,e),d=mu(o,l,u,a,e),c=pu(s,l,u,e)}else for(let h=0;h<u;h++)p[h]=yu(i,r,s,e,h,l),d[h]=bu(o,a,s,e,h,l),c[h]=gu(s,h,l);return{begin:p,end:d,strides:c}}function fu(e,t,n,r,a){let s=[...a],i=cu(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=0;else{let a=du(t,n,o),i=r[a];e&1<<a&&(i=0),s[o]=i}return s}function mu(e,t,n,r,a){let s=[...a],i=cu(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=Number.MAX_SAFE_INTEGER;else{let a=du(t,n,o),i=r[a];e&1<<a&&(i=Number.MAX_SAFE_INTEGER),s[o]=i}for(let o=0;o<s.length;o++){let e=a[o];s[o]<0&&(s[o]+=e),s[o]=re(0,s[o],a[o])}return s}function gu(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function yu(e,t,n,r,a,s){let i=t[a],o=n[a]||1;(e&1<<a||s&1<<a||null==i)&&(i=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);let l=r[a];return i<0&&(i+=l),i=re(0,i,l-1),i}function bu(e,t,n,r,a,s){let i=t[a],o=n[a]||1;(e&1<<a||s&1<<a||null==i)&&(i=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);let l=r[a];return i<0&&(i+=l),i=o>0?re(0,i,l):re(-1,i,l-1),i}function wu(e,t,n){let r=n.length;for(let a=0;a<n.length;a++)if(n[a]>1){r=a;break}for(let a=r+1;a<n.length;a++)if(t[a]>0||n[a]!==e[a])return!1;return!0}function xu(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function vu(e,t,n){let r,a,s=e.shape.length;return r="number"==typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach((e=>{ue(-1!==e,(()=>"slice() does not support negative begin indexing."))})),a=null==n?new Array(s).fill(-1):"number"==typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,a=a.map(((t,n)=>t>=0?t:(ue(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-r[n]))),[r,a]}function ku(e,t,n,r,a,s,i,o,l){let u;if(null==r?(u=new Array(t.length),u.fill(1)):u=r,null!=i&&0!==(i&i-1))throw new Error("Multiple ellipses in slice is not allowed.");let p=!1,d={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let b=0;b<d.dims;b++)p&&0!==(1<<b&o)&&d.numAddAxisAfterEllipsis++,1<<b&i&&(p=!0);p||(d.ellipsisMask|=1<<d.dims,d.dims++);let c={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};Iu(d,c);let h=!0,f=!0,m=!0,g=[],y=[];for(let b=0;b<e.length;++b){if(0===c.strides[b])throw Error(`strides[${b}] must be non-zero`);let t=!!(c.shrinkAxisMask&1<<b),n=e[b];if(-1===n){g.push(t?1:-1);continue}let r=[c.beginMask&1<<b,c.endMask&1<<b],a=[c.strides[b]>0?0:-1,c.strides[b]>0?n:n-1];if(t&&c.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===c.strides[b];let s=!!(c.beginMask&1<<b&&c.endMask&1<<b);if(c.beginValid&&c.endValid){if(t){let e=c.begin[b]<0?n+c.begin[b]:c.begin[b];if(c.begin[b]=e,c.end[b]=c.begin[b]+1,e<0||e>=n)throw Error(`slice index ${c.begin[b]} of dimension ${b} out of bounds.`)}else c.begin[b]=Su(c.begin[b],0,c.strides[b],n,r,a),c.end[b]=Su(c.end[b],1,c.strides[b],n,r,a);let e=1===c.strides[b]&&0===c.begin[b]&&c.end[b]===n;h=h&&e,f=f&&(0===b&&1===c.strides[b]||e)}else h=h&&1===c.strides[b]&&s,f=f&&(0===b&&1===c.strides[b]||s);let i,o=!1;if(c.beginValid&&c.endValid?(i=c.end[b]-c.begin[b],o=!0):t?(i=1,o=!0):s&&n>=0&&(i=c.strides[b]<0?-n:n,o=!0),o){let e;e=0===i||i<0!=c.strides[b]<0?0:Math.trunc(i/c.strides[b])+(i%c.strides[b]!==0?1:0),g.push(e)}else g.push(-1)}for(let b=0;b<c.finalShapeGatherIndices.length;++b){let e=c.finalShapeGatherIndices[b];e>=0?y.push(g[e]):e===su&&y.push(1)}return{finalShapeSparse:y.filter(((e,t)=>c.finalShapeGatherIndices[t]!==su)),finalShape:y,isIdentity:h,sliceDim0:f,isSimpleSlice:m,begin:c.begin,end:c.end,strides:c.strides}}function Iu(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){let a=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<a;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(su),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(iu),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}function Su(e,t,n,r,a,s){if(a[t])return n>0?s[t]:s[t+1&1];{let t=e<0?r+e:e;return t<s[0]?s[0]:t>s[1]?s[1]:t}}var Nu={};v(Nu,{Serializable:()=>Tu,SerializationMap:()=>Cu,registerClass:()=>_u});var Tu=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},Cu=class{constructor(){this.classNameMap={}}static getMap(){return null==Cu.instance&&(Cu.instance=new Cu),Cu.instance}static register(e){Cu.getMap().classNameMap[e.className]=[e,e.fromConfig]}};function _u(e){ue(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),ue("string"==typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),ue(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),Cu.register(e)}var Eu={};v(Eu,{TEST_EPSILON_FLOAT16:()=>$u,encodeStrings:()=>Wu,expectArrayBuffersEqual:()=>Bu,expectArraysClose:()=>Fu,expectArraysEqual:()=>Ou,expectNumbersClose:()=>Lu,expectPromiseToFail:()=>Mu,expectValuesInRange:()=>zu,testEpsilon:()=>Ru});var Au=.001,$u=.1;function Fu(e,t,n){return null==n&&(n=Ru()),Du(e,t,((e,t)=>Pu(e,t,n)))}function Ru(){return 32===Hs.backend.floatPrecision()?Au:$u}function Du(e,t,n){let r=!0;if((Ae(e)||Ae(t))&&(r=!1),Ae(e)&&Ae(t)&&(r=!0),r){let n=e.constructor.name,r=t.constructor.name;if(n!==r)throw new Error(`Arrays are of different type. Actual: ${n}. Expected: ${r}`)}if(Array.isArray(e)&&Array.isArray(t)){let n=ei(e),r=ei(t);if(!me(n,r))throw new Error(`Arrays have different shapes. Actual: [${n}]. Expected: [${r}]`)}let a=Ae(e)?e:ce(e),s=Ae(t)?t:ce(t);if(a.length!==s.length)throw new Error(`Arrays have different lengths actual: ${a.length} vs expected: ${s.length}.\nActual:   ${a}.\nExpected: ${s}.`);for(let i=0;i<s.length;++i){let e=a[i],t=s[i];if(!n(e,t))throw new Error(`Arrays differ: actual[${i}] = ${e}, expected[${i}] = ${t}.\nActual:   ${a}.\nExpected: ${s}.`)}}function Mu(e,t){e().then((()=>t.fail()),(()=>t()))}function Ou(e,t){let n="string"==typeof t||"number"==typeof t||"boolean"==typeof t?[t]:t;return Re(e)||Re(e[0])||Re(t)||Re(t[0])?Du(e,n,((e,t)=>e==t)):Du(e,t,((e,t)=>Pu(e,t,0)))}function Lu(e,t,n){if(null==n&&(n=Ru()),!Pu(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`)}function Pu(e,t,n){return!isFinite(e)&&!isFinite(t)||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function zu(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function Bu(e,t){let n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let a=0;a<r.length;a++)if(n[a]!==r[a])throw new Error(`Expected ArrayBuffer value at ${a} to be ${r[a]} but got ${n[a]} instead`)}function Wu(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?Wu(n):e[t]=es(n)}return e}var Vu="3.18.0";function Uu(e,t){let n=ri(e,"a","add"),r=ri(t,"b","add");[n,r]=Ds(n,r);let a={a:n,b:r};return Hs.runKernel(pt,a)}var Gu=ii({add_:Uu});function Hu(e,t){let n=ri(e,"a","floorDiv"),r=ri(t,"b","floorDiv");[n,r]=Ds(n,r);let a={a:n,b:r};return Hs.runKernel(gn,a)}var ju=ii({floorDiv_:Hu});function qu(e,t){let n=ri(e,"a","div"),r=ri(t,"b","div");if([n,r]=Ds(n,r),"int32"===n.dtype&&"int32"===r.dtype)return ju(n,r);let a={a:n,b:r},s={};return Hs.runKernel(nn,a,s)}var Ku=ii({div_:qu});function Xu(e,t){let n=ri(e,"a","mul"),r=ri(t,"b","mul");[n,r]=Ds(n,r);let a={a:n,b:r};return Hs.runKernel(er,a)}var Yu=ii({mul_:Xu});function Zu(e){let t=ri(e,"x","abs");if("complex64"===t.dtype){let e={x:t};return Hs.runKernel(Dt,e)}{let e={x:t};return Hs.runKernel(ot,e)}}var Ju=ii({abs_:Zu});function Qu(e){let t={x:ri(e,"x","acos")};return Hs.runKernel(lt,t)}var ep=ii({acos_:Qu});function tp(e){let t={x:ri(e,"x","acosh")};return Hs.runKernel(ut,t)}var np=ii({acosh_:tp});function rp(e){ue(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),ue(e.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`));let t=e.map(((e,t)=>ri(e,`tensors${t}`,"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!me(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));let r=t;return Hs.runKernel(dt,r)}var ap=ii({addN_:rp});function sp(e,t=null,n=!1){let r={x:ri(e,"x","all","bool")},a={axis:t,keepDims:n};return Hs.runKernel(ct,r,a)}var ip=ii({all_:sp});function op(e,t=null,n=!1){let r={x:ri(e,"x","any","bool")},a={axis:t,keepDims:n};return Hs.runKernel(ht,r,a)}var lp=ii({any_:op});function up(e,t=0){let n={x:ri(e,"x","argMax")},r={axis:t};return Hs.runKernel(ft,n,r)}var pp=ii({argMax_:up});function dp(e,t=0){let n={x:ri(e,"x","argMin")},r={axis:t};return Hs.runKernel(mt,n,r)}var cp=ii({argMin_:dp});function hp(e){let t={x:ri(e,"x","asin")};return Hs.runKernel(gt,t)}var fp=ii({asin_:hp});function mp(e){let t={x:ri(e,"x","asinh")};return Hs.runKernel(yt,t)}var gp=ii({asinh_:mp});function yp(e){let t={x:ri(e,"x","atan")};return Hs.runKernel(bt,t)}var bp=ii({atan_:yp});function wp(e,t){let n=ri(e,"a","atan2"),r=ri(t,"b","atan2");[n,r]=Ds(n,r);let a={a:n,b:r};return Hs.runKernel(xt,a)}var xp=ii({atan2_:wp});function vp(e){let t={x:ri(e,"x","atanh")};return Hs.runKernel(wt,t)}var kp=ii({atanh_:vp});function Ip(e,t,n,r,a="NHWC",s){let i=e[3],o=[...t,i],l=zp(a);return Tp(e,o,n,s,r,null,null,l)}function Sp(e,t,n,r,a,s,i="channelsLast"){let o,[l,u]=$p(t);if("channelsLast"===i)o=[l,u,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);o=[l,u,e[1],e[1]]}return Tp(e,o,n,r,a,s,!1,i)}function Np(e,t,n,r,a,s,i="NDHWC"){let o,l,[u,p,d]=Fp(t);if("NDHWC"===i)l="channelsLast",o=[u,p,d,e[4],e[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);l="channelsFirst",o=[u,p,d,e[1],e[1]]}return Cp(e,o,n,r,a,!1,l,s)}function Tp(e,t,n,r,a,s,i=!1,o="channelsLast"){let[l,u,p,d]=[-1,-1,-1,-1];if("channelsLast"===o)[l,u,p,d]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,d,u,p]=e}let c,[h,f,,m]=t,[g,y]=$p(n),[b,w]=$p(r),x=Rp(h,b),v=Rp(f,w),{padInfo:k,outHeight:I,outWidth:S}=Dp(a,u,p,g,y,x,v,s,o),N=i?m*d:m;return"channelsFirst"===o?c=[l,N,I,S]:"channelsLast"===o&&(c=[l,I,S,N]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:p,inChannels:d,outHeight:I,outWidth:S,outChannels:N,padInfo:k,strideHeight:g,strideWidth:y,filterHeight:h,filterWidth:f,effectiveFilterHeight:x,effectiveFilterWidth:v,dilationHeight:b,dilationWidth:w,inShape:e,outShape:c,filterShape:t}}function Cp(e,t,n,r,a,s=!1,i="channelsLast",o){let[l,u,p,d,c]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,u,p,d,c]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,c,u,p,d]=e}let h,[f,m,g,,y]=t,[b,w,x]=Fp(n),[v,k,I]=Fp(r),S=Rp(f,v),N=Rp(m,k),T=Rp(g,I),{padInfo:C,outDepth:_,outHeight:E,outWidth:A}=Mp(a,u,p,d,b,w,x,S,N,T,o),$=s?y*c:y;return"channelsFirst"===i?h=[l,$,_,E,A]:"channelsLast"===i&&(h=[l,_,E,A,$]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:p,inWidth:d,inChannels:c,outDepth:_,outHeight:E,outWidth:A,outChannels:$,padInfo:C,strideDepth:b,strideHeight:w,strideWidth:x,filterDepth:f,filterHeight:m,filterWidth:g,effectiveFilterDepth:S,effectiveFilterHeight:N,effectiveFilterWidth:T,dilationDepth:v,dilationHeight:k,dilationWidth:I,inShape:e,outShape:h,filterShape:t}}function _p(e,t,n,r,a){null==r&&(r=Ap(e,t,n));let s=e[0],i=e[1],o=Op((s-t+2*r)/n+1,a),l=Op((i-t+2*r)/n+1,a);return[o,l]}function Ep(e,t,n,r,a,s){null==a&&(a=Ap(e,t,r));let i=e[0],o=e[1],l=e[2],u=Op((i-t+2*a)/r+1,s),p=Op((o-t+2*a)/r+1,s),d=Op((l-t+2*a)/r+1,s);return[u,p,d,n]}function Ap(e,t,n,r=1){let a=Rp(t,r);return Math.floor((e[0]*(n-1)-n+a)/2)}function $p(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function Fp(e){return"number"==typeof e?[e,e,e]:e}function Rp(e,t){return t<=1?e:e+(e-1)*(t-1)}function Dp(e,t,n,r,a,s,i,o,l){let u,p,d;if("number"==typeof e){u={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};let a=_p([t,n],s,r,e,o);p=a[0],d=a[1]}else if("same"===e){p=Math.ceil(t/r),d=Math.ceil(n/a);let e=Math.max(0,(p-1)*r+s-t),o=Math.max(0,(d-1)*a+i-n),l=Math.floor(e/2),c=e-l,h=Math.floor(o/2),f=o-h;u={top:l,bottom:c,left:h,right:f,type:"SAME"}}else if("valid"===e)u={top:0,bottom:0,left:0,right:0,type:"VALID"},p=Math.ceil((t-s+1)/r),d=Math.ceil((n-i+1)/a);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{let c="channelsLast"===l?e[1][0]:e[2][0],h="channelsLast"===l?e[1][1]:e[2][1],f="channelsLast"===l?e[2][0]:e[3][0],m="channelsLast"===l?e[2][1]:e[3][1];u={top:c,bottom:h,left:f,right:m,type:0===c&&0===h&&0===f&&0===m?"VALID":"EXPLICIT"},p=Op((t-s+c+h)/r+1,o),d=Op((n-i+f+m)/a+1,o)}}return{padInfo:u,outHeight:p,outWidth:d}}function Mp(e,t,n,r,a,s,i,o,l,u,p){let d,c,h,f;if("number"==typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};let s=Ep([t,n,r,1],o,1,a,e,p);c=s[0],h=s[1],f=s[2]}else if("same"===e){c=Math.ceil(t/a),h=Math.ceil(n/s),f=Math.ceil(r/i);let e=(c-1)*a+o-t,p=(h-1)*s+l-n,m=(f-1)*i+u-r,g=Math.floor(e/2),y=e-g,b=Math.floor(p/2),w=p-b,x=Math.floor(m/2),v=m-x;d={top:b,bottom:w,left:x,right:v,front:g,back:y,type:"SAME"}}else{if("valid"!==e)throw Error(`Unknown padding parameter: ${e}`);d={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},c=Math.ceil((t-o+1)/a),h=Math.ceil((n-l+1)/s),f=Math.ceil((r-u+1)/i)}return{padInfo:d,outDepth:c,outHeight:h,outWidth:f}}function Op(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Lp(e){let[t,n,r]=$p(e);return 1===t&&1===n&&1===r}function Pp(e,t){return Lp(e)||Lp(t)}function zp(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function Bp(e,t,n){if(null!=n){if("string"==typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"==typeof t)ue(ge(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));else{if("object"!=typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach((t=>{t.forEach((t=>{ue(ge(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))}))}))}}}function Wp(e,t){let n={x:ri(e,"x","reshape","string_or_numeric")},r={shape:t};return Hs.runKernel(br,n,r)}var Vp=ii({reshape_:Wp});function Up(e,t,n,r,a){let s=ri(e,"x","avgPool","float32"),i=1;ue(Pp(n,i),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`));let o=s,l=!1;3===s.rank&&(l=!0,o=Vp(s,[1,s.shape[0],s.shape[1],s.shape[2]])),ue(4===o.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`)),Bp("avgPool",r,a);let u={x:o},p={filterSize:t,strides:n,pad:r,dimRoundingMode:a},d=Hs.runKernel(vt,u,p);return d=vo(d,s.dtype),l?Vp(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var Gp=ii({avgPool_:Up});function Hp(e,t,n,r,a,s="NDHWC"){let i=ri(e,"x","avgPool3d","float32"),o=i,l=!1;4===i.rank&&(l=!0,o=Vp(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),ue(5===o.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`)),ue("NDHWC"===s,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),Bp("avgPool3d",r,a);let u={x:o},p={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},d=Hs.runKernel(It,u,p);return d=vo(d,o.dtype),l?Vp(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var jp=ii({avgPool3d_:Hp});function qp(e,t=0){ue(e.length>=1,(()=>"Pass at least one tensor to concat"));let n=ai(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return Io(n[0]);let r=n,a={axis:t};return Hs.runKernel(Mt,r,a)}var Kp=ii({concat_:qp});function Xp(e){let t={x:ri(e,"x","sigmoid","float32")};return Hs.runKernel(Mr,t)}var Yp=ii({sigmoid_:Xp});function Zp(e,t,n){let r=ri(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");let a={x:r},s={begin:t,size:n};return Hs.runKernel($r,a,s)}var Jp=ii({slice_:Zp});function Qp(e){let t={x:ri(e,"x","tanh","float32")};return Hs.runKernel(ta,t)}var ed=ii({tanh_:Qp});function td(e,t,n,r,a,s){let i=ri(e,"forgetBias","basicLSTMCell"),o=ri(t,"lstmKernel","basicLSTMCell"),l=ri(n,"lstmBias","basicLSTMCell"),u=ri(r,"data","basicLSTMCell"),p=ri(a,"c","basicLSTMCell"),d=ri(s,"h","basicLSTMCell"),c=Kp([u,d],1),h=rl(c,o),f=Gu(h,l),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=Jp(f,[0,0],y),w=Jp(f,[0,g],y),x=Jp(f,[0,2*g],y),v=Jp(f,[0,3*g],y),k=Gu(Yu(Yp(b),ed(w)),Yu(p,Yp(Gu(i,x)))),I=Yu(ed(k),Yp(v));return[k,I]}var nd=ii({basicLSTMCell_:td});function rd(e,t,n){let r=ri(e,"x","batchToSpaceND"),a=t.reduce(((e,t)=>e*t));ue(r.rank>=1+t.length,(()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`)),ue(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),ue(r.shape[0]%a===0,(()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${a}`));let s={x:r},i={blockShape:t,crops:n};return Hs.runKernel(Tt,s,i)}var ad=ii({batchToSpaceND_:rd});function sd(e){let t;return t=0===e.rank||1===e.rank?Vp(e,[1,1,1,e.size]):2===e.rank?Vp(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?Vp(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}function id(e,t,n,r,a,s){null==s&&(s=.001);let i,o,l=ri(e,"x","batchNorm"),u=ri(t,"mean","batchNorm"),p=ri(n,"variance","batchNorm");null!=a&&(i=ri(a,"scale","batchNorm")),null!=r&&(o=ri(r,"offset","batchNorm")),ue(u.rank===p.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),ue(null==o||u.rank===o.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),ue(null==i||u.rank===i.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let d={x:sd(l),scale:i,offset:o,mean:u,variance:p},c={varianceEpsilon:s},h=Hs.runKernel(yn,d,c);return Vp(h,l.shape)}var od=ii({batchNorm_:id});function ld(e,t,n,r,a,s){let i,o,l=ri(e,"x","batchNorm"),u=ri(t,"mean","batchNorm"),p=ri(n,"variance","batchNorm");return null!=a&&(i=ri(a,"scale","batchNorm")),null!=r&&(o=ri(r,"offset","batchNorm")),ue(2===l.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${l.rank}.`)),ue(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${u.rank}.`)),ue(2===p.rank||1===p.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${p.rank}.`)),null!=i&&ue(2===i.rank||1===i.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${i.rank}.`)),null!=o&&ue(2===o.rank||1===o.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${o.rank}.`)),od(l,u,p,o,i,s)}var ud=ii({batchNorm2d_:ld});function pd(e,t,n,r,a,s){let i,o,l=ri(e,"x","batchNorm"),u=ri(t,"mean","batchNorm"),p=ri(n,"variance","batchNorm");return null!=a&&(i=ri(a,"scale","batchNorm")),null!=r&&(o=ri(r,"offset","batchNorm")),ue(3===l.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${l.rank}.`)),ue(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${u.rank}.`)),ue(3===p.rank||1===p.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${p.rank}.`)),null!=i&&ue(3===i.rank||1===i.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${i.rank}.`)),null!=o&&ue(3===o.rank||1===o.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${o.rank}.`)),od(l,u,p,o,i,s)}var dd=ii({batchNorm3d_:pd});function cd(e,t,n,r,a,s){let i,o,l=ri(e,"x","batchNorm"),u=ri(t,"mean","batchNorm"),p=ri(n,"variance","batchNorm");return null!=a&&(i=ri(a,"scale","batchNorm")),null!=r&&(o=ri(r,"offset","batchNorm")),ue(4===l.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${l.rank}.`)),ue(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${u.rank}.`)),ue(4===p.rank||1===p.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${p.rank}.`)),null!=i&&ue(4===i.rank||1===i.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${i.rank}.`)),null!=o&&ue(4===o.rank||1===o.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${o.rank}.`)),od(l,u,p,o,i,s)}var hd=ii({batchNorm4d_:cd});function fd(e,t,n){let r=ri(e,"x","bincount"),a=ri(t,"weights","bincount");ue("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),ue(n>=0,(()=>`size must be non-negative, but got ${n}.`)),ue(a.size===r.size||0===a.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${a.shape}.`));let s={x:r,weights:a},i={size:n};return Hs.runKernel(Ct,s,i)}var md=ii({bincount_:fd});function gd(e,t){let n=ri(e,"s0","broadcastArgs","int32"),r=ri(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let a={s0:n,s1:r};return Hs.runKernel(Et,a)}var yd=ii({broadcastArgs_:gd});function bd(e,t){let n=ri(e,"broadcastTo","x"),r=n.shape;if(t.some((e=>!(e>0)||e%1!==0)))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=Vp(n,e)}let a=n.shape,s=Array.from(t);for(let l=t.length-1;l>=0;l--)if(a[l]===t[l])s[l]=1;else if(1!==n.shape[l])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(0===s.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return Io(n);let i={x:n},o={reps:s};return Hs.runKernel(na,i,o)}var wd=ii({broadcastTo_:bd});function xd(e){let t={x:ri(e,"x","ceil","float32")};return Hs.runKernel($t,t)}var vd=ii({ceil_:xd});function kd(e,t,n){let r=ri(e,"x","clipByValue");ue(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`));let a={x:r},s={clipValueMin:t,clipValueMax:n};return Hs.runKernel(Ft,a,s)}var Id=ii({clipByValue_:kd});function Sd(e){return Kp(e,0)}var Nd=ii({concat1d_:Sd});function Td(e,t){return Kp(e,t)}var Cd=ii({concat2d_:Td});function _d(e,t){return Kp(e,t)}var Ed=ii({concat3d_:_d});function Ad(e,t){return Kp(e,t)}var $d=ii({concat4d_:Ad});function Fd(e,t,n,r,a="NHWC",s=[1,1],i){let o=ri(e,"x","conv2d","float32"),l=ri(t,"filter","conv2d","float32"),u=o,p=!1;3===o.rank&&(p=!0,u=Vp(o,[1,o.shape[0],o.shape[1],o.shape[2]])),ue(4===u.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`)),ue(4===l.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`)),Bp("conv2d",r,i);let d="NHWC"===a?u.shape[3]:u.shape[1];ue(d===l.shape[2],(()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`)),ue(Pp(n,s),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`));let c={x:u,filter:l},h={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},f=Hs.runKernel(Ot,c,h);return p?Vp(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Rd=ii({conv2d_:Fd});function Dd(e,t,n,r,a="NWC",s=1,i){let o=ri(e,"x","conv1d"),l=ri(t,"filter","conv1d"),u=o,p=!1;2===o.rank&&(p=!0,u=Vp(o,[1,o.shape[0],o.shape[1]])),ue(3===u.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`)),ue(3===l.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`)),Bp("conv1d",r,i),ue(u.shape[2]===l.shape[1],(()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`)),ue(Pp(n,s),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`)),ue("NWC"===a,(()=>`Error in conv1d: got dataFormat of ${a} but only NWC is currently supported.`));let d=Vp(l,[1,l.shape[0],l.shape[1],l.shape[2]]),c=Vp(u,[u.shape[0],1,u.shape[1],u.shape[2]]),h=Rd(c,d,[1,n],r,"NHWC",[1,s],i);return Vp(h,p?[h.shape[2],h.shape[3]]:[h.shape[0],h.shape[2],h.shape[3]])}var Md=ii({conv1d_:Dd});function Od(e,t,n,r,a,s="NHWC",i){ue(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let o=e,l=t,u=!1;3===t.rank&&(u=!0,l=Vp(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),ue(4===o.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`)),ue(4===l.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`)),ue(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));let p="NHWC"===s?o[3]:o[1],d="NHWC"===s?l.shape[3]:l.shape[1];ue(p===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${p}) must match input depth for filter ${n.shape[2]}.`)),ue(d===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`)),Bp("conv2dDerInput",a,i);let c={dy:l,filter:n},h={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,inputShape:o},f=Hs.runKernel(Pt,c,h);return u?Vp(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Ld=ii({conv2DBackpropInput_:Od});function Pd(e,t,n,r,a,s){let i=ri(e,"x","conv2dTranspose"),o=ri(t,"filter","conv2dTranspose");return Ld(n,i,o,r,a,"NHWC",s)}var zd=ii({conv2dTranspose_:Pd});function Bd(e,t,n,r,a="NDHWC",s=[1,1,1]){let i=ri(e,"x","conv3d"),o=ri(t,"filter","conv3d"),l=i,u=!1;4===i.rank&&(u=!0,l=Vp(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),ue(5===l.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`)),ue(5===o.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`)),ue(l.shape[4]===o.shape[3],(()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`)),ue(Pp(n,s),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),ue("NDHWC"===a,(()=>`Error in conv3d: got dataFormat of ${a} but only NDHWC is currently supported.`));let p={x:l,filter:o},d={strides:n,pad:r,dataFormat:a,dilations:s},c=Hs.runKernel(zt,p,d);return u?Vp(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}var Wd=ii({conv3d_:Bd});function Vd(e,t,n,r,a){ue(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let s=e,i=t,o=!1;4===t.rank&&(o=!0,i=Vp(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);let l=s[4],u=i.shape[4];ue(5===s.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`)),ue(5===i.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`)),ue(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),ue(l===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`)),ue(u===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`));let p={dy:i,filter:n},d={pad:a,strides:r,inputShape:s},c=Hs.runKernel(Wt,p,d);return o?Vp(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}var Ud=ii({conv3DBackpropInput_:Vd});function Gd(e,t,n,r,a){let s=ri(e,"x","conv3dTranspose"),i=ri(t,"filter","conv3dTranspose");return Ud(n,s,i,r,a)}var Hd=ii({conv3dTranspose_:Gd});function jd(e){let t={x:ri(e,"x","cos","float32")};return Hs.runKernel(Vt,t)}var qd=ii({cos_:jd});function Kd(e){let t={x:ri(e,"x","cosh","float32")};return Hs.runKernel(Ut,t)}var Xd=ii({cosh_:Kd});function Yd(e,t=0,n=!1,r=!1){let a={x:ri(e,"x","cumprod")},s={axis:t,exclusive:n,reverse:r};return Hs.runKernel(Gt,a,s)}var Zd=ii({cumprod_:Yd});function Jd(e,t=0,n=!1,r=!1){let a={x:ri(e,"x","cumsum")},s={axis:t,exclusive:n,reverse:r};return Hs.runKernel(Ht,a,s)}var Qd=ii({cumsum_:Jd});function ec(e,t,n,r=!1){let a=ri(e,"x","denseBincount"),s=ri(t,"weights","denseBincount");ue("int32"===a.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${a.dtype}`)),ue(a.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${a.rank}.`)),ue(n>=0,(()=>`size must be non-negative, but got ${n}.`)),ue(s.size===a.size||0===s.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${a.shape}, weights shape: ${s.shape}.`));let i={x:a,weights:s},o={size:n,binaryOutput:r};return Hs.runKernel(qt,i,o)}var tc=ii({denseBincount_:ec});function nc(e,t,n="NHWC"){let r=ri(e,"x","depthToSpace","float32"),a="NHWC"===n?r.shape[1]:r.shape[2],s="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];ue(t>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`)),ue(a*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t}  for depthToSpace with input shape\n    ${r.shape}`)),ue(s*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t} for depthToSpace with input shape\n        ${r.shape}`)),ue(i%(t*t)===0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`));let o={x:r},l={blockSize:t,dataFormat:n};return Hs.runKernel(Kt,o,l)}var rc=ii({depthToSpace_:nc});function ac(e,t,n,r,a="NHWC",s=[1,1],i){let o=ri(e,"x","depthwiseConv2d","float32"),l=ri(t,"filter","depthwiseConv2d","float32"),u=o,p=!1;3===o.rank&&(p=!0,u=Vp(o,[1,o.shape[0],o.shape[1],o.shape[2]])),ue(4===u.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`)),ue(4===l.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`)),ue(u.shape[3]===l.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`)),Bp("depthwiseConv2d",r,i);let d={x:u,filter:l},c={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},h=Hs.runKernel(Xt,d,c);return p?Vp(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var sc=ii({depthwiseConv2d_:ac});function ic(e){let t={x:ri(e,"x","diag")};return Hs.runKernel(Jt,t)}var oc=ii({diag_:ic});function lc(e,t,n,r,a=[1,1],s="NHWC"){let i=ri(e,"x","dilation2d"),o=ri(t,"filter","dilation2d");ue(3===i.rank||4===i.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`)),ue(3===o.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`)),ue("NHWC"===s,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`));let l=i,u=!1;3===i.rank&&(l=Vp(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0);let p={x:l,filter:o},d={strides:n,pad:r,dilations:a},c=Hs.runKernel(Qt,p,d);return u?Vp(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var uc=ii({dilation2d_:lc});function pc(e,t){let n=ri(e,"a","equal","string_or_numeric"),r=ri(t,"b","equal","string_or_numeric");[n,r]=Ds(n,r),Bl(n.shape,r.shape);let a={a:n,b:r};return Hs.runKernel(ln,a)}var dc=ii({equal_:pc});function cc(e,t,n){let r=ri(t,"a","where"),a=ri(n,"b","where"),s=ri(e,"condition","where","bool"),i=Bl(Bl(s.shape,r.shape),a.shape),o=wd(s,i),l=wd(r,i),u=wd(a,i),p={condition:o,t:l,e:u};return Hs.runKernel(Er,p)}var hc=ii({where_:cc});function fc(e){let t={x:ri(e,"x","zerosLike")};return Hs.runKernel(pa,t)}var mc=ii({zerosLike_:fc});function gc(e,t){let n=ri(e,"a","div"),r=ri(t,"b","div");[n,r]=Ds(n,r);let a=Ku(n,r),s=mc(a),i=dc(r,s);return hc(i,s,a)}var yc=ii({divNoNan_:gc});function bc(e,t){let n=ri(e,"t1","dot"),r=ri(t,"t2","dot");ue((1===n.rank||2===n.rank)&&(1===r.rank||2===r.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`));let a=1===n.rank?n.size:n.shape[1],s=1===r.rank?r.size:r.shape[0];if(ue(a===s,(()=>`Error in dot: inner dimensions of inputs must match, but got ${a} and ${s}.`)),1===n.rank&&1===r.rank){let e=Vp(n,[1,-1]),t=Vp(r,[-1,1]),a=rl(e,t);return Vp(a,[])}if(1===n.rank&&2===r.rank){let e=Vp(n,[1,-1]),t=Vp(r,[r.shape[0],r.shape[1]]),a=rl(e,t);return Vp(a,[a.size])}if(2===n.rank&&1===r.rank){let e=Vp(r,[-1,1]),t=rl(n,e);return Vp(t,[t.size])}{let e=Vp(r,[r.shape[0],r.shape[1]]);return rl(n,e)}}var wc=ii({dot_:bc});function xc(e,...t){let n=t.map(((e,t)=>ri(e,`tensors${t}`,"einsum"))),r={equation:e};return Hs.runKernel(rn,n,r)}var vc=ii({einsum_:xc});function kc(e){let t={x:ri(e,"x","elu","float32")};return Hs.runKernel(an,t)}var Ic=ii({elu_:kc});function Sc(e){let t=ri(e,"x","erf");ue("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=vo(t,"float32"));let n={x:t};return Hs.runKernel(on,n)}var Nc=ii({erf_:Sc});function Tc(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Cc(e,t,n){let r=e.length+t.length,a=[],s=0,i=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?a.push(e[s++]):a.push(t[i++]);return a}function _c(e,t){let n=[],r=e.length;for(let s=0;s<r;s++)-1===t.indexOf(s)&&n.push(e[s]);let a=t.map((t=>e[t]));return[n,a]}function Ec(e,t){let n=t.map((e=>1));return Cc(e,n,t)}function Ac(e,t,n){ue(Tc(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function $c(e,t){if(Tc(e,t))return null;let n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function Fc(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function Rc(e,t){let n=[];for(let r=t-e;r<t;++r)n.push(r);return n}function Dc(e,t=null,n=!1){let r={x:ri(e,"x","max")},a={reductionIndices:t,keepDims:n};return Hs.runKernel(Wn,r,a)}var Mc=ii({max_:Dc});function Oc(e,t=null,n=!1){let r={x:ri(e,"x","min")},a={axis:t,keepDims:n};return Hs.runKernel(Xn,r,a)}var Lc=ii({min_:Oc});function Pc(e,t){let n=ri(e,"base","pow"),r=ri(t,"exp","pow");[n,r]=Ds(n,r);let a={a:n,b:r};return Hs.runKernel(dr,a)}var zc=ii({pow_:Pc});function Bc(e,t){if((Ae(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Ae(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return ui(e,[],[],t)}function Wc(e){let t={x:ri(e,"x","sqrt","float32")};return Hs.runKernel(Lr,t)}var Vc=ii({sqrt_:Wc});function Uc(e){let t=ri(e,"x","square"),n={};return Hs.runKernel("Square",{x:t},n)}var Gc=ii({square_:Uc});function Hc(e,t=null,n=!1){let r=ri(e,"x","sum");"bool"===r.dtype&&(r=vo(r,"int32"));let a={x:r},s={axis:t,keepDims:n};return Hs.runKernel(Pr,a,s)}var jc=ii({sum_:Hc});function qc(e,t="euclidean",n=null,r=!1){e=ri(e,"x","norm");let a=Kc(e,t,n),s=a.shape;if(r){let t=Ie(n,e.shape);s=Ec(a.shape,t)}return Vp(a,s)}function Kc(e,t,n=null){if(0===e.rank)return Ju(e);if(1!==e.rank&&null===n)return Kc(Vp(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return jc(Ju(e),n);if(t===1/0)return Mc(Ju(e),n);if(t===-1/0)return Lc(Ju(e),n);if("euclidean"===t||2===t)return Vc(jc(zc(Ju(e),Bc(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return Mc(jc(Ju(e),n[0]),n[1]-1);if(t===1/0)return Mc(jc(Ju(e),n[1]),n[0]);if(t===-1/0)return Lc(jc(Ju(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return Vc(jc(Gc(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var Xc=ii({norm_:qc});function Yc(e,t=null,n=!1){return Xc(e,"euclidean",t,n)}var Zc=ii({euclideanNorm_:Yc});function Jc(e){let t={x:ri(e,"x","exp")};return Hs.runKernel(un,t)}var Qc=ii({exp_:Jc});function eh(e,t=0){let n=ri(e,"x","expandDims","string_or_numeric");ue(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));let r={input:n},a={dim:t};return Hs.runKernel(pn,r,a)}var th=ii({expandDims_:eh});function nh(e){let t={x:ri(e,"x","expm1")};return Hs.runKernel(dn,t)}var rh=ii({expm1_:nh});function ah(e,t){let n=ri(e,"x","tile","string_or_numeric");ue(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));let r={x:n},a={reps:t};return Hs.runKernel(na,r,a)}var sh=ii({tile_:ah});function ih(e,t,n,r="float32"){null==t&&(t=e);let a=wo([e,t],r),s=e<=t?e:t;for(let o=0;o<s;++o)a.set(1,o,o);let i=Vp(a.toTensor(),[e,t]);if(null==n)return i;if(1===n.length)return sh(th(i,0),[n[0],1,1]);if(2===n.length)return sh(th(th(i,0),0),[n[0],n[1],1,1]);if(3===n.length)return sh(th(th(th(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}var oh=ii({eye_:ih});function lh(e,t,n){let r={shape:e,value:t,dtype:n};return Hs.runKernel(hn,{},r)}function uh(e){let t={x:ri(e,"x","floor","float32")};return Hs.runKernel(mn,t)}var ph=ii({floor_:uh});function dh(e,t,n=0,r=0){let a=ri(e,"x","gather"),s=ri(t,"indices","gather","int32"),i={x:a,indices:s},o={axis:n,batchDims:r};return Hs.runKernel(bn,i,o)}var ch=ii({gather_:dh});function hh(e,t){let n=ri(e,"a","greater","string_or_numeric"),r=ri(t,"b","greater","string_or_numeric");[n,r]=Ds(n,r),Bl(n.shape,r.shape);let a={a:n,b:r};return Hs.runKernel(xn,a)}var fh=ii({greater_:hh});function mh(e,t){let n=ri(e,"a","greaterEqual","string_or_numeric"),r=ri(t,"b","greaterEqual","string_or_numeric");[n,r]=Ds(n,r),Bl(n.shape,r.shape);let a={a:n,b:r};return Hs.runKernel(vn,a)}var gh=ii({greaterEqual_:mh});function yh(e){let t={x:ri(e,"x","isFinite")};return Hs.runKernel(Nn,t)}var bh=ii({isFinite_:yh});function wh(e){let t={x:ri(e,"x","isInf")};return Hs.runKernel(Tn,t)}var xh=ii({isInf_:wh});function vh(e){let t={x:ri(e,"x","isNaN")};return Hs.runKernel(Cn,t)}var kh=ii({isNaN_:vh});function Ih(e,t=.2){let n={x:ri(e,"x","leakyRelu")},r={alpha:t};return Hs.runKernel(_n,n,r)}var Sh=ii({leakyRelu_:Ih});function Nh(e,t){let n=ri(e,"a","less","string_or_numeric"),r=ri(t,"b","less","string_or_numeric");[n,r]=Ds(n,r),Bl(n.shape,r.shape);let a={a:n,b:r};return Hs.runKernel(En,a)}var Th=ii({less_:Nh});function Ch(e,t){let n=ri(e,"a","lessEqual","string_or_numeric"),r=ri(t,"b","lessEqual","string_or_numeric");[n,r]=Ds(n,r),Bl(n.shape,r.shape);let a={a:n,b:r};return Hs.runKernel(An,a)}var _h=ii({lessEqual_:Ch});function Eh(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");let r={start:e,stop:t,num:n};return Hs.runKernel($n,{},r)}function Ah(e,t=5,n=1,r=1,a=.5){let s=ri(e,"x","localResponseNormalization");ue(4===s.rank||3===s.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${s.rank}.`)),ue(ge(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let i=s,o=!1;3===s.rank&&(o=!0,i=Vp(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let l={x:i},u={depthRadius:t,bias:n,alpha:r,beta:a},p=Hs.runKernel(zn,l,u);return o?Vp(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var $h=ii({localResponseNormalization_:Ah});function Fh(e){let t={x:ri(e,"x","log","float32")};return Hs.runKernel(Fn,t)}var Rh=ii({log_:Fh});function Dh(e){let t={x:ri(e,"x","log1p")};return Hs.runKernel(Rn,t)}var Mh=ii({log1p_:Dh});function Oh(e){return ue(Le(e),(()=>"The f passed in grad(f) must be a function")),(t,n)=>{let r=ri(t,"x","tf.grad","string_or_numeric"),a=null!=n?ri(n,"dy","tf.grad"):null;return Hs.tidy((()=>{let{value:t,grads:n}=Hs.gradients((()=>e(r)),[r],a);return null!=a&&pe(t.shape,a.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Vh(n),n[0]}))}}function Lh(e){return ue(Le(e),(()=>"The f passed in grads(f) must be a function")),(t,n)=>{ue(Array.isArray(t),(()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"));let r=ai(t,"args","tf.grads","string_or_numeric"),a=null!=n?ri(n,"dy","tf.grads"):null;return Hs.tidy((()=>{let{value:t,grads:n}=Hs.gradients((()=>e(...r)),r,a);return null!=a&&pe(t.shape,a.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Vh(n),n}))}}function Ph(e){return ue(Le(e),(()=>"The f passed in valueAndGrad(f) must be a function")),(t,n)=>{ue(t instanceof ks,(()=>"The x passed in valueAndGrad(f)(x) must be a tensor")),ue(null==n||n instanceof ks,(()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"));let{grads:r,value:a}=Hs.gradients((()=>e(t)),[t],n);return Vh(r),{grad:r[0],value:a}}}function zh(e){return ue(Le(e),(()=>"The f passed in valueAndGrads(f) must be a function")),(t,n)=>{ue(Array.isArray(t)&&t.every((e=>e instanceof ks)),(()=>"The args passed in valueAndGrads(f)(args) must be array of tensors")),ue(null==n||n instanceof ks,(()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"));let r=Hs.gradients((()=>e(...t)),t,n);return null!=n&&pe(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Vh(r.grads),r}}function Bh(e,t){ue(Le(e),(()=>"The f passed in variableGrads(f) must be a function")),ue(null==t||Array.isArray(t)&&t.every((e=>e instanceof Ss)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));let n=null!=t;if(!n){t=[];for(let e in Hs.registeredVariables)t.push(Hs.registeredVariables[e])}let r=n?t.filter((e=>!e.trainable)):null,a=t.length;t=t.filter((e=>e.trainable)),ue(t.length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${a} variables is trainable.`));let s=!0,{value:i,grads:o}=Hs.gradients(e,t,null,s);ue(o.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),ue(0===i.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`));let l={};return t.forEach(((e,t)=>{null!=o[t]&&(l[e.name]=o[t])})),null!=r&&r.forEach((e=>l[e.name]=null)),{value:i,grads:l}}function Wh(e){return Hs.customGrad(e)}function Vh(e){if(e.filter((e=>null==e)).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}function Uh(e){let t={x:ri(e,"x","softplus")};return Hs.runKernel(Or,t)}var Gh=ii({softplus_:Uh});function Hh(e){let t=ri(e,"x","logSigmoid");return Wh((e=>({value:Al(Gh(Al(e))),gradFunc:t=>Yu(t,Yp(Al(e)))})))(t)}var jh=ii({logSigmoid_:Hh});function qh(e,t){let n=ri(e,"a","sub"),r=ri(t,"b","sub");[n,r]=Ds(n,r);let a={a:n,b:r};return Hs.runKernel(Qr,a)}var Kh=ii({sub_:qh});function Xh(e,t=-1){let n=ri(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return Wh(((e,n)=>{let r=Mc(e,t,!0),a=Kh(e,r),s=Kh(vo(a,"float32"),Rh(jc(Qc(a),t,!0)));return n([s]),{value:s,gradFunc:(e,n)=>{let[r]=n,a=!0,s=Qc(r);return Kh(e,Yu(jc(e,t,a),s))}}}))(n)}var Yh=ii({logSoftmax_:Xh});function Zh(e,t=null,n=!1){let r=ri(e,"x","logSumExp"),a=Ie(t,r.shape),s=Mc(r,a,!0),i=Kh(r,s),o=Qc(i),l=jc(o,a),u=Rh(l),p=Gu(Vp(s,u.shape),u);if(n){let e=Ec(p.shape,a);return Vp(p,e)}return p}var Jh=ii({logSumExp_:Zh});function Qh(e,t){let n=ri(e,"a","logicalAnd","bool"),r=ri(t,"b","logicalAnd","bool");Bl(n.shape,r.shape);let a={a:n,b:r};return Hs.runKernel(Dn,a)}var ef=ii({logicalAnd_:Qh});function tf(e){let t={x:ri(e,"x","logicalNot","bool")};return Hs.runKernel(Mn,t)}var nf=ii({logicalNot_:tf});function rf(e,t){let n=ri(e,"a","logicalOr","bool"),r=ri(t,"b","logicalOr","bool");Bl(n.shape,r.shape);let a={a:n,b:r};return Hs.runKernel(On,a)}var af=ii({logicalOr_:rf});function sf(e,t){let n=ri(e,"a","logicalXor","bool"),r=ri(t,"b","logicalXor","bool");return Bl(n.shape,r.shape),ef(af(e,t),nf(ef(e,t)))}var of=ii({logicalXor_:sf}),lf=2147483648;function uf(e,t,n="left"){let r=ri(e,"sortedSequence","searchSorted"),a=ri(t,"values","searchSorted"),s=r.shape[r.shape.length-1],i=a.shape[a.shape.length-1],o=Vp(r,[-1,s]),l=Vp(a,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(he(l.shape)>=lf)throw new Error(`values tensor size must less than ${lf}`);if(o.shape[1]>=lf)throw new Error(`trailing dim_size must less than ${lf} for int32 output type, was ${o.shape[1]}`);let u={sortedSequence:o,values:l},p={side:n};return Hs.runKernel(_r,u,p)}var pf=ii({searchSorted_:uf});function df(e,t){return pf(e,t,"left")}function cf(e,t,n,r,a){let s=ri(e,"x","maxPool"),i=1,o=s,l=!1;3===s.rank&&(l=!0,o=Vp(s,[1,s.shape[0],s.shape[1],s.shape[2]])),ue(4===o.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`)),ue(Pp(n,i),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`)),Bp("maxPool",r,a);let u={x:o},p={filterSize:t,strides:n,pad:r,dimRoundingMode:a},d=Hs.runKernel(Un,u,p);return l?Vp(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var hf=ii({maxPool_:cf});function ff(e,t=[1,1,1],n,r,a,s="NDHWC"){let i=ri(e,"x","maxPool3d"),o=i,l=!1;4===i.rank&&(l=!0,o=Vp(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),ue(5===o.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`)),ue("NDHWC"===s,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),Bp("maxPool3d",r,a);let u={x:o},p={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},d=Hs.runKernel(Hn,u,p);return l?Vp(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var mf=ii({maxPool3d_:ff});function gf(e,t,n,r,a=!1){let s={x:ri(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:a},o=Hs.runKernel(qn,s,i);return{result:o[0],indexes:o[1]}}var yf=ii({maxPoolWithArgmax_:gf});function bf(e,t){let n=ri(e,"a","maximum"),r=ri(t,"b","maximum");[n,r]=Ds(n,r),"bool"===n.dtype&&(n=vo(n,"int32"),r=vo(r,"int32")),Bl(n.shape,r.shape);let a={a:n,b:r};return Hs.runKernel(Vn,a)}var wf=ii({maximum_:bf});function xf(e,t=null,n=!1){let r={x:ri(e,"x","mean")},a={axis:t,keepDims:n};return Hs.runKernel(Kn,r,a)}var vf=ii({mean_:xf});function kf(e,t="float32"){if("complex64"===t){let t=kf(e,"float32"),n=kf(e,"float32");return li(t,n)}let n=Ue(he(e),t);return Hs.makeTensor(n,e,t)}function If(e,t="float32"){if("complex64"===t){let t=If(e,"float32"),n=kf(e,"float32");return li(t,n)}let n=Ve(he(e),t);return Hs.makeTensor(n,e,t)}function Sf(e,t,{indexing:n="xy"}={}){if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===e)return[];let r=ri(e,"x","meshgrid",e instanceof ks?e.dtype:"float32");if(void 0===t)return[r];let a=ri(t,"y","meshgrid",t instanceof ks?t.dtype:"float32"),s=he(r.shape),i=he(a.shape);return"xy"===n?(r=Vp(r,[1,-1]),a=Vp(a,[-1,1]),[rl(If([i,1],r.dtype),r),rl(a,If([1,s],a.dtype))]):(r=Vp(r,[-1,1]),a=Vp(a,[1,-1]),[rl(r,If([1,i],r.dtype)),rl(If([s,1],a.dtype),a)])}function Nf(e,t){let n=ri(e,"a","minimum"),r=ri(t,"b","minimum");[n,r]=Ds(n,r),"bool"===n.dtype&&(n=vo(n,"int32"),r=vo(r,"int32")),Bl(n.shape,r.shape);let a={a:n,b:r};return Hs.runKernel(Yn,a)}var Tf=ii({minimum_:Nf});function Cf(e,t,n){ue("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));let r=ri(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");ue(t.length===r.rank,(()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`));let a="reflect"===n?1:0;for(let o=0;o<r.rank;o++)ue(2===t[o].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),ue(t[o][0]>=0&&t[o][0]<=r.shape[o]-a&&t[o][1]>=0&&t[o][1]<=r.shape[o]-a,(()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-a} or less than 0 for input of shape ${r.shape}`));let s={paddings:t,mode:n},i={x:r};return Hs.runKernel(Zn,i,s)}var _f=ii({mirrorPad_:Cf});function Ef(e,t){let n=ri(e,"a","mod"),r=ri(t,"b","mod");[n,r]=Ds(n,r);let a={a:n,b:r};return Hs.runKernel(Jn,a)}var Af=ii({mod_:Ef});function $f(e,t=null,n=!1){e=ri(e,"x","moments");let r=Ie(t,e.shape),a=vf(e,r,n),s=a.shape;n||(s=Ec(a.shape,r));let i=Gc(Kh(vo(e,"float32"),Vp(a,s))),o=vf(i,r,n);return{mean:a,variance:o}}var Ff=ii({moments_:$f});function Rf(e,t,n,r){let a=ri(t,"data","multiRNNCell"),s=ai(n,"c","multiRNNCell"),i=ai(r,"h","multiRNNCell"),o=a,l=[];for(let d=0;d<e.length;d++){let t=e[d](o,s[d],i[d]);l.push(t[0]),l.push(t[1]),o=t[1]}let u=[],p=[];for(let d=0;d<l.length;d+=2)u.push(l[d]),p.push(l[d+1]);return[u,p]}var Df=ii({multiRNNCell_:Rf});function Mf(e,t,n,r=!1){let a=ri(e,"logits","multinomial"),s=a.size,i=a.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();let o={logits:1===i?Vp(a,[1,-1]):a},l={numSamples:t,seed:n,normalized:r},u=Hs.runKernel(Qn,o,l);return 1===i?Vp(u,[u.size]):u}var Of=ii({multinomial_:Mf});function Lf(e,t){let n=ri(e,"a","notEqual","string_or_numeric"),r=ri(t,"b","notEqual","string_or_numeric");[n,r]=Ds(n,r),Bl(n.shape,r.shape);let a={a:n,b:r};return Hs.runKernel(nr,a)}var Pf=ii({notEqual_:Lf});function zf(e){let t={x:ri(e,"x","onesLike")};return Hs.runKernel(ir,t)}var Bf=ii({onesLike_:zf});function Wf(e,t){let n=ri(e,"v1","outerProduct"),r=ri(t,"v2","outerProduct");ue(1===n.rank&&1===r.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`));let a=Vp(n,[-1,1]),s=Vp(r,[1,-1]);return rl(a,s)}var Vf=ii({outerProduct_:Wf});function Uf(e,t,n=0){let r=ri(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let a={paddings:t,constantValue:n},s={x:r};return Hs.runKernel(ur,s,a)}var Gf=ii({pad_:Uf});function Hf(e,t,n=0){return ue(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),Gf(e,[t],n)}var jf=ii({pad1d_:Hf});function qf(e,t,n=0){return ue(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Gf(e,t,n)}var Kf=ii({pad2d_:qf});function Xf(e,t,n=0){return ue(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Gf(e,t,n)}var Yf=ii({pad3d_:Xf});function Zf(e,t,n=0){return ue(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Gf(e,t,n)}var Jf=ii({pad4d_:Zf});function Qf(e,t,n){let r=ri(e,"x","spaceToBatchND");ue(r.rank>=1+t.length,(()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`)),ue(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),ue(r.shape.reduce(((e,r,a)=>a>0&&a<=t.length?e&&(r+n[a-1][0]+n[a-1][1])%t[a-1]===0:e),!0),(()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));let a={x:r},s={blockShape:t,paddings:n};return Hs.runKernel(zr,a,s)}var em=ii({spaceToBatchND_:Qf});function tm(e,t,n,r,a,s,i){null==a&&(a=[1,1]),null==s&&(s=1),0===r&&(r="valid");let o=ri(e,"x","maxPool"),l=o,u=!1;3===o.rank&&(u=!0,l=Vp(o,[1,o.shape[0],o.shape[1],o.shape[2]])),ue(Pp(s,a),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${a}'`));let p,d=Sp(l.shape,t,s,a,r),c=[d.dilationHeight,d.dilationWidth];p="same"===r?rm([d.filterHeight,d.filterWidth],c):[[0,0],[0,0]];let h=1===c[0]&&1===c[1],[f,m]=nm([d.inHeight,d.inWidth],c,p),g=h?r:"valid",y=h?l:em(l,c,f),b=("avg"===n?()=>Gp(y,t,s,g,i):()=>hf(y,t,s,g,i))(),w=h?b:ad(b,c,m);return u?Vp(w,[w.shape[1],w.shape[2],w.shape[3]]):w}function nm(e,t,n){let r=n.map((e=>e[0])),a=n.map((e=>e[1])),s=e.concat(r,a),i=t.map(((e,t)=>(e-s[t]%e)%e)),o=a.map(((e,t)=>e+i[t])),l=t.map(((e,t)=>[r[t],o[t]])),u=t.map(((e,t)=>[0,i[t]]));return[l,u]}function rm(e,t){let n=e.map(((e,n)=>e+(e-1)*(t[n]-1))).map((e=>e-1)),r=n.map((e=>Math.floor(e/2))),a=n.map(((e,t)=>e-r[t]));return n.map(((e,t)=>[r[t],a[t]]))}var am=ii({pool_:tm});function sm(e,t){let n=ri(e,"x","prelu"),r=ri(t,"alpha","prelu"),a={x:n,alpha:r};return Hs.runKernel(cr,a)}var im=ii({prelu_:sm});function om(e,t=null,n=!1){let r=ri(e,"x","prod");"bool"===r.dtype&&(r=vo(r,"int32"));let a={x:r},s={axis:t,keepDims:n};return Hs.runKernel(hr,a,s)}var lm=ii({prod_:om});function um(e,t,n){let r=he(e),a=null;if(null==n||"float32"===n)a=new Float32Array(r);else if("int32"===n)a=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);a=new Uint8Array(r)}for(let s=0;s<r;s++)a[s]=t();return Hs.makeTensor(a,e,n)}var pm=ii({rand_:um}),dm=I(M()),cm=class{constructor(e,t,n,r,a){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);let s=a||Math.random();this.random=dm.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){let e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,a,s;do{r=2*this.random()-1,a=2*this.random()-1,s=r*r+a*a}while(s>=1||0===s);let i=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*a*i,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},hm=class{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;let a=r||Math.random();this.randu=dm.alea(a.toString()),this.randn=new cm(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,a,s;for(;;){do{r=this.randn.nextValue(),s=1+this.c*r}while(s<=0);if(s*=s*s,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-s+Math.log(s)),a=this.randu(),a<t||Math.log(a)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}},fm=class{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=dm.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function mm(e,t,n=1,r="float32",a){if(null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);let s=new hm(t,n,r,a),i=wo(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var gm=ii({randomGamma_:mm});function ym(e,t=0,n=1,r,a){if(null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);let s=new cm(t,n,r,!1,a),i=wo(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var bm=ii({randomNormal_:ym});function wm(e,t=0,n=1,r="float32",a){let s=wo(e,r),i=new fm(t,n,null,a);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}var xm=ii({randomUniform_:wm});function vm(e,t,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");let a={start:e,stop:t,step:n,dtype:r};return Hs.runKernel(fr,{},a)}function km(e){let t={x:ri(e,"x","reciprocal")};return Hs.runKernel(gr,t)}var Im=ii({reciprocal_:km});function Sm(e){let t={x:ri(e,"x","relu")};return Hs.runKernel(yr,t)}var Nm=ii({relu_:Sm});function Tm(e){let t={x:ri(e,"x","relu6")};return Hs.runKernel(Ir,t)}var Cm=ii({relu6_:Tm});function _m(e,t){let n={x:ri(e,"x","reverse")},r={dims:t};return Hs.runKernel(Sr,n,r)}var Em=ii({reverse_:_m});function Am(e){let t=ri(e,"x","reverse");return ue(1===t.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`)),Em(t,0)}var $m=ii({reverse1d_:Am});function Fm(e,t){let n=ri(e,"x","reverse");return ue(2===n.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`)),Em(n,t)}var Rm=ii({reverse2d_:Fm});function Dm(e,t){let n=ri(e,"x","reverse");return ue(3===n.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`)),Em(n,t)}var Mm=ii({reverse3d_:Dm});function Om(e,t){let n=ri(e,"x","reverse");return ue(4===n.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`)),Em(n,t)}var Lm=ii({reverse4d_:Om});function Pm(e){let t={x:ri(e,"x","round")};return Hs.runKernel(Nr,t)}var zm=ii({round_:Pm});function Bm(e){let t={x:ri(e,"x","rsqrt","float32")};return Hs.runKernel(Tr,t)}var Wm=ii({rsqrt_:Bm});function Vm(e){let t={x:ri(e,"x","selu")};return Hs.runKernel(Ar,t)}var Um=ii({selu_:Vm});function Gm(e,t,n,r,a,s=[1,1],i="NHWC"){let o=ri(e,"x","separableConv2d"),l=ri(t,"depthwiseFilter","separableConv2d"),u=ri(n,"pointwiseFilter","separableConv2d"),p=o,d=!1;if(3===o.rank&&(d=!0,p=Vp(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");ue(4===p.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${p.rank}.`)),ue(4===l.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`)),ue(4===u.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`)),ue(1===u.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`)),ue(1===u.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`));let c=l.shape[2],h=l.shape[3];ue(u.shape[2]===c*h,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${c*h}, but got ${u.shape[2]}.`));let f=sc(p,l,r,a,i,s),m=Rd(f,u,1,"valid",i);return d?Vp(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var Hm=ii({separableConv2d_:Gm});async function jm(e,t){let n=ri(e,"x","setdiff1d"),r=ri(t,"y","setdiff1d");ue(n.dtype===r.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`)),ue(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),ue(1===r.rank,(()=>`y should be 1D tensor, but got y (${r.shape}).`));let a=await n.data(),s=await r.data(),i=new Set(s),o=0;for(let p=0;p<a.length;p++)i.has(a[p])||o++;let l=new gs([o],n.dtype),u=new gs([o],"int32");for(let p=0,d=0;p<a.length;p++)i.has(a[p])||(l.values[d]=a[p],u.values[d]=p,d++);return[l.toTensor(),u.toTensor()]}var qm=jm;function Km(e){let t={x:ri(e,"x","sign")};return Hs.runKernel(Dr,t)}var Xm=ii({sign_:Km});function Ym(e){let t={x:ri(e,"x","sin","float32")};return Hs.runKernel(Fr,t)}var Zm=ii({sin_:Ym});function Jm(e){let t={x:ri(e,"x","sinh")};return Hs.runKernel(Rr,t)}var Qm=ii({sinh_:Jm});function eg(e,t,n){let r=ri(e,"x","slice1d");return ue(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),Jp(r,[t],[n])}var tg=ii({slice1d_:eg});function ng(e,t,n){let r=ri(e,"x","slice2d");return ue(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),Jp(r,t,n)}var rg=ii({slice2d_:ng});function ag(e,t,n){let r=ri(e,"x","slice3d");return ue(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),Jp(r,t,n)}var sg=ii({slice3d_:ag});function ig(e,t,n){let r=ri(e,"x","slice4d");return ue(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),Jp(r,t,n)}var og=ii({slice4d_:ig});function lg(e,t=-1){let n=ri(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let r={logits:n},a={dim:t};return Hs.runKernel(Wr,r,a)}var ug=ii({softmax_:lg});function pg(e){ue("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));let t={input:e};return Hs.runKernel(cn,t)}var dg=ii({fft_:pg});function cg(e){ue("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));let t={input:e};return Hs.runKernel(In,t)}var hg=ii({ifft_:cg});function fg(e){let t,n=e.shape[e.shape.length-1],r=e.size/n;if(n<=2){let a=Vp(e,[r,n]);t=hg(a)}else{let a=[r,2*(n-1)],s=Vp(Fl(e),[r,n]),i=Vp(_l(e),[r,n]),o=Em(Jp(s,[0,1],[r,n-2]),1),l=Yu(Em(Jp(i,[0,1],[r,n-2]),1),Bc(-1)),u=Kp([s,o],1),p=Kp([i,l],1),d=Vp(li(u,p),[a[0],a[1]]);t=hg(d)}if(t=Fl(t),3===e.rank&&0!==e.shape[0]){let n=t,r=e.shape[0];t=Vp(t,[r,t.shape[0]/r,t.shape[1]]),n.dispose()}return t}var mg=ii({irfft_:fg});function gg(e,t,n=0){let r={x:ri(e,"x","split")},a={numOrSizeSplits:t,axis:n};return Hs.runKernel(Br,r,a)}var yg=ii({split_:gg});function bg(e,t){ue("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n,r=e.shape[e.shape.length-1],a=e.size/r;if(null!=t&&t<r){let a=e.shape.map((e=>0)),s=e.shape.map((e=>e));s[e.shape.length-1]=t,n=Jp(e,a,s),r=t}else if(null!=t&&t>r){let a=e.shape.map((e=>e));a[e.shape.length-1]=t-r,n=Kp([e,kf(a)],e.shape.length-1),r=t}else n=e;let s=mc(n),i=Vp(li(n,s),[a,r]),o=dg(i),l=Math.floor(r/2)+1,u=Fl(o),p=_l(o),d=yg(u,[l,r-l],u.shape.length-1),c=yg(p,[l,r-l],p.shape.length-1),h=n.shape.slice();return h[n.shape.length-1]=l,Vp(li(d[0],c[0]),h)}var wg=ii({rfft_:bg});function xg(e,t){let n=ri(e,"a","squaredDifference"),r=ri(t,"b","squaredDifference");[n,r]=Ds(n,r),Bl(n.shape,r.shape);let a={a:n,b:r},s={};return Hs.runKernel(qr,a,s)}var vg=ii({squaredDifference_:xg});function kg(e,t){let n=ri(e,"x","squeeze");return Vp(n,Se(n.shape,t).newShape)}var Ig=ii({squeeze_:kg});function Sg(e,t=0){let n=ai(e,"tensors","stack","string_or_numeric");ue(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&ue(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));let r=n,a={axis:t};return Hs.runKernel(lr,r,a)}var Ng=ii({stack_:Sg});function Tg(e,t=0){let n={x:ri(e,"x","step")},r={alpha:t};return Hs.runKernel(da,n,r)}var Cg=ii({step_:Tg});function _g(e,t,n,r,a=0,s=0,i=0,o=0,l=0){let u={x:ri(e,"x","stridedSlice","string_or_numeric")},p={begin:t,end:n,strides:r,beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return Hs.runKernel(Xr,u,p)}var Eg=ii({stridedSlice_:_g});function Ag(e){let t={x:ri(e,"x","tan","float32")};return Hs.runKernel(ea,t)}var $g=ii({tan_:Ag});function Fg(e,t){de(e);let n=ei(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return ui(e,null,n,t)}function Rg(e,t,n){if(de(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");let r=ei(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return ui(e,t,r,n)}function Dg(e,t,n){if(de(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");let r=ei(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return ui(e,t,r,n)}function Mg(e,t,n){if(de(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");let r=ei(e,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return ui(e,t,r,n)}function Og(e,t,n){if(de(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");let r=ei(e,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||r,ui(e,t,r,n)}function Lg(e,t=1,n=!0){let r=ri(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");let a=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>a)throw new Error(`'k' passed to topk() must be <= the last dimension (${a}) but got ${t}`);let s={x:r},i={k:t,sorted:n},[o,l]=Hs.runKernel(ra,s,i);return{values:o,indices:l}}var Pg=ii({topk_:Lg});function zg(e,t=0,n=1,r,a){if(null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");let s=new cm(t,n,r,!0,a),i=wo(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var Bg=ii({truncatedNormal_:zg});function Wg(e,t=0){let n=ri(e,"x","unique","string_or_numeric");ue(n.rank>0,(()=>"The input tensor must be at least 1D"));let r={x:n},a={axis:t},[s,i]=Hs.runKernel(ia,r,a);return{values:s,indices:i}}var Vg=ii({unique_:Wg});function Ug(e,t,n){let r=ri(e,"x","unsortedSegmentSum"),a=ri(t,"segmentIds","unsortedSegmentSum","int32");ue(ge(n),(()=>"numSegments must be of dtype int"));let s={x:r,segmentIds:a},i={numSegments:n};return Hs.runKernel(la,s,i)}var Gg=ii({unsortedSegmentSum_:Ug});function Hg(e,t=0){let n=ri(e,"x","unstack","string_or_numeric");ue(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));let r={value:n},a={axis:t};return Hs.runKernel(oa,r,a)}var jg=ii({unstack_:Hg});function qg(e,t){return pf(e,t,"right")}function Kg(e,t=!0,n,r){return Hs.makeVariable(e,t,n,r)}function Xg(e,t){let n=[];for(let s=0;s<t.length;s++)t[s]&&n.push(s);let r=wo(e,"int32"),a=wo([n.length,e.length],"int32");for(let s=0;s<n.length;s++){let t=r.indexToLoc(n[s]),i=s*e.length;a.values.set(t,i)}return a.toTensor()}async function Yg(e){let t=ri(e,"condition","whereAsync","bool"),n=await t.data(),r=Xg(t.shape,n);return e!==t&&t.dispose(),r}var Zg=Yg;async function Jg(e,t,n){let r=ri(e,"tensor","boolMask"),a=ri(t,"mask","boolMask","bool"),s=null==n?0:n,i=a.rank,o=r.shape;ue(i>0,(()=>"mask cannot be scalar")),pe(o.slice(s,s+i),a.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=s;m<s+i;m++)l*=o[m];let u=o.slice(0,s).concat([l],o.slice(s+i)),p=Vp(r,u),d=Vp(a,[-1]),c=await Zg(d),h=Ig(c,[1]),f=ch(p,h,s);return e!==r&&r.dispose(),t!==a&&a.dispose(),h.dispose(),p.dispose(),d.dispose(),c.dispose(),f}var Qg=Jg;function ey(e,t,n,r,a=!0){let s=ri(e,"v","movingAverage"),i=ri(t,"x","movingAverage"),o=ri(n,"decay","movingAverage");Ms(s,i),ue(me(s.shape,i.shape),(()=>"Shape mismatch in v and x"));let l=Bc(1),u=Kh(l,o),p=Yu(Kh(i,s),u);if(a){ue(null!=r,(()=>"When using zeroDebias: true, step is required."));let e=ri(r,"step","movingAverage");p=Ku(p,Kh(l,zc(o,e)))}return Gu(s,p)}var ty=ii({movingAverage_:ey});function ny(e,t,n){let r=ri(e,"indices","scatterND","int32"),a=ri(t,"updates","scatterND");nu(a,r,n);let s={indices:r,updates:a},i={shape:n};return Hs.runKernel(Cr,s,i)}var ry=ii({scatterND_:ny});function ay(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let a=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);let i=t.size;if(0!==t.rank&&(1!==t.rank||i!==a))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${a}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function sy(e,t,n,r=0){let a=ri(e,"sparseIndices","sparseToDense","int32"),s=ri(t,"sparseValues","sparseToDense","string_or_numeric"),i=ri(r,"defaultValue","sparseToDense",s.dtype);ay(a,s,n,i);let o={sparseIndices:a,sparseValues:s,defaultValue:i},l={outputShape:n};return Hs.runKernel(jr,o,l)}var iy=ii({sparseToDense_:sy});function oy(e,t){let n=ri(t,"indices","gatherND","int32"),r={params:ri(e,"x","gatherND","string_or_numeric"),indices:n};return Hs.runKernel(wn,r)}var ly=ii({gatherND_:oy});function uy(e,t){if(null==t)return e.shape.slice();if(me(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}function py(e,t,n,r){let a=ri(e,"x","dropout");if(ue("float32"===a.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${a.dtype} tensor instead.`)),ue(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return e instanceof ks?a.clone():a;let s=uy(a,n),i=1-t,o=Ku(ph(Gu(xm(s,0,1,"float32",r),i)),i);return Yu(a,o)}var dy=ii({dropout_:py});function cy(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function hy(e,t,n){let r=1-e%2,a=new Float32Array(e);for(let s=0;s<e;++s){let i=2*Math.PI*s/(e+r-1);a[s]=t-n*Math.cos(i)}return Fg(a,"float32")}async function fy(e,t,n=1){let r=ri(e,"predictions","inTopK"),a=ri(t,"targets","inTopK");ue(r.rank>1,(()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`)),ue(r.rank-1===a.rank,(()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${a.rank}`)),pe(r.shape.slice(0,r.shape.length-1),a.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=r.shape[r.shape.length-1];ue(n>0&&n<=s,(()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`));let i=await r.data(),o=await a.data(),[l,u]=[i.length/s,s],p=Ne("bool",l);for(let d=0;d<l;d++){let e=d*u,t=i.subarray(e,e+u),r=[];for(let n=0;n<t.length;n++)r.push({value:t[n],index:n});r.sort(((e,t)=>t.value-e.value)),p[d]=0;for(let a=0;a<n;a++)if(r[a].index===o[d]){p[d]=1;break}}return e!==r&&r.dispose(),t!==a&&a.dispose(),pi(p,a.shape,"bool")}var my=fy,gy={};function yy(e,t,n,r,a,s="NHWC",i){let o=e;3===e.rank&&(o=Vp(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=Vp(t,[1,t.shape[0],t.shape[1],t.shape[2]])),ue(4===o.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`)),ue(4===l.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`)),ue(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));let u="NHWC"===s?o.shape[3]:o.shape[1],p="NHWC"===s?l.shape[3]:l.shape[1];ue(u===n[2],(()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`)),ue(p===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${p}) must match output depth for filter (${n[3]}).`)),Bp("conv2dDerFilter",a,i);let d={x:o,dy:l},c={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,filterShape:n};return Hs.runKernel(Lt,d,c)}v(gy,{conv2d:()=>Sy,depthwiseConv2d:()=>Ay,matMul:()=>Fy});var by=ii({conv2DBackpropFilter_:yy});function wy(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return Yu(e,Cg(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function xy(e,t){let n=t,r=zl(e.shape,t.shape);return r.length>0&&(n=jc(n,r)),Vp(n,e.shape)}function vy(e,t,n,r){if("linear"===t)return e;if("relu"===t)return Nm(e);if("elu"===t)return Ic(e);if("relu6"===t)return Cm(e);if("prelu"===t)return im(e,n);if("leakyrelu"===t)return Sh(e,r);if("sigmoid"===t)return Yp(e);throw new Error(`Unknown fused activation ${t}.`)}var ky=(e,t)=>!(e>0)||"linear"===t;function Iy({x:e,filter:t,strides:n,pad:r,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:p}){if(l=l||"linear",!1===ky(Hs.state.gradientDepth,l)){ue("NHWC"===a,(()=>`Error in fused conv2d: got dataFormat of ${a} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let d=Rd(e,t,n,r,a,s,i);return null!=o&&(d=Gu(d,o)),vy(d,l,u,p)}let d=ri(e,"x","conv2d","float32"),c=ri(t,"filter","conv2d","float32"),h=d,f=!1;3===d.rank&&(f=!0,h=Vp(d,[1,d.shape[0],d.shape[1],d.shape[2]])),ue(4===h.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${h.rank}.`)),ue(4===c.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${c.rank}.`)),Bp("fused conv2d",r,i);let m="NHWC"===a?h.shape[3]:h.shape[1];ue(c.shape[2]===m,(()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${c.shape[2]}.`)),ue(Pp(n,s),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`));let g,y,b=Tp(h.shape,c.shape,n,s,r,i);if(null!=o&&(g=ri(o,"bias","fused conv2d"),[g]=Ds(g,d),"NHWC"===a?Bl(b.outShape,g.shape):(ue(g.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${g.shape.length}.`)),ue(0===g.shape.length||g.shape[0]===b.outChannels||1===g.shape[0],(()=>`Error in fused conv2d: bias shape (${g.shape}) is not compatible with the number of output channels (${b.outChannels})`)))),null!=u){let e=u.shape;if(ue(e.length<=1||3===e.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`)),1===e.length)ue(1===e[0]||e[0]===b.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${b.outChannels}).`));else if(3===e.length)try{Bl(e,b.outShape)}catch(k){let t=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${b.outShape}).`;throw Error(t)}y=ri(u,"prelu weights","fused conv2d")}let w=(e,t)=>{ue("NHWC"===a,(()=>`Error in gradient of fused conv2D: got dataFormat of ${a} but only NHWC is currently supported.`));let[i,o,u,p]=t,d=wy(e,u,l);ue(Lp(s),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`));let c=Ld(o.shape,d,i,n,r),h=by(o,d,i.shape,n,r),f=[c,h];if(null!=p){let e=xy(p,d);f.push(e)}return f},x={x:h,filter:c,bias:g,preluActivationWeights:y},v={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:p};return null==o?Wh(((e,t,n)=>{let r=Hs.runKernel(ma,x,v);return n([t,e,r]),f&&(r=Vp(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:w}}))(h,c):Wh(((e,t,n,r)=>{let a=Hs.runKernel(ma,x,v);return r([t,e,a,n]),f&&(a=Vp(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:w}}))(h,c,g)}var Sy=ii({fusedConv2d_:Iy});function Ny(e,t,n,r,a,s=[1,1],i){let o=e;3===e.rank&&(o=Vp(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=Vp(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={x:o,dy:l},p={strides:r,pad:a,dimRoundingMode:i,dilations:s,filterShape:n};return Hs.runKernel(Yt,u,p)}var Ty=ii({depthwiseConv2dNativeBackpropFilter_:Ny});function Cy(e,t,n,r,a,s=[1,1],i){let o=t,l=!1;3===t.rank&&(l=!0,o=Vp(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={dy:o,filter:n},p={strides:r,pad:a,dimRoundingMode:i,dilations:s,inputShape:e},d=Hs.runKernel(Zt,u,p);return l?Vp(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var _y=ii({depthwiseConv2dNativeBackpropInput_:Cy});function Ey({x:e,filter:t,strides:n,pad:r,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:p}){if(!1===ky(Hs.state.gradientDepth,l)){let d=sc(e,t,n,r,a,s,i);return null!=o&&(d=Gu(d,o)),vy(d,l,u,p)}let d=ri(e,"x","depthwiseConv2d","float32"),c=ri(t,"filter","depthwiseConv2d","float32"),h=d,f=!1;3===d.rank&&(f=!0,h=Vp(d,[1,d.shape[0],d.shape[1],d.shape[2]])),ue(4===h.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`)),ue(4===c.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${c.rank}.`)),ue(h.shape[3]===c.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${h.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`)),null==s&&(s=[1,1]),ue(Pp(n,s),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),Bp("fused depthwiseConv2d",r,i);let m,g,y=Tp(h.shape,c.shape,n,s,r,i,!0);null!=o&&(m=ri(o,"bias","fused conv2d"),[m]=Ds(m,d),Bl(y.outShape,m.shape)),null!=u&&(g=ri(u,"prelu weights","fused depthwiseConv2d"));let b=(e,t)=>{ue(Lp(s),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`));let[a,o,u,p]=t,d=wy(e,u,l),c=_y(o.shape,d,a,n,r,s,i),h=Ty(o,d,a.shape,n,r,s,i);if(null!=p){let e=xy(m,d);return[c,h,e]}return[c,h]},w={x:h,filter:c,bias:m,preluActivationWeights:g},x={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:p};return null==o?Wh(((e,t,n)=>{let r=Hs.runKernel(ga,w,x);return n([t,e,r]),f&&(r=Vp(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:b}}))(h,c):Wh(((e,t,n,r)=>{let a=Hs.runKernel(ga,w,x);return r([t,e,a,n]),f&&(a=Vp(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:b}}))(h,c,m)}var Ay=ii({fusedDepthwiseConv2d_:Ey});function $y({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:a,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:o}){if(!1===ky(Hs.state.gradientDepth,s)){let l=rl(e,t,n,r);return null!=a&&(l=Gu(l,a)),vy(l,s,i,o)}let l=ri(e,"a","fused matMul"),u=ri(t,"b","fused matMul");[l,u]=Ds(l,u);let p=n?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?u.shape[u.rank-1]:u.shape[u.rank-2],c=n?l.shape[l.rank-1]:l.shape[l.rank-2],h=r?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=he(f),y=he(m);ue(p===d,(()=>`Error in fused matMul: inner shapes (${p}) and (${d}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${r} must match.`));let b,w,x=Bl(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([c,h]),v=Vp(l,n?[g,p,c]:[g,c,p]),k=Vp(u,r?[y,h,d]:[y,d,h]);null!=a&&(b=ri(a,"bias","fused matMul"),[b]=Ds(b,l),Bl(x,b.shape)),null!=i&&(w=ri(i,"prelu weights","fused matMul"));let I=(e,t)=>{let i,o,[l,u,p,d]=t,c=wy(Vp(e,p.shape),p,s);if(n||r?!n&&r?(i=rl(c,u,!1,!1),o=rl(c,l,!0,!1)):n&&!r?(i=rl(u,c,!1,!0),o=rl(l,c,!1,!1)):(i=rl(u,c,!0,!0),o=rl(c,l,!0,!0)):(i=rl(c,u,!1,!0),o=rl(l,c,!0,!1)),null!=a){let e=xy(d,c);return[i,o,e]}return[i,o]},S={a:v,b:k,bias:b,preluActivationWeights:w},N={transposeA:n,transposeB:r,activation:s,leakyreluAlpha:o};return null==a?Wh(((e,t,n)=>{let r=Hs.runKernel(fa,S,N);return n([e,t,r]),{value:Vp(r,x),gradFunc:I}}))(v,k):Wh(((e,t,n,r)=>{let a=Hs.runKernel(fa,S,N);return r([e,t,a,n]),{value:Vp(a,x),gradFunc:I}}))(v,k,b)}var Fy=ii({fusedMatMul_:$y});function Ry(e){return hy(e,.54,.46)}var Dy=ii({hammingWindow_:Ry});function My(e){return hy(e,.5,.5)}var Oy=ii({hannWindow_:My});function Ly(e,t,n,r=!1,a=0){let s=0,i=[];for(;s+t<=e.size;)i.push(Jp(e,s,t)),s+=n;if(r)for(;s<e.size;){let r=s+t-e.size,o=Kp([Jp(e,s,t-r),lh([r],a)]);i.push(o),s+=n}return 0===i.length?Rg([],[0,t]):Vp(Kp(i),[i.length,t])}var Py=ii({frame_:Ly});function zy(e,t,n,r,a=Oy){null==r&&(r=cy(t));let s=Py(e,t,n),i=Yu(s,a(t));return wg(i,r)}var By=ii({stft_:zy});function Wy(e,t,n,r,a="bilinear",s=0){let i=ri(e,"image","cropAndResize"),o=ri(t,"boxes","cropAndResize","float32"),l=ri(n,"boxInd","cropAndResize","int32"),u=o.shape[0];ue(4===i.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`)),ue(2===o.rank&&4===o.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`)),ue(1===l.rank&&l.shape[0]===u,(()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`)),ue(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),ue(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),ue("bilinear"===a||"nearest"===a,(()=>`method must be bilinear or nearest, but was ${a}`));let p={image:i,boxes:o,boxInd:l},d={method:a,extrapolationValue:s,cropSize:r};return Hs.runKernel(jt,p,d)}var Vy=ii({cropAndResize_:Wy});function Uy(e){let t=ri(e,"image","flipLeftRight","float32");ue(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));let n={image:t};return Hs.runKernel(fn,n,{})}var Gy=ii({flipLeftRight_:Uy});function Hy(e){let t=ri(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];ue(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),ue(1===r,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`));let a=new Array(t.rank);return a.fill(1,0,n),a[n]=3,sh(t,a)}var jy=ii({grayscaleToRGB_:Hy});function qy(e,t,n=0,r=.5){let a=ri(e,"image","rotateWithOffset","float32");ue(4===a.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`));let s={image:a},i={radians:t,fillValue:n,center:r};return Hs.runKernel(ha,s,i)}var Ky=ii({rotateWithOffset_:qy});function Xy(e,t,n,r,a,s){null==r&&(r=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==s&&(s=0);let i=e.shape[0];return n=Math.min(n,i),ue(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),ue(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),ue(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),ue(1===t.rank,(()=>"scores must be a 1D tensor")),ue(t.shape[0]===i,(()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`)),ue(0<=s&&s<=1,(()=>`softNmsSigma must be in [0, 1], but was '${s}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s}}function Yy(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY){let s=ri(e,"boxes","nonMaxSuppression","float32"),i=ri(t,"scores","nonMaxSuppression","float32"),o=Xy(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;let l={maxOutputSize:n,iouThreshold:r,scoreThreshold:a};return Hs.runKernel(rr,{boxes:s,scores:i},l)}var Zy=ii({nonMaxSuppression_:Yy});function Jy(e,t,n){let r=Qy(e,t,n),a=r<0?-(r+1):r;e.splice(a,0,t)}function Qy(e,t,n){return tb(e,t,n||eb)}function eb(e,t){return e>t?1:e<t?-1:0}function tb(e,t,n){let r=0,a=e.length,s=0,i=!1;for(;r<a;){s=r+(a-r>>>1);let o=n(t,e[s]);o>0?r=s+1:(a=s,i=!o)}return i?r:-r-1}function nb(e,t,n,r,a){return sb(e,t,n,r,a,0)}function rb(e,t,n,r,a,s){return sb(e,t,n,r,a,0,!1,s,!0)}function ab(e,t,n,r,a,s){return sb(e,t,n,r,a,s,!0)}function sb(e,t,n,r,a,s,i=!1,o=!1,l=!1){let u=[];for(let g=0;g<t.length;g++)t[g]>a&&u.push({score:t[g],boxIndex:g,suppressBeginIndex:0});u.sort(lb);let p=s>0?-.5/s:0,d=[],c=[];for(;d.length<n&&u.length>0;){let t=u.pop(),{score:n,boxIndex:s,suppressBeginIndex:i}=t;if(n<a)break;let o=!1;for(let l=d.length-1;l>=i;--l){let n=ib(e,s,d[l]);if(n>=r){o=!0;break}if(t.score=t.score*ob(r,p,n),t.score<=a)break}t.suppressBeginIndex=d.length,o||(t.score===n?(d.push(s),c.push(t.score)):t.score>a&&Jy(u,t,lb))}let h=d.length,f=n-h;o&&f>0&&(d.push(...new Array(f).fill(0)),c.push(...new Array(f).fill(0)));let m={selectedIndices:d};return i&&(m.selectedScores=c),l&&(m.validOutputs=h),m}function ib(e,t,n){let r=e.subarray(4*t,4*t+4),a=e.subarray(4*n,4*n+4),s=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(a[0],a[2]),p=Math.min(a[1],a[3]),d=Math.max(a[0],a[2]),c=Math.max(a[1],a[3]),h=(o-s)*(l-i),f=(d-u)*(c-p);if(h<=0||f<=0)return 0;let m=Math.max(s,u),g=Math.max(i,p),y=Math.min(o,d),b=Math.min(l,c),w=Math.max(y-m,0)*Math.max(b-g,0);return w/(h+f-w)}function ob(e,t,n){let r=Math.exp(t*n*n);return n<=e?r:0}function lb(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function ub(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY){let s=ri(e,"boxes","nonMaxSuppressionAsync"),i=ri(t,"scores","nonMaxSuppressionAsync"),o=Xy(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;let l=await Promise.all([s.data(),i.data()]),u=l[0],p=l[1],{selectedIndices:d}=nb(u,p,n,r,a);return s!==e&&s.dispose(),i!==t&&i.dispose(),Fg(d,"int32")}var pb=ub;function db(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=0){let i=ri(e,"boxes","nonMaxSuppression"),o=ri(t,"scores","nonMaxSuppression"),l=Xy(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;let u={boxes:i,scores:o},p={maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s},d=Hs.runKernel(sr,u,p);return{selectedIndices:d[0],selectedScores:d[1]}}var cb=ii({nonMaxSuppressionWithScore_:db});async function hb(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=0){let i=ri(e,"boxes","nonMaxSuppressionAsync"),o=ri(t,"scores","nonMaxSuppressionAsync"),l=Xy(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;let u=await Promise.all([i.data(),o.data()]),p=u[0],d=u[1],{selectedIndices:c,selectedScores:h}=ab(p,d,n,r,a,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Fg(c,"int32"),selectedScores:Fg(h)}}var fb=hb;function mb(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=!1){let i=ri(e,"boxes","nonMaxSuppression"),o=ri(t,"scores","nonMaxSuppression"),l=Xy(i,o,n,r,a,null),u=l.maxOutputSize,p=l.iouThreshold,d=l.scoreThreshold,c={boxes:i,scores:o},h={maxOutputSize:u,iouThreshold:p,scoreThreshold:d,padToMaxOutputSize:s},f=Hs.runKernel(ar,c,h);return{selectedIndices:f[0],validOutputs:f[1]}}var gb=ii({nonMaxSuppressionPadded_:mb});async function yb(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=!1){let i=ri(e,"boxes","nonMaxSuppressionAsync"),o=ri(t,"scores","nonMaxSuppressionAsync"),l=Xy(i,o,n,r,a,null),u=l.maxOutputSize,p=l.iouThreshold,d=l.scoreThreshold,[c,h]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=rb(c,h,u,p,d,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Fg(f,"int32"),validOutputs:Bc(m,"int32")}}var bb=yb;function wb(e,t,n=!1,r=!1){let a=ri(e,"images","resizeBilinear");ue(3===a.rank||4===a.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a.rank}.`)),ue(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),ue(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let s=a,i=!1;3===a.rank&&(i=!0,s=Vp(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let[]=t,o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},u=Hs.runKernel(vr,o,l);return i?Vp(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var xb=ii({resizeBilinear_:wb});function vb(e,t,n=!1,r=!1){let a=ri(e,"images","resizeNearestNeighbor");ue(3===a.rank||4===a.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a.rank}.`)),ue(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),ue("float32"===a.dtype||"int32"===a.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),ue(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let s=a,i=!1;3===a.rank&&(i=!0,s=Vp(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let[]=t,o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},u=Hs.runKernel(wr,o,l);return i?Vp(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var kb=ii({resizeNearestNeighbor_:vb});function Ib(e,t="binary",n=!1,r=.5){let a,s,i,o,l=ri(e,"image","threshold"),u=.2989,p=.587,d=.114,c=l.shape[0]*l.shape[1],h=Yu(Fg([r]),255);if(ue(3===l.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${l.rank}.`)),ue(3===l.shape[2]||1===l.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${l.shape[2]}.`)),ue("int32"===l.dtype||"float32"===l.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${l.dtype}.`)),ue("otsu"===t||"binary"===t,(()=>`Method must be binary or otsu, but was ${t}`)),3===l.shape[2]){[a,s,i]=yg(l,[1,1,1],-1);let e=Yu(a,u),t=Yu(s,p),n=Yu(i,d);o=Gu(Gu(e,t),n)}else o=e;if("otsu"===t){let e=md(vo(zm(o),"int32"),pi([]),256);h=Sb(e,c)}let f=n?_h(o,h):fh(o,h);return vo(Yu(f,255),"int32")}function Sb(e,t){let n,r,a,s,i,o,l=Fg([-1]),u=Fg([0]),p=Fg([0]);for(let d=0;d<e.size-1;d++){n=Jp(e,0,d+1),r=Jp(e,d+1),i=Ku(jc(n),t),o=Ku(jc(r),t);let c=jc(Yu(n,vm(0,n.size)));a=Ku(c,jc(n));let h=lh(r.shape,n.size),f=Gu(vm(0,r.size),h),m=Yu(r,f);s=Ku(jc(m),jc(r));let g=Kh(a,s),y=Kh(a,s),b=Yu(i,o);p=Yu(Yu(b,g),y);let w=fh(p,u);u=hc(w,p,u),l=hc(w,Fg([d]),l)}return l}var Nb=ii({threshold_:Ib});function Tb(e,t,n="nearest",r="constant",a=0,s){let i=ri(e,"image","transform","float32"),o=ri(t,"transforms","transform","float32");ue(4===i.rank,(()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`)),ue(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),ue(null==s||2===s.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`));let l={image:i,transforms:o},u={interpolation:n,fillMode:r,fillValue:a,outputShape:s};return Hs.runKernel(aa,l,u)}var Cb=ii({transform_:Tb});function _b(e,t,n){ue(t%1===0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),ue(n%1===0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`));let r=ri(e,"a","bandPart");ue(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));let a=r.shape,[s,i]=r.shape.slice(-2);if(!(t<=s))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`);if(!(n<=i))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`);t<0&&(t=s),n<0&&(n=i);let o=Vp(vm(0,s,1,"int32"),[-1,1]),l=vm(0,i,1,"int32"),u=Kh(o,l),p=ef(_h(u,Bc(+t,"int32")),gh(u,Bc(-n,"int32"))),d=kf([s,i],r.dtype);return Vp(Ng(jg(Vp(r,[-1,s,i])).map((e=>hc(p,e,d)))),a)}var Eb=ii({bandPart_:_b});function Ab(e){let t;if(Array.isArray(e)){t=!1,ue(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));let n=e[0].shape[0];for(let t=1;t<e.length;++t)ue(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=yg(e,e.shape[0],0).map((e=>Ig(e,[0])));ue(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));let n=[],r=e;for(let a=0;a<e.length;++a)n.push(Hs.tidy((()=>{let e=r[a];if(a>0)for(let t=0;t<a;++t){let r=Yu(jc(Yu(n[t],e)),n[t]);e=Kh(e,r)}return Ku(e,Xc(e,"euclidean"))})));return t?Ng(n,0):n}var $b=ii({gramSchmidt_:Ab});function Fb(e,t=!1){if(ue(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return Rb(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=jg(Vp(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),a=[],s=[];r.forEach((e=>{let[n,r]=Rb(e,t);a.push(n),s.push(r)}));let i=Vp(Ng(a,0),e.shape),o=Vp(Ng(s,0),e.shape);return[i,o]}}function Rb(e,t=!1){return Hs.tidy((()=>{ue(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));let n=e.shape[0],r=e.shape[1],a=oh(n),s=Io(e),i=Rg([[1]],[1,1]),o=Io(i),l=n>=r?r:n;for(let e=0;e<l;++e){let t=s,l=o,u=a;[o,s,a]=Hs.tidy((()=>{let t=Jp(s,[e,e],[n-e,1]),l=Xc(t),u=Jp(s,[e,e],[1,1]),p=hc(fh(u,0),Rg([[-1]]),Rg([[1]])),d=Kh(u,Yu(p,l)),c=Ku(t,d);o=1===c.shape[0]?Io(i):Kp([i,Jp(c,[1,0],[c.shape[0]-1,c.shape[1]])],0);let h=Al(Ku(rl(p,d),l)),f=Jp(s,[e,0],[n-e,r]),m=Yu(h,o),g=Dl(o);if(0===e)s=Kh(f,rl(m,rl(g,f)));else{let t=Kh(f,rl(m,rl(g,f)));s=Kp([Jp(s,[0,0],[e,r]),t],0)}let y=Dl(m),b=Jp(a,[0,e],[n,a.shape[1]-e]);if(0===e)a=Kh(b,rl(rl(b,o),y));else{let t=Kh(b,rl(rl(b,o),y));a=Kp([Jp(a,[0,0],[n,e]),t],1)}return[o,s,a]})),ml([t,l,u])}return!t&&n>r&&(a=Jp(a,[0,0],[n,r]),s=Jp(s,[0,0],[r,r])),[a,s]}))}var Db,Mb=ii({qr_:Fb});function Ob(e,t,n=Db.SUM_BY_NONZERO_WEIGHTS){let r=ri(e,"losses","computeWeightedLoss"),a=null;null!=t&&(a=ri(t,"weights","computeWeightedLoss"));let s=null==a?r:Yu(r,a);if(n===Db.NONE)return s;if(n===Db.SUM)return jc(s);if(n===Db.MEAN){if(null==a)return vf(s);{let e=r.size/a.size,t=Ku(jc(s),jc(a));return e>1?Ku(t,Bc(e)):t}}if(n===Db.SUM_BY_NONZERO_WEIGHTS){if(null==a)return Ku(jc(s),Bc(r.size));{let e=Yu(a,If(r.shape)),t=vo(jc(Pf(e,Bc(0))),"float32");return Ku(jc(s),t)}}throw Error(`Unknown reduction: ${n}`)}(function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Db||(Db={}));var Lb=ii({computeWeightedLoss_:Ob});function Pb(e,t,n,r=Db.SUM_BY_NONZERO_WEIGHTS){let a=ri(e,"labels","absoluteDifference"),s=ri(t,"predictions","absoluteDifference"),i=null;null!=n&&(i=ri(n,"weights","absoluteDifference")),pe(a.shape,s.shape,"Error in absoluteDifference: ");let o=Ju(Kh(a,s));return Lb(o,i,r)}var zb=ii({absoluteDifference_:Pb});function Bb(e,t,n,r,a=Db.SUM_BY_NONZERO_WEIGHTS){let s=ri(e,"labels","cosineDistance"),i=ri(t,"predictions","cosineDistance"),o=null;null!=r&&(o=ri(r,"weights","cosineDistance")),pe(s.shape,i.shape,"Error in cosineDistance: ");let l=Bc(1),u=Kh(l,jc(Yu(s,i),n,!0));return Lb(u,o,a)}var Wb=ii({cosineDistance_:Bb});function Vb(e,t,n,r=Db.SUM_BY_NONZERO_WEIGHTS){let a=ri(e,"labels","hingeLoss"),s=ri(t,"predictions","hingeLoss"),i=null;null!=n&&(i=ri(n,"weights","hingeLoss")),pe(a.shape,s.shape,"Error in hingeLoss: ");let o=Bc(1);a=Kh(Yu(Bc(2),a),o);let l=Nm(Kh(o,Yu(a,s)));return Lb(l,i,r)}var Ub=ii({hingeLoss_:Vb});function Gb(e,t,n,r=1,a=Db.SUM_BY_NONZERO_WEIGHTS){let s=ri(e,"labels","huberLoss"),i=ri(t,"predictions","huberLoss"),o=null;null!=n&&(o=ri(n,"weights","huberLoss")),pe(s.shape,i.shape,"Error in huberLoss: ");let l=Bc(r),u=Ju(Kh(i,s)),p=Tf(u,l),d=Kh(u,p),c=Gu(Yu(Bc(.5),Gc(p)),Yu(l,d));return Lb(c,o,a)}var Hb=ii({huberLoss_:Gb});function jb(e,t,n,r=1e-7,a=Db.SUM_BY_NONZERO_WEIGHTS){let s=ri(e,"labels","logLoss"),i=ri(t,"predictions","logLoss"),o=null;null!=n&&(o=ri(n,"weights","logLoss")),pe(s.shape,i.shape,"Error in logLoss: ");let l=Bc(1),u=Bc(r),p=Al(Yu(s,Rh(Gu(i,u)))),d=Yu(Kh(l,s),Rh(Gu(Kh(l,i),u))),c=Kh(p,d);return Lb(c,o,a)}var qb=ii({logLoss_:jb});function Kb(e,t,n,r=Db.SUM_BY_NONZERO_WEIGHTS){let a=ri(e,"labels","meanSquaredError"),s=ri(t,"predictions","meanSquaredError"),i=null;null!=n&&(i=ri(n,"weights","meanSquaredError")),pe(a.shape,s.shape,"Error in meanSquaredError: ");let o=vg(a,s);return Lb(o,i,r)}var Xb=ii({meanSquaredError_:Kb});function Yb(e,t){let n=ri(e,"labels","sigmoidCrossEntropyWithLogits"),r=ri(t,"logits","sigmoidCrossEntropyWithLogits");pe(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let a=Nm(r),s=Yu(r,n),i=Mh(Qc(Al(Ju(r))));return Gu(Kh(a,s),i)}function Zb(e,t,n,r=0,a=Db.SUM_BY_NONZERO_WEIGHTS){let s=ri(e,"multiClassLabels","sigmoidCrossEntropy"),i=ri(t,"logits","sigmoidCrossEntropy"),o=null;if(null!=n&&(o=ri(n,"weights","sigmoidCrossEntropy")),pe(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){let e=Bc(r),t=Bc(1),n=Bc(.5);s=Gu(Yu(s,Kh(t,e)),Yu(n,e))}let l=Yb(s,i);return Lb(l,o,a)}var Jb=ii({sigmoidCrossEntropy_:Zb});function Qb(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return Wh(((e,t,r)=>{let a=Jh(t,[n],!0),s=Kh(vo(t,"float32"),a);r([e,s]);let i=Al(Yu(s,e));return{value:jc(i,[n]),gradFunc:(e,t)=>{let[r,a]=t,s=Ec(e.shape,[n]);return[Yu(Vp(e,s),Kh(vo(r,"float32"),Qc(a))),Yu(Vp(e,s),Kh(Qc(a),vo(r,"float32")))]}}}))(e,t)}function ew(e,t,n,r=0,a=Db.SUM_BY_NONZERO_WEIGHTS){let s=ri(e,"onehotLabels","softmaxCrossEntropy"),i=ri(t,"logits","softmaxCrossEntropy"),o=null;if(null!=n&&(o=ri(n,"weights","softmaxCrossEntropy")),pe(s.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){let e=Bc(r),t=Bc(1),n=Bc(s.shape[1]);s=Gu(Yu(s,Kh(t,e)),Ku(e,n))}let l=Qb(s,i);return Lb(l,o,a)}var tw=ii({softmaxCrossEntropy_:ew});function nw(e,t,n,r){let a=ri(e,"indices","sparseFillEmptyRows","int32"),s=ri(t,"values","sparseFillEmptyRows"),i=ri(n,"denseShape","sparseFillEmptyRows","int32"),o=ri(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==a.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${a.shape}`);if(1!==s.rank)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(1!==i.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);let l={indices:a,values:s,denseShape:i,defaultValue:o},u=Hs.runKernel(Vr,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}var rw=ii({sparseFillEmptyRows_:nw});function aw(e,t,n){let r=ri(e,"inputIndices","sparseReshape","int32"),a=ri(t,"inputShape","sparseReshape","int32"),s=ri(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==a.rank)throw new Error(`Input shape should be Tensor1D but received shape ${a.shape}`);if(1!==s.rank)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:r,inputShape:a,newShape:s},o=Hs.runKernel(Ur,i);return{outputIndices:o[0],outputShape:o[1]}}var sw=ii({sparseReshape_:aw});function iw(e,t,n){let r=ri(e,"data","sparseSegmentMean"),a=ri(t,"indices","sparseSegmentMean","int32"),s=ri(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${a.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${s.shape}`);let i={data:r,indices:a,segmentIds:s};return Hs.runKernel(Gr,i)}var ow=ii({sparseSegmentMean_:iw});function lw(e,t,n){let r=ri(e,"data","sparseSegmentSum"),a=ri(t,"indices","sparseSegmentSum","int32"),s=ri(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${a.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${s.shape}`);let i={data:r,indices:a,segmentIds:s};return Hs.runKernel(Hr,i)}var uw=ii({sparseSegmentSum_:lw});function pw(e,t,n,r,a,s,i,o){let l=ri(e,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);let u=ri(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");let p={separator:n,nGramWidths:r,leftPad:a,rightPad:s,padWidth:i,preserveShortSequences:o},d={data:l,dataSplits:u},c=Hs.runKernel(Yr,d,p);return{nGrams:c[0],nGramsSplits:c[1]}}var dw=ii({stringNGrams_:pw});function cw(e,t,n=!0){let r=ri(e,"input","stringSplit","string"),a=ri(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==a.rank)throw new Error(`Delimiter should be a scalar but received shape ${a.shape}`);let s={skipEmpty:n},i={input:r,delimiter:a},o=Hs.runKernel(Zr,i,s);return{indices:o[0],values:o[1],shape:o[2]}}var hw=ii({stringSplit_:cw});function fw(e,t){let n=ri(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let a={input:n};return Hs.runKernel(Jr,a,r)}var mw=ii({stringToHashBucketFast_:fw}),gw={fft:dg,ifft:hg,rfft:wg,irfft:mg},yw={hammingWindow:Dy,hannWindow:Oy,frame:Py,stft:By},bw={flipLeftRight:Gy,grayscaleToRGB:jy,resizeNearestNeighbor:kb,resizeBilinear:xb,rotateWithOffset:Ky,cropAndResize:Vy,nonMaxSuppression:Zy,nonMaxSuppressionAsync:pb,nonMaxSuppressionWithScore:cb,nonMaxSuppressionWithScoreAsync:fb,nonMaxSuppressionPadded:gb,nonMaxSuppressionPaddedAsync:bb,threshold:Nb,transform:Cb},ww={bandPart:Eb,gramSchmidt:$b,qr:Mb},xw={absoluteDifference:zb,computeWeightedLoss:Lb,cosineDistance:Wb,hingeLoss:Ub,huberLoss:Hb,logLoss:qb,meanSquaredError:Xb,sigmoidCrossEntropy:Jb,softmaxCrossEntropy:tw},vw={sparseFillEmptyRows:rw,sparseReshape:sw,sparseSegmentMean:ow,sparseSegmentSum:uw},kw={stringNGrams:dw,stringSplit:hw,stringToHashBucketFast:mw},Iw=class extends Tu{minimize(e,t=!1,n){let{value:r,grads:a}=this.computeGradients(e,n);if(null!=n){let e=n.map((e=>({name:e.name,tensor:a[e.name]})));this.applyGradients(e)}else this.applyGradients(a);return ml(a),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return Bh(e,t)}dispose(){null!=this.iterations_&&ml(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:Bc(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(Iw,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});var Sw=class extends Iw{constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=Hs.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=Hs.registeredVariables[t],a=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:fl((()=>mc(r).variable(a)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:fl((()=>mc(r).variable(a)))});let s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;let i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;fl((()=>{let e=Gu(Yu(i,this.rho),Yu(Gc(s),1-this.rho)),t=Yu(Ku(Vc(Gu(o,this.epsilon)),Vc(Gu(i,this.epsilon))),s),n=Gu(Yu(o,this.rho),Yu(Gc(t),1-this.rho));i.assign(e),o.assign(n);let a=Gu(Yu(t,-this.learningRate),r);r.assign(a)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(ml(this.accumulatedGrads.map((e=>e.variable))),ml(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}};Sw.className="Adadelta",_u(Sw);var Nw=class extends Iw{constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=Hs.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:fl((()=>lh(r.shape,this.initialAccumulatorValue).variable(!1)))});let a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;let s=this.accumulatedGrads[n].variable;fl((()=>{let e=Gu(s,Gc(a));s.assign(e);let t=Gu(Yu(Ku(a,Vc(Gu(e,Hs.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&ml(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(t)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}};Nw.className="Adagrad",_u(Nw);var Tw=class extends Iw{constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],fl((()=>{this.accBeta1=Bc(t).variable(),this.accBeta2=Bc(n).variable()})),null==r&&(this.epsilon=Hs.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);fl((()=>{let n=Kh(1,this.accBeta1),r=Kh(1,this.accBeta2);t.forEach(((t,a)=>{let s=Hs.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:fl((()=>mc(s).variable(i)))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:`${t}/v`,variable:fl((()=>mc(s).variable(i)))});let o=Array.isArray(e)?e[a].tensor:e[t];if(null==o)return;let l=this.accumulatedFirstMoment[a].variable,u=this.accumulatedSecondMoment[a].variable,p=Gu(Yu(l,this.beta1),Yu(o,1-this.beta1)),d=Gu(Yu(u,this.beta2),Yu(Gc(o),1-this.beta2)),c=Ku(p,n),h=Ku(d,r);l.assign(p),u.assign(d);let f=Gu(Yu(Ku(c,Gu(Vc(h),this.epsilon)),-this.learningRate),s);s.assign(f)})),this.accBeta1.assign(Yu(this.accBeta1,this.beta1)),this.accBeta2.assign(Yu(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&ml(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&ml(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),fl((()=>{this.accBeta1.assign(zc(this.beta1,this.iterations_+1)),this.accBeta2.assign(zc(this.beta2,this.iterations_+1))}));let t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}};Tw.className="Adam",_u(Tw);var Cw=class extends Iw{constructor(e,t,n,r=null,a=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],fl((()=>{this.iteration=Bc(0).variable(),this.accBeta1=Bc(t).variable()})),null==r&&(this.epsilon=Hs.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);fl((()=>{let n=Kh(1,this.accBeta1),r=Ku(-this.learningRate,Gu(Yu(this.iteration,this.decay),1));t.forEach(((t,a)=>{let s=Hs.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:mc(s).variable(i)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:`${t}/v`,variable:mc(s).variable(i)});let o=Array.isArray(e)?e[a].tensor:e[t];if(null==o)return;let l=this.accumulatedFirstMoment[a].variable,u=this.accumulatedWeightedInfNorm[a].variable,p=Gu(Yu(l,this.beta1),Yu(o,1-this.beta1)),d=Yu(u,this.beta2),c=Ju(o),h=wf(d,c);l.assign(p),u.assign(h);let f=Gu(Yu(Ku(r,n),Ku(p,Gu(h,this.epsilon))),s);s.assign(f)})),this.iteration.assign(Gu(this.iteration,1)),this.accBeta1.assign(Yu(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&ml(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&ml(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}};Cw.className="Adamax",_u(Cw);var _w=class extends Iw{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;let a=Hs.registeredVariables[t];fl((()=>{let e=Gu(Yu(this.c,r),a);a.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=gl(Bc(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),0!==e.length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}};_w.className="SGD",_u(_w);var Ew=class extends _w{constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=Bc(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=Hs.registeredVariables[t];null==this.accumulations[n]&&(this.accumulations[n]={originalName:`${t}/momentum`,variable:fl((()=>mc(r).variable(!1)))});let a=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];null!=s&&fl((()=>{let e,t=Gu(Yu(this.m,a),s);e=this.useNesterov?Gu(Yu(this.c,Gu(s,Yu(t,this.m))),r):Gu(Yu(this.c,t),r),a.assign(t),r.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&ml(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(t)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}};Ew.className="Momentum",_u(Ew);var Aw=class extends Iw{constructor(e,t=.9,n=0,r=null,a=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==r&&(this.epsilon=Hs.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=Hs.registeredVariables[t],a=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:fl((()=>mc(r).variable(a)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:fl((()=>mc(r).variable(a)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:fl((()=>mc(r).variable(a)))});let s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;let i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;fl((()=>{let e=Gu(Yu(i,this.decay),Yu(Gc(s),1-this.decay));if(this.centered){let t=this.accumulatedMeanGrads[n].variable,a=Gu(Yu(t,this.decay),Yu(s,1-this.decay)),l=Ku(Yu(s,this.learningRate),Vc(Kh(e,Gu(Gc(a),this.epsilon)))),u=Gu(Yu(o,this.momentum),l);i.assign(e),t.assign(a),o.assign(u);let p=Kh(r,u);r.assign(p)}else{let e=Gu(Yu(i,this.decay),Yu(Gc(s),1-this.decay)),t=Gu(Yu(o,this.momentum),Ku(Yu(s,this.learningRate),Vc(Gu(e,this.epsilon))));i.assign(e),o.assign(t);let n=Kh(r,t);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&ml(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&ml(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&ml(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}};Aw.className="RMSProp",_u(Aw);var $w=class{static sgd(e){return new _w(e)}static momentum(e,t,n=!1){return new Ew(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,a=!1){return new Aw(e,t,n,r,a)}static adam(e=.001,t=.9,n=.999,r=null){return new Tw(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new Sw(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,a=0){return new Cw(e,t,n,r,a)}static adagrad(e,t=.1){return new Nw(e,t)}},Fw={sgd:$w.sgd,momentum:$w.momentum,adadelta:$w.adadelta,adagrad:$w.adagrad,rmsprop:$w.rmsprop,adamax:$w.adamax,adam:$w.adam},Rw=(()=>"undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e())();function Dw(){return new Promise((e=>Rw((()=>e()))))}var Mw={};function Ow(e,t){let n=e[0].length;e.forEach(((e,t)=>{ue(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),ue(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));let r=e[0];e.forEach(((e,a)=>{for(let s=0;s<n;s++)ue(s===t||e[s]===r[s],(()=>`Error in concat${n}D: Shape of tensors[${a}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`))}))}function Lw(e,t){let n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}v(Mw,{ERF_A1:()=>Xw,ERF_A2:()=>Yw,ERF_A3:()=>Zw,ERF_A4:()=>Jw,ERF_A5:()=>Qw,ERF_P:()=>Kw,PARALLELIZE_THRESHOLD:()=>Pw,SELU_SCALE:()=>qw,SELU_SCALEALPHA:()=>jw,applyActivation:()=>vy,assertAndGetBroadcastShape:()=>Bl,assertAxesAreInnerMostDims:()=>Ac,assertParamsConsistent:()=>Ow,assignToTypedArray:()=>sx,axesAreInnerMostDims:()=>Tc,calculateShapes:()=>ru,checkEinsumDimSizes:()=>fx,checkPadOnDimRoundingMode:()=>Bp,combineLocations:()=>Cc,complexWithEvenIndex:()=>nx,complexWithOddIndex:()=>rx,computeConv2DInfo:()=>Tp,computeConv3DInfo:()=>Cp,computeDefaultPad:()=>Ap,computeDilation2DInfo:()=>Ip,computeOptimalWindowSize:()=>zw,computeOutAndReduceShapes:()=>_c,computeOutShape:()=>Lw,computePool2DInfo:()=>Sp,computePool3DInfo:()=>Np,convertConv2DDataFormat:()=>zp,decodeEinsumEquation:()=>cx,eitherStridesOrDilationsAreOne:()=>Pp,expandShapeToKeepDim:()=>Ec,exponent:()=>ox,exponents:()=>ix,fromStringArrayToUint8:()=>Ox,fromUint8ToStringArray:()=>Mx,getAxesPermutation:()=>$c,getBroadcastDims:()=>Pl,getComplexWithIndex:()=>ax,getEinsumComputePath:()=>mx,getEinsumPermutation:()=>hx,getFusedBiasGradient:()=>xy,getFusedDyActivation:()=>wy,getImageCenter:()=>Bw,getInnerMostAxes:()=>Rc,getPermuted:()=>Vw,getReductionAxes:()=>zl,getReshaped:()=>Ww,getReshapedPermuted:()=>Uw,getSliceBeginCoords:()=>Gw,getSliceSize:()=>Hw,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>wx,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>xx,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>vx,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>Sx,getSparseReshapeInputOutputMismatchErrorMessage:()=>Tx,getSparseReshapeInputOutputMultipleErrorMessage:()=>Nx,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>kx,getSparseReshapeNegativeOutputDimErrorMessage:()=>Ix,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>Ax,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>Cx,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>_x,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>Ex,getUndoAxesPermutation:()=>Fc,isIdentityPermutation:()=>gx,log:()=>ba,mergeRealAndImagArrays:()=>ex,prepareAndValidate:()=>Ql,prepareSplitSize:()=>bx,segment_util:()=>$x,shouldFuse:()=>ky,slice_util:()=>au,splitRealAndImagArrays:()=>tx,tupleValuesAreOne:()=>Lp,upcastType:()=>Fs,validateInput:()=>nu,validateUpdateShape:()=>tu,warn:()=>ya});var Pw=30;function zw(e){return e<=Pw?e:Pe(e,Math.floor(Math.sqrt(e)))}function Bw(e,t,n){let r=n*("number"==typeof e?e:e[0]),a=t*("number"==typeof e?e:e[1]);return[r,a]}function Ww(e,t,n,r=!0){let a=[];if(r)a=a.concat(t.slice(0)),a.push(e[0]/n),a=a.concat(e.slice(1));else{a=a.concat(e[0]);let n=t.length;for(let r=0;r<n;++r)a=a.concat([e[r+1]/t[r],t[r]]);a=a.concat(e.slice(n+1))}return a}function Vw(e,t,n=!0){let r=[];if(n){r.push(t);for(let n=t+1;n<e;++n)n<=2*t?(r.push(n),r.push(n-(t+1))):r.push(n)}else{let n=[],a=[];for(let r=1;r<e;++r)r>=2*t+1||r%2===1?a.push(r):n.push(r);r.push(...n),r.push(0),r.push(...a)}return r}function Uw(e,t,n,r=!0){let a=[];r?a.push(e[0]/n):a.push(e[0]*n);for(let s=1;s<e.length;++s)s<=t.length?r?a.push(t[s-1]*e[s]):a.push(e[s]/t[s-1]):a.push(e[s]);return a}function Gw(e,t){let n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function Hw(e,t,n){let r=e.slice(0,1);for(let a=0;a<n;++a)r.push(e[a+1]-t[a][0]-t[a][1]);return r}var jw=1.7580993408473768,qw=1.0507009873554805,Kw=.3275911,Xw=.254829592,Yw=-.284496736,Zw=1.421413741,Jw=-1.453152027,Qw=1.061405429;function ex(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function tx(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function nx(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=0;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function rx(e){let t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=2;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function ax(e,t){let n=e[2*t],r=e[2*t+1];return{real:n,imag:r}}function sx(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function ix(e,t){let n=new Float32Array(e/2),r=new Float32Array(e/2);for(let a=0;a<Math.ceil(e/2);a++){let s=(t?2:-2)*Math.PI*(a/e);n[a]=Math.cos(s),r[a]=Math.sin(s)}return{real:n,imag:r}}function ox(e,t,n){let r=(n?2:-2)*Math.PI*(e/t),a=Math.cos(r),s=Math.sin(r);return{real:a,imag:s}}var lx="->",ux=/->/g,px=",",dx="...";function cx(e,t){e=e.replace(/\s/g,"");let n=(e.length-e.replace(ux,"").length)/lx.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${lx}").`);let[r,a]=e.split(lx);ue(-1===r.indexOf(dx),(()=>`The ellipsis notation ("${dx}") is not supported yet.`));let s=r.split(px),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let o=[];for(let c=0;c<a.length;++c){let e=a[c];if(!s.some((t=>-1!==t.indexOf(e))))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===o.indexOf(e)&&o.push(e)}for(let c=0;c<r.length;++c){let e=r[c];-1===o.indexOf(e)&&e!==px&&o.push(e)}let l=new Array(s.length);for(let c=0;c<i;++c){if(new Set(s[c].split("")).size!==s[c].length)throw new Error(`Found duplicate axes in input component ${s[c]}. Support for duplicate axes in input is not implemented yet.`);l[c]=[];for(let e=0;e<s[c].length;++e)l[c].push(o.indexOf(s[c][e]))}let u=o.length,p=a.length,d=[];for(let c=p;c<u;++c)d.push(c);return{allDims:o,summedDims:d,idDims:l}}function hx(e,t){let n=new Array(e);n.fill(-1);for(let a=0;a<t.length;++a)n[t[a]]=a;let r=[];for(let a=0;a<e;++a)-1===n[a]&&r.push(a);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function fx(e,t,n){let r=new Array(e);for(let a=0;a<n.length;++a){let e=n[a].shape;for(let n=0;n<t[a].length;++n)void 0===r[t[a][n]]?r[t[a][n]]=e[n]:ue(r[t[a][n]]===e[n],(()=>`Expected dimension ${r[t[a][n]]} at axis ${n} of input shaped ${JSON.stringify(e)}, but got dimension ${e[n]}`))}}function mx(e,t){let n=e,r=[],a=0;0===e.length&&n.push(-1),a=e.length+1;for(let i=0;i<a;++i)r.push([]);let s=[];for(let i=0;i<n.length;++i){let e=n[i],a=yx(t,e);for(let t of a)-1===s.indexOf(t)&&(r[i].push(t),s.push(t))}return{path:n,steps:r}}function gx(e){return e.every(((e,t)=>e===t))}function yx(e,t){let n=[];for(let r=0;r<e.length;++r)(0===e[r].length||-1!==e[r].indexOf(t)||-1===t)&&n.push(r);return n}function bx(e,t,n=0){let r=[];if("number"==typeof t)ue(e.shape[n]%t===0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{let a=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);ue(a<=1,(()=>"There should be only one negative value in split array."));let s=t.indexOf(-1);if(-1!==s){let r=t.reduce(((e,t)=>t>0?e+t:e));t[s]=e.shape[n]-r}ue(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function wx(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function xx(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function vx(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function kx(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function Ix(e,t){return`size ${e} must be non-negative, not ${t}`}function Sx(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Nx(e,t){let n=he(e),r=he(t);return`Input to reshape is a SparseTensor with ${n}\n  dense values, but the requested shape requires a multiple of ${r}. inputShape=${e} outputShape= ${t}`}function Tx(e,t){let n=he(e),r=he(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${e} outputShape=${t}`}function Cx(){return"segment ids must be >= 0"}function _x(){return"segment ids are not increasing"}function Ex(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function Ax(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}var $x={};function Fx(e,t){let n,r=!1;for(e<=Pw?(n=e,r=!0):n=Pe(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=Pe(e,n+1);return n}function Rx(e,t,n){let r=[],a=e.length;for(let s=0;s<a;s++)s!==t?r.push(e[s]):r.push(n);return r}function Dx(e,t,n,r){let a=t.shape.length,s=e.shape.length;if(0!==r&&(r<-a||r>a))throw new Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${r}`);if(r<0&&(r+=a),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${s}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let d=0;d<r;++d)if(e.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${e.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);let i=e.shape[n],o=[],l=1,u=1,p=1;for(let d=0;d<r;++d)o.push(e.shape[d]),l*=e.shape[d];for(let d=r;d<n;d++)o.push(e.shape[d]),u*=e.shape[d];for(let d=r;d<a;d++)o.push(t.shape[d]);for(let d=n+1;d<s;d++)o.push(e.shape[d]),p*=e.shape[d];return{batchSize:l,sliceSize:p,outerSize:u,dimSize:i,outputShape:o}}function Mx(e){try{return e.map((e=>ts(e)))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function Ox(e){return e.map((e=>es(e)))}v($x,{collectGatherOpShapeInfo:()=>Dx,computeOutShape:()=>Rx,segOpComputeOptimalWindowSize:()=>Fx});var Lx={};v(Lx,{nonMaxSuppressionV3Impl:()=>nb,nonMaxSuppressionV4Impl:()=>rb,nonMaxSuppressionV5Impl:()=>ab,whereImpl:()=>Xg});var Px={kernelName:ot,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Yu(e,Cg(vo(n,"float32"),-1))}}},zx={kernelName:lt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=Gc(vo(n,"float32")),r=Vc(Kh(Bc(1),t));return Al(Ku(e,r))}}}},Bx={kernelName:ut,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=Vc(Kh(Gc(vo(n,"float32")),1));return Ku(e,t)}}}},Wx={kernelName:pt,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Bl(n.shape,r.shape);return{a:()=>{let t=e,r=zl(n.shape,a);return r.length>0&&(t=jc(t,r)),Vp(t,n.shape)},b:()=>{let t=e,n=zl(r.shape,a);return n.length>0&&(t=jc(t,n)),Vp(t,r.shape)}}}},Vx={kernelName:dt,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach(((t,r)=>{n[r]=()=>e.clone()})),n}},Ux={kernelName:ft,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>mc(n)}}},Gx={kernelName:mt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>mc(n)}}},Hx={kernelName:gt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ku(e,Vc(Kh(Bc(1),Gc(vo(n,"float32")))))}}},jx={kernelName:yt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=Vc(Gu(Bc(1),Gc(vo(n,"float32"))));return Ku(e,t)}}}},qx={kernelName:xt,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Bl(n.shape,r.shape);return{a:()=>{let t=Gu(Gc(n),Gc(r)),s=Yu(e,Ku(r,t)),i=zl(n.shape,a);return i.length>0&&(s=jc(s,i)),Vp(s,n.shape)},b:()=>{let t=Gu(Gc(n),Gc(r)),s=Al(Yu(e,Ku(n,t))),i=zl(r.shape,a);return i.length>0&&(s=jc(s,i)),Vp(s,r.shape)}}}},Kx={kernelName:bt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ku(e,Gu(Gc(vo(n,"float32")),1))}}},Xx={kernelName:wt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ku(e,Kh(Bc(1),Gc(vo(n,"float32"))))}}};function Yx(e,t,n,r,a,s){let i=ri(e,"dy","avgPool3dGrad"),o=ri(t,"input","avgPool3dGrad"),l=i,u=o,p=!1;4===o.rank&&(p=!0,l=Vp(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=Vp(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),ue(5===l.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`)),ue(5===u.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`)),Bp("avgPool3dGrad",a,s);let d={dy:l,input:u},c={filterSize:n,strides:r,pad:a,dimRoundingMode:s},h=Hs.runKernel(St,d,c);return p?Vp(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var Zx=ii({avgPool3dGrad_:Yx}),Jx={kernelName:It,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:s,pad:i,dimRoundingMode:o}=n;return{x:()=>Zx(e,r,a,s,i,o)}}};function Qx(e,t,n,r,a){let s=ri(e,"dy","avgPoolGrad"),i=ri(t,"input","avgPoolGrad");ue(i.rank===s.rank,(()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`));let o=i,l=s,u=!1;3===i.rank&&(u=!0,o=Vp(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=Vp(s,[1,s.shape[0],s.shape[1],s.shape[2]])),ue(4===l.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`)),ue(4===o.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`));let p={dy:l,input:o},d={filterSize:n,strides:r,pad:a},c=Hs.runKernel(kt,p,d);return u?Vp(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var ev=ii({avgPoolGrad_:Qx}),tv={kernelName:vt,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:s,pad:i}=n;return{x:()=>ev(e,r,a,s,i)}}},nv={kernelName:Nt,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{let[r,a]=t,{transposeA:s,transposeB:i}=n;return s||i?!s&&i?{a:()=>rl(e,a,!1,!1),b:()=>rl(e,r,!0,!1)}:s&&!i?{a:()=>rl(a,e,!1,!0),b:()=>rl(r,e,!1,!1)}:{a:()=>rl(a,e,!0,!0),b:()=>rl(e,r,!0,!0)}:{a:()=>rl(e,a,!1,!0),b:()=>rl(r,e,!0,!1)}}},rv={kernelName:Tt,gradFunc:(e,t,n)=>{let{blockShape:r,crops:a}=n;return{x:()=>em(e,r,a)}}},av={kernelName:_t,gradFunc:(e,t,n)=>{let r=n,a=r.inputShape,s=r.shape,i=Array.from(s);for(let l=a.length-1;l>=0;l--)if(a[l]===s[l])i[l]=1;else if(1!==a[l])throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${s}].`);let o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>jc(e,o,!0)}}},sv={kernelName:At,gradFunc:e=>({x:()=>e.clone()})},iv={kernelName:$t,gradFunc:e=>({x:()=>mc(e)})},ov={kernelName:Ft,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{clipValueMin:a,clipValueMax:s}=n;return{x:()=>hc(ef(gh(r,a),_h(r,s)),e,mc(e))}}},lv={kernelName:Dt,inputsToSave:["x"],gradFunc:Px.gradFunc},uv={kernelName:Mt,saveAllInputs:!0,gradFunc:(e,t,n)=>{let r=t.map((e=>e.shape)),{axis:a}=n,s=Ie(a,t[0].shape)[0],i=r.map((e=>e[s]));return yg(e,i,s).map((e=>()=>e))}},pv={kernelName:Ot,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{dilations:s,strides:i,pad:o,dataFormat:l}=n;return ue(Lp(s),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`)),{x:()=>Ld(r.shape,e,a,i,o,l),filter:()=>by(r,e,a.shape,i,o,l)}}},dv={kernelName:Pt,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{strides:s,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>Rd(e,a,s,i,o,1,l),filter:()=>by(e,r,a.shape,s,i,o,l)}}};function cv(e,t,n,r,a){let s=e;4===e.rank&&(s=Vp(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;4===i.rank&&(i=Vp(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),ue(5===s.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`)),ue(5===i.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`)),ue(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),ue(s.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`)),ue(i.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`));let o={x:s,dy:i},l={strides:r,pad:a,filterShape:n};return Hs.runKernel(Bt,o,l)}var hv=ii({conv3DBackpropFilter_:cv}),fv={kernelName:zt,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:s}=n;ue(Lp(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));let[i,o]=t;return{x:()=>Ud(i.shape,e,o,a,s),filter:()=>hv(i,e,o.shape,a,s)}}},mv={kernelName:Vt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Yu(Al(Zm(vo(n,"float32"))),e)}}},gv={kernelName:Ut,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Yu(Qm(vo(n,"float32")),e)}}},yv={kernelName:Ht,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a,exclusive:s,reverse:i}=n;return{x:()=>{let t=$c([a],r.rank),n=Qd(e,a,s,!i);return null!=t&&(n=Dl(n,t)),n}}}},bv={kernelName:Xt,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:s,dimRoundingMode:i}=n,o=null==r?[1,1]:r;ue(Lp(o),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`));let[l,u]=t;return ue(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`)),ue(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`)),ue(l.shape[3]===u.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)),ue(Pp(a,o),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${a} and dilations '${o}'.`)),Bp("depthwiseConv2d",s,i),{x:()=>_y(l.shape,e,u,a,s,o,i),filter:()=>Ty(l,e,u.shape,a,s,o,i)}}},wv={kernelName:Qt,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,s={x:r,filter:a,dy:e},i={x:r,filter:a,dy:e};return{x:()=>Hs.runKernel(en,s,n),filter:()=>Hs.runKernel(tn,i,n)}}},xv={kernelName:an,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,r={dy:e,y:n};return{x:()=>Hs.runKernel(sn,r)}}},vv={kernelName:on,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=Yu(Qc(Al(Gc(n))),2/Math.sqrt(Math.PI));return{x:()=>Yu(e,r)}}},kv={kernelName:un,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Yu(e,n)}}},Iv={kernelName:pn,inputsToSave:["input"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>Vp(e,n.shape)}}},Sv={kernelName:dn,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Yu(e,Qc(n))}}},Nv={kernelName:mn,gradFunc:e=>({x:()=>mc(e)})},Tv={kernelName:gn,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Bl(n.shape,r.shape);return{a:()=>{let t=Ku(e,vo(r,"float32")),s=zl(n.shape,a);return s.length>0?Vp(jc(t,s),n.shape):t},b:()=>{let t=Yu(e,vo(n,"float32")),s=zl(r.shape,a);s.length>0&&(t=Vp(jc(t,s),r.shape));let i=Gc(r);return Al(Ku(t,vo(i,"float32")))}}}},Cv={kernelName:yn,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{let{varianceEpsilon:r}=n,[a,s,i,o]=t,l=null==o?Bc(1):o,u=zl(s.shape,a.shape),p=[];if(1===s.rank){for(let e=0;e<a.shape.length-1;++e)p.push(a.shape[e]);p.push(1)}let d=Kh(a,s),c=Yu(e,l),h=Wm(Gu(i,Bc(r))),f=Yu(Yu(Yu(h,h),h),Bc(-.5));return{x:()=>1===s.rank?Vp(Yu(Yu(e,sh(Vp(h,[1,1,1,s.shape[0]]),p)),l),a.shape):Vp(Yu(Yu(e,h),l),a.shape),mean:()=>{let e=Yu(Yu(h,Bc(-1)),c);return 1===s.rank&&(e=jc(e,u)),Vp(e,s.shape)},variance:()=>{let e=Yu(Yu(f,d),c);return 1===s.rank&&(e=jc(e,u)),Vp(e,s.shape)},scale:()=>{let t=Yu(d,h),n=Yu(e,t);return 1===s.rank&&(n=jc(n,u)),Vp(n,s.shape)},offset:()=>{let t=e;return 1===s.rank&&(t=jc(t,u)),Vp(t,s.shape)}}}},_v={kernelName:bn,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{let[r,a]=t,{axis:s}=n,i=Ie(s,r.shape)[0];return{x:()=>{let t=r.shape,n=a.size,o=t.slice(0,i),l=o.length,u=t.slice(s,t.length).slice(1),p=u.length,d=Ev(0,l),c=Ev(l+1,l+1+p),h=Av([o,[n],u]),f=Vp(e,h),m=Vp(a,[n]),g=Av([[l],d,c]),y=Dl(f,g),b=Gg(y,m,r.shape[i]),w=Fc(g);return b=Dl(b,w),b},indices:()=>a}}};function Ev(e,t){let n=[];for(let r=e;r<t;++r)n.push(r);return n}function Av(e){let t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}var $v={kernelName:vn,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>mc(n),b:()=>mc(r)}}},Fv={kernelName:kn,gradFunc:e=>({x:()=>vo(e,"float32")})},Rv={kernelName:Nn,gradFunc:e=>({x:()=>mc(e)})},Dv={kernelName:Tn,gradFunc:e=>({x:()=>mc(e)})},Mv={kernelName:Cn,gradFunc:e=>({x:()=>mc(e)})},Ov={kernelName:_n,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{alpha:a}=n,s=fh(r,0);return{x:()=>hc(s,e,Yu(e,a))}}},Lv={kernelName:Rn,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ku(e,Gu(n,1))}}},Pv={kernelName:Fn,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ku(e,vo(n,"float32"))}}},zv={kernelName:Ln,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n;return{logits:()=>{let t=Qc(r);return Kh(e,Yu(jc(e,a,!0),t))}}}};function Bv(e,t,n,r=5,a=1,s=1,i=.5){let o={x:e,y:t,dy:n},l={depthRadius:r,bias:a,alpha:s,beta:i};return Hs.runKernel(Bn,o,l)}var Wv=ii({localResponseNormalizationBackprop_:Bv}),Vv={kernelName:zn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{depthRadius:s,bias:i,alpha:o,beta:l}=n;return{x:()=>Wv(r,a,e,s,i,o,l)}}};function Uv(e,t,n,r){return t.rank<n.rank&&(t=Vp(t,Ec(t.shape,r))),e.rank<n.rank&&(e=Vp(e,Ec(e.shape,r))),{x:()=>Yu(e,vo(dc(n,t),e.dtype))}}var Gv={kernelName:Wn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{reductionIndices:a}=r,s=t[0],i=t[1],o=Ie(a,s.shape),l=Uv(e,i,s,o);return{x:()=>l.x()}}},Hv={kernelName:Vn,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>Yu(e,vo(gh(n,r),"float32")),b:()=>Yu(e,vo(Th(n,r),"float32"))}}};function jv(e,t,n,r,a,s,i){let o=ri(e,"dy","maxPool3dGrad"),l=ri(t,"input","maxPool3dGrad"),u=ri(n,"output","maxPool3dGrad"),p=o,d=l,c=u,h=!1;4===l.rank&&(h=!0,p=Vp(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=Vp(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),c=Vp(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),ue(5===p.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${p.rank}.`)),ue(5===d.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`)),ue(5===c.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${c.rank}.`)),Bp("maxPool3dGrad",s,i);let f={dy:p,input:d,output:c},m={filterSize:r,strides:a,pad:s,dimRoundingMode:i},g=Hs.runKernel(jn,f,m);return h?Vp(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var qv=ii({maxPool3dGrad_:jv}),Kv={kernelName:Hn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>qv(e,r,a,s,i,o,l)}}};function Xv(e,t,n,r,a,s,i){let o=ri(e,"dy","maxPoolGrad"),l=ri(t,"input","maxPoolGrad"),u=ri(n,"output","maxPoolGrad");ue(l.rank===o.rank,(()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`)),ue(4===o.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`)),ue(4===l.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`)),Bp("maxPoolGrad",s,i);let p={dy:o,input:l,output:u},d={filterSize:r,strides:a,pad:s,dimRoundingMode:i};return Hs.runKernel(Gn,p,d)}var Yv=ii({maxPoolGrad_:Xv}),Zv={kernelName:Un,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:s,strides:i,pad:o}=n;return{x:()=>Yv(e,r,a,s,i,o)}}},Jv={kernelName:Kn,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,s=Ie(a,r.shape),i=_c(r.shape,s)[1],o=he(i);return{x:()=>{let t=r.shape.slice();s.forEach((e=>{t[e]=1}));let n=Vp(e,t);return Ku(Yu(n,If(r.shape,"float32")),o)}}}},Qv={kernelName:Xn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{axis:a}=r,[s,i]=t,o=Ie(a,s.shape),l=Uv(e,i,s,o);return{x:()=>l.x()}}},ek={kernelName:Yn,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>Yu(e,vo(_h(n,r),"float32")),b:()=>Yu(e,vo(fh(n,r),"float32"))}}},tk={kernelName:Zn,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,s=a.map((e=>e[0]));return{x:()=>Jp(e,s,r.shape)}}},nk={kernelName:Jn,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Bl(n.shape,r.shape);return{a:()=>{let t=zl(n.shape,a);return t.length>0?Vp(jc(e,t),n.shape):e},b:()=>{let t=Yu(e,Al(ph(Ku(n,r)))),s=zl(r.shape,a);return s.length>0?Vp(jc(t,s),r.shape):t}}}},rk={kernelName:er,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Bl(n.shape,r.shape);return{a:()=>{let t=Yu(e,vo(r,"float32")),s=zl(n.shape,a);return s.length>0?Vp(jc(t,s),n.shape):t},b:()=>{let t=Yu(e,vo(n,"float32")),s=zl(r.shape,a);return s.length>0?Vp(jc(t,s),r.shape):t}}}},ak={kernelName:tr,gradFunc:e=>({x:()=>Al(e)})},sk={kernelName:or,inputsToSave:["indices"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>kf(n.shape,"float32")}}},ik={kernelName:ir,gradFunc:e=>({x:()=>mc(e)})},ok={kernelName:lr,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:r}=n;return jg(e,r).map((e=>()=>e))}},lk={kernelName:ur,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,s=a.map((e=>e[0]));return{x:()=>Jp(e,s,r.shape)}}},uk={kernelName:dr,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,r,a]=t,s=n,i=r,o=Bl(s.shape,i.shape);return{a:()=>{let t=vo(i,"float32"),n=Yu(e,Yu(t,zc(s,Kh(t,Bc(1))))),r=zl(s.shape,o);return r.length>0&&(n=jc(n,r)),Vp(n,s.shape)},b:()=>{let t=fh(s,0),n=hc(t,Rh(s),mc(s)),r=Yu(e,Yu(a,n)),l=zl(i.shape,o);return l.length>0&&(r=jc(r,l)),Vp(r,i.shape)}}}},pk={kernelName:cr,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[n,r]=t,a=fh(n,0);return{x:()=>hc(a,e,Yu(e,r)),alpha:()=>{let t=hc(a,mc(e),Yu(e,n)),s=zl(r.shape,e.shape);return s.length>0&&(t=jc(t,s)),Vp(t,r.shape)}}}};function dk(e,t,n){let r=e.shape.slice();r[n]=1;let a=Vp(t,r),s=Zd(e,n,!0,!1),i=Zd(e,n,!0,!0),o=Yu(s,i);return Yu(a,o)}function ck(e,t,n){let r=e.shape.length,a=r-n.length,s=Mw.getAxesPermutation(n,r),i=e;null!=s&&(i=Dl(e,s));let o=i.shape.slice(),l=o.splice(r-n.length,n.length).reduce(((e,t)=>e*t),1);o.push(l);let u=i.reshape(o),p=dk(u,t,a);if(p=p.reshape(i.shape),null!=s){let e=Mw.getUndoAxesPermutation(s);p=Dl(p,e)}return p}var hk={kernelName:hr,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,s=[];return s=null==a?r.shape.map(((e,t)=>t)):"number"==typeof a?[a]:a,{x:()=>ck(r,e,s)}}},fk={kernelName:nn,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Bl(n.shape,r.shape);return{a:()=>{let t=Ku(e,vo(r,"float32")),s=zl(n.shape,a);return s.length>0?Vp(jc(t,s),n.shape):t},b:()=>{let t=Yu(e,vo(n,"float32")),s=zl(r.shape,a);s.length>0&&(t=Vp(jc(t,s),r.shape));let i=Gc(r);return Al(Ku(t,vo(i,"float32")))}}}},mk={kernelName:gr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ku(e,Al(Gc(n)))}}},gk={kernelName:Ir,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=Yu(_h(n,6),Cg(n));return{x:()=>Yu(e,vo(r,"float32"))}}},yk={kernelName:yr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Yu(e,vo(Cg(n),"float32"))}}},bk={kernelName:br,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Vp(e,n.shape)}}},wk={kernelName:vr,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>Hs.runKernel(kr,a,n)}}},xk={kernelName:wr,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>Hs.runKernel(xr,a,n)}}},vk={kernelName:Sr,gradFunc:(e,t,n)=>{let{dims:r}=n,a=Ie(r,e.shape);return{x:()=>Em(e,a)}}},kk={kernelName:Nr,gradFunc:e=>({x:()=>mc(e)})},Ik={kernelName:Tr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Al(Ku(e,Yu(zc(n,1.5),2)))}}},Sk={kernelName:Er,inputsToSave:["condition"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>vo(mc(n),"float32"),t:()=>Yu(e,vo(n,e.dtype)),e:()=>Yu(e,vo(nf(n),e.dtype))}}},Nk={kernelName:Ar,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=fh(n,Bc(0)),r=Bc(jw),a=Bc(qw),s=Yu(e,a),i=Yu(Yu(e,r),Qc(vo(n,"float32")));return hc(t,s,i)}}}},Tk={kernelName:Mr,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Yu(e,Yu(n,Kh(Bc(1),n)))}}},Ck={kernelName:Dr,gradFunc:e=>({x:()=>mc(e)})},_k={kernelName:Fr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Yu(qd(vo(n,"float32")),e)}}},Ek={kernelName:Rr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Yu(Xd(vo(n,"float32")),e)}}},Ak={kernelName:$r,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{begin:a,size:s}=n,i=r.shape,[o,l]=vu(r,a,s),u=[];for(let p=0;p<e.rank;p++)u.push([o[p],i[p]-o[p]-l[p]]);return{x:()=>Gf(e,u)}}},$k={kernelName:Wr,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{dim:a}=n,s=!0,i=Yu(e,r);return{logits:()=>Kh(i,Yu(jc(i,[a],s),r))}}},Fk={kernelName:Or,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Yu(e,Yp(n))}}},Rk={kernelName:zr,gradFunc:(e,t,n)=>{let{blockShape:r,paddings:a}=n;return{x:()=>ad(e,r,a)}}},Dk={kernelName:Br,gradFunc:(e,t,n)=>{let{axis:r}=n;return{x:()=>Kp(e,r)}}},Mk={kernelName:Lr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ku(e,Yu(Vc(vo(n,"float32")),2))}}},Ok={kernelName:Kr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Yu(e,Yu(vo(n,"float32"),2))}}},Lk={kernelName:qr,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Bc(2);return{a:()=>Yu(e,Yu(a,Kh(n,r))),b:()=>Yu(e,Yu(a,Kh(r,n)))}}},Pk={kernelName:da,gradFunc:e=>({x:()=>mc(e)})},zk={kernelName:Qr,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Bl(n.shape,r.shape);return{a:()=>{let t=e,r=zl(n.shape,a);return r.length>0&&(t=jc(t,r)),Vp(t,n.shape)},b:()=>{let t=e,n=zl(r.shape,a);return n.length>0&&(t=jc(t,n)),Vp(Al(t),r.shape)}}}},Bk={kernelName:Pr,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,a=r.shape.slice(),{axis:s}=n;Ie(s,r.shape).forEach((e=>{a[e]=1}));let i=Vp(e,a),o=Yu(i,If(r.shape,"float32"));return{x:()=>o}}},Wk={kernelName:ea,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Ku(e,Gc(qd(n)))}}},Vk={kernelName:ta,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Yu(Kh(Bc(1),Gc(n)),e)}}},Uk={kernelName:na,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{reps:a}=n;return{x:()=>{let t=mc(r);if(1===r.rank)for(let n=0;n<a[0];++n)t=Gu(t,Jp(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)t=Gu(t,Jp(e,[n*r.shape[0],s*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let i=0;i<a[2];++i)t=Gu(t,Jp(e,[n*r.shape[0],s*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let i=0;i<a[2];++i)for(let o=0;o<a[3];++o)t=Gu(t,Jp(e,[n*r.shape[0],s*r.shape[1],i*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}},Gk={kernelName:sa,gradFunc:(e,t,n)=>{let r=n,{perm:a}=r,s=Fc(a);return{x:()=>Dl(e,s)}}},Hk={kernelName:oa,gradFunc:(e,t,n)=>{let r=n,{axis:a}=r;return{value:()=>Ng(e,a)}}},jk={kernelName:la,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>qk(e,n)}}};function qk(e,t){let n=wf(t,mc(t)),r=ch(e,n),a=gh(t,Bc(0,"int32")),s=r.rank-a.rank;for(let o=0;o<s;++o)a=th(a,o+1);a=ef(a,If(r.shape,"bool"));let i=mc(r);return hc(a,r,i)}var Kk={kernelName:pa,gradFunc:e=>({x:()=>mc(e)})},Xk=[Px,zx,Bx,Wx,Vx,Ux,Gx,Hx,jx,qx,Kx,Xx,Jx,tv,nv,rv,av,sv,iv,ov,lv,uv,dv,pv,fv,mv,gv,yv,bv,wv,fk,xv,vv,kv,Iv,Sv,Tv,Nv,Cv,_v,$v,Fv,Rv,Dv,Mv,Ov,Lv,Pv,zv,Vv,Gv,Gv,Hv,Kv,Zv,Jv,Qv,ek,tk,nk,rk,ak,sk,ik,ok,lk,lk,uk,pk,hk,mk,gk,yk,bk,wk,xk,vk,kk,Ik,Sk,Nk,Tk,Ck,_k,Ek,Ak,$k,Fk,Rk,Rk,Dk,Dk,Mk,Lk,Ok,Pk,zk,Bk,Wk,Vk,Uk,Gk,Hk,jk,Kk];for(let dae of Xk)Na(dae);Is().prototype.abs=function(){return this.throwIfDisposed(),Ju(this)},Is().prototype.acos=function(){return this.throwIfDisposed(),ep(this)},Is().prototype.acosh=function(){return this.throwIfDisposed(),np(this)},Is().prototype.add=function(e){return this.throwIfDisposed(),Gu(this,e)},Is().prototype.all=function(e,t){return this.throwIfDisposed(),ip(this,e,t)},Is().prototype.any=function(e,t){return this.throwIfDisposed(),lp(this,e,t)},Is().prototype.argMax=function(e){return this.throwIfDisposed(),pp(this,e)},Is().prototype.argMin=function(e){return this.throwIfDisposed(),cp(this,e)},Is().prototype.asScalar=function(){return this.throwIfDisposed(),ue(1===this.size,(()=>"The array must have only 1 element.")),Vp(this,[])},Is().prototype.asType=function(e){return this.throwIfDisposed(),vo(this,e)},Is().prototype.as1D=function(){return this.throwIfDisposed(),Vp(this,[this.size])},Is().prototype.as2D=function(e,t){return this.throwIfDisposed(),Vp(this,[e,t])},Is().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),Vp(this,[e,t,n])},Is().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),Vp(this,[e,t,n,r])},Is().prototype.as5D=function(e,t,n,r,a){return this.throwIfDisposed(),Vp(this,[e,t,n,r,a])},Is().prototype.asin=function(){return this.throwIfDisposed(),fp(this)},Is().prototype.asinh=function(){return this.throwIfDisposed(),gp(this)},Is().prototype.atan=function(){return this.throwIfDisposed(),bp(this)},Is().prototype.atan2=function(e){return this.throwIfDisposed(),xp(this,e)},Is().prototype.atanh=function(){return this.throwIfDisposed(),kp(this)},Is().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),Gp(this,e,t,n,r)},Is().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),ad(this,e,t)},Is().prototype.batchNorm=function(e,t,n,r,a){return this.throwIfDisposed(),od(this,e,t,n,r,a)},Is().prototype.broadcastTo=function(e){return this.throwIfDisposed(),wd(this,e)},Is().prototype.cast=function(e){return this.throwIfDisposed(),vo(this,e)},Is().prototype.ceil=function(){return this.throwIfDisposed(),vd(this)},Is().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),Id(this,e,t)},Is().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof ks&&(e=[e]),Kp([this,...e],t)},Is().prototype.conv1d=function(e,t,n,r,a,s){return this.throwIfDisposed(),Md(this,e,t,n,r,a,s)},Is().prototype.conv2dTranspose=function(e,t,n,r,a){return this.throwIfDisposed(),zd(this,e,t,n,r,a)},Is().prototype.conv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),Rd(this,e,t,n,r,a,s)},Is().prototype.cos=function(){return this.throwIfDisposed(),qd(this)},Is().prototype.cosh=function(){return this.throwIfDisposed(),Xd(this)},Is().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),Zd(this,e,t,n)},Is().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),Qd(this,e,t,n)},Is().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),rc(this,e,t)},Is().prototype.depthwiseConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),sc(this,e,t,n,r,a,s)},Is().prototype.dilation2d=function(e,t,n,r,a){return this.throwIfDisposed(),uc(this,e,t,n,r,a)},Is().prototype.divNoNan=function(e){return this.throwIfDisposed(),yc(this,e)},Is().prototype.div=function(e){return this.throwIfDisposed(),Ku(this,e)},Is().prototype.dot=function(e){return this.throwIfDisposed(),wc(this,e)},Is().prototype.elu=function(){return this.throwIfDisposed(),Ic(this)},Is().prototype.equal=function(e){return this.throwIfDisposed(),dc(this,e)},Is().prototype.erf=function(){return this.throwIfDisposed(),Nc(this)},Is().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),Zc(this,e,t)},Is().prototype.exp=function(){return this.throwIfDisposed(),Qc(this)},Is().prototype.expandDims=function(e){return this.throwIfDisposed(),th(this,e)},Is().prototype.expm1=function(){return this.throwIfDisposed(),rh(this)},Is().prototype.fft=function(){return this.throwIfDisposed(),dg(this)},Is().prototype.flatten=function(){return this.throwIfDisposed(),Vp(this,[this.size])},Is().prototype.floor=function(){return this.throwIfDisposed(),ph(this)},Is().prototype.floorDiv=function(e){return this.throwIfDisposed(),ju(this,e)},Is().prototype.gather=function(e,t){return this.throwIfDisposed(),ch(this,e,t)},Is().prototype.greaterEqual=function(e){return this.throwIfDisposed(),gh(this,e)},Is().prototype.greater=function(e){return this.throwIfDisposed(),fh(this,e)},Is().prototype.ifft=function(){return this.throwIfDisposed(),hg(this)},Is().prototype.irfft=function(){return this.throwIfDisposed(),mg(this)},Is().prototype.isFinite=function(){return this.throwIfDisposed(),bh(this)},Is().prototype.isInf=function(){return this.throwIfDisposed(),xh(this)},Is().prototype.isNaN=function(){return this.throwIfDisposed(),kh(this)},Is().prototype.leakyRelu=function(e){return this.throwIfDisposed(),Sh(this,e)},Is().prototype.lessEqual=function(e){return this.throwIfDisposed(),_h(this,e)},Is().prototype.less=function(e){return this.throwIfDisposed(),Th(this,e)},Is().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),$h(this,e,t,n,r)},Is().prototype.logSigmoid=function(){return this.throwIfDisposed(),jh(this)},Is().prototype.logSoftmax=function(e){return this.throwIfDisposed(),Yh(this,e)},Is().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),Jh(this,e,t)},Is().prototype.log=function(){return this.throwIfDisposed(),Rh(this)},Is().prototype.log1p=function(){return this.throwIfDisposed(),Mh(this)},Is().prototype.logicalAnd=function(e){return this.throwIfDisposed(),ef(this,e)},Is().prototype.logicalNot=function(){return this.throwIfDisposed(),nf(this)},Is().prototype.logicalOr=function(e){return this.throwIfDisposed(),af(this,e)},Is().prototype.logicalXor=function(e){return this.throwIfDisposed(),of(this,e)},Is().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),rl(this,e,t,n)},Is().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),hf(this,e,t,n,r)},Is().prototype.max=function(e,t){return this.throwIfDisposed(),Mc(this,e,t)},Is().prototype.maximum=function(e){return this.throwIfDisposed(),wf(this,e)},Is().prototype.mean=function(e,t){return this.throwIfDisposed(),vf(this,e,t)},Is().prototype.min=function(e,t){return this.throwIfDisposed(),Lc(this,e,t)},Is().prototype.minimum=function(e){return this.throwIfDisposed(),Tf(this,e)},Is().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),_f(this,e,t)},Is().prototype.mod=function(e){return this.throwIfDisposed(),Af(this,e)},Is().prototype.mul=function(e){return this.throwIfDisposed(),Yu(this,e)},Is().prototype.neg=function(){return this.throwIfDisposed(),Al(this)},Is().prototype.norm=function(e,t,n){return this.throwIfDisposed(),Xc(this,e,t,n)},Is().prototype.notEqual=function(e){return this.throwIfDisposed(),Pf(this,e)},Is().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),sl(this,e,t,n)},Is().prototype.onesLike=function(){return this.throwIfDisposed(),Bf(this)},Is().prototype.pad=function(e,t){return this.throwIfDisposed(),Gf(this,e,t)},Is().prototype.pool=function(e,t,n,r,a,s){return this.throwIfDisposed(),am(this,e,t,n,r,a,s)},Is().prototype.pow=function(e){return this.throwIfDisposed(),zc(this,e)},Is().prototype.prelu=function(e){return this.throwIfDisposed(),im(this,e)},Is().prototype.prod=function(e,t){return this.throwIfDisposed(),lm(this,e,t)},Is().prototype.reciprocal=function(){return this.throwIfDisposed(),Im(this)},Is().prototype.relu=function(){return this.throwIfDisposed(),Nm(this)},Is().prototype.relu6=function(){return this.throwIfDisposed(),Cm(this)},Is().prototype.reshapeAs=function(e){return this.throwIfDisposed(),Vp(this,e.shape)},Is().prototype.reshape=function(e){return this.throwIfDisposed(),Vp(this,e)},Is().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),xb(this,e,t,n)},Is().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),kb(this,e,t,n)},Is().prototype.reverse=function(e){return this.throwIfDisposed(),Em(this,e)},Is().prototype.rfft=function(){return this.throwIfDisposed(),wg(this)},Is().prototype.round=function(){return this.throwIfDisposed(),zm(this)},Is().prototype.rsqrt=function(){return this.throwIfDisposed(),Wm(this)},Is().prototype.selu=function(){return this.throwIfDisposed(),Um(this)},Is().prototype.separableConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),Hm(this,e,t,n,r,a,s)},Is().prototype.sigmoid=function(){return this.throwIfDisposed(),Yp(this)},Is().prototype.sign=function(){return this.throwIfDisposed(),Xm(this)},Is().prototype.sin=function(){return this.throwIfDisposed(),Zm(this)},Is().prototype.sinh=function(){return this.throwIfDisposed(),Qm(this)},Is().prototype.slice=function(e,t){return this.throwIfDisposed(),Jp(this,e,t)},Is().prototype.softmax=function(e){return this.throwIfDisposed(),ug(this,e)},Is().prototype.softplus=function(){return this.throwIfDisposed(),Gh(this)},Is().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),em(this,e,t)},Is().prototype.split=function(e,t){return this.throwIfDisposed(),yg(this,e,t)},Is().prototype.sqrt=function(){return this.throwIfDisposed(),Vc(this)},Is().prototype.square=function(){return this.throwIfDisposed(),Gc(this)},Is().prototype.squaredDifference=function(e){return this.throwIfDisposed(),vg(this,e)},Is().prototype.squeeze=function(e){return this.throwIfDisposed(),Ig(this,e)},Is().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof ks?[this,e]:[this,...e];return Ng(n,t)},Is().prototype.step=function(e){return this.throwIfDisposed(),Cg(this,e)},Is().prototype.stridedSlice=function(e,t,n,r,a,s,i,o){return this.throwIfDisposed(),Eg(this,e,t,n,r,a,s,i,o)},Is().prototype.sub=function(e){return this.throwIfDisposed(),Kh(this,e)},Is().prototype.sum=function(e,t){return this.throwIfDisposed(),jc(this,e,t)},Is().prototype.tan=function(){return this.throwIfDisposed(),$g(this)},Is().prototype.tanh=function(){return this.throwIfDisposed(),ed(this)},Is().prototype.tile=function(e){return this.throwIfDisposed(),sh(this,e)},Is().prototype.toBool=function(){return this.throwIfDisposed(),vo(this,"bool")},Is().prototype.toFloat=function(){return this.throwIfDisposed(),vo(this,"float32")},Is().prototype.toInt=function(){return this.throwIfDisposed(),vo(this,"int32")},Is().prototype.topk=function(e,t){return this.throwIfDisposed(),Pg(this,e,t)},Is().prototype.transpose=function(e){return this.throwIfDisposed(),Dl(this,e)},Is().prototype.unique=function(e){return this.throwIfDisposed(),Vg(this,e)},Is().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),Gg(this,e,t)},Is().prototype.unstack=function(e){return this.throwIfDisposed(),jg(this,e)},Is().prototype.where=function(e,t){return this.throwIfDisposed(),hc(e,this,t)},Is().prototype.zerosLike=function(){return this.throwIfDisposed(),mc(this)};var Yk=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Yk.prototype)}},Zk=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Zk.prototype)}},Jk=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Jk.prototype)}},Qk=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Qk.prototype)}},eI=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,eI.prototype)}},tI=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}};function nI(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{let n=new Array(t);return n.fill(e),n}}function rI(e,t){if(!e)throw new eI(t)}function aI(e,t){let n=0;for(let r of e)r===t&&n++;return n}function sI(e){return 1===e.length?e[0]:e}function iI(e){return Array.isArray(e)?e:[e]}function oI(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function lI(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}var uI={};function pI(e){if(null==e)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function dI(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach((e=>dI(e)));else{let t=Object.keys(e);for(let n of t){let t=e[n];null!=t&&"object"==typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!=typeof t.value?dI(t):e[n]=t.value)}}}function cI(e,t={},n={},r="object",a=!1){if("string"==typeof e){let a,s=e;if(s in n)a=n[s];else if(s in uI)a=uI[s];else if(a=t[s],null==a)throw new Jk(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}{let s=e;if(null==s.className||null==s.config)throw new Jk(`${r}: Improper config format: ${JSON.stringify(s)}.\n'className' and 'config' must set.`);let i,o,l=s.className;if(l in n?[i,o]=n[l]:l in uI?[i,o]=uI.className:l in t&&([i,o]=t[l]),null==i)throw new Jk(`Unknown ${r}: ${l}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=o){let e={};for(let n of Object.keys(uI))e[n]=uI[n];for(let a of Object.keys(n))e[a]=n[a];let t=s.config;t.customObjects=e;let r=Object.assign({},uI);for(let a of Object.keys(n))uI[a]=n[a];dI(s.config);let l=o(i,s.config,n,a);return uI=Object.assign({},r),l}{let e=Object.assign({},uI);for(let r of Object.keys(n))uI[r]=n[r];let t=new i(s.config);return uI=Object.assign({},e),t}}}function hI(e,t){return e<t?-1:e>t?1:0}function fI(e,t){return-1*hI(e,t)}function mI(e){if(null==e)return e;let t=[];for(let n of e)-1===t.indexOf(n)&&t.push(n);return t}function gI(e){if(null==e)throw new Jk(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function yI(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new Jk(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function bI(e,t,n=0,r=1/0){return rI(n>=0),rI(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every((e=>typeof e===t))}function wI(e,t){Array.isArray(e)?(Aa.assert(e.length>0,(()=>`${t} is unexpectedly an empty array.`)),e.forEach(((e,n)=>wI(e,`element ${n+1} of ${t}`)))):Aa.assert(Number.isInteger(e)&&e>0,(()=>`Expected ${t} to be a positive integer, but got ${xI(e)}.`))}function xI(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>xI(e))).join(",")+"]":"string"==typeof e?`"${e}"`:`${e}`}function vI(e,t,n){let r,a=null!=n?n():Aa.now();return(...s)=>{let i=null!=n?n():Aa.now();return i-a<t||(a=i,r=e(...s)),r}}function kI(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}var II=0;function SI(){return II++}var NI={};function TI(e=""){return e in NI||(NI[e]=0),NI[e]+=1,e+NI[e].toString()}var CI=["channelsFirst","channelsLast"],_I=["nearest","bilinear"],EI=["valid","same","causal"],AI=["max","avg"],$I=["sum","mul","concat","ave"],FI=new Map;function RI(e){yI(CI,"DataFormat",e)}function DI(e){yI(_I,"InterpolationFormat",e)}function MI(e){yI(EI,"PaddingMode",e)}function OI(e){yI(AI,"PoolMode",e)}var LI=[],PI="/";function zI(e,t){LI.push(e);try{let e=t();return LI.pop(),e}catch(n){throw LI.pop(),n}}function BI(){return 0===LI.length?"":LI.join(PI)+PI}function WI(e){if(!HI(e))throw new Error("Not a valid tensor name: '"+e+"'");return BI()+e}function VI(e){if(!HI(e))throw new Error("Not a valid tensor name: '"+e+"'");FI.has(e)||FI.set(e,0);let t=FI.get(e);if(FI.set(e,FI.get(e)+1),t>0){let n=`${e}_${t}`;return FI.set(n,1),n}return e}var UI,GI=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function HI(e){return!!e.match(GI)}function jI(e){return e===parseInt(e.toString(),10)}function qI(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let a=t;a<n;++a)r*=e[a];return r}function KI(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r<t&&(t=r)}return t}function XI(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r>t&&(t=r)}return t}function YI(e,t){if(t<e)throw new Jk(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let r=e;r<t;++r)n.push(r);return n}function ZI(){return null==UI&&(UI=Nl().epsilon()),UI}function JI(){return"channelsLast"}function QI(e,t){return vo(e,t)}function eS(e,t=-1){let n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),Vp(e,n)}function tS(e,t){return fl((()=>{if(2!==e.shape.length)throw new Jk(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);let n=eS(e,1);return uS(n,[1,t,1])}))}function nS(e){let t=[qI(e.shape)];return Vp(e,t)}function rS(e){if(e.rank<=1)throw new Jk(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],qI(e.shape,1)];return Vp(e,t)}function aS(e,t,n){return fl((()=>{switch(e.rank){case 1:return tg(e,t,n);case 2:return rg(e,[t,0],[n,e.shape[1]]);case 3:return sg(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return og(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Jp(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Jp(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new Jk(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function sS(e,t,n){return fl((()=>{switch(e.rank){case 1:return tg(e,t,n);case 2:return rg(e,[0,t],[e.shape[0],n]);case 3:return sg(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return og(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new Jk(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function iS(e,t,n,r){return fl((()=>{switch(e.rank){case 1:return tg(e,t,n);case 2:switch(r){case 1:return aS(e,t,n);case 2:return sS(e,t,n);default:throw new Jk(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return aS(e,t,n);case 2:return sg(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return sS(e,t,n);default:throw new Jk(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return aS(e,t,n);case 2:return og(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return og(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return sS(e,t,n);default:throw new Jk(`The axis is not within the rank of the tensor ${r}`)}default:throw new Jk(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function oS(e,t=-1){let n;return t<0&&(n=e[0].rank,t=0!==n?n:0),t===e[0].rank&&(t=-1),Kp(e,t)}function lS(e,t){switch(e.rank){case 1:return Nd([e,t]);case 2:return Cd([e,t],0);case 3:return Ed([e,t],0);case 4:return $d([e,t],0);default:throw new Jk(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function uS(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new Jk(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return sh(e,t)}function pS(e,t=0,n=1,r,a){return bm(e,t,n,r,a)}function dS(e,t,n,r){if(e.rank<2||t.rank<2)throw new Qk(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){let n=e.shape.slice(-1)[0],r=t.shape.slice(-2)[0];if(n!==r)throw new Qk(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(2===e.rank&&2===t.rank)return gy.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?fS(e.rank,r,JI()):null,activation:n});{let a=e.shape.slice(),s=a.pop();e=Vp(e,[-1,s]);let i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],p=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=Vp(Dl(t,p),[l,-1]);let d=[...a,...u],c=!1,h=!1;return Vp(gy.matMul({a:e,b:t,transposeA:c,transposeB:h,bias:r?fS(e.rank,r,JI()):null,activation:n}),d)}}function cS(e,t,n){return fl((()=>(t=Array.isArray(t)?Fg(t,"int32"):vo(t,"int32"),ch(e,t,n))))}function hS(e){return Yu(e,e)}function fS(e,t,n){let r=t.shape;if(1!==t.rank&&t.rank!==e)throw new Jk(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return 1===r.length?Vp(t,[1,r[0],1,1,1]):Vp(t,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?Vp(t,[1,1,1,1,r[0]]):Vp(t,[1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?Vp(t,[1,r[0],1,1]):Vp(t,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?Vp(t,[1,1,1,r[0]]):Vp(t,[1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?Vp(t,[1,r[0],1]):Vp(t,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?Vp(t,[1,1,r[0]]):Vp(t,[1].concat(r))}else if(e<3)return t;throw new Jk(`Unsupported input rank by biasAdd: ${t.rank}`)}function mS(e,t,n){return fl((()=>(null==n&&(n=JI()),RI(n),Gu(e,fS(e.rank,t,n)))))}function gS(e,t=1){if(1!==t)throw new Qk(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Ic(e)}function yS(e){return fl((()=>Ku(e,Gu(Ju(e),1))))}function bS(e,t,n,r){return fl((()=>dy(e,t,n,r)))}function wS(e){return fl((()=>{let t=Gu(.5,Yu(.2,e));return Id(t,0,1)}))}function xS(e,t,n=!1){return n?e():t()}var vS=["fanIn","fanOut","fanAvg"],kS=["normal","uniform","truncatedNormal"];function IS(e){yI(vS,"FanMode",e)}function SS(e){yI(kS,"Distribution",e)}var NS=class extends Nu.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},TS=class extends NS{apply(e,t){return kf(e,t)}};TS.className="Zeros",Nu.registerClass(TS);var CS=class extends NS{apply(e,t){return If(e,t)}};CS.className="Ones",Nu.registerClass(CS);var _S=class extends NS{constructor(e){if(super(),"object"!=typeof e)throw new Jk(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new Jk(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return fl((()=>Yu(Bc(this.value),If(e,t))))}getConfig(){return{value:this.value}}};_S.className="Constant",Nu.registerClass(_S);var ES=class extends NS{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return xm(e,this.minval,this.maxval,t)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};ES.className="RandomUniform",Nu.registerClass(ES);var AS=class extends NS{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32","float32"!==t&&"int32"!==t)throw new Qk(`randomNormal does not support dType ${t}.`);return pS(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};AS.className="RandomNormal",Nu.registerClass(AS);var $S=class extends NS{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32","float32"!==t&&"int32"!==t)throw new Qk(`truncatedNormal does not support dType ${t}.`);return Bg(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};$S.className="TruncatedNormal",Nu.registerClass($S);var FS=class extends NS{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return fl((()=>{if(2!==e.length||e[0]!==e[1])throw new Jk("Identity matrix initializer can only be used for 2D square matrices.");return Yu(this.gain,oh(e[0]))}))}getConfig(){return{gain:this.gain}}};function RS(e,t="channelsLast"){let n,r;if(RI(t),2===e.length)n=e[0],r=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===t){let t=qI(e,2);n=e[1]*t,r=e[0]*t}else if("channelsLast"===t){let t=qI(e,0,e.length-2);n=e[e.length-2]*t,r=e[e.length-1]*t}}else{let t=qI(e);n=Math.sqrt(t),r=Math.sqrt(t)}return[n,r]}FS.className="Identity",Nu.registerClass(FS);var DS=class extends NS{constructor(e){if(super(),e.scale<0)throw new Jk(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,IS(this.mode),this.distribution=null==e.distribution?"normal":e.distribution,SS(this.distribution),this.seed=e.seed}apply(e,t){let n=RS(e),r=n[0],a=n[1],s=this.scale;if("fanIn"===this.mode?s/=Math.max(1,r):"fanOut"===this.mode?s/=Math.max(1,a):s/=Math.max(1,(r+a)/2),"normal"===this.distribution){let n=Math.sqrt(s);if(t=t||"float32","float32"!==t&&"int32"!==t)throw new Qk(`${this.getClassName()} does not support dType ${t}.`);return Bg(e,0,n,t,this.seed)}{let n=Math.sqrt(3*s);return xm(e,-n,n,t)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};DS.className="VarianceScaling",Nu.registerClass(DS);var MS=class extends DS{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return DS.className}};MS.className="GlorotUniform",Nu.registerClass(MS);var OS=class extends DS{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return DS.className}};OS.className="GlorotNormal",Nu.registerClass(OS);var LS=class extends DS{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return DS.className}};LS.className="HeNormal",Nu.registerClass(LS);var PS=class extends DS{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return DS.className}};PS.className="HeUniform",Nu.registerClass(PS);var zS=class extends DS{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return DS.className}};zS.className="LeCunNormal",Nu.registerClass(zS);var BS=class extends DS{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return DS.className}};BS.className="LeCunNormal",Nu.registerClass(BS);var WS=class extends NS{constructor(e){if(super(),this.DEFAULT_GAIN=1,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,null!=this.seed)throw new Qk("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,t){return fl((()=>{if(e.length<2)throw new Qk("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);let t=e[0]>e[1]?[e[1],e[0]]:e,n=pS(t,0,1,"float32"),r=ww.gramSchmidt(n);return e[0]>e[1]&&(r=Dl(r)),Yu(this.gain,r)}))}getConfig(){return{gain:this.gain,seed:this.seed}}};WS.className="Orthogonal",Nu.registerClass(WS);var VS={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function US(e,t={}){return cI(e,Nu.SerializationMap.getMap().classNameMap,t,"initializer")}function GS(e){return pI(e)}function HS(e){if("string"==typeof e){let t=e in VS?VS[e]:e;if("GlorotNormal"===t)return new OS;if("GlorotUniform"===t)return new MS;if("HeNormal"===t)return new LS;if("HeUniform"===t)return new PS;if("LeCunNormal"===t)return new zS;if("LeCunUniform"===t)return new BS;{let e={};return e.className=t,e.config={},US(e)}}return e instanceof NS?e:US(e)}function jS(e){return Array.isArray(e)&&Array.isArray(e[0])}function qS(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function KS(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new Jk(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function XS(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new Jk(`Expected exactly 1 Shape; got ${e.length}`)}return e}function YS(e){let t=0;for(let n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}var ZS="Variable",JS=class{constructor(e,t="float32",n=ZS,r=!0,a=null){this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=SI(),n=null==n?ZS:n,this.originalName=WI(n),this.name=VI(this.originalName),this.trainable_=r,this.constraint=a,this.val=Kg(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),QS(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function QS(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function eN(e){return e.map((e=>e.read()))}function tN(e){e.forEach((e=>{e[0].write(e[1])}))}var nN=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},rN=class{constructor(e,t,n,r,a,s,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=i,this.id=SI(),null!=s&&(this.originalName=WI(s),this.name=VI(this.originalName)),this.rank=t.length}},aN=0,sN=class{constructor(e,t){this.callArgs=t,this.id=aN++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},iN=0,oN=class extends Nu.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=iN++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let e=this.getClassName();t=oI(e)+"_"+TI(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new Zk(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new Jk(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return sI(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return sI(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Yk(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new Yk(`Layer ${this.name} is not connected, no input to return.`);return sI(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new Yk(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Yk(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return sI(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=iI(e),null==this.inputSpec||0===this.inputSpec.length)return;let t=iI(this.inputSpec);if(e.length!==t.length)throw new Jk(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let n=0;n<e.length;n++){let r=e[n],a=t[n];if(null==a)continue;let s=r.rank;if(null!=a.ndim&&s!==a.ndim)throw new Jk(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${s}`);if(null!=a.maxNDim&&s>a.maxNDim)throw new Jk(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${s}`);if(null!=a.minNDim&&s<a.minNDim)throw new Jk(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${s}.`);if(null!=a.dtype&&r.dtype!==a.dtype)throw new Jk(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${r.dtype}.`);if(a.axes){let e=r.shape;for(let t in a.axes){let r=Number(t),s=a.axes[t],i=r>=0?e[r]:e[e.length+r];if(null!=s&&-1===[s,null].indexOf(i))throw new Jk(`Input ${n} is incompatible with layer ${this.name}: expected axis ${r} of input shape to have value ${s} but got shape ${e}.`)}}if(null!=a.shape)for(let e=0;e<a.shape.length;++e){let t=a.shape[e],s=r.shape[e];if(null!=t&&null!=s&&t!==s)throw new Jk(`Input ${n} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=iI(e),r=!0;for(let s of n)if(!(s instanceof rN)){r=!1;break}let a=!0;for(let s of n)if(s instanceof rN){a=!1;break}if(r===a)throw new Jk("Arguments to apply() must be all SymbolicTensors or all Tensors");return zI(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);let t=[];for(let n of iI(e))t.push(n.shape);this.build(sI(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let r=this.call(e,t),a=iI(r),s=[];for(let e of a)-1!==n.indexOf(e)&&(e=e.clone()),s.push(e);if(r=sI(s),null!=this.activityRegularizer)throw new Qk("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{let n,r=lN(e),a=this.computeOutputShape(r),s=uN(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?r[0]:r),n=null!=a&&a.length>0&&Array.isArray(a[0])?a.map(((n,r)=>new rN(s,n,this,iI(e),t,this.name,r))):new rN(s,a,this,iI(e),t,this.name),this.addInboundNode(e,n,null,null,r,a,t),this._refCount++,null!=this.activityRegularizer)throw new Qk("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return n}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)})),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new Yk(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){let e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new Yk(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Zk(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return YS(this.weights)}build(e){this.built=!0}getWeights(e=!1){return eN(e?this.trainableWeights:this.weights)}setWeights(e){fl((()=>{let t=this.weights;if(t.length!==e.length)throw new Jk(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;let n=[],r=eN(t);for(let a=0;a<r.length;++a){let s=r[a],i=t[a],o=e[a];if(!Aa.arraysEqual(s.shape,o.shape))throw new Jk(`Layer weight shape ${s.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}tN(n)}))}addWeight(e,t,n,r,a,s,i,o){if(-1!==this._addedWeightNames.indexOf(e))throw new Jk(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=o?o():HS("zeros"));let l=r.apply(t,n),u=new JS(l,n,e,s,i);return l.dispose(),null!=a&&this.addLoss((()=>a.apply(u.read()))),null==s&&(s=!0),s?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=iI(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach((e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return t}addInboundNode(e,t,n,r,a,s,i=null){let o=iI(e);t=iI(t),n=iI(n),r=iI(r),a=qS(a),s=qS(s);let l=[],u=[],p=[];for(let d of o)l.push(d.sourceLayer),u.push(d.nodeIndex),p.push(d.tensorIndex);new sN({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:p,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:s},i);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){let e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function lN(e){e=iI(e);let t=[];for(let n of e)t.push(n.shape);return sI(t)}function uN(e){return"float32"}function pN(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{let e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{let t=[];for(let n=0;n<e.inboundLayers.length;n++){let r=e.inputTensors[n],a=e.inboundLayers[n],s=e.nodeIndices[n],i=pN(r,a,s);for(let e of i)-1===t.indexOf(e)&&t.push(e)}return t}}}var dN=class extends oN{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:TI("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new Jk("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new Jk("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new Jk("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let r=new rN(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new sN({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new Jk(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};function cN(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new Jk("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new dN({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}function hN(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return vo(t,e.dtype)}catch(n){throw new Jk(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}dN.className="InputLayer",Nu.registerClass(dN);var fN=class{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof fN)for(let t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(let t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new Jk(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=hN(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof rN){if(null==this.id2Value[e.id])throw new Jk(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{let t=this.name2Id[e];if(null==t)throw new Jk(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof rN){if(null==this.id2Value[e.id])throw new Jk(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{let t=this.name2Id[e];if(null==t)throw new Jk(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&ml(this.id2Mask)}},mN=new tI,gN=new tI;function yN(e){null!=mN&&mN.setMaxEntries(e),null!=gN&&gN.setMaxEntries(e)}function bN(e,t,n,r){let a=null!=n&&n.training,s=Array.isArray(e),i=s?e:[e],o=i.map((e=>e.name)),l=[],u=t.names();for(let f of o)-1!==u.indexOf(f)?l.push(t.getValue(f)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);let p,d=o.join(",")+"|"+t.names().sort().join(","),c=mN.get(d);if(null==c){let e=wN(i,t);c=e.sorted,p=e.recipientCounts,mN.put(d,c),gN.put(d,p)}p={},a||Object.assign(p,gN.get(d));let h=new fN(t);for(let f=0;f<c.length;++f){if(null!=r){let e=cl().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}let e=c[f],s=e.sourceLayer;if(s instanceof dN)continue;let i=[],u=[],d=[],m=!1;for(let n of e.inputs){let e=h.getValue(n),r=h.getMask(n);i.push(e),u.push(r),null!=r&&(m=!0),a||(p[n.name]--,0===p[n.name]&&!t.hasKey(n)&&-1===o.indexOf(n.name)&&!e.isDisposed&&!0!==n.sourceLayer.stateful&&d.push(e))}m&&(n=n||{},n.mask=u[0]);let g=iI(s.apply(i,n)),y=null;s.supportsMasking&&(y=s.computeMask(i,u));let b=kN(e),w=Array.isArray(b)?b:[b];for(let t=0;t<w.length;++t){h.hasKey(w[t])||h.add(w[t],g[t],Array.isArray(y)?y[0]:y);let e=o.indexOf(w[t].name);-1!==e&&(l[e]=g[t])}a||ml(d)}return h.disposeMasks(),s?l:l[0]}function wN(e,t){Aa.assert(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===e.length){let a=vN(e[0],t);n=a.sorted,r=a.recipientMap}else{let a=new Set;for(let s of e){let{sorted:e,recipientMap:i}=vN(s,t);for(let t of e)a.has(t.name)||(n.push(t),a.add(t.name));for(let t in i)null==r[t]&&(r[t]=new Set),i[t].forEach((e=>r[t].add(e)))}}return{sorted:n,recipientCounts:xN(r)}}function xN(e){let t={};for(let n in e)t[n]=e[n].size;return t}function vN(e,t){let n=new Set,r=[],a={};for(let o of t.names())n.add(o);let s=[],i=[];for(s.push(e);s.length>0;){let e=s[s.length-1];if(n.has(e.name)){s.pop();continue}let t=i[i.length-1]===s.length-1;if(0===e.inputs.length||t)s.pop(),r.push(e),n.add(e.name),t&&i.pop();else{i.push(s.length-1);for(let t of e.inputs)null==a[t.name]&&(a[t.name]=new Set),a[t.name].add(e.name),!n.has(t.name)&&s.push(t)}}return{sorted:r,recipientMap:a}}function kN(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(let r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}var IN=et();IN.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),yN);var SN={};function NN(e,t){return fl((()=>Vc(jc(Yu(e,e),t,!0))))}v(SN,{maxNorm:()=>MN,minMaxNorm:()=>PN,nonNeg:()=>LN,unitNorm:()=>ON});var TN=class extends Nu.Serializable{getConfig(){return{}}},CN=class extends TN{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return fl((()=>{let t=NN(e,this.axis),n=Id(t,0,this.maxValue);return Yu(e,Ku(n,Gu(ZI(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};CN.className="MaxNorm",Nu.registerClass(CN);var _N=class extends TN{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return fl((()=>Ku(e,Gu(ZI(),NN(e,this.axis)))))}getConfig(){return{axis:this.axis}}};_N.className="UnitNorm",Nu.registerClass(_N);var EN=class extends TN{apply(e){return Nm(e)}};EN.className="NonNeg",Nu.registerClass(EN);var AN=class extends TN{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return fl((()=>{let t=NN(e,this.axis),n=Gu(Yu(this.rate,Id(t,this.minValue,this.maxValue)),Yu(1-this.rate,t));return Yu(e,Ku(n,Gu(ZI(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};AN.className="MinMaxNorm",Nu.registerClass(AN);var $N={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function FN(e){return pI(e)}function RN(e,t={}){return cI(e,Nu.SerializationMap.getMap().classNameMap,t,"constraint")}function DN(e){if(null==e)return null;if("string"==typeof e){let t={className:e in $N?$N[e]:e,config:{}};return RN(t)}return e instanceof TN?e:RN(e)}function MN(e){return new CN(e)}function ON(e){return new _N(e)}function LN(){return new EN}function PN(e){return new AN(e)}var zN={};function BN(){return new TS}function WN(){return new CS}function VN(e){return new _S(e)}function UN(e){return new ES(e)}function GN(e){return new AS(e)}function HN(e){return new $S(e)}function jN(e){return new FS(e)}function qN(e){return new DS(e)}function KN(e){return new MS(e)}function XN(e){return new OS(e)}function YN(e){return new LS(e)}function ZN(e){return new PS(e)}function JN(e){return new zS(e)}function QN(e){return new BS(e)}function eT(e){return new WS(e)}v(zN,{constant:()=>VN,glorotNormal:()=>XN,glorotUniform:()=>KN,heNormal:()=>YN,heUniform:()=>ZN,identity:()=>jN,leCunNormal:()=>JN,leCunUniform:()=>QN,ones:()=>WN,orthogonal:()=>eT,randomNormal:()=>GN,randomUniform:()=>UN,truncatedNormal:()=>HN,varianceScaling:()=>qN,zeros:()=>BN});var tT,nT={};async function rT(e){if(null==e)return;let t=[],n=[],r=[];for(let a in e){let s=e[a];if("number"!=typeof s){let e=s;t.push(e.data()),n.push(a),r.push(e)}}if(t.length>0){let a=await Promise.all(t);for(let t=0;t<a.length;++t)e[n[t]]=a[t][0];ml(r)}}function aT(e){if(null!=e)for(let t in e){let n=e[t];"number"!=typeof n&&n.dispose()}}v(nT,{Layer:()=>oN,RNN:()=>aE,RNNCell:()=>sE,activation:()=>RA,add:()=>VA,alphaDropout:()=>F$,average:()=>UA,averagePooling1d:()=>JA,averagePooling2d:()=>t$,averagePooling3d:()=>a$,avgPool1d:()=>QA,avgPool2d:()=>n$,avgPool3d:()=>s$,avgPooling1d:()=>e$,avgPooling2d:()=>r$,avgPooling3d:()=>i$,batchNormalization:()=>XA,bidirectional:()=>S$,concatenate:()=>GA,conv1d:()=>SA,conv2d:()=>NA,conv2dTranspose:()=>TA,conv3d:()=>CA,conv3dTranspose:()=>_A,convLstm2d:()=>x$,convLstm2dCell:()=>v$,cropping2D:()=>AA,dense:()=>DA,depthwiseConv2d:()=>FA,dot:()=>KA,dropout:()=>MA,elu:()=>bA,embedding:()=>WA,flatten:()=>LA,gaussianDropout:()=>$$,gaussianNoise:()=>A$,globalAveragePooling1d:()=>o$,globalAveragePooling2d:()=>l$,globalMaxPool1d:()=>T$,globalMaxPool2d:()=>C$,globalMaxPooling1d:()=>u$,globalMaxPooling2d:()=>p$,gru:()=>f$,gruCell:()=>m$,input:()=>e_,inputLayer:()=>yA,layerNormalization:()=>YA,leakyReLU:()=>xA,lstm:()=>g$,lstmCell:()=>y$,masking:()=>R$,maxPool1d:()=>_$,maxPool2d:()=>E$,maxPooling1d:()=>d$,maxPooling2d:()=>c$,maxPooling3d:()=>h$,maximum:()=>HA,minimum:()=>jA,multiply:()=>qA,permute:()=>BA,prelu:()=>vA,reLU:()=>wA,repeatVector:()=>PA,reshape:()=>zA,rnn:()=>k$,separableConv2d:()=>EA,simpleRNN:()=>b$,simpleRNNCell:()=>w$,softmax:()=>kA,spatialDropout1d:()=>OA,stackedRNNCells:()=>I$,thresholdedReLU:()=>IA,timeDistributed:()=>N$,upSampling2d:()=>$A,zeroPadding2d:()=>ZA}),function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(tT||(tT={}));var sT=125,iT=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},oT=class{constructor(e,t=10){null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},lT=class extends iT{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});let n=null==t.size?0:t.size;this.seen+=n;for(let r in t){let e=t[r];if("number"==typeof e)this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+e*n;else{let t;r in this.totals?t=this.totals[r]:this.totals[r]=0;let a=fl((()=>Gu(this.totals[r],Yu(e,n))));this.totals[r]=a,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(let n of this.params.metrics)null!=this.totals[n]&&("number"==typeof this.totals[n]?t[n]=this.totals[n]/this.seen:fl((()=>{let e=Yu(Ku(1,this.seen),this.totals[n]);t[n]=e,this.totals[n].dispose(),gl(t[n])})))}},uT=class extends iT{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(let n in t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let a in this.history){let r=this.history[a];for(let s=0;s<r.length;++s)if("number"!=typeof r[s]){let i=r[s];e.push(i.data()),t.push(a),n.push(s)}}let r=await Promise.all(e);for(let a=0;a<r.length;++a)this.history[t[a]][n[a]].dispose(),this.history[t[a]][n[a]]=r[a][0]}},pT=class extends iT{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Dw,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=sT),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Aa.isNumber(this.yieldEvery)&&(this.maybeWait=vI(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let r=[];null!=this.yield&&(await rT(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await rT(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];null!=this.epochEnd&&(await rT(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await rT(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];null!=this.batchEnd&&(await rT(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):Aa.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await rT(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await rT(e),await this.trainEnd(e))}};function dT(e,t){return null==e&&(e={}),e instanceof iT?[e]:Array.isArray(e)&&e[0]instanceof iT?e:iI(e).map((e=>new pT(e,t)))}var cT=class{constructor(){}static registerCallbackConstructor(e,t){Aa.assert(e>=0&&Number.isInteger(e),(()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`)),cT.checkForDuplicate(t),null==cT.constructors[e]&&(cT.constructors[e]=[]),cT.constructors[e].push(t)}static checkForDuplicate(e){for(let t in cT.constructors)cT.constructors[+t].forEach((t=>{if(t===e)throw new Jk("Duplicate callback constructor.")}))}static clear(){cT.constructors={}}static createCallbacks(e){let t=[];for(let n in cT.constructors){let r=+n;e>=r&&t.push(...cT.constructors[r])}return t.map((e=>new e))}};function hT(e,t,n,r,a,s,i,o,l){let u=new uT,p=[new lT,...cT.createCallbacks(t)];null!=e&&p.push(...e),p.push(u);let d=new oT(p);return d.setParams({epochs:n,initialEpoch:r,samples:a,steps:s,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:d,history:u}}function fT(e,t={},n=!1){return cI(e,Nu.SerializationMap.getMap().classNameMap,t,"layer",n)}function mT(e,t){return fl((()=>{"float32"!==e.dtype&&(e=vo(e,"float32"));let n=jc(hS(e),t,!0),r=lh(n.shape,ZI()),a=Vc(wf(n,r));return Ku(e,a)}))}function gT(e,t){return fl((()=>vf(hS(Kh(t,e)),-1)))}function yT(e,t){return fl((()=>vf(Ju(Kh(t,e)),-1)))}function bT(e,t){return fl((()=>{let n=Kh(e,t),r=Id(Ju(e),ZI(),Number.MAX_VALUE),a=Ju(Ku(n,r));return Yu(100,vf(a,-1))}))}function wT(e,t){return fl((()=>{let n=Id(t,ZI(),Number.MAX_VALUE),r=Rh(Gu(1,n)),a=Id(e,ZI(),Number.MAX_VALUE),s=Rh(Gu(1,a));return vf(hS(Kh(r,s)),-1)}))}function xT(e,t){return fl((()=>{let n=wf(0,Kh(1,Yu(e,t)));return vf(hS(n),-1)}))}function vT(e,t){return fl((()=>{let n=wf(0,Kh(1,Yu(e,t)));return vf(n,-1)}))}function kT(e,t){return fl((()=>{let n=jc(Yu(e,t),-1),r=Mc(Yu(Kh(1,e),t),-1);return wf(0,Gu(1,Kh(r,n)))}))}function IT(e,t){return fl((()=>{let n=Math.log(2),r=Kh(t,e),a=Kh(Gu(r,Gh(Yu(-2,r))),n);return vf(a,-1)}))}function ST(e,t,n=!1){return fl((()=>{if(n)t=ug(t);else{let e=jc(t,t.shape.length-1,!0);t=Ku(t,e)}return t=Id(t,ZI(),1-ZI()),Al(jc(Yu(vo(e,"float32"),Rh(t)),t.shape.length-1))}))}function NT(e,t,n=!1){return fl((()=>{let r=vo(ph(nS(e)),"int32");t=Id(t,ZI(),1-ZI());let a=t.shape,s=Vp(sl(r,a[a.length-1]),a);return ST(s,t,n)}))}function TT(e,t){if(!Aa.arraysEqual(e.shape,t.shape))throw new Jk(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return fl((()=>{let n=Nm(t),r=Al(Ju(t));return Gu(Kh(n,Yu(t,e)),Mh(Qc(r)))}))}function CT(e,t){return fl((()=>{let n;return n=Id(t,ZI(),1-ZI()),n=Rh(Ku(n,Kh(1,n))),vf(TT(e,n),-1)}))}function _T(e,t){return fl((()=>{let n=Id(e,ZI(),1),r=Id(t,ZI(),1);return jc(Yu(e,Rh(Ku(n,r))),-1)}))}function ET(e,t){return fl((()=>{let n=Rh(Gu(ZI(),t));return vf(Kh(t,Yu(e,n)),-1)}))}function AT(e,t){return fl((()=>{let n=mT(e,-1),r=mT(t,-1),a=Yu(n,r);return Al(jc(a,-1))}))}cT.constructors={};var $T={meanSquaredError:gT,meanAbsoluteError:yT,meanAbsolutePercentageError:bT,meanSquaredLogarithmicError:wT,squaredHinge:xT,hinge:vT,categoricalHinge:kT,logcosh:IT,categoricalCrossentropy:ST,sparseCategoricalCrossentropy:NT,binaryCrossentropy:CT,kullbackLeiblerDivergence:_T,poisson:ET,cosineProximity:AT};function FT(e){if("string"==typeof e){if(e in $T)return $T[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new Jk(t)}return e}function RT(e,t){return fl((()=>{let n=Yu(.5,Bf(t)),r=QI(fh(t,n),e.dtype);return vf(dc(e,r),-1)}))}function DT(e,t){return fl((()=>QI(dc(pp(e,-1),pp(t,-1)),"float32")))}function MT(e,t){return fl((()=>vo(jc(ef(dc(e,1),dc(t,1))),"float32")))}function OT(e,t){return fl((()=>vo(jc(ef(dc(e,1),dc(t,0))),"float32")))}function LT(e,t){return fl((()=>vo(jc(ef(dc(e,0),dc(t,1))),"float32")))}function PT(e,t){return fl((()=>{let n=MT(e,t),r=LT(e,t),a=Gu(n,r);return vo(hc(fh(a,0),Ku(n,a),0),"float32")}))}function zT(e,t){return fl((()=>{let n=MT(e,t),r=OT(e,t),a=Gu(n,r);return vo(hc(fh(a,0),Ku(n,a),0),"float32")}))}function BT(e,t){return CT(e,t)}function WT(e,t){return e.rank===t.rank&&(e=Ig(e,[e.rank-1])),t=pp(t,-1),t.dtype!==e.dtype&&(t=vo(t,e.dtype)),vo(dc(e,t),"float32")}var VT=gT,UT=gT,GT=yT,HT=yT,jT=bT,qT=bT,KT=ST,XT=AT,YT=NT,ZT={binaryAccuracy:RT,categoricalAccuracy:DT,precision:PT,categoricalCrossentropy:KT,sparseCategoricalCrossentropy:YT,mse:VT,MSE:UT,mae:GT,MAE:HT,mape:jT,MAPE:qT,cosine:XT};function JT(e){if("string"==typeof e&&e in ZT)return ZT[e];if("string"!=typeof e&&null!=e)return e;throw new Jk(`Unknown metric ${e}`)}function QT(e){if(rI(null!==e,`Unknown LossOrMetricFn ${e}`),"string"==typeof e)return e;{let t;for(let n of Object.keys($T))if($T[n]===e){t=n;break}if(void 0!==t)return t;for(let n of Object.keys(ZT))if(ZT[n]===e){t=n;break}return void 0!==t?t:e.name}}function eC(e){let t={Adagrad:()=>Fw.adagrad(.01),Adadelta:()=>Fw.adadelta(1,.95,ZI()),Adam:()=>Fw.adam(.001,.9,.999,ZI()),Adamax:()=>Fw.adamax(.002,.9,.999,ZI(),0),RMSProp:()=>Fw.rmsprop(.001,.9,0,ZI()),SGD:()=>Fw.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new Jk(`Unknown Optimizer ${e}`)}function tC(e,t,n=!1){if(null==e||"object"!=typeof e||Object.getPrototypeOf(e)!==Object.prototype||!nC(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let n=JSON.stringify(e);n.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function nC(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if("string"!=typeof n||!nC(e[n]))return!1;return!0}if(Array.isArray(e)){for(let t of e)if(!nC(t))return!1;return!0}return!1}{let t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function rC(e,t,n,r=console.log){let a,s=sC(e),i=["Layer (type)","Input Shape","Output shape","Param #"];if(s?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!s){i.push("Receives inputs"),a=[];for(let t in e.nodesByDepth)a.push(...e.nodesByDepth[t])}r("_".repeat(t)),iC(i,n,r),r("=".repeat(t));let o=e.layers;for(let p=0;p<o.length;++p)s?oC(o[p],n,r):lC(o[p],n,a,r),r((p===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let l=aC(e),u=YS(e.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}function aC(e){let t;return t=null!=e.collectedTrainableWeights?YS(e.collectedTrainableWeights):YS(e.trainableWeights),t}function sC(e){let t=!0,n=[],r=[];for(let a in e.nodesByDepth)n.push(e.nodesByDepth[a]);for(let a of n){if(a.length>1||1===a.length&&a[0].inboundLayers.length>1){t=!1;break}r.push(...a)}if(t)for(let a of e.layers){let e=!1;for(let n of a.inboundNodes)if(-1!==r.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}function iC(e,t,n=console.log){let r="";for(let a=0;a<e.length;++a)a>0&&(r=r.slice(0,r.length-1)+" "),r+=e[a],r=r.slice(0,t[a]),r+=" ".repeat(t[a]-r.length);n(r)}function oC(e,t,n){let r,a;try{a=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(l){a="multiple"}try{r=JSON.stringify(e.outputShape)}catch(l){r="multiple"}let s=e.name,i=e.getClassName(),o=[`${s} (${i})`,a,r,e.countParams().toString()];iC(o,t,n)}function lC(e,t,n,r){let a,s;try{s=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(d){s="multiple"}try{a=JSON.stringify(e.outputShape)}catch(d){a="multiple"}let i=[];for(let c of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(c)))for(let e=0;e<c.inboundLayers.length;++e){let t=c.inboundLayers[e].name,n=c.nodeIndices[e],r=c.tensorIndices[e];i.push(`${t}[${n}][${r}]`)}let o=e.name,l=e.getClassName(),u=0===i.length?"":i[0],p=[`${o} (${l})`,s,a,e.countParams().toString(),u];iC(p,t,r);for(let c=1;c<i.length;++c)iC(["","","","",i[c]],t,r)}function uC(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function pC(e,t){if(null===e)return null;if("string"==typeof e)return lI(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let r=e[a];uC(t,a,r)?n.push(r):n.push(pC(r,t))}return n}{let t={};for(let n of Object.keys(e)){let r=e[n];if("name"===n&&"string"==typeof r)t[n]=r;else{let e=lI(n);t[e]=pC(r,e)}}return t}}function dC(e,t){if(null==e)return null;if("string"==typeof e)return oI(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let r=e[a];uC(t,a,r)?n.push(r):n.push(dC(r,t))}return n}{let t={};for(let n of Object.keys(e)){let r=e[n],a=oI(n);t[a]="name"!==n&&"className"!==n||"string"!=typeof r?dC(r,n):r}return t}}var cC="3.18.0",hC=class extends oN{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){let e=this.getClassName().toLowerCase();this.name=TI(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],mI(this.inputs).length!==this.inputs.length)throw new Jk(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((e=>e.name))}`);mI(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((e=>e.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let y of this.outputs){let e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;this.outputLayers.push(e),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(n)}for(let y of this.inputs){let e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;rI(0===t,"input layer has >1 nodes"),rI(0===n,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(t),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){let t=this.inputLayers[y];if(!(t instanceof dN))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${y} (0-based) originates from layer type ${t.getClassName()}.`);this.inputNames.push(t.name),this.feedInputShapes.push(t.batchInputShape),this.feedInputNames.push(t.name)}for(let y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));let t={},n={},r={},a={},s={},i=[],o=(e,t,n,r,a,l)=>{(null==r||null==a||null==l)&&(r=e.sourceLayer,a=e.nodeIndex,l=e.tensorIndex);let u=r.inboundNodes[a];if(-1!==n.indexOf(u))throw new Zk(`The tensor ${e.name} at layer "${r.name}" is part of a cycle.`);if(-1!==t.indexOf(u))return;this.containerNodes.add(hC.nodeKey(r,a)),r.id in s||(s[r.id]=Object.keys(s).length),-1===n.indexOf(u)&&n.push(u);let p=u.inboundLayers.length;for(let s=0;s<p;s++){let e=u.inputTensors[s],r=u.inboundLayers[s],a=u.nodeIndices[s],i=u.tensorIndices[s];o(e,t,n,r,a,i)}for(t.push(u);n.indexOf(u)>=0;)n.splice(n.indexOf(u),1);i.push(u)},l=[],u=[];for(let y of this.outputs)o(y,l,u);let p=i.slice().reverse();for(let y of p){n[y.id]=y,y.id in t||(t[y.id]=0);let e=t[y.id],s=null==r[y.outboundLayer.id]?0:r[y.outboundLayer.id];e=Math.max(e,s),r[y.outboundLayer.id]=e,a[y.outboundLayer.id]=y.outboundLayer,t[y.id]=e;for(let r=0;r<y.inboundLayers.length;r++){let a=y.inboundLayers[r],s=y.nodeIndices[r],i=a.inboundNodes[s],o=null==t[i.id]?0:t[i.id];t[i.id]=Math.max(e+1,o),n[i.id]=i}}let d={};for(let y in t){let e=t[y];e in d||(d[e]=[]),d[e].push(n[y])}let c={};for(let y in r){let e=r[y];e in c||(c[e]=[]),c[e].push(a[y])}let h=Object.keys(c).map((e=>parseInt(e,10))).sort(fI);this.layers=[];for(let y of h){let e=c[y];e.sort(((e,t)=>{let n=s[e.id],r=s[t.id];return n<r?-1:n>r?1:0}));for(let t of e)t instanceof hC&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=c,h=Object.keys(d).map((e=>parseInt(e,10))).sort(fI);let f=this.inputs.slice(),m=[];for(let y of h)for(let e of d[y]){let t=e.outboundLayer;if(null!=t){for(let n of e.inputTensors)if(-1===f.indexOf(n))throw new Zk(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${t.name}". The following previous layers were accessed without issue: ${m}`);for(let t of e.outputTensors)f.push(t);m.push(t.name)}}this.nodesByDepth=d;let g=this.layers.map((e=>e.name));for(let y of g){let e=g.filter((e=>e===y)).length;if(1!==e)throw new Zk(`The name "${y}" is used ${e} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new sN({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(let t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(let t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new Jk("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(let t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){let n={},r=0;for(let s of this.layers)for(let e of s.weights){if(null!=n[e.originalName])throw new Jk(`Duplicate weight name: ${e.originalName}`);n[e.originalName]=e,r++}let a=[];for(let s in e){let r=s;if(null==n[s]){let e=s.split("/");r=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[r])a.push([n[r],e[s]]);else if(t)throw new Jk(`Provided weight data has no target variable: ${s}`);delete n[r]}if(t){let e=[];for(let t in n)e.push(t);if(e.length>0)throw new Jk(`${e.length} of ${r} weights are not set: ${e}`)}tN(a)}updatedConfig(){let e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${cC}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){let n=dC(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return fl((()=>{e=iI(e);let n=new fN;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return bN(this.outputs,n,t)}))}computeMask(e,t){return fl((()=>{let n;return e=iI(e),n=null==t?nI(null,e.length):iI(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){let t=qS(e);if(t.length!==this.inputLayers.length)throw new Jk(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);let n={};for(let i=0;i<t.length;i++){let e=this.inputLayers[i],r=t[i],a=e.name+"_0_0";n[a]=r}let r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(fI);if(r.length>1)for(let i of r){let e=this.nodesByDepth[i];for(let t of e){let e=t.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(e.id))continue;let r=[];for(let o=0;o<t.inboundLayers.length;o++){let e=t.inboundLayers[o],a=t.nodeIndices[o],s=t.tensorIndices[o],i=`${e.name}_${a}_${s}`,l=n[i];r.push(l)}let a=e.computeOutputShape(sI(r)),s=qS(a),i=e.inboundNodes.indexOf(t);for(let t=0;t<s.length;t++){let r=`${e.name}_${i}_${t}`;n[r]=s[t]}}}let a=[],s=[];for(let i=0;i<this.outputLayers.length;i++){let e=this.outputLayers[i],t=this.outputLayersNodeIndices[i],n=this.outputLayersTensorIndices[i],r=`${e.name}_${t}_${n}`;s.push(r)}for(let i=0;i<s.length;i++){let e=s[i];rI(e in n),a.push(n[e])}return sI(a)}runInternalGraph(e,t){null==t&&(t=nI(null,e.length));let n={};for(let o=0;o<this.inputs.length;++o){let r=this.inputs[o],a=e[o],s=t[o];n[r.id]=[a,s]}let r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(fI);for(let o of r){let e=this.nodesByDepth[o];for(let t of e){let e=t.outboundLayer,r=t.inputTensors,a=t.outputTensors,s=new Array;for(let t of r)t.id in n&&s.push(n[t.id]);if(s.length===r.length){let r,i,o,l,u={};if(null!=t.callArgs&&(u=t.callArgs),1===s.length){let[t,n]=s[0];null==u.mask&&(u.mask=n),o=iI(e.call(t,u)),l=iI(e.computeMask(t,n)),r=[t],i=[n]}else r=s.map((e=>e[0])),i=s.map((e=>e[1])),null==u.mask&&(u.mask=i),o=iI(e.call(r,u)),l=iI(e.computeMask(r,i));if(e.activityRegularizer)throw new Qk("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<a.length;++e){let t=a[e],r=o[e],s=l[e];n[t.id]=[r,s]}}}}let a=[],s=[],i=[];for(let o of this.outputs){rI(o.id in n,`Could not compute output ${o.name} : ${o.id}`);let[e,t]=n[o.id];i.push(e.shape),a.push(e),s.push(t)}return[a,s,i]}buildNodeConversionMap(e){let t,n={};for(let r of this.layers){t=r instanceof hC?1:0;for(let e=0;e<r.inboundNodes.length;e++){let a=hC.nodeKey(r,e);this.containerNodes.has(a)&&(n[a]=t,t+=1)}}return n}getLayer(e,t){if(null!=t){if(this.layers.length<=t)throw new Jk(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}if(null==e)throw new Jk("Provide either a layer name or layer index");for(let n of this.layers)if(n.name===e)return n;throw new Jk(`No such layer: ${e}`)}calculateLosses(){return fl((()=>{let e=[];for(let t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){let r=hC.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e}))}getConfig(){let e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(let i of this.layers){let e=i.getClassName(),r=i.getConfig(),a=[];for(let n=0;n<i.inboundNodes.length;n++){let e=i.inboundNodes[n],r=hC.nodeKey(i,n),o={};if(this.containerNodes.has(r)){if(e.callArgs)try{JSON.stringify(e.callArgs),o=e.callArgs}catch(s){console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${e.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),o={}}if(e.inboundLayers.length>0){let n=[];for(let r=0;r<e.inboundLayers.length;r++){let a=e.inboundLayers[r],s=e.nodeIndices[r],i=e.tensorIndices[r],l=hC.nodeKey(a,s),u=t[l];null==u&&(u=0),n.push([a.name,u,i,o])}a.push(n)}}}let o={};o.name=i.name,o.className=e,o.config=r,o.inboundNodes=a,n.push(o)}e.layers=n;let r=[];for(let i=0;i<this.inputLayers.length;i++){let e=this.inputLayers[i],n=this.inputLayersNodeIndices[i],a=hC.nodeKey(e,n);if(!this.containerNodes.has(a))continue;let s=t[a];null==s&&(s=0);let o=this.inputLayersTensorIndices[i];r.push([e.name,s,o])}e.inputLayers=r;let a=[];for(let i=0;i<this.outputLayers.length;i++){let e=this.outputLayers[i],n=this.outputLayersNodeIndices[i],r=hC.nodeKey(e,n);if(!this.containerNodes.has(r))continue;let s=t[r];null==s&&(s=0);let o=this.outputLayersTensorIndices[i];a.push([e.name,s,o])}return e.outputLayers=a,e}static fromConfig(e,t,n={},r=!1){let a={},s={};function i(e,t){e.name in s?s[e.name].push(t):s[e.name]=[t]}function o(e,t){let n,r=[];for(let s of t){let o=s[0],l=s[1],u=s[2];if(n=null==s[3]?{}:s[3],!(o in a))return void i(e,t);let p=a[o];if(p.inboundNodes.length<=l)return void i(e,t);let d=p.inboundNodes[l];r.push(d.outputTensors[u])}r.length>0&&e.apply(sI(r),n)}function l(e){let n=e.name,s=fT(e,null!=t.customObjects?t.customObjects:{});s.setFastWeightInitDuringBuild(r),a[n]=s,e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new Jk(`Corrupted configuration, expected array for nodeData: ${e}`);i(s,e)}))}let u=t.name,p=t.layers;for(let m of p)l(m);for(;!gI(s);)for(let e of p){let t=a[e.name];if(t.name in s){let e=s[t.name];delete s[t.name];for(let n of e)o(t,n)}}let d=[],c=[],h=t.inputLayers;for(let m of h){let e=m[0],t=m[1],n=m[2];rI(e in a);let r=a[e].inboundNodes[t].outputTensors;d.push(r[n])}let f=t.outputLayers;for(let m of f){let e=m[0],t=m[1],n=m[2];rI(e in a);let r=a[e].inboundNodes[t].outputTensors;c.push(r[n])}return new e({inputs:d,outputs:c,name:u})}get stateful(){if(this._stateful)throw new Jk("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let e of this.layers)if(e.stateful)return!0;return!1}resetStates(){fl((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}};function fC(e,t,n){let r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===r)return Array.isArray(e)&&1===e.length?e:"object"==typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){let n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function mC(e,t){return fC(e,t,"classWeight")}async function gC(e,t,n,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){let t=fl((()=>{if(1===e.shape.length)return Io(e);if(2===e.shape.length){if(e.shape[1]>1)return pp(e,1);if(1===e.shape[1])return Vp(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),r=Array.from(await t.data());ml(t);let a=[];return r.forEach((e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);a.push(n[e])})),Fg(a,"float32")}return null}function yC(e,t){return Yu(e,t)}var bC=32;function wC(e,t){let n,r,a=t;n=a.xs,r=a.ys,Aa.assert(null!=n&&null!=r,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`));let s=xC("input",e.inputNames,n),i=xC("output",e.outputNames,r),o=s[0].shape[0];Aa.assert(s.length===e.inputs.length,(()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`)),Aa.assert(i.length===e.outputs.length,(()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`));for(let l=0;l<s.length;l++)Aa.assert(s[l].shape[0]===o,(()=>`Batch size mismatch: input ${e.inputNames[l]} has ${s[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));for(let l=0;l<i.length;l++)Aa.assert(i[l].shape[0]===o,(()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));return{xs:s,ys:i}}function xC(e,t,n){if(n instanceof ks)return[n];if(Array.isArray(n))return Aa.assert(n.length===t.length,(()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`)),n;{let r=[];for(let a of t){if(null==n[a])throw new Jk(`The feature data generated by the dataset lacks the required ${e} key '${a}'.`);r.push(n[a])}return r}}function vC(e){if(3===e.length)throw new Qk("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}async function kC(e,t,n){let r=null!=n.batchesPerEpoch;if(Aa.assert(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),Aa.assert(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),Aa.assert(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),Aa.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),Aa.assert(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let a,s,i=null!=n.validationData;if(i)if(SC(n.validationData))Aa.assert(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{let e=vC(n.validationData);a=e.xs,s=e.ys}let o,l=e.makeTrainFunction(),u=e.getDedupedMetricsNames();o=i?u.slice().concat(u.map((e=>"val_"+e))):u.slice();let p=dT(n.callbacks,n.yieldEvery),d=null==n.verbose?1:n.verbose,{callbackList:c,history:h}=hT(p,d,n.epochs,null,null,IC(t,n),null,i,o);c.setModel(e),e.history=h,await c.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){let o={};await c.onEpochBegin(f);let p=0,d=0;for(r||(m=await t.iterator());!r||p<n.batchesPerEpoch;){let t=await m.next();if(r&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${p} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=t.value){let{xs:r,ys:a}=wC(e,t.value),s={};s.batch=d,s.size=r[0].shape[0],await c.onBatchBegin(d,s);let i=[];if(null!=n.classWeight){let t=mC(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)i.push(await gC(a[e],null,t[e]))}let o=r.concat(a).concat(i),h=l(o);ml(o);for(let e=0;e<u.length;++e){let t=u[e],n=h[e];s[t]=n,gl(n)}await c.onBatchEnd(d,s),aT(s),d++,p++}if(r?p>=n.batchesPerEpoch:t.done){if(i){let t;t=SC(n.validationData)?iI(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):iI(e.evaluate(a,s,{batchSize:null==n.validationBatchSize?bC:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)o[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await c.onEpochEnd(f,o),f++,e.stopTraining_)break}return await c.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function IC(e,t){let n=null;return null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function SC(e){return"function"==typeof e.iterator}function NC(e){return"function"==typeof e.next}async function TC(e,t,n){n=n||{};let r=null!=n.batches,a=e.testFunction,s=[];if(n.verbose>0)throw new Qk("Verbose mode is not implemented yet.");Aa.assert(!r||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));let i=NC(t)?t:await t.iterator(),o=0,l=0;for(;!r||l<n.batches;){let t=await i.next();if(s=fl((()=>{if(t.value){let{xs:n,ys:r}=wC(e,t.value),i=n.concat(r),u=fl((()=>a(i)));if(ml(i),0===l)for(let e=0;e<u.length;++e)s.push(Bc(0));let p=i[0].shape[0];for(let e=0;e<u.length;++e){let t=u[e],n=s[e];s[e]=fl((()=>Gu(s[e],Yu(p,t)))),l>0&&ml(n)}ml(u),o+=p,++l}return s})),t.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<s.length;++u){let e=s[u];s[u]=Ku(s[u],o),ml(e)}return sI(s)}function CC(e){Aa.assert(e>0&&Number.isInteger(e),(()=>`batchSize is required to be a positive integer, but got ${e}`))}function _C(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>aS(e,t,n-t))):aS(e,t,n-t)}function EC(e,t){return fl((()=>null==e?null:Array.isArray(e)?e.map((e=>EC(e,t))):cS(e,"int32"===t.dtype?t:vo(t,"int32"))))}function AC(e,t){let n=[],r=0,a=null;for(;r<e;)a=r+t,a>=e&&(a=e),n.push([r,a]),r=a;return n}async function $C(e,t,n,r,a,s,i,o,l,u,p,d,c,h,f){null==a&&(a=32),null==s&&(s=1),null==p&&(p=!0),null==c&&(c=0);let m=!1;if(null!=l&&null!=u&&(m=!0),null!=f&&(m=!0,null==h))throw new Jk("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let g,y=e.checkNumSamples(n,a,h,"steps_per_epoch");null!=y&&(g=YI(0,y)),null==i&&(i=1);let{callbackList:b,history:w}=hT(o,i,s,c,y,h,a,m,d);b.setModel(e),e.history=w,await b.onTrainBegin(),e.stopTraining_=!1;for(let x=c;x<s;++x){await b.onEpochBegin(x);let s={};if(null!=h)throw new Qk("stepsPerEpoch mode is not implemented yet.");{if("batch"===p)throw new Qk("batch shuffling is not implemneted yet");p&&Aa.shuffle(g);let i=Fg(g),o=AC(y,a);for(let p=0;p<o.length;++p){let d={};if(await b.onBatchBegin(p,d),fl((()=>{let c=o[p][0],h=o[p][1],f=aS(i,c,h-c);d.batch=p,d.size=h-c;let g=EC(n,f),y=t(g);for(let e=0;e<r.length;++e){let t=r[e],n=y[e];d[t]=n,gl(n)}if(p===o.length-1&&m){let t=e.testLoop(l,u,a);for(let e=0;e<r.length;++e){let n=r[e],a=t[e];gl(a),s["val_"+n]=a}}})),await b.onBatchEnd(p,d),aT(d),e.stopTraining_)break}i.dispose()}if(await b.onEpochEnd(x,s),e.stopTraining_)break}return await b.onTrainEnd(),await e.history.syncData(),e.history}async function FC(e,t,n,r={}){if(e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let a,s,i,o,l,u,p,d,c;e.isTraining=!0;try{let h=null==r.batchSize?32:r.batchSize;CC(h);let f=!1,m=await e.standardizeUserData(t,n,r.sampleWeight,r.classWeight,f,h);a=m[0],s=m[1],c=m[2];let g,y=!1;if(null!=r.validationData&&r.validationData.length>0){if(y=!0,2!==r.validationData.length)throw 3===r.validationData.length?new Qk("validationData including sample weights is not supported yet."):new Jk(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);l=r.validationData[0],u=r.validationData[1];let t=!0,n=await e.standardizeUserData(l,u,null,null,t,h);p=n[0],d=n[1],g=p.concat(d)}else if(null!=r.validationSplit&&r.validationSplit>0&&r.validationSplit<1){y=!0;let e=Math.floor(a[0].shape[0]*(1-r.validationSplit)),t=a[0].shape[0];p=_C(a,e,t),i=a,a=_C(a,0,e),d=_C(s,e,t),o=s,s=_C(s,0,e),g=p.concat(d)}else null!=r.validationSteps&&(y=!0);let b=a.concat(s).concat(c);e.checkTrainableWeightsConsistency();let w,x,v=e.makeTrainFunction(),k=e.getDedupedMetricsNames();y?(e.makeTestFunction(),w=e.testFunction,x=k.slice().concat(k.map((e=>"val_"+e)))):(w=null,g=[],x=k.slice());let I=dT(r.callbacks,r.yieldEvery);return await $C(e,v,b,k,h,r.epochs,r.verbose,I,w,g,r.shuffle,x,r.initialEpoch,null,null)}finally{e.isTraining=!1,DC(a,t),DC(s,n),DC(i,t),DC(o,n),DC(p,l),DC(d,u),null!=c&&ml(c)}}function RC(e){let t=[];e instanceof ks&&(e=[e]);for(let n=0;n<e.length;++n){let r=e[n];if(1===r.rank)t.push(eS(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function DC(e,t){if(null==e)return;let n=[];if(t instanceof ks)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(let a in t){let e=t[a];n.push(e.id)}let r=[];if(e instanceof ks)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&r.push(e)}));else if(null!=e)for(let a in e){let t=e[a];-1===n.indexOf(t.id)&&r.push(t)}r.forEach((e=>{e.isDisposed||e.dispose()}))}function MC(e){return e instanceof ks}function OC(e){return Array.isArray(e)}function LC(e){return!MC(e)&&!OC(e)}function PC(e,t,n,r=!0,a=""){if(null==t||0===t.length){if(null!=e){let t=!1;if(OC(e)&&e.length>0)t=!0;else if(LC(e)){for(let n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new Jk(`Error when checking model ${a} expected no data, but got ${e}`)}return[]}if(null==e)return t.map((e=>null));let s;if(LC(e)){s=[];for(let n of t){if(null==e[n])throw new Jk(`No data provided for "${n}". Need data for each key in: ${t}`);s.push(e[n])}}else if(OC(e)){if(e.length!==t.length)throw new Jk(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);s=e}else{if(t.length>1)throw new Jk(`The model ${a} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);s=[e]}if(s=RC(s),null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;let e=s[i];if(e.shape.length!==n[i].length)throw new Jk(`Error when checking ${a}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${e.shape}`);for(let t=0;t<n[i].length;++t){if(0===t&&!r)continue;let s=e.shape[t],o=n[i][t];if(null!=o&&o>=0&&s!==o)throw new Jk(`${a} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${a} received an input with ${e.shape[0]} examples, each with shape [${e.shape.slice(1,e.shape.length)}] (tensor shape [${e.shape}])`)}}return s}function zC(e,t,n){let r=mI(e.map((e=>e.shape[0])));r.sort();let a=mI(t.map((e=>e.shape[0])));if(a.sort(),r.length>1)throw new Jk(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((e=>e.shape)))}`);if(a.length>1)throw new Jk(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((e=>e.shape)))}`);if(r.length>0&&a.length>0&&!Aa.arraysEqual(r,a))throw new Jk(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${a[0]} target sample(s).`)}function BC(e,t,n){let r=[gT,CT,ST];for(let a=0;a<e.length;++a){let s=e[a],i=t[a],o=n[a];if(null!=i){if(i===ST&&1===s.shape[s.shape.length-1])throw new Jk(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){let e=s.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){let r=e[n],a=t[n];if(null!=a&&r!==a)throw new Jk(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function WC(e,t,n,r=!0,a=""){let s;if(Array.isArray(e)){if(e.length!==t.length)throw new Jk(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);s=e}else{if(t.length>1)throw new Jk(`The model expects ${t.length} ${a} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);s=[e]}if(null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;let e=s[i];if(e.shape.length!==n[i].length)throw new Jk(`Error when checking ${a}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(e.shape)}`);for(let s=0;s<n[i].length;++s){if(0===s&&!r)continue;let o=e.shape[s],l=n[i][s];if(null!=l&&l!==o)throw new Jk(`Error when checking ${a}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(e.shape)}.`)}}}function VC(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"==typeof e||"function"==typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!=typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map((e=>n));{let e=[];for(let r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}var UC="layers-model",GC=class extends hC{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new Jk("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");rC(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=eC(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Iw))throw new Jk("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new Jk(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map((e=>FT(e)))}else{let n=FT(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(let t in e.loss)if(-1===this.outputNames.indexOf(t))throw new Jk(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(let n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(FT(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){let e=this.internalOutputShapes[s],t=this.outputNames[s];this.feedOutputNames.push(t),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[s])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],zI("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;let t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));let r=VC(e.metrics,this.outputNames),a=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};zI("metric",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;let t=r[e];(t=>{let n,r,s,i="";for(let o of t){if("string"==typeof o&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(o)){let t,a=this.internalOutputShapes[e];1===a[a.length-1]||this.lossFunctions[e]===CT?-1!==["accuracy","acc"].indexOf(o)?r=RT:-1!==["crossentropy","ce"].indexOf(o)&&(r=BT):this.lossFunctions[e]===NT?-1!==["accuracy","acc"].indexOf(o)?r=WT:-1!==["crossentropy","ce"].indexOf(o)&&(r=YT):-1!==["accuracy","acc"].indexOf(o)?r=DT:-1!==["crossentropy","ce"].indexOf(o)&&(r=KT),-1!==["accuracy","acc"].indexOf(o)?t="acc":-1!==["crossentropy","ce"].indexOf(o)&&(t="ce"),s=r,n=i+t}else s=JT(o),n=i+QT(o);let t;zI(n,(()=>{t=s})),a(e,n,t)}})(t)}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){let r=null==n.batchSize?32:n.batchSize;CC(r);let a=!0,s=this.standardizeUserDataXY(e,t,a,r);try{let a=s[0].concat(s[1]);this.makeTestFunction();let i=this.testFunction,o=this.testLoop(i,a,r,n.verbose,n.steps);return sI(o)}finally{DC(s[0],e),DC(s[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),TC(this,e,t)}checkNumSamples(e,t,n,r="steps"){let a;if(null!=n){if(a=null,null!=t)throw new Jk(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new Jk(`Either the input data should have a defined shape, or ${r} shoud be specified.`);a=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return a}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new Jk("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),r=n?t:[t],a=this.retrieveSymbolicTensors(r),s=new fN;if(e instanceof ks&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new Jk(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)s.add(this.inputs[t],e[t])}else for(let o of this.inputs){let t=e[o.name];if(null==t)throw new Jk(`No value is provided for the model's input ${o.name}`);s.add(o,t)}let i=bN(a,s);return n?i:i[0]}retrieveSymbolicTensors(e){let t=nI(null,e.length),n=e.length;for(let r of this.layers){let a=Array.isArray(r.output)?r.output:[r.output],s=a.map((e=>e.name));for(let r=0;r<e.length;++r){let i=s.indexOf(e[r]);if(-1!==i&&(t[r]=a[i],n--),0===n)break}if(0===n)break}if(n>0){let n=[];throw t.forEach(((t,r)=>{null==t&&n.push(e[r])})),new Jk(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e,t=32,n=!1){return fl((()=>{let r=this.checkNumSamples(e);if(n)throw new Qk("Verbose predictLoop() is not implemented yet.");let a=AC(r,t),s=this.outputs.map((e=>[]));for(let t=0;t<a.length;++t)fl((()=>{let n=a[t][0],r=a[t][1],s=_C(e,n,r),i=[];if(Array.isArray(s))for(let e=0;e<s.length;++e)i.push({key:this.inputs[e],value:s[e]});else i.push({key:this.inputs[0],value:s});let o=new fN(i);return bN(this.outputs,o)})).forEach(((e,t)=>s[t].push(e)));return sI(s.map((e=>Kp(e,0))))}))}predict(e,t={}){let n=RC(e);WC(n,this.inputNames,this.feedInputShapes,!1);try{let r=null==t.batchSize?32:t.batchSize;return CC(r),this.predictLoop(n,r)}finally{DC(n,e)}}predictOnBatch(e){WC(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(null==this.optimizer_)throw new Zk("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let a=[];for(let s=0;s<this.feedOutputShapes.length;++s){let e=this.feedOutputShapes[s];this.feedLossFns[s]===NT?a.push(e.slice(0,e.length-1).concat([1])):a.push(e)}if(e=PC(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=PC(t,this.feedOutputNames,a,!1,"target"),zC(e,t,null),BC(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=r&&r>0&&e[0].shape[0]%r!==0)throw new Jk(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,a=!0,s){let[i,o]=this.standardizeUserDataXY(e,t,a,s);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){let e=mC(r,this.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(await gC(o[t],null,e[t]))}return[i,o,l]}testLoop(e,t,n,r=0,a){return fl((()=>{let s=this.checkNumSamples(t,n,a,"steps"),i=[];if(r>0)throw new Qk("Verbose mode is not implemented yet.");if(null!=a)throw new Qk("steps mode in testLoop() is not implemented yet");{let r=AC(s,n),a=Fg(YI(0,s));for(let n=0;n<r.length;++n){let s=r[n][0],o=r[n][1],l=aS(a,s,o-s),u=EC(t,l),p=e(u);if(0===n)for(let e=0;e<p.length;++e)i.push(Bc(0));for(let e=0;e<p.length;++e){let t=p[e];i[e]=Gu(i[e],Yu(o-s,t))}}for(let e=0;e<i.length;++e)i[e]=Ku(i[e],s)}return i}))}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let r=e[n],a=r;aI(e,r)>1&&(a+=`_${aI(e.slice(0,n),r)}`),t.push(a)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),s=[],i=()=>{let e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});let i,o=new fN(e),l=bN(this.outputs,o,{training:!0});for(let n=0;n<this.lossFunctions.length;++n){let e=this.lossFunctions[n](r[n],l[n]);null!=a[n]&&(e=yC(e,a[n]));let s=vf(e);t.push(s),i=0===n?e:Gu(i,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{let t=this.metricsTensors[n][0],a=this.metricsTensors[n][1];e=vf(t(r[a],l[a]))}gl(e),s.push(e)}return i=vf(i),this.calculateLosses().forEach((e=>{i=Gu(i,e)})),i},o=this.collectedTrainableWeights.map((e=>e.read())),l=!0;return[this.optimizer_.minimize(i,l,o)].concat(s)}}makeTestFunction(){this.testFunction=e=>fl((()=>{let t,n=[],r=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let e=0;e<this.inputs.length;++e)s.push({key:this.inputs[e],value:r[e]});let i=new fN(s),o=bN(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){let r=this.lossFunctions[e],s=vf(r(a[e],o[e]));t=0===e?s:Gu(t,s),n.push(t)}for(let e=0;e<this.metricsTensors.length;++e){let t=this.metricsTensors[e][0],r=this.metricsTensors[e][1],s=vf(t(a[r],o[r]));n.push(s)}return n}))}async fit(e,t,n={}){return FC(this,e,t,n)}async fitDataset(e,t){return kC(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),r=n[0],a=n[1],s=this.makeTrainFunction()(r.concat(a)),i=[];for(let o of s){let e=await o.data();i.push(e[0])}return ml(s),DC(n[0],e),DC(n[1],t),sI(i)}getNamedWeights(e){let t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let s=0;s<r.length;++s)n&&!r[s].trainable||t.push({name:r[s].originalName,tensor:a[s]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){let t=cl().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-cl().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=oI(this.loss);else if(Array.isArray(this.loss)){for(let e of this.loss)if("string"!=typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>oI(e)))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let r of t){if("string"!=typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=oI(n[r])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[oI(QT(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>oI(QT(e))));{let e={};for(let t in this.metrics)e[t]=oI(QT(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");let t,n,r=pC(e.optimizer_config),a=fT(r);if("string"==typeof e.loss)t=lI(e.loss);else if(Array.isArray(e.loss))t=e.loss.map((e=>lI(e)));else if(null!=e.loss){t={};for(let n in e.loss)t[n]=lI(e.loss[n])}if(Array.isArray(e.metrics))n=e.metrics.map((e=>lI(e)));else if(null!=e.metrics){n={};for(let t in e.metrics)n[t]=lI(e.metrics[t])}this.compile({loss:t,metrics:n,optimizer:a})}async save(e,t){if("string"==typeof e){let t=To.getSaveHandlers(e);if(0===t.length)throw new Jk(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Jk(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Jk("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await To.encodeWeights(this.getNamedWeights(t)),r=!1,a=null,s={modelTopology:this.toJSON(a,r),format:UC,generatedBy:`TensorFlow.js tfjs-layers v${cC}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){s.trainingConfig=this.getTrainingConfig();let e="optimizer",{data:t,specs:r}=await To.encodeWeights(await this.optimizer.getWeights(),e);n.specs.push(...r),n.data=To.concatenateArrayBuffers([n.data,t])}return null!=this.userDefinedMetadata&&(tC(this.userDefinedMetadata,this.name,!0),s.userDefinedMetadata=this.userDefinedMetadata),s.weightData=n.data,s.weightSpecs=n.specs,e.save(s)}setUserDefinedMetadata(e){tC(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};GC.className="Model",Nu.registerClass(GC);var HC=class extends GC{};async function jC(e,t){"modelTopology"in e||(e={modelTopology:e});let n=e.modelTopology;null!=n.model_config&&(n=n.model_config);let r=pC(n),a=fT(r,t);if(null!=e.weightsManifest){let t=await To.loadWeights(e.weightsManifest,e.pathPrefix,a.weights.map((e=>e.originalName))),n={};for(let e of a.weights)n[e.originalName]=t[e.originalName];a.loadWeights(n),ml(t)}return a}async function qC(e,t){if(null==t&&(t={}),"string"==typeof e){let n=To.getLoadHandlers(e,t);if(0===n.length)n.push(To.browserHTTPRequest(e,t));else if(n.length>1)throw new Jk(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return KC(e,void 0,t)}async function KC(e,t,n){if(null==n&&(n={}),null==e.load)throw new Jk("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let r=await e.load(),a=r.modelTopology;null!=a.model_config&&(a=a.model_config);let s=null==n.strict||n.strict,i=null!=r.weightData&&null!=r.weightSpecs&&s,o=fT(pC(a),t,i),l=r.trainingConfig;if(null!=l&&o.loadTrainingConfig(l),null!=r.userDefinedMetadata&&o.setUserDefinedMetadata(r.userDefinedMetadata),null!=r.weightData){if(null==r.weightSpecs)throw new Jk("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:e,optimizerWeights:t}=XC(r.weightData,r.weightSpecs);o.loadWeights(e,s),null!=o.optimizer&&t.length>0&&await o.optimizer.setWeights(t),ml(e),ml(t.map((e=>e.tensor)))}return o}function XC(e,t){let n=To.decodeWeights(e,t),r={},a=[];return t.forEach((e=>{"optimizer"===e.group?a.push({name:e.name,tensor:n[e.name]}):r[e.name]=n[e.name]})),{modelWeights:r,optimizerWeights:a}}HC.className="Functional",Nu.registerClass(HC);var YC=class extends GC{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:TI("sequential_"),null!=e.layers)for(let t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new Jk(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){let t,n=e instanceof YC||e instanceof GC;if(n){if(t=e,1!==t.outputs.length)throw new Jk("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==t.inputs.length)throw new Jk("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new Jk("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let t=cN({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(n)this.outputs=t.outputs,this.inputs=t.inputs;else{if(1!==e.inboundNodes.length)throw new Jk(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new Jk("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=pN(this.outputs[0])}this.inboundNodes=[],new sN({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:nI(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{let t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(XS(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new GC({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new Zk("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new Zk("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new Zk("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new Zk("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,n={},r=!1){let a,s={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new Jk("Legacy serialization format not supported yet.");a=t}else Aa.assert(null!=t.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),a=t.layers,delete t.layers,s=t;let i=new e(s);if(!(i instanceof YC))throw new Qk(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(let o of a){let e=fT(o,void 0,r);r&&e.setFastWeightInitDuringBuild(!0),i.add(e)}return i}set stopTraining(e){if(null==this.model)throw new Jk("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new Jk("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let e=[];for(let t of this.layers){let n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}};function ZC(e){return new GC(e)}function JC(e){return new YC(e)}function QC(e,t){return null==t&&(t={}),qC(e,t)}function e_(e){return cN(e)}function t_(e,t){cT.registerCallbackConstructor(e,t)}YC.className="Sequential",Nu.registerClass(YC);var n_=class extends Nu.Serializable{getConfig(){return{}}},r_=class extends n_{apply(e,t=1){return gS(e,t)}};r_.className="elu",Nu.registerClass(r_);var a_=class extends n_{apply(e){return Um(e)}};a_.className="selu",Nu.registerClass(a_);var s_=class extends n_{apply(e){return Nm(e)}};s_.className="relu",Nu.registerClass(s_);var i_=class extends n_{apply(e){return fl((()=>Tf(6,Nm(e))))}};i_.className="relu6",Nu.registerClass(i_);var o_=class extends n_{apply(e){return e}};o_.className="linear",Nu.registerClass(o_);var l_=class extends n_{apply(e){return Yp(e)}};l_.className="sigmoid",Nu.registerClass(l_);var u_=class extends n_{apply(e){return wS(e)}};u_.className="hardSigmoid",Nu.registerClass(u_);var p_=class extends n_{apply(e){return Gh(e)}};p_.className="softplus",Nu.registerClass(p_);var d_=class extends n_{apply(e){return yS(e)}};d_.className="softsign",Nu.registerClass(d_);var c_=class extends n_{apply(e){return ed(e)}};c_.className="tanh",Nu.registerClass(c_);var h_=class extends n_{apply(e,t=-1){return ug(e,t)}};h_.className="softmax",Nu.registerClass(h_);var f_=class extends n_{apply(e,t=-1){return Yh(e,t)}};f_.className="logSoftmax",Nu.registerClass(f_);var m_=class extends n_{apply(e,t=1){return fl((()=>Yu(Yp(Yu(e,t)),e)))}};m_.className="swish",Nu.registerClass(m_);var g_=class extends n_{apply(e){return fl((()=>Yu(e,ed(Gh(e)))))}};function y_(e){return e.getClassName()}function b_(e,t={}){return cI(e,Nu.SerializationMap.getMap().classNameMap,t,"activation")}function w_(e){if(null==e){let e={className:"linear",config:{}};return b_(e)}if("string"==typeof e){let t={};return t.className=e,t.config={},b_(t)}return e instanceof n_?e:b_(e)}function x_(e){if(null!=e&&"object"!=typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}g_.className="mish",Nu.registerClass(g_);var v_=class extends Nu.Serializable{},k_=class extends v_{constructor(e){super(),x_(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return fl((()=>{let t=kf([1]);return this.hasL1&&(t=Gu(t,jc(Yu(this.l1,Ju(e))))),this.hasL2&&(t=Gu(t,jc(Yu(this.l2,hS(e))))),Vp(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};function I_(e){return x_(e),new k_({l1:null!=e?e.l1:null,l2:0})}function S_(e){return x_(e),new k_({l2:null!=e?e.l2:null,l1:0})}k_.className="L1L2",Nu.registerClass(k_);var N_={l1l2:"L1L2"};function T_(e){return pI(e)}function C_(e,t={}){return cI(e,Nu.SerializationMap.getMap().classNameMap,t,"regularizer")}function __(e){if(null==e)return null;if("string"==typeof e){let t={className:e in N_?N_[e]:e,config:{}};return C_(t)}return e instanceof v_?e:C_(e)}var E_=class extends oN{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=KS(e);let n=Nm(e);return null!=this.maxValue&&(n=Id(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};E_.className="ReLU",Nu.registerClass(E_);var A_=class extends oN{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=KS(e);return Sh(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};A_.className="LeakyReLU",Nu.registerClass(A_);var $_=class extends oN{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=HS(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=__(e.alphaRegularizer),this.alphaConstraint=DN(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new Jk(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){e=XS(e);let t=e.slice(1);if(null!=this.sharedAxes)for(let r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(null!=this.sharedAxes)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new nN({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=KS(e),im(e,this.alpha.read())}getConfig(){let e={alphaInitializer:GS(this.alphaInitializer),alphaRegularizer:T_(this.alphaRegularizer),alphaConstraint:FN(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};$_.className="PReLU",Nu.registerClass($_);var F_=class extends oN{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new Qk(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=KS(e);return Ic(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};F_.className="ELU",Nu.registerClass(F_);var R_=class extends oN{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){let n=KS(e);return Yu(n,vo(fh(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};R_.className="ThresholdedReLU",Nu.registerClass(R_);var D_=class extends oN{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new h_).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){let n=KS(e);return this.softmax(n,this.axis)}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};function M_(e,t,n){if("number"==typeof e)return nI(e,t);if(e.length!==t)throw new Jk(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){let a=e[r];if(!jI(a))throw new Jk(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)}return e}function O_(e,t,n,r,a=1){if(null==e)return e;let s,i=t+(t-1)*(a-1);return s="same"===n?e:e-i+1,Math.floor((s+r-1)/r)}function L_(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+XI([n-t,0]);else{if("same"!==r)throw new Jk(`Unsupport padding mode: ${r}.`);e*=t}return e}function P_(e,t){return fl((()=>(RI(t),"channelsFirst"===t?Dl(e,[0,2,3,1]):e)))}function z_(e,t){return fl((()=>(RI(t),"channelsFirst"===t?Dl(e,[0,2,3,4,1]):e)))}function B_(e,t,n,r=1,a="valid",s,i=1){return fl((()=>{if(null==s&&(s=JI()),RI(s),3!==e.shape.length)throw new Jk(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new Jk(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new Jk(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===s&&(e=Dl(e,[0,2,1])),"causal"===a)throw new Qk("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=Md(e,t,r,"same"===a?"same":"valid","NWC",i);return null!=n&&(o=mS(o,n)),o}))}function W_(e,t,n,r=[1,1],a="valid",s,i,o=null){return fl((()=>{if(null==s&&(s=JI()),RI(s),3!==e.rank&&4!==e.rank)throw new Jk(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new Jk(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=P_(e,s);if("causal"===a)throw new Qk("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=gy.conv2d({x:l,filter:t,strides:r,pad:"same"===a?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===s&&(l=Dl(l,[0,3,1,2])),l}))}function V_(e,t,n,r=[1,1,1],a="valid",s,i){return fl((()=>{if(null==s&&(s=JI()),RI(s),4!==e.rank&&5!==e.rank)throw new Jk(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new Jk(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=z_(e,s);if("causal"===a)throw new Qk("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=Wd(o,t,r,"same"===a?"same":"valid","NDHWC",i),null!=n&&(o=mS(o,n)),"channelsFirst"===s&&(o=Dl(o,[0,4,1,2,3])),o}))}D_.className="Softmax",Nu.registerClass(D_);var U_=class extends oN{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",U_.verifyArgs(t),this.rank=e,wI(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new Qk(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=M_(t.kernelSize,e,"kernelSize"),this.strides=M_(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,MI(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,RI(this.dataFormat),this.activation=w_(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=HS(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=DN(t.biasConstraint),this.biasRegularizer=__(t.biasRegularizer),this.activityRegularizer=__(t.activityRegularizer),this.dilationRate=M_(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new Jk(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new Jk(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new Jk(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(rI("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!bI(e.kernelSize,"number",1,3))throw new Jk(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){let e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:y_(this.activation),useBias:this.useBias,biasInitializer:GS(this.biasInitializer),biasRegularizer:T_(this.biasRegularizer),activityRegularizer:T_(this.activityRegularizer),biasConstraint:FN(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}},G_=class extends U_{constructor(e,t){super(e,t),this.kernel=null,G_.verifyArgs(t),this.filters=t.filters,wI(this.filters,"filters"),this.kernelInitializer=HS(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=DN(t.kernelConstraint),this.kernelRegularizer=__(t.kernelRegularizer)}build(e){e=XS(e);let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Jk(`The channel dimension of the input should be defined. Found ${e[t]}`);let n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return fl((()=>{e=KS(e);let t,n=null==this.bias?null:this.bias.read(),r=kI(this.activation.getClassName());if(null!=r&&2===this.rank)t=W_(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=B_(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=W_(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new Qk("convolutions greater than 3D are not implemented yet.");t=V_(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=XS(e);let t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let a=0;a<n.length;++a){let e=O_(n[a],this.kernelSize[a],this.padding,this.strides[a],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[a]);t.push(e)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){let e={filters:this.filters,kernelInitializer:GS(this.kernelInitializer),kernelRegularizer:T_(this.kernelRegularizer),kernelConstraint:FN(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new Jk(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}},H_=class extends G_{constructor(e){super(2,e),H_.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!bI(e.kernelSize,"number",1,2))throw new Jk(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}};H_.className="Conv2D",Nu.registerClass(H_);var j_=class extends G_{constructor(e){super(3,e),j_.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new Jk(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}};j_.className="Conv3D",Nu.registerClass(j_);var q_=class extends H_{constructor(e){if(super(e),this.inputSpec=[new nN({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new Jk(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=XS(e),4!==e.length)throw new Jk("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Jk("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new nN({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return fl((()=>{let t=KS(e);if(4!==t.shape.length)throw new Jk(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);let n,r,a=t.shape,s=a[0];"channelsFirst"===this.dataFormat?(n=2,r=3):(n=1,r=2);let i=a[n],o=a[r],l=this.kernelSize[0],u=this.kernelSize[1],p=this.strides[0],d=this.strides[1],c=L_(i,p,l,this.padding),h=L_(o,d,u,this.padding),f=[s,c,h,this.filters];"channelsLast"!==this.dataFormat&&(t=Dl(t,[0,2,3,1]));let m=zd(t,this.kernel.read(),f,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(m=Dl(m,[0,3,1,2])),null!=this.bias&&(m=mS(m,this.bias.read(),this.dataFormat)),null!=this.activation&&(m=this.activation.apply(m)),m}))}computeOutputShape(e){e=XS(e);let t,n,r,a=e.slice();"channelsFirst"===this.dataFormat?(t=1,n=2,r=3):(t=3,n=1,r=2);let s=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return a[t]=this.filters,a[n]=L_(a[n],o,s,this.padding),a[r]=L_(a[r],l,i,this.padding),a}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};q_.className="Conv2DTranspose",Nu.registerClass(q_);var K_=class extends j_{constructor(e){if(super(e),this.inputSpec=[new nN({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new Jk(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=XS(e),5!==e.length)throw new Jk("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Jk("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new nN({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return fl((()=>{let t=KS(e);if(5!==t.shape.length)throw new Jk(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);let n,r,a,s=t.shape,i=s[0];"channelsFirst"===this.dataFormat?(a=2,n=3,r=4):(a=1,n=2,r=3);let o=s[a],l=s[n],u=s[r],p=this.kernelSize[0],d=this.kernelSize[1],c=this.kernelSize[2],h=this.strides[0],f=this.strides[1],m=this.strides[2],g=L_(o,h,p,this.padding),y=L_(l,f,d,this.padding),b=L_(u,m,c,this.padding),w=[i,g,y,b,this.filters];"channelsLast"!==this.dataFormat&&(t=Dl(t,[0,2,3,4,1]));let x=Hd(t,this.kernel.read(),w,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(x=Dl(x,[0,4,1,2,3])),null!==this.bias&&(x=mS(x,this.bias.read(),this.dataFormat)),null!==this.activation&&(x=this.activation.apply(x)),x}))}computeOutputShape(e){e=XS(e);let t,n,r,a,s=e.slice();"channelsFirst"===this.dataFormat?(t=1,n=2,r=3,a=4):(t=4,n=1,r=2,a=3);let i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],p=this.strides[1],d=this.strides[2];return s[t]=this.filters,s[n]=L_(s[n],u,i,this.padding),s[r]=L_(s[r],p,o,this.padding),s[a]=L_(s[a],d,l,this.padding),s}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};K_.className="Conv3DTranspose",Nu.registerClass(K_);var X_=class extends G_{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new Jk("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new Jk("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new Jk(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=HS(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=__(t.depthwiseRegularizer),this.depthwiseConstraint=DN(t.depthwiseConstraint),this.pointwiseInitializer=HS(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=__(t.pointwiseRegularizer),this.pointwiseConstraint=DN(t.pointwiseConstraint)}build(e){if(e=XS(e),e.length<this.rank+2)throw new Jk(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new Jk(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),a=[];for(let i=0;i<this.rank;++i)a.push(1);a.push(n*this.depthMultiplier,this.filters);let s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new nN({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return fl((()=>{let t;if(e=KS(e),1===this.rank)throw new Qk("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=Dl(e,[0,2,3,1])),t=Hm(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=mS(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=Dl(t,[0,3,1,2])),t}))}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=GS(this.depthwiseInitializer),e.pointwiseInitializer=GS(this.pointwiseInitializer),e.depthwiseRegularizer=T_(this.depthwiseRegularizer),e.pointwiseRegularizer=T_(this.pointwiseRegularizer),e.depthwiseConstraint=FN(this.depthwiseConstraint),e.pointwiseConstraint=FN(this.pointwiseConstraint),e}};X_.className="SeparableConv";var Y_=class extends X_{constructor(e){super(2,e)}};Y_.className="SeparableConv2D",Nu.registerClass(Y_);var Z_=class extends G_{constructor(e){super(1,e),Z_.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){let e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!bI(e.kernelSize,"number",1,1))throw new Jk(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}};Z_.className="Conv1D",Nu.registerClass(Z_);var J_=class extends oN{constructor(e){super(e),"number"==typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return fl((()=>{if(e=KS(e),"channelsLast"===this.dataFormat){let t=iS(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return iS(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{let t=iS(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return iS(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};J_.className="Cropping2D",Nu.registerClass(J_);var Q_=class extends oN{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,RI(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,DI(this.interpolation)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){let t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{let t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return fl((()=>{let t=KS(e),n=t.shape;if("channelsFirst"===this.dataFormat){t=Dl(t,[0,2,3,1]);let e=this.size[0]*n[2],r=this.size[1]*n[3],a="nearest"===this.interpolation?bw.resizeNearestNeighbor(t,[e,r]):bw.resizeBilinear(t,[e,r]);return Dl(a,[0,3,1,2])}{let e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?bw.resizeNearestNeighbor(t,[e,r]):bw.resizeBilinear(t,[e,r])}}))}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};function eE(e,t,n=[1,1],r="valid",a,s){return fl((()=>{null==a&&(a=JI()),RI(a);let i=P_(e,a);if(4!==e.rank)throw new Jk(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new Jk(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=sc(i,t,n,"same"===r?"same":"valid","NHWC",s),"channelsFirst"===a&&(i=Dl(i,[0,3,1,2])),i}))}Q_.className="UpSampling2D",Nu.registerClass(Q_);var tE=class extends U_{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=HS(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=DN(e.depthwiseConstraint),this.depthwiseRegularizer=__(e.depthwiseRegularizer)}build(e){if(e=XS(e),e.length<4)throw new Jk(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new Jk(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return fl((()=>{e=KS(e);let t=eE(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=mS(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=XS(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=O_(t,this.kernelSize[0],this.padding,this.strides[0]),s=O_(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,a,s]:[e[0],a,s,r]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=GS(this.depthwiseInitializer),e.depthwiseRegularizer=T_(this.depthwiseRegularizer),e.depthwiseConstraint=FN(this.depthwiseRegularizer),e}};function nE(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new Jk("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function a(e){return null==e||Array.isArray(e)?e:[e]}return t=a(t),n=a(n),{inputs:e,initialState:t,constants:n}}function rE(e,t,n,r=!1,a,s,i=!1,o=!1){return fl((()=>{let l=t.shape.length;if(l<3)throw new Jk(`Input should be at least 3D, but is ${l}D.`);let u=[1,0].concat(YI(2,l));if(t=Dl(t,u),null!=s)throw new Qk("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=a&&(a=vo(vo(a,"bool"),"float32"),a.rank===l-1&&(a=th(a,-1)),a=Dl(a,u)),r&&(t=Em(t,0),null!=a&&(a=Em(a,0)));let p,d,c,h=[],f=n,m=t.shape[0],g=jg(t);null!=a&&(d=jg(a));for(let t=0;t<m;++t){let n=g[t],r=fl((()=>e(n,f)));if(null==a)p=r[0],f=r[1];else{let e=fl((()=>{let e=d[t],n=Kh(Bf(e),e),a=Gu(Yu(r[0],e),Yu(f[0],n)),s=f.map(((t,a)=>Gu(Yu(r[1][a],e),Yu(t,n))));return{output:a,newStates:s}}));p=e.output,f=e.newStates}o&&h.push(p)}return o&&(c=Ng(h,1)),[p,c,f]}))}tE.className="DepthwiseConv2D",Nu.registerClass(tE);var aE=class extends oN{constructor(e){let t;if(super(e),null==e.cell)throw new Jk("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new cE({cells:e.cell}):e.cell,null==t.stateSize)throw new Jk("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new nN({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return YI(0,e).map((e=>null))}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){jS(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);let n,r=t[0];if(n=this.returnSequences?[e[0],e[1],r]:[e[0],r],this.returnState){let r=[];for(let n of t)r.push([e[0],n]);return[n].concat(r)}return n}computeMask(e,t){return fl((()=>{Array.isArray(t)&&(t=t[0]);let e=this.returnSequences?t:null;if(this.returnState){let t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new Qk("Constants support is not implemented in RNN yet.");jS(e)&&(e=e[0]);let t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new nN({shape:[t,null,...n]});let r,a=[e[0]].concat(e.slice(2));if(this.cell.build(a),r=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!Aa.arraysEqual(this.stateSpec.map((e=>e.shape[e.shape.length-1])),r))throw new Jk(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=r.map((e=>new nN({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e,t=!1){fl((()=>{if(!this.stateful)throw new Yk("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape[0];if(null==n)throw new Jk("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>kf([n,e]))):this.states_=[kf([n,this.cell.stateSize])];else if(null==e)ml(this.states_),null!=this.keptStates&&(ml(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>kf([n,e]))):this.states_[0]=kf([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Jk(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):ml(this.states_);for(let t=0;t<this.states_.length;++t){let r=e[t],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,s=[n,a];if(!Aa.arraysEqual(r.shape,s))throw new Jk(`State ${t} is incompatible with layer ${this.name}: expected shape=${s}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map((e=>gl(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});let a=nE(e,n,r,this.numConstants);e=a.inputs,n=a.initialState,r=a.constants;let s=[],i=[];if(null!=n){t.initialState=n,s=s.concat(n),this.stateSpec=[];for(let e of n)this.stateSpec.push(new nN({shape:e.shape}));i=i.concat(this.stateSpec)}if(null!=r&&(t.constants=r,s=s.concat(r),this.numConstants=r.length),s[0]instanceof rN){let n=[e].concat(s),r=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=r;let o=super.apply(n,t);return this.inputSpec=a,o}return super.apply(e,t)}call(e,t){return fl((()=>{let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;e=KS(e),null==a&&(a=this.stateful?this.states_:this.getInitialState(e));let s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==s)throw new Jk(`RNN Layer has ${s} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let i={training:r},o=rE(((e,t)=>{let n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]}),e,a,this.goBackwards,n,null,this.unroll,this.returnSequences),l=o[0],u=o[1],p=o[2];this.stateful&&this.resetStates(p,r);let d=this.returnSequences?u:l;return this.returnState?[d].concat(p):d}))}getInitialState(e){return fl((()=>{let t=kf(e.shape);return t=jc(t,[1,2]),t=eS(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?uS(t,[1,e]):t)):this.cell.stateSize>1?[uS(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){let e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);let n=this.cell.getConfig();return this.getClassName()===aE.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign({},n,e,t)}static fromConfig(e,t,n={}){let r=t.cell,a=fT(r,n);return new e(Object.assign(t,{cell:a}))}};aE.className="RNN",Nu.registerClass(aE);var sE=class extends oN{},iE=class extends sE{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,wI(this.units,"units"),this.activation=w_(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=HS(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=HS(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=HS(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=__(e.kernelRegularizer),this.recurrentRegularizer=__(e.recurrentRegularizer),this.biasRegularizer=__(e.biasRegularizer),this.kernelConstraint=DN(e.kernelConstraint),this.recurrentConstraint=DN(e.recurrentConstraint),this.biasConstraint=DN(e.biasConstraint),this.dropout=KI([1,XI([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=KI([1,XI([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=XS(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return fl((()=>{if(2!==e.length)throw new Jk(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let r=null!=t.training&&t.training;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=hE({ones:()=>Bf(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=hE({ones:()=>Bf(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let a,s=this.dropoutMask,i=this.recurrentDropoutMask;a=dS(null!=s?Yu(e,s):e,this.kernel.read()),null!=this.bias&&(a=mS(a,this.bias.read())),null!=i&&(n=Yu(n,i));let o=Gu(a,dS(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]}))}getConfig(){let e=super.getConfig(),t={units:this.units,activation:y_(this.activation),useBias:this.useBias,kernelInitializer:GS(this.kernelInitializer),recurrentInitializer:GS(this.recurrentInitializer),biasInitializer:GS(this.biasInitializer),kernelRegularizer:T_(this.kernelRegularizer),recurrentRegularizer:T_(this.recurrentRegularizer),biasRegularizer:T_(this.biasRegularizer),activityRegularizer:T_(this.activityRegularizer),kernelConstraint:FN(this.kernelConstraint),recurrentConstraint:FN(this.recurrentConstraint),biasConstraint:FN(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},e,t)}};iE.className="SimpleRNNCell",Nu.registerClass(iE);var oE=class extends aE{constructor(e){e.cell=new iE(e),super(e)}call(e,t){return fl((()=>{null!=this.cell.dropoutMask&&(ml(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ml(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return new e(t)}};oE.className="SimpleRNN",Nu.registerClass(oE);var lE=class extends sE{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new Jk("GRUCell does not support reset_after parameter set to true.");this.units=e.units,wI(this.units,"units"),this.activation=w_(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=w_(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=HS(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=HS(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=HS(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=__(e.kernelRegularizer),this.recurrentRegularizer=__(e.recurrentRegularizer),this.biasRegularizer=__(e.biasRegularizer),this.kernelConstraint=DN(e.kernelConstraint),this.recurrentConstraint=DN(e.recurrentConstraint),this.biasConstraint=DN(e.biasConstraint),this.dropout=KI([1,XI([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=KI([1,XI([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=XS(e);let t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return fl((()=>{if(2!==e.length)throw new Jk(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=null!=t.training&&t.training,r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=hE({ones:()=>Bf(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=hE({ones:()=>Bf(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let a,s,i,o=this.dropoutMask,l=this.recurrentDropoutMask;0<this.dropout&&this.dropout<1&&(e=Yu(e,o[0]));let u=dS(e,this.kernel.read());this.useBias&&(u=mS(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Yu(r,l[0]));let p=this.recurrentKernel.read(),[d,c]=yg(p,[2*this.units,this.units],p.rank-1),h=dS(r,d),[f,m,g]=yg(u,3,u.rank-1),[y,b]=yg(h,2,h.rank-1);a=this.recurrentActivation.apply(Gu(f,y)),s=this.recurrentActivation.apply(Gu(m,b));let w=dS(Yu(s,r),c);i=this.activation.apply(Gu(g,w));let x=Gu(Yu(a,r),Yu(Gu(1,Al(a)),i));return[x,x]}))}getConfig(){let e=super.getConfig(),t={units:this.units,activation:y_(this.activation),recurrentActivation:y_(this.recurrentActivation),useBias:this.useBias,kernelInitializer:GS(this.kernelInitializer),recurrentInitializer:GS(this.recurrentInitializer),biasInitializer:GS(this.biasInitializer),kernelRegularizer:T_(this.kernelRegularizer),recurrentRegularizer:T_(this.recurrentRegularizer),biasRegularizer:T_(this.biasRegularizer),activityRegularizer:T_(this.activityRegularizer),kernelConstraint:FN(this.kernelConstraint),recurrentConstraint:FN(this.recurrentConstraint),biasConstraint:FN(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},e,t)}};lE.className="GRUCell",Nu.registerClass(lE);var uE=class extends aE{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new lE(e),super(e)}call(e,t){return fl((()=>{null!=this.cell.dropoutMask&&(ml(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ml(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}};uE.className="GRU",Nu.registerClass(uE);var pE=class extends sE{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,wI(this.units,"units"),this.activation=w_(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=w_(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=HS(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=HS(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=HS(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=__(e.kernelRegularizer),this.recurrentRegularizer=__(e.recurrentRegularizer),this.biasRegularizer=__(e.biasRegularizer),this.kernelConstraint=DN(e.kernelConstraint),this.recurrentConstraint=DN(e.recurrentConstraint),this.biasConstraint=DN(e.biasConstraint),this.dropout=KI([1,XI([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=KI([1,XI([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=XS(e);let n,r=e[e.length-1];if(this.kernel=this.addWeight("kernel",[r,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){let e=this.biasInitializer,r=this.units;n=new(t=class extends NS{apply(t,n){let a=e.apply([r]),s=(new CS).apply([r]),i=e.apply([2*r]);return lS(lS(a,s),i)}},t.className="CustomInit",t)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return fl((()=>{let n=null!=t.training&&t.training;if(3!==e.length)throw new Jk(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1],a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=hE({ones:()=>Bf(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=hE({ones:()=>Bf(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let s,i,o,l,u=this.dropoutMask,p=this.recurrentDropoutMask;0<this.dropout&&this.dropout<1&&(e=Yu(e,u[0]));let d=dS(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Yu(r,p[0])),d=Gu(d,dS(r,this.recurrentKernel.read())),this.useBias&&(d=mS(d,this.bias.read()));let[c,h,f,m]=yg(d,4,d.rank-1);s=this.recurrentActivation.apply(c),i=this.recurrentActivation.apply(h),o=Gu(Yu(i,a),Yu(s,this.activation.apply(f))),l=this.recurrentActivation.apply(m);let g=Yu(l,this.activation.apply(o));return[g,g,o]}))}getConfig(){let e=super.getConfig(),t={units:this.units,activation:y_(this.activation),recurrentActivation:y_(this.recurrentActivation),useBias:this.useBias,kernelInitializer:GS(this.kernelInitializer),recurrentInitializer:GS(this.recurrentInitializer),biasInitializer:GS(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:T_(this.kernelRegularizer),recurrentRegularizer:T_(this.recurrentRegularizer),biasRegularizer:T_(this.biasRegularizer),activityRegularizer:T_(this.activityRegularizer),kernelConstraint:FN(this.kernelConstraint),recurrentConstraint:FN(this.recurrentConstraint),biasConstraint:FN(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},e,t)}};pE.className="LSTMCell",Nu.registerClass(pE);var dE=class extends aE{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new pE(e),super(e)}call(e,t){return fl((()=>{null!=this.cell.dropoutMask&&(ml(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ml(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}};dE.className="LSTM",Nu.registerClass(dE);var cE=class extends sE{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return fl((()=>{let n=e.slice(1),r=[];for(let e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();let a,s=[];for(let i=0;i<this.cells.length;++i){let o=this.cells[i];n=r[i],a=0===i?[e[0]].concat(n):[a[0]].concat(n),a=o.call(a,t),s.push(a.slice(1))}n=[];for(let e of s.slice().reverse())n.push(...e);return[a[0]].concat(n)}))}build(e){let t;jS(e)&&(e=e[0]),this.cells.forEach(((n,r)=>{zI(`RNNCell_${r}`,(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){let e=super.getConfig(),t=e=>({className:e.getClassName(),config:e.getConfig()}),n={cells:this.cells.map(t)};return Object.assign({},e,n)}static fromConfig(e,t,n={}){let r=[];for(let a of t.cells)r.push(fT(a,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return eN(e)}setWeights(e){let t=[];for(let n of this.cells){let r=n.weights.length,a=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],a[e]])}tN(t)}};function hE(e){let{ones:t,rate:n,training:r=!1,count:a=1,dropoutFunc:s}=e,i=()=>null!=s?s(t(),n):bS(t(),n),o=()=>xS(i,t,r);return!a||a<=1?gl(o().clone()):Array(a).fill(void 0).map(o).map((e=>gl(e.clone())))}cE.className="StackedRNNCells",Nu.registerClass(cE);var fE=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n},mE=class extends aE{constructor(e){if(e.unroll)throw new Qk("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Qk("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new nN({ndim:5})]}call(e,t){return fl((()=>{if(null!=this.cell.dropoutMask&&(ml(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(ml(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new Jk("ConvRNN2D cell does not support constants");let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return fl((()=>{let{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)],s=kf(a);return Array.isArray(t)?Array(t.length).fill(s):[s]}))}resetStates(e,t=!1){fl((()=>{if(!this.stateful)throw new Yk("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(null==n[0])throw new Jk("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>kf(a))):this.states_=[kf(a)];else if(null==e)ml(this.states_),null!=this.keptStates&&(ml(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>kf(a))):this.states_[0]=kf(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Jk(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):ml(this.states_);for(let t=0;t<this.states_.length;++t){let n=e[t],r=a;if(!Aa.arraysEqual(n.shape,r))throw new Jk(`State ${t} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map((e=>gl(e.clone())))}))}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:r,padding:a,strides:s,dilationRate:i}=this.cell,o="channelsFirst"===t,l=e[o?3:2],u=e[o?4:3],p=O_(l,r[0],a,s[0],i[0]),d=O_(u,r[1],a,s[1],i[1]);return[...e.slice(0,2),...o?[n,p,d]:[p,d,n]]}};mE.className="ConvRNN2D";var gE=class extends pE{constructor(e){let{filters:t,kernelSize:n,strides:r,padding:a,dataFormat:s,dilationRate:i}=e;super(Object.assign({},e,{units:t})),this.filters=t,wI(this.filters,"filters"),this.kernelSize=M_(n,2,"kernelSize"),this.kernelSize.forEach((e=>wI(e,"kernelSize"))),this.strides=M_(r||1,2,"strides"),this.strides.forEach((e=>wI(e,"strides"))),this.padding=a||"valid",MI(this.padding),this.dataFormat=s||"channelsLast",RI(this.dataFormat),this.dilationRate=M_(i||1,2,"dilationRate"),this.dilationRate.forEach((e=>wI(e,"dilationRate")))}build(e){var t;e=XS(e);let n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new Jk(`The channel dimension of the input should be defined. Found ${e[n]}`);let r=e[n],a=4,s=this.kernelSize.concat([r,this.filters*a]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let i=this.kernelSize.concat([this.filters,this.filters*a]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){let n=this.biasInitializer,r=this.filters;e=new(t=class extends NS{apply(e,t){let a=n.apply([r]),s=If([r]),i=n.apply([2*r]);return oS([a,s,i])}},t.className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*a],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return fl((()=>{if(3!==e.length)throw new Jk(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,r=e[0],a=e[1],s=e[2],i=4;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=hE({ones:()=>Bf(r),rate:this.dropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let o=this.dropoutMask,l=(e,t,n)=>t&&t[n]?Yu(t[n],e):e,u=l(r,o,0),p=l(r,o,1),d=l(r,o,2),c=l(r,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=hE({ones:()=>Bf(a),rate:this.recurrentDropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let h=this.recurrentDropoutMask,f=l(a,h,0),m=l(a,h,1),g=l(a,h,2),y=l(a,h,3),b=3,[w,x,v,k]=yg(this.kernel.read(),i,b),[I,S,N,T]=this.useBias?yg(this.bias.read(),i):[null,null,null,null];u=this.inputConv(u,w,I,this.padding),p=this.inputConv(p,x,S,this.padding),d=this.inputConv(d,v,N,this.padding),c=this.inputConv(c,k,T,this.padding);let[C,_,E,A]=yg(this.recurrentKernel.read(),i,b);f=this.recurrentConv(f,C),m=this.recurrentConv(m,_),g=this.recurrentConv(g,E),y=this.recurrentConv(y,A);let $=this.recurrentActivation.apply(Gu(u,f)),F=this.recurrentActivation.apply(Gu(p,m)),R=Gu(Yu(F,s),Yu($,this.activation.apply(Gu(d,g)))),D=Yu(this.recurrentActivation.apply(Gu(c,y)),this.activation.apply(R));return[D,D,R]}))}getConfig(){let e=super.getConfig(),{units:t}=e,n=fE(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},n,r)}inputConv(e,t,n,r){let a=Rd(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?mS(a,n,this.dataFormat):a}recurrentConv(e,t){return Rd(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}};gE.className="ConvLSTM2DCell",Nu.registerClass(gE);var yE=class extends mE{constructor(e){let t=new gE(e);super(Object.assign({},e,{cell:t}))}static fromConfig(e,t){return new e(t)}};yE.className="ConvLSTM2D",Nu.registerClass(yE);var bE=class extends oN{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;let t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?t[r]:this.noiseShape[r]);return n}call(e,t){return fl((()=>{this.invokeCallHook(e,t);let n=KS(e);if(0<this.rate&&this.rate<1){let e=null!=t.training&&t.training,r=this.getNoiseShape(n);return xS((()=>bS(n,this.rate,r,this.seed)),(()=>n),e)}return e}))}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};bE.className="Dropout",Nu.registerClass(bE);var wE=class extends bE{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};wE.className="SpatialDropout1D",Nu.registerClass(wE);var xE=class extends oN{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,wI(this.units,"units"),this.activation=w_(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=HS(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=HS(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=DN(e.kernelConstraint),this.biasConstraint=DN(e.biasConstraint),this.kernelRegularizer=__(e.kernelRegularizer),this.biasRegularizer=__(e.biasRegularizer),this.activityRegularizer=__(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=XS(e);let t=e[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=XS(e);let t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return fl((()=>{this.invokeCallHook(e,t);let n,r=KS(e),a=kI(this.activation.getClassName());return null!=a?n=dS(r,this.kernel.read(),a,this.bias?this.bias.read():null):(n=dS(r,this.kernel.read()),null!=this.bias&&(n=mS(n,this.bias.read())),null!=this.activation&&(n=this.activation.apply(n))),n}))}getConfig(){let e={units:this.units,activation:y_(this.activation),useBias:this.useBias,kernelInitializer:GS(this.kernelInitializer),biasInitializer:GS(this.biasInitializer),kernelRegularizer:T_(this.kernelRegularizer),biasRegularizer:T_(this.biasRegularizer),activityRegularizer:T_(this.activityRegularizer),kernelConstraint:FN(this.kernelConstraint),biasConstraint:FN(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};xE.className="Dense",Nu.registerClass(xE);var vE=class extends oN{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=XS(e);for(let t of e.slice(1))if(null==t)throw new Jk(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],qI(e,1)]}call(e,t){return fl((()=>{this.invokeCallHook(e,t);let n=KS(e);if("channelsFirst"===this.dataFormat&&n.rank>1){let e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=Dl(n,e)}return rS(n)}))}getConfig(){let e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};vE.className="Flatten",Nu.registerClass(vE);var kE=class extends oN{constructor(e){super(e),this.supportsMasking=!0,this.activation=w_(e.activation)}call(e,t){return fl((()=>{this.invokeCallHook(e,t);let n=KS(e);return this.activation.apply(n)}))}getConfig(){let e={activation:y_(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};kE.className="Activation",Nu.registerClass(kE);var IE=class extends oN{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return fl((()=>(e=KS(e),tS(e,this.n))))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};IE.className="RepeatVector",Nu.registerClass(IE);var SE=class extends oN{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",r=t.slice(),a=1,s=null;for(let o=0;o<r.length;++o){let e=r[o];if(this.isUnknown(e)){if(null!==s)throw new Jk("Can only specifiy one unknown dimension.");s=o}else a*=e}let i=qI(e);if(null!==s){if(0===a||i%a!==0)throw new Jk(n);r[s]=i/a}else if(i!==a)throw new Jk(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return fl((()=>{this.invokeCallHook(e,t);let n=KS(e),r=n.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return Vp(n,a)}))}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};SE.className="Reshape",Nu.registerClass(SE);var NE=class extends oN{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=YI(1,e.dims.length+1);if(!Aa.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new nN({ndim:this.dims.length+1})]}computeOutputShape(e){e=XS(e);let t=e.slice();return this.dims.forEach(((n,r)=>{t[r+1]=e[n]})),t}call(e,t){return Dl(KS(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};NE.className="Permute",Nu.registerClass(NE);var TE=class extends oN{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=KS(e),r=-1;return lp(Pf(n,this.maskValue),r)}call(e,t){return fl((()=>{this.invokeCallHook(e,t);let n=KS(e),r=-1,a=!0,s=lp(Pf(n,this.maskValue),r,a);return Yu(n,vo(s,n.dtype))}))}};TE.className="Masking",Nu.registerClass(TE);var CE=class extends oN{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(iI(e.inputLength))}this.inputDim=e.inputDim,wI(this.inputDim,"inputDim"),this.outputDim=e.outputDim,wI(this.outputDim,"outputDim"),this.embeddingsInitializer=HS(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=__(e.embeddingsRegularizer),this.activityRegularizer=__(e.activityRegularizer),this.embeddingsConstraint=DN(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return fl((()=>this.maskZero?(e=KS(e),Pf(e,mc(e))):null))}computeOutputShape(e){if(e=XS(e),null==this.inputLength)return[...e,this.outputDim];let t=iI(this.inputLength);if(t.length!==e.length-1)throw new Jk(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){let a=t[r],s=e[r+1];if(null!=a&&null!=s&&a!==s)throw new Jk(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==a&&(t[n]=s),n++}}return[e[0],...t,this.outputDim]}call(e,t){return fl((()=>{this.invokeCallHook(e,t);let n=KS(e);"int32"!==n.dtype&&(n=QI(n,"int32"));let r=cS(this.embeddings.read(),Vp(n,[n.size]));return Vp(r,XS(this.computeOutputShape(n.shape)))}))}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:GS(this.embeddingsInitializer),embeddingsRegularizer:T_(this.embeddingsRegularizer),activityRegularizer:T_(this.activityRegularizer),embeddingsConstraint:FN(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};CE.className="Embedding",Nu.registerClass(CE);var _E=class extends oN{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Qk}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;let n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){let a=e[e.length-t.length+r],s=t[r];if(null==a||null==s||a<0||s<0)n.push(null);else if(1===a)n.push(s);else if(1===s)n.push(a);else{if(a!==s)throw new Jk("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(a)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[XS(e)]),e.length<2)throw new Jk(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let a of e)null!=a&&null!==a[0]&&t.push(a[0]);if(t=mI(t),t.length>1)throw new Jk(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let a=1;a<e.length;++a){let t=null==e[a]?null:e[a].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}let r=e.map((e=>e.length));-1===e.indexOf(null)&&1===mI(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return fl((()=>{if(this.reshapeRequired){let t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){let r=XI(n);for(let n of e){let e=n.rank;for(let t=0;t<r-e;++t)n=eS(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(let s of e){let e=s.rank;if(null==e){let e=s.shape,r=e[0],a=e.slice(1).concat([r]),i=Vp(s,[r].concat(qI(e.slice(1))));i=Dl(i,[1,0]),i=Vp(i,a),t.push(i),n=!0}else if(e>1){let r=YI(1,e).concat([0]);t.push(Dl(s,r)),n=!0}else t.push(s)}let r=this.mergeFunction(t),a=r.rank;if(n)if(null==a){let e=r.shape,t=e.length,n=e[t-1],a=[n].concat(e.slice(0,e.length-1));r=Vp(Dl(Vp(r,[-1,n]),[1,0]),a)}else if(a>1){let e=[a-1].concat(YI(0,a-1));r=Dl(r,e)}return r}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){let n=null==e[r]?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(let r of e)null!=r&&null!==r[0]&&n.push(r[0]);return n=mI(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return fl((()=>{if(null==t)return null;if(!Array.isArray(t))throw new Jk("`mask` should be an Array");if(!Array.isArray(e))throw new Jk("`inputs` should be an Array");if(t.length!==e.length)throw new Jk(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every((e=>null==e)))return null;t=t.map((e=>null==e?e:th(e,0)));let n=t[0];for(let e=1;e<t.length-1;++e)n=ef(n,t[e]);return n}))}},EE=class extends _E{constructor(e){super(e)}mergeFunction(e){return fl((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Gu(t,e[n]);return t}))}};EE.className="Add",Nu.registerClass(EE);var AE=class extends _E{constructor(e){super(e)}mergeFunction(e){return fl((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Yu(t,e[n]);return t}))}};AE.className="Multiply",Nu.registerClass(AE);var $E=class extends _E{constructor(e){super(e)}mergeFunction(e){return fl((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Gu(t,e[n]);return Yu(1/e.length,t)}))}};$E.className="Average",Nu.registerClass($E);var FE=class extends _E{constructor(e){super(e)}mergeFunction(e){return fl((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=wf(t,e[n]);return t}))}};FE.className="Maximum",Nu.registerClass(FE);var RE=class extends _E{constructor(e){super(e)}mergeFunction(e){return fl((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Tf(t,e[n]);return t}))}};RE.className="Minimum",Nu.registerClass(RE);var DE=class extends _E{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new Jk("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(let r of e)if(null!=r){t=!1;break}if(t)return;let n=[];for(let r=0;r<e.length;++r){let t=e[r].slice();t.splice(this.axis,1);let a=!1;for(let e of n)if(Aa.arraysEqual(e,t)){a=!0;break}a||n.push(t)}if(n.length>1)throw new Jk("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return fl((()=>oS(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new Jk("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(let a of t.slice(1)){if(null==n[r]||null==a[r]){n[r]=null;break}n[r]+=a[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new Jk("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new Jk("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new Jk(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return fl((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;let r=[];for(let s=0;s<e.length;++s)null==t[s]?r.push(vo(Bf(e[s]),"bool")):t[s].rank<e[s].rank?r.push(th(t[s],-1)):r.push(t[s]);let a=Kp(r,this.axis);return ip(a,-1,!1)}))}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};function ME(e,t){for(;e<0;)e+=t;return e}function OE(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new Qk("batchDot is not implemented for tensors of 4D or higher rank yet");if(Aa.assert(e.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`)),Aa.assert(e.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`)),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new Qk("batchDot is not implemented for complex64-type Tensors yet.");let r=e.shape.length,a=t.shape.length;null==n&&(n=[r-1,a-2]);let s=n;return fl((()=>{let n,i;if(r>a){n=r-a;let e=[];for(let t=0;t<n;++t)e.push(1);t=Vp(t,t.shape.concat(e))}else if(a>r){n=a-r;let t=[];for(let e=0;e<n;++e)t.push(1);e=Vp(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)i=s[0]===s[1]?jc(Yu(e,t),s[0]):jc(Yu(Dl(e,[1,0]),t),s[1]);else{let n=s[0]!==e.shape.length-1,r=s[1]===t.shape.length-1;i=rl(e,t,n,r)}if(n>0){let e;e=r>a?r+a-3:r-1;let t=[];for(let r=e;r<e+n;++r)t.push(r);i=Ig(i,t)}return 1===i.shape.length&&(i=th(i,1)),i}))}DE.className="Concatenate",Nu.registerClass(DE);var LE=class extends _E{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){Aa.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new Qk("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new Jk(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(2!==e.length)throw new Jk(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>ME(t,e[n].shape.length))):[ME(this.axes,n.shape.length),ME(this.axes,r.shape.length)],this.normalize&&(n=mT(n,t[0]),r=mT(r,t[1])),OE(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[ME(this.axes,e.length),ME(this.axes,t.length)],n}computeOutputShape(e){Aa.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new Qk("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);let a=t.concat(n);return 1===a.length&&a.push(1),a}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};LE.className="Dot",Nu.registerClass(LE);var PE=class extends oN{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return fl((()=>{this.invokeCallHook(e,t);let n=KS(e);return xS((()=>Gu(pS(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}};PE.className="GaussianNoise",Nu.registerClass(PE);var zE=class extends oN{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return fl((()=>{this.invokeCallHook(e,t);let n=KS(e);return this.rate>0&&this.rate<1?xS((()=>{let e=Math.sqrt(this.rate/(1-this.rate));return Yu(n,pS(n.shape,1,e))}),(()=>n),t.training||!1):n}))}};zE.className="GaussianDropout",Nu.registerClass(zE);var BE=class extends oN{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||KS(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return fl((()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return xS((()=>{let t=KS(e),r=1.6732632423543772,a=1.0507009873554805,s=-r*a,i=gh(xm(n),this.rate);i=QI(i,"float32");let o=((1-this.rate)*(1+this.rate*s**2))**-.5,l=-o*s*this.rate,u=Gu(Yu(t,i),Yu(Gu(i,-1),s));return Gu(Yu(u,o),l)}),(()=>KS(e)),t.training||!1)}return e}))}};function WE(e,t,n,r,a,s=.001){let i;if(2===e.rank)i=ud(e,t,n,r,a,s);else if(3===e.rank)i=dd(e,t,n,r,a,s);else{if(4!==e.rank)throw new Qk(`batchNormalization is not implemented for array of rank ${e.rank} yet`);i=hd(e,t,n,r,a,s)}return i}function VE(e,t,n,r,a=.001){return fl((()=>{let s=Ff(e,r),i=s.mean,o=s.variance;return[WE(e,i,o,n,t,a),i,o]}))}function UE(e,t,n,r,a=.001){return fl((()=>{let s=Ff(e,r),i=s.mean,o=s.variance,l=[];for(let t of YI(0,e.rank))-1!==r.indexOf(t)?l.push(1):l.push(e.shape[t]);let u=Vp(i,l),p=Vp(o,l),d=null==t?null:Vp(t,l),c=null==n?null:Vp(n,l);return[WE(e,u,p,c,d,a),i,o]}))}function GE(e,t,n,r,a=.001){return Aa.arraysEqual(r.slice().sort(),YI(0,e.rank-1))?VE(e,t,n,r,a):UE(e,t,n,r,a)}BE.className="AlphaDropout",Nu.registerClass(BE);var HE=class extends oN{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=HS(e.betaInitializer||"zeros"),this.gammaInitializer=HS(e.gammaInitializer||"ones"),this.movingMeanInitializer=HS(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=HS(e.movingVarianceInitializer||"ones"),this.betaConstraint=DN(e.betaConstraint),this.gammaConstraint=DN(e.gammaConstraint),this.betaRegularizer=__(e.betaRegularizer),this.gammaRegularizer=__(e.gammaRegularizer)}build(e){e=XS(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new Jk(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new nN({ndim:e.length,axes:{[t]:n}})];let r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return fl((()=>{let n=null!=t.training&&t.training,r=KS(e),a=r.shape,s=a.length,i=YI(0,s),o=this.axis>=0?this.axis:this.axis+s;i.splice(o,1);let l=nI(1,s);l[o]=a[o];let u=i.slice();u.sort();let p=!Aa.arraysEqual(u,YI(0,s).slice(0,s-1)),d=()=>{if(p){let e=Vp(this.movingMean.read(),l),t=Vp(this.movingVariance.read(),l),n=this.center?Vp(this.beta.read(),l):null,a=this.scale?Vp(this.gamma.read(),l):null;return WE(r,e,t,n,a,this.epsilon)}return WE(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)};if(!n)return d();let[c,h,f]=GE(r,this.gamma.read(),this.beta.read(),i,this.epsilon),m=(e,t,n)=>{fl((()=>{let r=1-n,a=e.read(),s=Yu(Kh(a,t),r);e.write(Kh(a,s))}))};return m(this.movingMean,h,this.momentum),m(this.movingVariance,f,this.momentum),c}))}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:GS(this.betaInitializer),gammaInitializer:GS(this.gammaInitializer),movingMeanInitializer:GS(this.movingMeanInitializer),movingVarianceInitializer:GS(this.movingVarianceInitializer),betaRegularizer:T_(this.betaRegularizer),gammaRegularizer:T_(this.gammaRegularizer),betaConstraint:FN(this.betaConstraint),gammaConstraint:FN(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};HE.className="BatchNormalization",Nu.registerClass(HE);var jE=class extends oN{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(let e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=HS(e.betaInitializer||"zeros"),this.gammaInitializer=HS(e.gammaInitializer||"ones"),this.betaRegularizer=__(e.betaRegularizer),this.gammaRegularizer=__(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=XS(e);let t=e.length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=t);for(let a of this.axis)if(a<0||a>=t)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==mI(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map((t=>e[t])),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){let n=KS(e),r=n.shape,a=r.length;return fl((()=>{let{mean:e,variance:t}=Ff(n,this.axis,!0),s=nI(1,a);for(let n of this.axis)s[n]=r[n];let i=e=>null!=e&&e.shape.length!==a?Vp(e,s):e,o=this.scale?i(this.gamma.read()):null,l=this.center?i(this.beta.read()):null,u=[],p=[];for(let n=0;n<a;++n)-1!==this.axis.indexOf(n)?(u.push(r[n]),p.push(1)):(u.push(1),p.push(r[n]));return e=sh(e,u),t=sh(t,u),null!=o&&(o=sh(o,p)),null!=l&&(l=sh(l,p)),WE(n,e,t,l,o,this.epsilon)}))}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:GS(this.betaInitializer),gammaInitializer:GS(this.gammaInitializer),betaRegularizer:T_(this.betaRegularizer),gammaRegularizer:T_(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};function qE(e,t,n){return fl((()=>{if(4!==e.rank)throw new Jk(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new Jk("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==n&&(n=JI()),"channelsLast"!==n&&"channelsFirst"!==n)throw new Jk(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===n?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],Gf(e,r)}))}jE.className="LayerNormalization",Nu.registerClass(jE);var KE=class extends oN{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?JI():e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new Jk(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"==typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new Jk(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new Jk(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new nN({ndim:4})]}computeOutputShape(e){let t,n;return e=XS(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return fl((()=>qE(KS(e),this.padding,this.dataFormat)))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};function XE(e,t,n,r,a,s){return fl((()=>{RI(a),OI(s),MI(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==a&&(a=JI()),null==s&&(s="max"),e=P_(e,a);let i,o="same"===r?"same":"valid";return i="max"===s?hf(e,t,n,o):Gp(e,t,n,o),"channelsFirst"===a&&(i=Dl(i,[0,3,1,2])),i}))}function YE(e,t,n,r,a,s){return fl((()=>{RI(a),OI(s),MI(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==a&&(a=JI()),null==s&&(s="max"),e=z_(e,a);let i,o="same"===r?"same":"valid";return i="max"===s?mf(e,t,n,o):jp(e,t,n,o),"channelsFirst"===a&&(i=Dl(i,[0,4,1,2,3])),i}))}KE.className="ZeroPadding2D",Nu.registerClass(KE);var ZE=class extends oN{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"==typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new Jk(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(wI(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"==typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new Jk(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}wI(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,MI(this.padding),this.inputSpec=[new nN({ndim:3})]}computeOutputShape(e){e=XS(e);let t=O_(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return fl((()=>{this.invokeCallHook(e,t),e=eS(KS(e),2);let n=this.poolingFunction(KS(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Ig(n,[2])}))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},JE=class extends ZE{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return RI(a),MI(r),XE(e,t,n,r,a,"max")}};JE.className="MaxPooling1D",Nu.registerClass(JE);var QE=class extends ZE{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return RI(a),MI(r),XE(e,t,n,r,a,"avg")}};QE.className="AveragePooling1D",Nu.registerClass(QE);var eA=class extends oN{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new Jk(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];wI(this.poolSize,"poolSize"),wI(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,RI(this.dataFormat),MI(this.padding),this.inputSpec=[new nN({ndim:4})]}computeOutputShape(e){e=XS(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=O_(t,this.poolSize[0],this.padding,this.strides[0]),n=O_(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return fl((()=>(this.invokeCallHook(e,t),this.poolingFunction(KS(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},tA=class extends eA{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return RI(a),MI(r),XE(e,t,n,r,a,"max")}};tA.className="MaxPooling2D",Nu.registerClass(tA);var nA=class extends eA{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return RI(a),MI(r),XE(e,t,n,r,a,"avg")}};nA.className="AveragePooling2D",Nu.registerClass(nA);var rA=class extends oN{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new Jk(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];wI(this.poolSize,"poolSize"),wI(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,RI(this.dataFormat),MI(this.padding),this.inputSpec=[new nN({ndim:5})]}computeOutputShape(e){e=XS(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=O_(t,this.poolSize[0],this.padding,this.strides[0]),n=O_(n,this.poolSize[1],this.padding,this.strides[1]),r=O_(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return fl((()=>(this.invokeCallHook(e,t),this.poolingFunction(KS(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},aA=class extends rA{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return RI(a),MI(r),YE(e,t,n,r,a,"max")}};aA.className="MaxPooling3D",Nu.registerClass(aA);var sA=class extends rA{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return RI(a),MI(r),YE(e,t,n,r,a,"avg")}};sA.className="AveragePooling3D",Nu.registerClass(sA);var iA=class extends oN{constructor(e){super(e),this.inputSpec=[new nN({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Qk}},oA=class extends iA{constructor(e){super(e||{})}call(e,t){return fl((()=>{let t=KS(e);return vf(t,1)}))}};oA.className="GlobalAveragePooling1D",Nu.registerClass(oA);var lA=class extends iA{constructor(e){super(e||{})}call(e,t){return fl((()=>{let t=KS(e);return Mc(t,1)}))}};lA.className="GlobalMaxPooling1D",Nu.registerClass(lA);var uA=class extends oN{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,RI(this.dataFormat),this.inputSpec=[new nN({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Qk}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},pA=class extends uA{call(e,t){return fl((()=>{let t=KS(e);return"channelsLast"===this.dataFormat?vf(t,[1,2]):vf(t,[2,3])}))}};pA.className="GlobalAveragePooling2D",Nu.registerClass(pA);var dA=class extends uA{call(e,t){return fl((()=>{let t=KS(e);return"channelsLast"===this.dataFormat?Mc(t,[1,2]):Mc(t,[2,3])}))}};dA.className="GlobalMaxPooling2D",Nu.registerClass(dA);var cA=class extends oN{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let r=t.layer,a=fT(r,n);delete t.layer;let s={layer:a};return Object.assign(s,t),new e(s)}},hA=class extends cA{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=XS(e),e.length<3)throw new Jk(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=XS(e);let t=[e[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return fl((()=>(e=KS(e),rE(((e,n)=>[KS(this.layer.call(e,t)),[]]),e,[],!1,null,null,!1,!0)[1])))}};function fA(e){yI($I,"BidirectionalMergeMode",e)}hA.className="TimeDistributed",Nu.registerClass(hA);var mA="concat",gA=class extends cA{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=fT(n),t.goBackwards=!0!==t.goBackwards;let r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=fT(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?mA:e.mergeMode,fA(this.mergeMode),e.weights)throw new Qk("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,r,a=this.forwardLayer.computeOutputShape(e);return Array.isArray(a)&&Array.isArray(a[0])||(a=[a]),this.returnState&&(r=a.slice(1)),t=a[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):sI(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});let a=nE(e,n,r,this.numConstants);if(e=a.inputs,n=a.initialState,r=a.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);let s=[],i=[];if(null!=n){let e=n.length;if(e%2>0)throw new Jk("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,s.push(...n);let r=n.map((e=>new nN({shape:e.shape})));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),i.push(...r)}if(null!=r)throw new Qk("Support for constants in Bidirectional layers is not implemented yet.");let o=s[0]instanceof rN;for(let l of s)if(l instanceof rN!==o)throw new Jk("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){let n=[e].concat(s),r=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=r;let o=super.apply(n,t);return this.inputSpec=a,o}return super.apply(e,t)}call(e,t){return fl((()=>{let n,r,a,s,i=t.initialState;if(null==i)n=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{let a=i.slice(0,i.length/2),s=i.slice(i.length/2);n=this.forwardLayer.call(e,Object.assign(t,{initialState:a})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:s}))}return this.returnState&&(Array.isArray(n)&&(a=n.slice(1).concat(r.slice(1))),n=n[0],r=r[0]),this.returnSequences&&(r=Em(r,1)),"concat"===this.mergeMode?s=oS([n,r]):"sum"===this.mergeMode?s=Gu(n,r):"ave"===this.mergeMode?s=Yu(.5,Gu(n,r)):"mul"===this.mergeMode?s=Yu(n,r):null==this.mergeMode&&(s=[n,r]),this.returnState?null==this.mergeMode?s.concat(a):[s].concat(a):s}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){zI(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),zI(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){let e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=fT(t.layer);if(delete t.layer,null!=t.numConstants)throw new Qk("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let r=t;return r.layer=n,new e(r)}};function yA(e){return new dN(e)}function bA(e){return new F_(e)}function wA(e){return new E_(e)}function xA(e){return new A_(e)}function vA(e){return new $_(e)}function kA(e){return new D_(e)}function IA(e){return new R_(e)}function SA(e){return new Z_(e)}function NA(e){return new H_(e)}function TA(e){return new q_(e)}function CA(e){return new j_(e)}function _A(e){return new K_(e)}function EA(e){return new Y_(e)}function AA(e){return new J_(e)}function $A(e){return new Q_(e)}function FA(e){return new tE(e)}function RA(e){return new kE(e)}function DA(e){return new xE(e)}function MA(e){return new bE(e)}function OA(e){return new wE(e)}function LA(e){return new vE(e)}function PA(e){return new IE(e)}function zA(e){return new SE(e)}function BA(e){return new NE(e)}function WA(e){return new CE(e)}function VA(e){return new EE(e)}function UA(e){return new $E(e)}function GA(e){return new DE(e)}function HA(e){return new FE(e)}function jA(e){return new RE(e)}function qA(e){return new AE(e)}function KA(e){return new LE(e)}function XA(e){return new HE(e)}function YA(e){return new jE(e)}function ZA(e){return new KE(e)}function JA(e){return new QE(e)}function QA(e){return JA(e)}function e$(e){return JA(e)}function t$(e){return new nA(e)}function n$(e){return t$(e)}function r$(e){return t$(e)}function a$(e){return new sA(e)}function s$(e){return a$(e)}function i$(e){return a$(e)}function o$(e){return new oA(e)}function l$(e){return new pA(e)}function u$(e){return new lA(e)}function p$(e){return new dA(e)}function d$(e){return new JE(e)}function c$(e){return new tA(e)}function h$(e){return new aA(e)}function f$(e){return new uE(e)}function m$(e){return new lE(e)}function g$(e){return new dE(e)}function y$(e){return new pE(e)}function b$(e){return new oE(e)}function w$(e){return new iE(e)}function x$(e){return new yE(e)}function v$(e){return new gE(e)}function k$(e){return new aE(e)}function I$(e){return new cE(e)}function S$(e){return new gA(e)}function N$(e){return new hA(e)}gA.className="Bidirectional",Nu.registerClass(gA);var T$=u$,C$=p$,_$=d$,E$=c$;function A$(e){return new PE(e)}function $$(e){return new zE(e)}function F$(e){return new BE(e)}function R$(e){return new TE(e)}var D$={};function M$(e,t){return RT(e,t)}function O$(e,t){return BT(e,t)}function L$(e,t){return WT(e,t)}function P$(e,t){return DT(e,t)}function z$(e,t){return KT(e,t)}function B$(e,t){return PT(e,t)}function W$(e,t){return zT(e,t)}function V$(e,t){return AT(e,t)}function U$(e,t){return yT(e,t)}function G$(e,t){return bT(e,t)}function H$(e,t){return bT(e,t)}function j$(e,t){return bT(e,t)}function q$(e,t){return gT(e,t)}function K$(e,t){return gT(e,t)}function X$(e,t){return gT(e,t)}v(D$,{MAPE:()=>H$,MSE:()=>K$,binaryAccuracy:()=>M$,binaryCrossentropy:()=>O$,categoricalAccuracy:()=>P$,categoricalCrossentropy:()=>z$,cosineProximity:()=>V$,mape:()=>j$,meanAbsoluteError:()=>U$,meanAbsolutePercentageError:()=>G$,meanSquaredError:()=>q$,mse:()=>X$,precision:()=>B$,recall:()=>W$,sparseCategoricalAccuracy:()=>L$});var Y$={};v(Y$,{modelFromJSON:()=>jC});var Z$={};function J$(e){return new k_(e)}function Q$(e){return I_(e)}function eF(e){return S_(e)}v(Z$,{l1:()=>Q$,l1l2:()=>J$,l2:()=>eF});var tF=class extends iT{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof GC))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function nF(e,t){return e<t}function rF(e,t){return e>t}var aF=class extends tF{constructor(e){if(super(),null==e&&(e={}),e.restoreBestWeights)throw new Qk("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,-1===["auto","min","max"].indexOf(this.mode)&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),"min"===this.mode?this.monitorFunc=nF:"max"===this.mode||-1!==this.monitor.indexOf("acc")?this.monitorFunc=rF:this.monitorFunc=nF,this.monitorFunc===nF&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,null!=this.baseline?this.best=this.baseline:this.best=this.monitorFunc===nF?1/0:-1/0}async onEpochEnd(e,t){await rT(t);let n=this.getMonitorValue(t);null!=n&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){null==e&&(e={});let t=e[this.monitor];return null==t&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};function sF(e){return new aF(e)}var iF,oF,lF={earlyStopping:sF},uF=et();uF.registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(iF||(iF={})),function(e){let t;(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(oF||(oF={}));var pF={};function dF(e,t){let n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};pF[e]=n}function cF(e){return pF[e]}function hF(e){delete pF[e]}function fF(e,t,n,r,a){let s=t.inputParams[e];if(s&&void 0!==s.inputIndexStart){let e=s.inputIndexStart,i=0===s.inputIndexEnd?void 0:void 0===s.inputIndexEnd?e+1:s.inputIndexEnd;if("tensor"===s.type)return mF(t.inputNames[s.inputIndexStart],n,r,a);if("tensors"===s.type)return t.inputNames.slice(e,i).map((e=>mF(e,n,r,a)));let o=mF(t.inputNames.slice(e)[0],n,r,a),l=o.dataSync();return"number"===s.type?l[0]:Aa.toNestedArray(o.shape,l)}let i=t.attrParams[e];return i&&i.value}function mF(e,t,n,r){let[a,s]=wF(e);if(null!=r){let e=r.getHashTableHandleByName(a);if(null!=e)return e}let i=n.currentContextIds.find((e=>!!t[bF(a,e)]));return void 0!==i?t[bF(a,i)][s]:void 0}function gF(e,t,n){return t[bF(e,n.currentContextId)]}function yF(e,t){let[n,r,a]=wF(e);return[bF(n,t&&t.currentContextId),r,a]}function bF(e,t){return t?`${e}-${t}`:e}function wF(e){let t=e.split(":");if(1===t.length)return[e,0,void 0];let n=t[0],r=3===t.length?t[1]:void 0,a=Number(t[t.length-1]);return[n,a,r]}function xF(e,t,n){let r=fF("pad",e,t,n);if("explicit"===r){r=fF("explicitPaddings",e,t,n);let a=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)a[e][0]=r[2*e],a[e][1]=r[2*e+1];return a}return r}function vF(e){return e.kept?e:Io(e)}var kF={};v(kF,{json:()=>IF});var IF=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],SF={};v(SF,{json:()=>NF});var NF=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],TF={};v(TF,{json:()=>CF});var CF=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],_F={};v(_F,{json:()=>EF});var EF=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],AF={};v(AF,{json:()=>$F});var $F=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],FF={};v(FF,{json:()=>RF});var RF=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],DF={};v(DF,{json:()=>MF});var MF=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],OF={};v(OF,{json:()=>LF});var LF=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],PF={};v(PF,{json:()=>zF});var zF=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],BF={};v(BF,{json:()=>WF});var WF=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],VF={};v(VF,{json:()=>UF});var UF=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],GF={};v(GF,{json:()=>HF});var HF=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],jF={};v(jF,{json:()=>qF});var qF=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],KF={};v(KF,{json:()=>XF});var XF=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],YF={};v(YF,{json:()=>ZF});var ZF=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],JF={};v(JF,{json:()=>QF});var QF=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],eR={};v(eR,{json:()=>tR});var tR=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],nR={};v(nR,{json:()=>rR});var rR=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],aR={};v(aR,{json:()=>sR});var sR=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],iR=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[kF,SF,TF,_F,AF,FF,DF,OF,PF,BF,VF,GF,jF,KF,YF,JF,eR,nR,aR],t=[].concat(...e.map((e=>e.json)));this.opMappers=t.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e,t={}){let n=e.node,r=[],a=[],s=[],i=n.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?r.push(e[t.name]):"Const"===t.op?a.push(e[t.name]):(null==t.input||0===t.input.length)&&s.push(e[t.name]),e)),{}),o=[],l=[],u={},p={};null!=t&&(u=this.mapSignatureEntries(t.inputs),p=this.mapSignatureEntries(t.outputs));let d=Object.keys(i);d.forEach((e=>{let t=i[e];t.inputNames.forEach(((e,n)=>{let[r,,a]=yF(e),s=i[r];if(null!=s.outputs){let e=s.outputs.indexOf(a);if(-1!==e){let a=`${r}:${e}`;t.inputNames[n]=a}}t.inputs.push(s),s.children.push(t)}))})),0===Object.keys(p).length?d.forEach((e=>{let t=i[e];0===t.children.length&&l.push(t)})):Object.keys(p).forEach((e=>{let[t]=yF(e),n=i[t];null!=n&&(n.signatureKey=p[e],l.push(n))})),Object.keys(u).length>0?Object.keys(u).forEach((e=>{let[t]=yF(e),n=i[t];n&&(n.signatureKey=u[e],o.push(n))})):o=r;let c={};null!=e.library&&null!=e.library.function&&(c=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));let h={nodes:i,inputs:o,outputs:l,weights:a,placeholders:r,signature:t,functions:c};return s.length>0&&(h.initNodes=s),h}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){let t=cF(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.slice(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((t,n)=>{let r,a=n.type;switch(n.type){case"string":r=uR(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=uR(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":r=wR(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=wR(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":r=dR(e.attr,n.tfName,n.defaultValue||0),void 0===r&&n.tfDeprecatedName&&(r=dR(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":r=bR(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=bR(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":r=pR(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=pR(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":r=vR(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=vR(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":r=yR(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=yR(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":r=xR(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=xR(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":r=fR(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=fR(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":r=mR(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=mR(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":r=hR(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=hR(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:r,type:a},t}),{})),n}mapFunction(e){let t=e.nodeDef,n=[],r=[],a={};null!=t&&(a=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&r.push(e[t.name]),e)),{}));let s=[],i=[];e.signature.inputArg.forEach((e=>{let[t]=yF(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:cR(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,s.push(n),a[t]=n})),Object.keys(a).forEach((e=>{let t=a[e];t.inputNames.forEach(((e,n)=>{let[r,,s]=yF(e),i=a[r];if(null!=i.outputs){let e=i.outputs.indexOf(s);if(-1!==e){let a=`${r}:${e}`;t.inputNames[n]=a}}t.inputs.push(i),i.children.push(t)}))}));let o=e.ret;e.signature.outputArg.forEach((e=>{let[t,n]=yF(o[e.name]),r=a[t];null!=r&&(r.defaultOutput=n,i.push(r))}));let l=this.mapArgsToSignature(e);return{nodes:a,inputs:s,outputs:i,weights:r,placeholders:n,signature:l}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}};function oR(e){let t=et().global;if("undefined"!=typeof t.atob)return t.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function lR(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):oR(e);return t?n:n.toLowerCase()}function uR(e,t,n,r=!1){let a=e[t];return null!=a?lR(a.s,r):n}function pR(e,t,n){let r=e[t];return r?r.b:n}function dR(e,t,n){let r=e[t]||{},a=null!=r.i?r.i:null!=r.f?r.f:n;return"number"==typeof a?a:parseInt(a,10)}function cR(e){switch("string"==typeof e&&(e=iF[e]),e){case iF.DT_FLOAT:case iF.DT_HALF:return"float32";case iF.DT_INT32:case iF.DT_INT64:case iF.DT_INT8:case iF.DT_UINT8:return"int32";case iF.DT_BOOL:return"bool";case iF.DT_DOUBLE:return"float32";case iF.DT_STRING:return"string";default:return null}}function hR(e,t,n){let r=e[t];return r&&r.func?r.func.name:n}function fR(e,t,n){let r=e[t];return r&&r.type?cR(r.type):n}function mR(e,t,n){let r=e[t];return r&&r.list&&r.list.type?r.list.type.map((e=>cR(e))):n}function gR(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"==typeof e.size?e.size:parseInt(e.size,10))):[]}function yR(e,t,n){let r=e[t];return r&&r.shape?gR(r.shape):n}function bR(e,t,n){let r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map((e=>"number"==typeof e?e:parseInt(e,10))):n}function wR(e,t,n,r=!1){let a=e[t];return a&&a.list&&a.list.s?a.list.s.map((e=>lR(e,r))):n}function xR(e,t,n){let r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map((e=>gR(e))):n}function vR(e,t,n){let r=e[t];return r&&r.list&&r.list.b?r.list.b:n}var kR=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return mF(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(null!=n.tensor)return mF(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return dR(this.node.rawAttrs,e,t);if(null!=n.s)return uR(this.node.rawAttrs,e,t);if(null!=n.b)return pR(this.node.rawAttrs,e,t);if(null!=n.shape)return yR(this.node.rawAttrs,e,t);if(null!=n.type)return fR(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return bR(this.node.rawAttrs,e,t);if(null!=n.list.s)return wR(this.node.rawAttrs,e,t);if(null!=n.list.shape)return xR(this.node.rawAttrs,e,t);if(null!=n.list.b)return vR(this.node.rawAttrs,e,t);if(null!=n.list.type)return mR(this.node.rawAttrs,e,t)}return t}},IR=(e,t,n)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[Gu(fF("a",e,t,n),fF("b",e,t,n))];case"AddN":return[ap(fF("tensors",e,t,n))];case"FloorMod":case"Mod":return[Af(fF("a",e,t,n),fF("b",e,t,n))];case"Mul":return[Yu(fF("a",e,t,n),fF("b",e,t,n))];case"RealDiv":case"Div":return[Ku(fF("a",e,t,n),fF("b",e,t,n))];case"DivNoNan":return[yc(fF("a",e,t,n),fF("b",e,t,n))];case"FloorDiv":return[ju(fF("a",e,t,n),fF("b",e,t,n))];case"Sub":return[Kh(fF("a",e,t,n),fF("b",e,t,n))];case"Minimum":return[Tf(fF("a",e,t,n),fF("b",e,t,n))];case"Maximum":return[wf(fF("a",e,t,n),fF("b",e,t,n))];case"Pow":return[zc(fF("a",e,t,n),fF("b",e,t,n))];case"SquaredDifference":return[vg(fF("a",e,t,n),fF("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},SR=(e,t,n)=>{switch(e.op){case"Abs":case"ComplexAbs":return[Ju(fF("x",e,t,n))];case"Acos":return[ep(fF("x",e,t,n))];case"Acosh":return[np(fF("x",e,t,n))];case"Asin":return[fp(fF("x",e,t,n))];case"Asinh":return[gp(fF("x",e,t,n))];case"Atan":return[bp(fF("x",e,t,n))];case"Atan2":return[xp(fF("x",e,t,n),fF("y",e,t,n))];case"Atanh":return[kp(fF("x",e,t,n))];case"Ceil":return[vd(fF("x",e,t,n))];case"Complex":return[li(fF("real",e,t,n),fF("imag",e,t,n))];case"Cos":return[qd(fF("x",e,t,n))];case"Cosh":return[Xd(fF("x",e,t,n))];case"Elu":return[Ic(fF("x",e,t,n))];case"Erf":return[Nc(fF("x",e,t,n))];case"Exp":return[Qc(fF("x",e,t,n))];case"Expm1":return[rh(fF("x",e,t,n))];case"Floor":return[ph(fF("x",e,t,n))];case"Log":return[Rh(fF("x",e,t,n))];case"Log1p":return[Mh(fF("x",e,t,n))];case"Imag":return[_l(fF("x",e,t,n))];case"Neg":return[Al(fF("x",e,t,n))];case"Reciprocal":return[Im(fF("x",e,t,n))];case"Real":return[Fl(fF("x",e,t,n))];case"Relu":return[Nm(fF("x",e,t,n))];case"Round":return[zm(fF("x",e,t,n))];case"Selu":return[Um(fF("x",e,t,n))];case"Sigmoid":return[Yp(fF("x",e,t,n))];case"Sin":return[Zm(fF("x",e,t,n))];case"Sign":return[Xm(fF("x",e,t,n))];case"Sinh":return[Qm(fF("x",e,t,n))];case"Softplus":return[Gh(fF("x",e,t,n))];case"Sqrt":return[Vc(fF("x",e,t,n))];case"Square":return[Gc(fF("x",e,t,n))];case"Tanh":return[ed(fF("x",e,t,n))];case"Tan":return[$g(fF("x",e,t,n))];case"ClipByValue":return[Id(fF("x",e,t,n),fF("clipValueMin",e,t,n),fF("clipValueMax",e,t,n))];case"Relu6":return[Cm(fF("x",e,t,n))];case"Rsqrt":return[Wm(mF(e.inputNames[0],t,n))];case"Prod":return[lm(fF("x",e,t,n),fF("axes",e,t,n))];case"LeakyRelu":return[Sh(fF("x",e,t,n),fF("alpha",e,t,n))];case"Prelu":return[im(fF("x",e,t,n),fF("alpha",e,t,n))];case"IsNan":return[kh(mF(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function NR(e,t,n=""){if("number"!=typeof e&&"number"!=typeof t){Aa.assert(e.length===t.length,(()=>n+` Shapes ${e} and ${t} must match`));for(let r=0;r<e.length;r++){let a=e[r],s=t[r];Aa.assert(a<0||s<0||a===s,(()=>n+` Shapes ${e} and ${t} must match`))}}}function TR(e){return!("number"==typeof e||e.some((e=>e<0)))}function CR(e,t,n){let r=_R(e,n),a=!TR(r);if(a&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(a&&t.forEach((e=>{r=_R(e.shape,r)})),!TR(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function _R(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let r=0;r<e.length;++r){let a=e[r],s=t[r];if(a>=0&&s>=0&&a!==s)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=a>=0?a:s}return n}var ER=class{constructor(e,t,n,r,a,s,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=a,this.dynamicSize=s,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=Bc(0),gl(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{(null==e||!e.has(t.tensor.id))&&t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=t.shape),NR(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,gl(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return pi([],[0].concat(this.elementShape));let n=this.readMany(e);return NR(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Ng(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return pi([],[0].concat(this.elementShape));let t=[];for(let r=0;r<this.size();r++)t.push(r);let n=this.readMany(t);return NR(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),Kp(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,jg(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,r=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let a=0===n?0:t.size/n,s=[];fl((()=>{t=Vp(t,[1,n,a]);for(let n=0;n<e.length;++n){let i=0===n?0:r[n-1],o=[0,i,0],l=[1,e[n],a];s[n]=Vp(Jp(t,o,l),this.elementShape)}return s}));let i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,s)}},AR=class{constructor(e,t,n,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);NR(t,e.shape,"TensorList shape mismatch: "),gl(e)})),this.idTensor=Bc(0),this.maxNumElements=r,gl(this.idTensor)}get id(){return this.idTensor.id}copy(){return new AR([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{(null==e||!e.has(t.id))&&t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);NR(e,this.elementShape,"TensorList shape mismatch: ");let r=CR(this.elementShape,this.tensors,e);return fl((()=>{let e=this.tensors.map((e=>Vp(e,r)));return Ng(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");let n=CR(this.elementShape,this.tensors,e),r=this.tensors.pop();return NR(r.shape,e,"TensorList shape mismatch: "),Vp(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(NR(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");gl(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);let t=new AR([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);NR(this.tensors[e].shape,t,"TensorList shape mismatch: ");let r=CR(this.elementShape,this.tensors,t);return Vp(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);NR(this.elementShape,t.shape,"TensorList shape mismatch: "),gl(t),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);NR(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());let r=CR(this.elementShape,this.tensors,n);return 0===e.length?pi([],[0].concat(r)):fl((()=>{let t=e.map((e=>Vp(this.tensors[e],r)));return Ng(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);NR(this.elementShape,t,"TensorList shape mismatch: ");let n=CR(this.elementShape,this.tensors,t);return 0===this.size()?pi([],[0].concat(n)):fl((()=>{let e=this.tensors.map((e=>Vp(e,n)));return Kp(e,0)}))}};function $R(e,t,n){let r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);let a=e.shape.slice(1);NR(a,t,"TensorList shape mismatch: ");let s=jg(e);return new AR(s,t,r)}function FR(e,t,n){return new AR([],e,t,n)}function RR(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let a=Math.max(...t);if(null!=r&&-1!==r&&a>=r)throw new Error(`Max index must be < array size (${a}  vs. ${r})`);let s=new AR([],n,e.dtype,r),i=jg(e,0);return t.forEach(((e,t)=>{s.setItem(e,i[t])})),s}function DR(e,t,n){let r=0,a=t.map((e=>(r+=e,r)));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);let s=e.shape.slice(1),i=_R(s,n),o=0===r?0:e.size/r,l=fl((()=>{let n=[];e=Vp(e,[1,r,o]);for(let r=0;r<t.length;++r){let s=0===r?0:a[r-1],l=[0,s,0],u=[1,t[r],o];n[r]=Vp(Jp(e,l,u),i)}return e.dispose(),n})),u=new AR([],n,e.dtype,t.length);for(let p=0;p<l.length;p++)u.setItem(p,l[p]);return u}var MR=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{let r=fF("thenBranch",e,t,n),a=fF("elseBranch",e,t,n),s=fF("cond",e,t,n),i=fF("args",e,t,n);return(await s.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[a].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{let r=fF("body",e,t,n),a=fF("cond",e,t,n),s=fF("args",e,t,n),i=await n.functionMap[a].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),o=s.map((e=>e.id)),l=await i[0].data();i.forEach((e=>{!e.kept&&-1===o.indexOf(e.id)&&e.dispose()}));let u=s;for(;l[0];){let e=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);let t=u.map((e=>e.id));e.forEach((e=>{!e.kept&&-1===o.indexOf(e.id)&&-1===t.indexOf(e.id)&&e.dispose()}));let s=await n.functionMap[a].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await s[0].data(),s.forEach((e=>{!e.kept&&-1===o.indexOf(e.id)&&-1===t.indexOf(e.id)&&e.dispose()}))}return u}case"LoopCond":{let r=fF("pred",e,t,n);return[vF(r)]}case"Switch":{let r=fF("pred",e,t,n),a=fF("data",e,t,n);return a.kept||(a=vF(a)),(await r.data())[0]?[void 0,a]:[a,void 0]}case"Merge":{let r=e.inputNames.find((e=>void 0!==mF(e,t,n)));if(r){let e=mF(r,t,n);return[vF(e)]}return}case"Enter":{let r=fF("frameName",e,t,n),a=fF("tensor",e,t,n);return n.enterFrame(r),[vF(a)]}case"Exit":{let r=fF("tensor",e,t,n);return n.exitFrame(),[vF(r)]}case"NextIteration":{let r=fF("tensor",e,t,n);return n.nextIteration(),[vF(r)]}case"TensorArrayV3":{let r=fF("size",e,t,n),a=fF("dtype",e,t,n),s=fF("elementShape",e,t,n),i=fF("dynamicSize",e,t,n),o=fF("clearAfterRead",e,t,n),l=fF("identicalElementShapes",e,t,n),u=fF("name",e,t,n),p=new ER(u,a,r,s,l,i,o);return n.addTensorArray(p),[p.idTensor,Bc(1)]}case"TensorArrayWriteV3":{let r=fF("tensorArrayId",e,t,n),a=fF("index",e,t,n),s=fF("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(a,s),[i.idTensor]}case"TensorArrayReadV3":{let r=fF("tensorArrayId",e,t,n),a=fF("index",e,t,n);return[n.getTensorArray(r.id).read(a)]}case"TensorArrayGatherV3":{let r=fF("tensorArrayId",e,t,n),a=fF("indices",e,t,n),s=fF("dtype",e,t,n);return[n.getTensorArray(r.id).gather(a,s)]}case"TensorArrayScatterV3":{let r=fF("tensorArrayId",e,t,n),a=fF("indices",e,t,n),s=fF("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(a,s),[i.idTensor]}case"TensorArrayConcatV3":{let r=fF("tensorArrayId",e,t,n),a=n.getTensorArray(r.id),s=fF("dtype",e,t,n);return[a.concat(s)]}case"TensorArraySplitV3":{let r=fF("tensorArrayId",e,t,n),a=fF("tensor",e,t,n),s=fF("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(s,a),[i.idTensor]}case"TensorArraySizeV3":{let r=fF("tensorArrayId",e,t,n),a=n.getTensorArray(r.id);return[Bc(a.size(),"int32")]}case"TensorArrayCloseV3":{let r=fF("tensorArrayId",e,t,n),a=n.getTensorArray(r.id);return a.clearAndClose(),[a.idTensor]}case"TensorListSetItem":{let r=fF("tensorListId",e,t,n),a=fF("index",e,t,n),s=fF("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(a,s),[i.idTensor]}case"TensorListGetItem":{let r=fF("tensorListId",e,t,n),a=fF("index",e,t,n),s=fF("elementShape",e,t,n),i=fF("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(a,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let r=fF("indices",e,t,n),a=fF("tensor",e,t,n),s=fF("elementShape",e,t,n),i=fF("numElements",e,t,n),o=RR(a,r,s,i);return n.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r,a=fF("elementShape",e,t,n),s=fF("elementDType",e,t,n);r="TensorListReserve"===e.op?"numElements":"maxNumElements";let i=fF(r,e,t,n),o=FR(a,s,i);return n.addTensorList(o),[o.idTensor]}case"TensorListGather":{let r=fF("tensorListId",e,t,n),a=fF("indices",e,t,n),s=fF("elementShape",e,t,n),i=fF("elementDType",e,t,n);return[n.getTensorList(r.id).gather(a,i,s)]}case"TensorListStack":{let r=fF("tensorListId",e,t,n),a=fF("elementShape",e,t,n),s=fF("elementDType",e,t,n),i=fF("numElements",e,t,n);return[n.getTensorList(r.id).stack(a,s,i)]}case"TensorListFromTensor":{let r=fF("tensor",e,t,n),a=fF("elementShape",e,t,n),s=fF("elementDType",e,t,n),i=$R(r,a,s);return n.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let r=fF("tensorListId",e,t,n),a=n.getTensorList(r.id),s=fF("dtype",e,t,n),i=fF("elementShape",e,t,n);return[a.concat(s,i)]}case"TensorListPushBack":{let r=fF("tensorListId",e,t,n),a=fF("tensor",e,t,n),s=n.getTensorList(r.id);return s.pushBack(a),[s.idTensor]}case"TensorListPopBack":{let r=fF("tensorListId",e,t,n),a=fF("elementShape",e,t,n),s=fF("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(a,s)]}case"TensorListSplit":{let r=fF("tensor",e,t,n),a=fF("elementShape",e,t,n),s=fF("lengths",e,t,n),i=DR(r,s,a);return n.addTensorList(i),[i.idTensor]}case"TensorListLength":{let r=fF("tensorListId",e,t,n),a=n.getTensorList(r.id);return[Bc(a.size(),"int32")]}case"TensorListResize":{let r=fF("tensorListId",e,t,n),a=fF("size",e,t,n),s=n.getTensorList(r.id).resize(a);return n.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function OR(e,t,n){let[r,a]=fF("fusedOps",e,t,n),s="biasadd"===r,i=!s,o="prelu"===a,l="fusedbatchnorm"===r,u=fF("numArgs",e,t,n);if(s){if(o&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&s&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let p=fF("strides",e,t,n),d=xF(e,t,n),c=fF("dataFormat",e,t,n).toUpperCase(),h=fF("dilations",e,t,n),[f,m]=fF("args",e,t,n);i&&(m=f,f=void 0);let g=fF("leakyreluAlpha",e,t,n);return{stride:p,pad:d,dataFormat:c,dilations:h,biasArg:f,preluArg:m,activationFunc:a,leakyreluAlpha:g}}var LR=(e,t,n)=>{switch(e.op){case"Conv1D":{let r=fF("stride",e,t,n),a=fF("pad",e,t,n),s=fF("dataFormat",e,t,n).toUpperCase(),i=fF("dilation",e,t,n);return[Md(fF("x",e,t,n),fF("filter",e,t,n),r,a,s,i)]}case"Conv2D":{let r=fF("strides",e,t,n),a=xF(e,t,n),s=fF("dataFormat",e,t,n).toUpperCase(),i=fF("dilations",e,t,n);return[Rd(fF("x",e,t,n),fF("filter",e,t,n),[r[1],r[2]],a,s,[i[1],i[2]])]}case"_FusedConv2D":{let{stride:r,pad:a,dataFormat:s,dilations:i,biasArg:o,preluArg:l,activationFunc:u,leakyreluAlpha:p}=OR(e,t,n);return[gy.conv2d({x:fF("x",e,t,n),filter:fF("filter",e,t,n),strides:[r[1],r[2]],pad:a,dataFormat:s,dilations:[i[1],i[2]],bias:o,activation:u,preluActivationWeights:l,leakyreluAlpha:p})]}case"FusedDepthwiseConv2dNative":{let{stride:r,pad:a,dataFormat:s,dilations:i,biasArg:o,preluArg:l,activationFunc:u,leakyreluAlpha:p}=OR(e,t,n);return[gy.depthwiseConv2d({x:fF("x",e,t,n),filter:fF("filter",e,t,n),strides:[r[1],r[2]],pad:a,dataFormat:s,dilations:[i[1],i[2]],bias:o,activation:u,preluActivationWeights:l,leakyreluAlpha:p})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let r=fF("outputShape",e,t,n),a=fF("strides",e,t,n),s=xF(e,t,n);return[zd(fF("x",e,t,n),fF("filter",e,t,n),r,[a[1],a[2]],s)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let r=fF("strides",e,t,n),a=xF(e,t,n),s=fF("dilations",e,t,n),i=fF("dataFormat",e,t,n).toUpperCase();return[sc(fF("input",e,t,n),fF("filter",e,t,n),[r[1],r[2]],a,i,[s[1],s[2]])]}case"Conv3D":{let r=fF("strides",e,t,n),a=fF("pad",e,t,n),s=fF("dataFormat",e,t,n).toUpperCase(),i=fF("dilations",e,t,n);return[Wd(fF("x",e,t,n),fF("filter",e,t,n),[r[1],r[2],r[3]],a,s,[i[1],i[2],i[3]])]}case"AvgPool":{let r=fF("strides",e,t,n),a=fF("pad",e,t,n),s=fF("kernelSize",e,t,n);return[Gp(fF("x",e,t,n),[s[1],s[2]],[r[1],r[2]],a)]}case"MaxPool":{let r=fF("strides",e,t,n),a=fF("pad",e,t,n),s=fF("kernelSize",e,t,n);return[hf(fF("x",e,t,n),[s[1],s[2]],[r[1],r[2]],a)]}case"MaxPoolWithArgmax":{let r=fF("strides",e,t,n),a=fF("pad",e,t,n),s=fF("kernelSize",e,t,n),i=fF("includeBatchInIndex",e,t,n),{result:o,indexes:l}=yf(fF("x",e,t,n),[s[1],s[2]],[r[1],r[2]],a,i);return[o,l]}case"AvgPool3D":{let r=fF("strides",e,t,n),a=fF("pad",e,t,n),s=fF("kernelSize",e,t,n);return[jp(fF("x",e,t,n),[s[1],s[2],s[3]],[r[1],r[2],r[3]],a)]}case"MaxPool3D":{let r=fF("strides",e,t,n),a=fF("pad",e,t,n),s=fF("kernelSize",e,t,n);return[mf(fF("x",e,t,n),[s[1],s[2],s[3]],[r[1],r[2],r[3]],a)]}case"Dilation2D":{let r=fF("strides",e,t,n),a=fF("pad",e,t,n),s=fF("dilations",e,t,n),i=r[1],o=r[2],l=s[1],u=s[2];return[uc(fF("x",e,t,n),fF("filter",e,t,n),[i,o],a,[l,u],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},PR=(e,t,n)=>{switch(e.op){case"Fill":{let r=fF("shape",e,t,n),a=fF("dtype",e,t,n),s=fF("value",e,t,n);return[lh(r,s,a)]}case"LinSpace":{let r=fF("start",e,t,n),a=fF("stop",e,t,n),s=fF("num",e,t,n);return[Eh(r,a,s)]}case"Multinomial":{let r=fF("logits",e,t,n),a=fF("numSamples",e,t,n),s=fF("seed",e,t,n);return[Of(r,a,s)]}case"OneHot":{let r=fF("indices",e,t,n),a=fF("depth",e,t,n),s=fF("onValue",e,t,n),i=fF("offValue",e,t,n);return[sl(r,a,s,i)]}case"Ones":return[If(fF("shape",e,t,n),fF("dtype",e,t,n))];case"OnesLike":return[Bf(fF("x",e,t,n))];case"RandomUniform":return[xm(fF("shape",e,t,n),fF("minval",e,t,n),fF("maxval",e,t,n),fF("dtype",e,t,n))];case"Range":{let r=fF("start",e,t,n),a=fF("stop",e,t,n),s=fF("step",e,t,n);return[vm(r,a,s,fF("dtype",e,t,n))]}case"TruncatedNormal":{let r=fF("shape",e,t,n),a=fF("mean",e,t,n),s=fF("stdDev",e,t,n),i=fF("seed",e,t,n);return[Bg(r,a,s,fF("dtype",e,t,n),i)]}case"Zeros":return[kf(fF("shape",e,t,n),fF("dtype",e,t,n))];case"ZerosLike":return[mc(fF("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function zR(e,t,n){let r=fF("boxes",e,t,n),a=fF("scores",e,t,n),s=fF("maxOutputSize",e,t,n),i=fF("iouThreshold",e,t,n),o=fF("scoreThreshold",e,t,n),l=fF("softNmsSigma",e,t,n);return{boxes:r,scores:a,maxOutputSize:s,iouThreshold:i,scoreThreshold:o,softNmsSigma:l}}var BR=async(e,t,n)=>{switch(e.op){case"NonMaxSuppressionV5":{let{boxes:r,scores:a,maxOutputSize:s,iouThreshold:i,scoreThreshold:o,softNmsSigma:l}=zR(e,t,n),u=await bw.nonMaxSuppressionWithScoreAsync(r,a,s,i,o,l);return[u.selectedIndices,u.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:r,scores:a,maxOutputSize:s,iouThreshold:i,scoreThreshold:o}=zR(e,t,n),l=fF("padToMaxOutputSize",e,t,n),u=await bw.nonMaxSuppressionPaddedAsync(r,a,s,i,o,l);return[u.selectedIndices,u.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:r,scores:a,maxOutputSize:s,iouThreshold:i,scoreThreshold:o}=zR(e,t,n);return[await bw.nonMaxSuppressionAsync(r,a,s,i,o)]}case"Where":{let r=vo(fF("condition",e,t,n),"bool"),a=[await Zg(r)];return r.dispose(),a}case"ListDiff":return qm(fF("x",e,t,n),fF("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}},WR=(e,t,n)=>{switch(e.op){case"LowerBound":{let r=fF("sortedSequence",e,t,n),a=fF("values",e,t,n);return[df(r,a)]}case"TopKV2":{let r=fF("x",e,t,n),a=fF("k",e,t,n),s=fF("sorted",e,t,n),i=Pg(r,a,s);return[i.values,i.indices]}case"UpperBound":{let r=fF("sortedSequence",e,t,n),a=fF("values",e,t,n);return[qg(r,a)]}case"Unique":{let r=fF("x",e,t,n),a=Vg(r);return[a.values,a.indices]}case"UniqueV2":{let r=fF("x",e,t,n),a=fF("axis",e,t,n),s=Vg(r,a);return[s.values,s.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},VR=(e,t,n)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let r=fF("default",e,t,n);return[mF(e.name,t,n)||r];case"Placeholder":return[mF(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let r=fF("x",e,t,n);return[vF(r)]}case"IdentityN":return fF("x",e,t,n).map((e=>vF(e)));case"Snapshot":let a=fF("x",e,t,n);return[vF(a)];case"Shape":return[Fg(fF("x",e,t,n).shape,"int32")];case"ShapeN":return fF("x",e,t,n).map((e=>Fg(e.shape)));case"Size":return[Bc(fF("x",e,t,n).size,"int32")];case"Rank":return[Bc(fF("x",e,t,n).rank,"int32")];case"NoOp":return[Bc(1)];case"Print":let s=fF("x",e,t,n),i=fF("data",e,t,n),o=fF("message",e,t,n),l=fF("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(let e=0;e<i.length;e++)console.log(Array.prototype.slice.call(i[e].dataSync()).slice(0,l));return[s];default:throw TypeError(`Node type ${e.op} is not implemented`)}},UR=class{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=Bc(0),this.tensorMap=new Map,gl(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Bc(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),fl((()=>{let e=jg(t),r=n.length,a=e.length;Aa.assert(r===a,(()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${a} elements.`));for(let t=0;t<r;t++){let r=n[t],a=e[t];gl(a),this.tensorMap.set(r,a)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return fl((()=>{let e=[];for(let r=0;r<n.length;r++){let a=n[r],s=this.findWithDefault(a,t);e.push(s)}return Ng(e)}))}findWithDefault(e,t){let n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}},GR=async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{let a=fF("keyDType",e,t,n),s=fF("valueDType",e,t,n),i=new UR(a,s);return r.addHashTable(e.name,i),[i.handle]}case"LookupTableImport":case"LookupTableImportV2":{let a=fF("tableHandle",e,t,n,r),s=fF("keys",e,t,n),i=fF("values",e,t,n);return[await r.getHashTableById(a.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let a=fF("tableHandle",e,t,n,r),s=fF("keys",e,t,n),i=fF("defaultValue",e,t,n);return[await r.getHashTableById(a.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let a=fF("tableHandle",e,t,n,r);return[r.getHashTableById(a.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},HR=(e,t,n)=>{switch(e.op){case"ResizeBilinear":{let r=fF("images",e,t,n),a=fF("size",e,t,n),s=fF("alignCorners",e,t,n),i=fF("halfPixelCenters",e,t,n);return[bw.resizeBilinear(r,[a[0],a[1]],s,i)]}case"ResizeNearestNeighbor":{let r=fF("images",e,t,n),a=fF("size",e,t,n),s=fF("alignCorners",e,t,n),i=fF("halfPixelCenters",e,t,n);return[bw.resizeNearestNeighbor(r,[a[0],a[1]],s,i)]}case"CropAndResize":{let r=fF("image",e,t,n),a=fF("boxes",e,t,n),s=fF("boxInd",e,t,n),i=fF("cropSize",e,t,n),o=fF("method",e,t,n),l=fF("extrapolationValue",e,t,n);return[bw.cropAndResize(r,a,s,i,o,l)]}case"ImageProjectiveTransformV3":{let r=fF("images",e,t,n),a=fF("transforms",e,t,n),s=fF("outputShape",e,t,n),i=fF("fillValue",e,t,n),o=fF("interpolation",e,t,n),l=fF("fillMode",e,t,n);return[bw.transform(r,a,o.toLowerCase(),l.toLowerCase(),i,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},jR=(e,t,n)=>{switch(e.op){case"Equal":return[dc(fF("a",e,t,n),fF("b",e,t,n))];case"NotEqual":return[Pf(fF("a",e,t,n),fF("b",e,t,n))];case"Greater":return[fh(fF("a",e,t,n),fF("b",e,t,n))];case"GreaterEqual":return[gh(fF("a",e,t,n),fF("b",e,t,n))];case"Less":return[Th(fF("a",e,t,n),fF("b",e,t,n))];case"LessEqual":return[_h(fF("a",e,t,n),fF("b",e,t,n))];case"LogicalAnd":return[ef(fF("a",e,t,n),fF("b",e,t,n))];case"LogicalNot":return[nf(fF("a",e,t,n))];case"LogicalOr":return[af(fF("a",e,t,n),fF("b",e,t,n))];case"Select":case"SelectV2":return[hc(fF("condition",e,t,n),fF("a",e,t,n),fF("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},qR=(e,t,n)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[rl(fF("a",e,t,n),fF("b",e,t,n),fF("transposeA",e,t,n),fF("transposeB",e,t,n))];case"Einsum":return[vc(fF("equation",e,t,n),...fF("tensors",e,t,n))];case"Transpose":return[Dl(fF("x",e,t,n),fF("perm",e,t,n))];case"_FusedMatMul":let[r,a]=fF("fusedOps",e,t,n),s="biasadd"===r,i="prelu"===a,o=fF("numArgs",e,t,n),l=fF("leakyreluAlpha",e,t,n);if(s){if(i&&2!==o)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&1!==o)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[u,p]=fF("args",e,t,n);return[gy.matMul({a:fF("a",e,t,n),b:fF("b",e,t,n),transposeA:fF("transposeA",e,t,n),transposeB:fF("transposeB",e,t,n),bias:u,activation:a,preluActivationWeights:p,leakyreluAlpha:l})];default:throw TypeError(`Node type ${e.op} is not implemented`)}},KR=(e,t,n)=>{switch(e.op){case"EuclideanNorm":return[Zc(fF("x",e,t,n),fF("axis",e,t,n),fF("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[od(fF("x",e,t,n),fF("mean",e,t,n),fF("variance",e,t,n),fF("offset",e,t,n),fF("scale",e,t,n),fF("epsilon",e,t,n))];case"FusedBatchNormV3":return[od(fF("x",e,t,n),fF("mean",e,t,n),fF("variance",e,t,n),fF("offset",e,t,n),fF("scale",e,t,n),fF("epsilon",e,t,n))];case"LRN":return[$h(fF("x",e,t,n),fF("radius",e,t,n),fF("bias",e,t,n),fF("alpha",e,t,n),fF("beta",e,t,n))];case"Softmax":return[ug(fF("x",e,t,n))];case"LogSoftmax":return[Yh(fF("x",e,t,n))];case"SparseToDense":return[iy(fF("sparseIndices",e,t,n),fF("outputShape",e,t,n),fF("sparseValues",e,t,n),fF("defaultValue",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},XR=(e,t,n)=>{switch(e.op){case"Max":{let r=fF("axis",e,t,n),a=fF("keepDims",e,t,n);return[Mc(fF("x",e,t,n),r,a)]}case"Mean":{let r=fF("axis",e,t,n),a=fF("keepDims",e,t,n);return[vf(fF("x",e,t,n),r,a)]}case"Min":{let r=fF("axis",e,t,n),a=fF("keepDims",e,t,n);return[Lc(fF("x",e,t,n),r,a)]}case"Sum":{let r=fF("axis",e,t,n),a=fF("keepDims",e,t,n);return[jc(fF("x",e,t,n),r,a)]}case"All":{let r=fF("axis",e,t,n),a=fF("keepDims",e,t,n);return[ip(fF("x",e,t,n),r,a)]}case"Any":{let r=fF("axis",e,t,n),a=fF("keepDims",e,t,n);return[lp(fF("x",e,t,n),r,a)]}case"ArgMax":{let r=fF("axis",e,t,n);return[pp(fF("x",e,t,n),r)]}case"ArgMin":{let r=fF("axis",e,t,n);return[cp(fF("x",e,t,n),r)]}case"Prod":{let r=fF("axis",e,t,n),a=fF("keepDims",e,t,n);return[lm(fF("x",e,t,n),r,a)]}case"Cumprod":{let r=fF("axis",e,t,n),a=fF("exclusive",e,t,n),s=fF("reverse",e,t,n);return[Zd(fF("x",e,t,n),r,a,s)]}case"Cumsum":{let r=fF("axis",e,t,n),a=fF("exclusive",e,t,n),s=fF("reverse",e,t,n);return[Qd(fF("x",e,t,n),r,a,s)]}case"Bincount":let r=fF("x",e,t,n),a=fF("weights",e,t,n),s=fF("size",e,t,n);return[md(r,a,s)];case"DenseBincount":{let r=fF("x",e,t,n),a=fF("weights",e,t,n),s=fF("size",e,t,n),i=fF("binaryOutput",e,t,n);return[tc(r,a,s,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},YR=(e,t,n)=>{switch(e.op){case"ConcatV2":case"Concat":{let r=fF("n",e,t,n),a=fF("axis",e,t,n),s=fF("tensors",e,t,n);return s=s.slice(0,r),[Kp(s,a)]}case"Gather":{let r=fF("x",e,t,n),a=fF("indices",e,t,n);return[ch(r,vo(a,"int32"),0)]}case"GatherV2":{let r=fF("axis",e,t,n),a=fF("batchDims",e,t,n),s=fF("x",e,t,n),i=fF("indices",e,t,n);return[ch(s,vo(i,"int32"),r,a)]}case"Reverse":{let r=fF("dims",e,t,n),a=[];for(let e=0;e<r.length;e++)r[e]&&a.push(e);let s=fF("x",e,t,n);return[Em(s,a)]}case"ReverseV2":{let r=fF("axis",e,t,n),a=fF("x",e,t,n);return[Em(a,r)]}case"Slice":{let r=fF("begin",e,t,n),a=fF("size",e,t,n);return[Jp(fF("x",e,t,n),r,a)]}case"StridedSlice":{let r=fF("begin",e,t,n),a=fF("end",e,t,n),s=fF("strides",e,t,n),i=fF("beginMask",e,t,n),o=fF("endMask",e,t,n),l=fF("ellipsisMask",e,t,n),u=fF("newAxisMask",e,t,n),p=fF("shrinkAxisMask",e,t,n),d=fF("x",e,t,n);return[Eg(d,r,a,s,i,o,l,u,p)]}case"Pack":return fl((()=>{let r=fF("axis",e,t,n),a=fF("tensors",e,t,n),s=a[0].shape,i=Ig(a[0]).shape,o=a.map((e=>{let t=Aa.arraysEqual(e.shape,s);if(!t&&!Aa.arraysEqual(Ig(e).shape,i))throw new Error("the input tensors shape does not match");return t?e:Vp(e,s)}));return[Ng(o,r)]}));case"Unpack":{let r=fF("axis",e,t,n),a=fF("tensor",e,t,n);return jg(a,r)}case"Tile":{let r=fF("reps",e,t,n);return[sh(fF("x",e,t,n),r)]}case"Split":case"SplitV":{let r=fF("axis",e,t,n),a=fF("numOrSizeSplits",e,t,n),s=fF("x",e,t,n);return yg(s,a,r)}case"ScatterNd":{let r=fF("indices",e,t,n),a=fF("values",e,t,n),s=fF("shape",e,t,n);return[ry(r,a,s)]}case"GatherNd":{let r=fF("x",e,t,n),a=fF("indices",e,t,n);return[ly(r,a)]}case"SparseToDense":{let r=fF("sparseIndices",e,t,n),a=fF("outputShape",e,t,n),s=fF("sparseValues",e,t,n),i=fF("defaultValue",e,t,n);return[iy(r,s,a,s.dtype===i.dtype?i:vo(i,s.dtype))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},ZR=(e,t,n)=>{switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:r,outputValues:a,emptyRowIndicator:s,reverseIndexMap:i}=vw.sparseFillEmptyRows(fF("indices",e,t,n),fF("values",e,t,n),fF("denseShape",e,t,n),fF("defaultValue",e,t,n));return[r,a,s,i]}case"SparseReshape":{let{outputIndices:r,outputShape:a}=vw.sparseReshape(fF("inputIndices",e,t,n),fF("inputShape",e,t,n),fF("newShape",e,t,n));return[r,a]}case"SparseSegmentMean":return[vw.sparseSegmentMean(fF("data",e,t,n),fF("indices",e,t,n),fF("segmentIds",e,t,n))];case"SparseSegmentSum":return[vw.sparseSegmentSum(fF("data",e,t,n),fF("indices",e,t,n),fF("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},JR=(e,t,n)=>{switch(e.op){case"FFT":return[dg(fF("x",e,t,n))];case"IFFT":return[hg(fF("x",e,t,n))];case"RFFT":return[wg(fF("x",e,t,n))];case"IRFFT":return[mg(fF("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},QR=(e,t,n)=>{switch(e.op){case"StringNGrams":{let{nGrams:r,nGramsSplits:a}=kw.stringNGrams(fF("data",e,t,n),fF("dataSplits",e,t,n),fF("separator",e,t,n),fF("nGramWidths",e,t,n),fF("leftPad",e,t,n),fF("rightPad",e,t,n),fF("padWidth",e,t,n),fF("preserveShortSequences",e,t,n));return[r,a]}case"StringSplit":{let{indices:r,values:a,shape:s}=kw.stringSplit(fF("input",e,t,n),fF("delimiter",e,t,n),fF("skipEmpty",e,t,n));return[r,a,s]}case"StringToHashBucketFast":return[kw.stringToHashBucketFast(fF("input",e,t,n),fF("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},eD=(e,t,n)=>{switch(e.op){case"Cast":return[vo(fF("x",e,t,n),fF("dtype",e,t,n))];case"ExpandDims":{let r=fF("axis",e,t,n);return[th(fF("x",e,t,n),r)]}case"Squeeze":{let r=fF("axis",e,t,n);return[Ig(fF("x",e,t,n),r)]}case"Reshape":return[Vp(fF("x",e,t,n),fF("shape",e,t,n))];case"MirrorPad":return[_f(fF("x",e,t,n),fF("padding",e,t,n),fF("mode",e,t,n))];case"PadV2":case"Pad":return[Gf(fF("x",e,t,n),fF("padding",e,t,n),fF("constantValue",e,t,n))];case"SpaceToBatchND":{let r=fF("blockShape",e,t,n),a=fF("paddings",e,t,n);return[em(fF("x",e,t,n),r,a)]}case"BatchToSpaceND":{let r=fF("blockShape",e,t,n),a=fF("crops",e,t,n);return[ad(fF("x",e,t,n),r,a)]}case"DepthToSpace":{let r=fF("blockSize",e,t,n),a=fF("dataFormat",e,t,n).toUpperCase();return[rc(fF("x",e,t,n),r,a)]}case"BroadcastTo":return[wd(fF("x",e,t,n),fF("shape",e,t,n))];case"BroadcastArgs":return[yd(fF("s0",e,t,n),fF("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function tD(e,t,n,r){let a=((e,t,n)=>{switch(e.category){case"arithmetic":return fl((()=>IR(e,t,n)));case"basic_math":return fl((()=>SR(e,t,n)));case"control":return MR(e,t,n);case"convolution":return fl((()=>LR(e,t,n)));case"creation":return fl((()=>PR(e,t,n)));case"dynamic":return BR(e,t,n);case"evaluation":return fl((()=>WR(e,t,n)));case"image":return fl((()=>HR(e,t,n)));case"graph":return fl((()=>VR(e,t,n)));case"logical":return fl((()=>jR(e,t,n)));case"matrices":return fl((()=>qR(e,t,n)));case"normalization":return fl((()=>KR(e,t,n)));case"reduction":return fl((()=>XR(e,t,n)));case"slice_join":return fl((()=>YR(e,t,n)));case"sparse":return fl((()=>ZR(e,t,n)));case"spectral":return fl((()=>JR(e,t,n)));case"string":return fl((()=>QR(e,t,n)));case"transformation":return fl((()=>eD(e,t,n)));case"hash_table":return GR(e,t,n,r);case"custom":let a=cF(e.op);if(a&&a.customExecutor)return a.customExecutor(new kR(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return Aa.isPromise(a)?a.then((e=>[].concat(e))):[].concat(a)}var nD=class{constructor(e={},t={},n={},r={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function rD(e,t,n,r){let a=new Set,s=[],i=null,o=null,l=new Set,u=Object.keys(e).map((e=>wF(e)[0])),p=[];null!=r&&(p=r.map((e=>wF(e.name)[0])));let d=[...t];for(;d.length>0;){let e=d.pop();if((lD(e)||uD(e)||pD(e))&&null==i&&(i=e,o=i.children.map((e=>e.name)).filter((e=>a.has(e)))),a.add(e.name),null==n[e.name]&&-1===u.indexOf(e.name)&&-1===p.indexOf(e.name)){if(0===e.inputs.length){s.push(e.name);continue}e.inputs.forEach((e=>{l.has(e.name)||(l.add(e.name),d.push(e))}))}}return{inputs:e,outputs:t,usedNodes:a,missingInputs:s,dynamicNode:i,syncInputs:o}}function aD(e,t,n){let{usedNodes:r,inputs:a}=n,s=[],i=Object.keys(a).map((e=>wF(e)[0])).map((t=>e.nodes[t])),o=e.initNodes;i.forEach((e=>{r.has(e.name)&&s.push(e)})),e.weights.forEach((e=>{r.has(e.name)&&s.push(e)})),null!=o&&o.forEach((e=>{r.has(e.name)&&s.push(e)}));let l=new Set,u=[];for(;s.length>0;){let e=s.pop();l.add(e.name),t[e.name]||u.push(e),e.children.forEach((e=>{!l.has(e.name)&&r.has(e.name)&&e.inputs.every((e=>l.has(e.name)))&&s.push(e)}))}return u}var sD=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],iD=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],oD=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function lD(e){return sD.indexOf(e.op)>=0}function uD(e){return iD.indexOf(e.op)>=0}function pD(e){return oD.indexOf(e.op)>=0}var dD=class{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new dD(e.functions[t],this)}))}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){let t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{let t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}getCompilationKey(e,t){let n=e.map((e=>e.name)).sort(),r=t.map((e=>e.name)).sort();return n.join(this.SEPERATOR)+"--"+r.join(this.SEPERATOR)}compile(e,t){let n=rD(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:a,syncInputs:s}=n;if(null!=a)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${s}]`);if(r.length>0){let n=t.map((e=>e.name)),a=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${a}]. Missing the following inputs: [${r}]`)}return aD(this.graph,this.weightMap,n)}execute(e,t){e=this.mapInputs(e);let n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);let r=n.map((e=>this.graph.nodes[wF(e)[0]])),a=t.map((e=>wF(e)[0])),s=a.map((e=>this.graph.nodes[e]));this.resetIntermediateTensors(),0===s.length&&(s=this._outputs);let i=this.getCompilationKey(r,s),o=this.compiledMap.get(i);null==o&&(o=this.compile(e,s),this.compiledMap.set(i,o));let l={},u={};return fl((()=>{let n=new nD(this.weightMap,l,u,this.functionExecutorMap),r=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{let[n,a]=wF(t),s=[];s[a]=e[t],r[n]=s}));let s=this.getFrozenTensorIds(r),i={};for(let e=0;e<o.length;e++){let t=o[e];if(!r[t.name]){let e=tD(t,r,n,this._resourceManager);if(Aa.isPromise(e))throw new Error(`The execution of the op '${t.op}' returned a promise. Please use model.executeAsync() instead.`);r[t.name]=e,this.checkTensorForDisposal(t.name,t,r,n,s,a,i)}}return null==this.parent&&n.dispose(s),t.map((e=>mF(e,r,n)))}))}getFrozenTensorIds(e){let t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,r,a,s,i){"control"===t.category||-1!==s.indexOf(e)||(n[e].forEach((e=>{null!=e&&(i[e.id]=(i[e.id]||0)+t.children.length)})),t.inputs.forEach((e=>{if("control"!==e.category){let s=gF(e.name,n,r);null!=s&&s.forEach((e=>{if(e&&!e.kept&&!a.has(e.id)){let n=i[e.id];if(1===n){if(this.keepTensorForDebug){let[n,a]=yF(t.name,r);this.intermediateTensors[n]||(this.intermediateTensors[n]=[]),this.intermediateTensors[n][a]=e}else e.dispose();delete i[e.id]}else null!=n&&i[e.id]--}}))}})))}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){!this.intermediateTensors||(Object.keys(this.intermediateTensors).forEach((e=>this.intermediateTensors[e].forEach((e=>e.dispose())))),this.disposeTensorsMap())}disposeTensorsMap(){!this.tensorsMap||Object.keys(this.tensorsMap).forEach((e=>{this.tensorsMap[e].forEach((e=>{e&&!e.kept&&!e.isDisposed&&!this.keepIds.has(e.id)&&e.dispose()}))}))}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(let e in this.intermediateTensors)this.intermediateTensors[e].forEach((e=>e.dispose())),delete this.intermediateTensors[e]}async _executeAsync(e,t,n=!1,r={},a={}){n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepTensorForDebug=et().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(u){console.warn(u.message)}this.resetIntermediateTensors();let s=new nD(this.weightMap,r,a,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(e,s,t,n);let i=t.map((e=>mF(e,this.tensorsMap,s))),o=i.map((e=>e.id)),l=Object.keys(e).map((t=>e[t].id));return this.keepIds=new Set([...o,...l,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),null==this.parent&&s.dispose(this.keepIds),i}async executeFunctionAsync(e,t,n){let r=e.reduce(((e,t,n)=>(e[this.inputs[n].name]=t,e)),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){let a=Object.keys(e),s=a.map((e=>this.graph.nodes[wF(e)[0]])),i=n.map((e=>wF(e)[0])),o=i.map((e=>this.graph.nodes[e]));0===o.length&&(o=this._outputs);let{usedNodes:l,missingInputs:u,dynamicNode:p,syncInputs:d}=rD(e,o,this.weightMap,this._initNodes),c=[...s,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),h=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{let[n,r]=wF(t),a=[];a[r]=e[t],h[n]=a}));let f={},m=this.getFrozenTensorIds(h),g={};for(;c.length>0;){let e=this.processStack(s,c,t,h,g,m,i,f,l);await Promise.all(e)}null==p&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let y=o.filter((e=>!lD(e)&&!mF(e.name,h,t))).map((e=>e.name));if(y.length>0){let e="";throw null!=p&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${y}] from the provided inputs [${a}]. Consider providing the following inputs: [${u}]. ${e}`)}return h}processStack(e,t,n,r,a,s,i,o,l){let u=[];for(;t.length>0;){let e=t.pop();n.currentContext=e.contexts;let p="";if("Enter"===e.node.op&&fF("isConstant",e.node,r,n)&&([p]=yF(e.node.name,n)),null==r[e.node.name]){let d=tD(e.node,r,n,this._resourceManager);p||([p]=yF(e.node.name,n));let c=n.currentContext;Aa.isPromise(d)?u.push(d.then((u=>(r[p]=u,n.currentContext=c,this.checkTensorForDisposal(p,e.node,r,n,s,i,o),this.processChildNodes(e.node,t,n,r,a,l),u)))):(r[p]=d,this.checkTensorForDisposal(p,e.node,r,n,s,i,o),this.processChildNodes(e.node,t,n,r,a,l))}else this.processChildNodes(e.node,t,n,r,a,l)}return u}processChildNodes(e,t,n,r,a,s){e.children.forEach((e=>{let[i]=yF(e.name,n);a[i]||!s.has(e.name)||("Merge"===e.op?e.inputNames.some((e=>!!mF(e,r,n)))&&(a[i]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!mF(e,r,n)))&&(a[i]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{let n=e[t],[r]=wF(t),a=this.graph.nodes[r];if(a.attrParams.shape&&a.attrParams.shape.value){let e=a.attrParams.shape.value,t=e.length===n.shape.length&&n.shape.every(((t,n)=>-1===e[n]||e[n]===t));Aa.assert(t,(()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`))}a.attrParams.dtype&&a.attrParams.dtype.value&&Aa.assert(n.dtype===a.attrParams.dtype.value,(()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${n.dtype}`))}))}mapInputs(e){let t={};for(let n in e)if(null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[n]){let r=this._signature.inputs[n];t[r.name]=e[n]}else t[n]=e[n];return t}checkInputs(e){let t=Object.keys(e).filter((e=>{let[t]=wF(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map((e=>null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[e]?this._signature.outputs[e].name:e),{})}checkOutputs(e){e.forEach((e=>{let[t]=wF(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)}))}},cD=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}},hD="?tfjs-format=file",fD="model.json",mD=class{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",null==t&&(this.loadOptions={}),this.resourceManager=new cD}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){let e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=To.browserHTTPRequest(e,this.loadOptions);else{let t=To.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(To.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return Aa.isPromise(e)?e.then((e=>this.loadSync(e))):this.loadSync(e)}loadSync(e){this.artifacts=e;let t,n=this.artifacts.modelTopology;t=null!=this.artifacts.userDefinedMetadata&&null!=this.artifacts.userDefinedMetadata.signature?this.artifacts.userDefinedMetadata.signature:this.artifacts.signature,this.signature=t,this.version=`${n.versions.producer}.${n.versions.minConsumer}`;let r=To.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new dD(iR.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){let t=iR.Instance.transformGraph(e.modelInitializer);this.initializer=new dD(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if("string"==typeof e){let t=To.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof ks)&&!Array.isArray(e))return e;if(e=Array.isArray(e)?e:[e],e.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce(((t,n,r)=>(t[n]=e[r],t)),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>(t[n]=[e[n]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}};async function gD(e,t={}){if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof e&&(e=bD(e));let n=new mD(e,t);return await n.load(),n}function yD(e){if(null==e)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide a url or an IOHandler that loads the model");if(!e.load)throw new Error(`modelUrl IO Handler ${e} has no load function`);let t=new mD(e);return t.load(),t}function bD(e){return e.endsWith("/")||(e+="/"),`${e}${fD}${hD}`}var wD="3.18.0",xD={};v(xD,{CSVDataset:()=>yM,Dataset:()=>aM,FileDataSource:()=>$M,TextLineDataset:()=>pM,URLDataSource:()=>FM,array:()=>iM,csv:()=>RM,func:()=>DM,generator:()=>MM,microphone:()=>LM,version_data:()=>PM,webcam:()=>OM,zip:()=>oM});var vD=I(U()),kD=I(U());function ID(e,t){return SD(e,t)}function SD(e,t,n=new Map,r=new Set){if(null==e)return null;if("function"==typeof Blob&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);let a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(a.recurse){if(ED(e)){let a=Array.isArray(e)?[]:{};r.add(e);for(let s in e){let i=e[s],o=SD(i,t,n,r);a[s]=o}return r.delete(e),e.__proto__&&(a.__proto__=e.__proto__),a}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,a.value),a.value}function ND(e,t=CD){return TD(e,t)}function TD(e,t,n=new Set){let r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");let a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(a.recurse){if(ED(r)){let a=Array.isArray(r)?[]:{};n.add(r);for(let s in r){let r=e.map((e=>e[s])),i=TD(r,t,n);a[s]=i}return n.delete(r),a}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return a.value}function CD(e){return null===e?null:ED(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function _D(e,t){let n=new Map;SD(e,t,n);for(let r of Array.from(n.keys())){let e=n.get(r);if(Aa.isPromise(e)){let t=await e;n.set(r,t)}}return SD(e,t,n)}function ED(e){let t=!1;if(et().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=G();t=e instanceof n}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"==typeof e&&!(e instanceof ks)&&!(e instanceof Promise)&&!t)}function AD(e){return null==e||$D(e)||Array.isArray(e)||"object"==typeof e&&e instanceof ks||Aa.isTypedArray(e)}function $D(e){return null===e||"object"!=typeof e&&"function"!=typeof e}function FD(e){return ID(e,RD)}function RD(e){return e instanceof ks?{value:e.clone(),recurse:!1}:ED(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var DD=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},MD=class extends DD{constructor(){super(MD.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){let e=2*this.capacity,t=new Array(e),n=this.length();for(let r=0;r<n;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}};function OD(e){return new VD(e)}function LD(e){return new UD(e)}function PD(e,t){return new eM(e,t)}function zD(e,t=BD.FAIL){return new tM(e,t)}MD.INITIAL_CAPACITY=32;var BD,WD=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new YD(this,e)}filter(e){return new KD(this,e)}map(e){return new XD(this,e)}mapAsync(e){return new ZD(this,e)}serialMapAsync(e){return new ZD(this,e).serial()}flatmap(e){return new QD(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e,t=!0){return new qD(this,e,t)}columnMajorBatch(e,t=!0,n=CD){return this.rowMajorBatch(e,t).map((e=>ND(e,n)))}concatenate(e,t){return new eM(OD([this,e]),t)}take(e){return e<0||null==e?this:new jD(this,e)}skip(e){return e<0||null==e?this:new HD(this,e)}prefetch(e){return new nM(this,e)}shuffle(e,t){return new rM(this,e,t)}serial(){return new GD(this)}},VD=class extends WD{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:FD(e),done:!1}}},UD=class extends WD{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(pae){throw pae.message=`Error thrown while iterating through a dataset: ${pae.message}`,pae}}},GD=class extends WD{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}},HD=class extends WD{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;ml(e.value)}return this.upstream.next()}},jD=class extends WD{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},qD=class extends WD{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},KD=class extends WD{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;ml(e.value)}}},XD=class extends WD{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=As.getTensorsInContainer(e.value),n=this.transform(e.value),r=As.getTensorsInContainer(n);for(let a of t)As.isTensorInList(a,r)||a.dispose();return{value:n,done:!1}}},YD=class extends WD{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(pae){if(!this.handler(pae))return{value:null,done:!0}}}},ZD=class extends WD{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=As.getTensorsInContainer(e.value),n=await this.transform(e.value),r=As.getTensorsInContainer(n);for(let a of t)As.isTensorInList(a,r)||a.dispose();return{value:n,done:!1}}},JD=class extends WD{constructor(){super(),this.outputQueue=new MD,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},QD=class extends JD{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=As.getTensorsInContainer(e.value),n=this.transform(e.value),r=As.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let a of t)As.isTensorInList(a,r)||a.dispose();return!0}},eM=class extends WD{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){let e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}};(function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"})(BD||(BD={}));var tM=class extends WD{constructor(e,t=BD.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;function r(e){return e instanceof WD?{value:e.next().then((e=>(t++,e.done&&n++,e.value))),recurse:!1}:{value:null,recurse:!0}}let a=await _D(this.iterators,r);if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case BD.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case BD.SHORTEST:return{value:null,done:!0};case BD.LONGEST:default:}return this.count++,{value:a,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},nM=class extends WD{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new DD(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},rM=class extends nM{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=kD.alea(n||Aa.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}},aM=class{constructor(){this.size=null}batch(e,t=!0){let n,r=this;return Aa.assert(e>0,(()=>`batchSize needs to be positive, but it is\n      ${e}`)),n=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),sM((async()=>(await r.iterator()).columnMajorBatch(e,t,lM)),n)}concatenate(e){let t,n=this;return t=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,sM((async()=>(await n.iterator()).concatenate(await e.iterator())),t)}filter(e){let t,n=this;return t=this.size===1/0?1/0:null,sM((async()=>(await n.iterator()).filter((t=>fl((()=>e(t)))))),t)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return sM((async()=>(await t.iterator()).map((t=>fl((()=>e(t)))))),this.size)}mapAsync(e){let t=this;return sM((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return sM((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){let t,n=this;return t=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,sM((async()=>{let t=LD((async()=>({value:await n.iterator(),done:!1})));return PD(t.take(e))}),t)}skip(e){let t,n=this;return t=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,sM((async()=>(await n.iterator()).skip(e)),t)}shuffle(e,t,n=!0){if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let r=this,a=vD.alea(t||Aa.now().toString());return sM((async()=>{let t=a.int32();return n&&(t+=a.int32()),(await r.iterator()).shuffle(e,t.toString())}),this.size)}take(e){let t,n=this;return t=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,sM((async()=>(await n.iterator()).take(e)),t)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};function sM(e,t=null){return new class extends aM{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function iM(e){return sM((async()=>OD(e)),e.length)}function oM(e){if(!ED(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=null==t?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=null==t?e[n].size:Math.min(t,e[n].size);return sM((async()=>{let t=await _D(e,(e=>{if(e instanceof aM)return{value:e.iterator(),recurse:!1};if(ED(e))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")}));return zD(t,BD.SHORTEST)}),t)}function lM(e){if(null===e)return null;let t=e[0];return AD(t)?{value:uM(e),recurse:!1}:{value:null,recurse:!0}}function uM(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof ks?Ng(e):pi(e)}aM.MAX_BUFFER_SIZE=1e4;var pM=class extends aM{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split("\n").map((e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e)))}},dM='"',cM=Symbol("out"),hM=Symbol("field"),fM=Symbol("quote"),mM=Symbol("quoteafterquote"),gM=Symbol("quoteinquote"),yM=class extends aM{constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new pM(e),t||(t={}),this.hasHeader=!1!==t.hasHeader,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(Aa.assert(null==t.delimiter,(()=>"Delimiter should not be provided when delimWhitespace is true.")),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&Aa.assert(e.length===this.fullColumnNames.length,(()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+").")),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce(((e,t)=>(e[t]=e[t]+1||1,e)),{}),n=Object.keys(t).filter((e=>t[e]>1));if(Aa.assert(0===n.length,(()=>"Duplicate column names found: "+n.toString())),this.columnConfigs)for(let r of Object.keys(this.columnConfigs))if(-1===this.fullColumnNames.indexOf(r))throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").");this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");let t=e.value;return this.parseRow(t,!1)}return null}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map((e=>this.makeDataElement(e)))}makeDataElement(e){let t=this.parseRow(e),n={},r={};for(let a=0;a<this.fullColumnNames.length;a++){let s=this.fullColumnNames[a],i=this.columnConfigs?this.columnConfigs[s]:null;if(!this.configuredColumnsOnly||i){let o=t[a],l=null;if(""===o)if(i&&void 0!==i.default)l=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${s} is empty in this line: ${e}`);l=void 0}else{let e=Number(o);if(isNaN(e))l=i&&"bool"===i.dtype?this.getBoolean(o):o;else if(i&&i.dtype)switch(i.dtype){case"float32":l=e;break;case"int32":l=Math.floor(e);break;case"bool":l=this.getBoolean(o);break;default:l=e}else l=e}i&&i.isLabel?r[s]=l:n[s]=l}}return 0===Object.keys(r).length?n:{xs:n,ys:r}}getBoolean(e){return"1"===e||"true"===e.toLowerCase()?1:0}parseRow(e,t=!0){let n=[],r=0,a=e.length,s=cM;for(let i=0;i<a;i++)switch(s){case cM:switch(e.charAt(i)){case dM:r=i+1,s=fM;break;case this.delimiter:if(r=i+1," "===this.delimiter&&this.delimWhitespace)break;n.push(""),s=cM;break;default:s=hM,r=i;break}break;case hM:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(r,i)),s=cM,r=i+1;break;default:}break;case fM:switch(e.charAt(i)){case dM:s=mM;break;default:}break;case mM:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(r,i-1)),s=cM,r=i+1;break;case dM:s=fM;break;default:s=gM;break}break;case gM:switch(e.charAt(i)){case dM:s=fM;break;default:}break;default:}if(s===mM?n.push(e.substring(r,a-1)):n.push(e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},bM=class extends WD{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;let t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=!1!==e.includeSpectrogram,this.includeWaveform=!0===e.includeWaveform,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!et().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let t=new bM(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:null==this.audioTrackConstraints||this.audioTrackConstraints,video:!1})}catch(n){throw new Error(`Error thrown while initializing video stream: ${n.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,this.sampleRateHz){if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`)}else this.sampleRateHz=this.audioContext.sampleRate;let t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t,n=await this.getAudioData();if(this.includeSpectrogram){let t=this.flattenQueue(n.freqDataQueue);e=this.getTensorFromAudioDataArray(t,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let e=this.flattenQueue(n.timeDataQueue);t=this.getTensorFromAudioDataArray(e,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let e=[],t=[],n=0;return new Promise((r=>{let a=setInterval((()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(a),r({freqDataQueue:e,timeDataQueue:t}))}),this.fftSize/this.sampleRateHz*1e3)}))}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){let t=e[0].length,n=new Float32Array(e.length*t);return e.forEach(((e,r)=>n.set(e,r*t))),n}getTensorFromAudioDataArray(e,t){let n=new Float32Array(Aa.sizeFromShape(t));return n.set(e,n.length-e.length),pi(n,t)}},wM=class extends WD{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Fg([0],"int32"),this.webcamConfig.centerCrop){let e=1*this.webcamConfig.resizeWidth/this.webcamVideoElement.width,t=1*this.webcamConfig.resizeHeight/this.webcamVideoElement.height,n=(1-e)/2,r=(1-t)/2,a=n+e,s=t+r;this.cropBox=Rg([r,n,s,a],[1,4])}else this.cropBox=Rg([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(!et().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}let n=new wM(e,t);return await n.start(),n}async start(){this.webcamConfig.facingMode&&Aa.assert("user"===this.webcamConfig.facingMode||"environment"===this.webcamConfig.facingMode,(()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`));try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(pae){throw pae.message=`Error thrown while initializing video stream: ${pae.message}`,pae}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(pae){console.log(pae),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise((e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}}))}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=Vl.fromPixels(this.webcamVideoElement)}catch(t){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(t)}`)}if(!this.resize)return{value:e,done:!1};try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(t){throw new Error(`Error thrown cropping the video: ${t.message}`)}finally{e.dispose()}}needToResize(){return!(!this.webcamConfig.resizeWidth||!this.webcamConfig.resizeHeight||this.webcamVideoElement.width===this.webcamConfig.resizeWidth&&this.webcamVideoElement.height===this.webcamConfig.resizeHeight)}cropAndResizeFrame(e){return fl((()=>{let t,n=th(vo(e,"float32"),0);t=bw.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let r=t.shape;return Vp(t,r.slice(1))}))}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach((e=>e.stop()));try{this.webcamVideoElement.srcObject=null}catch(pae){console.log(pae),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},xM=class{},vM=class extends WD{split(e){return new kM(this,e)}},kM=class extends vM{constructor(e,t){super(),this.upstream=e,this.impl=new IM(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},IM=class extends JD{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return""!==this.carryover&&(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}},SM=class extends WD{decodeUTF8(){return new NM(this)}},NM=class extends vM{constructor(e){super(),this.upstream=e,this.impl=new TM(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},TM=class extends JD{constructor(e){if(super(),this.upstream=e,et().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:e}=G();this.decoder=new e("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e,t,n=await this.upstream.next();return!n.done&&(e=n.value,t=et().get("IS_BROWSER")?this.decoder.decode(e,{stream:!0}):this.decoder.write(Buffer.from(e.buffer)),this.outputQueue.push(t),!0)}},CM=class extends SM{constructor(e,t={}){super(),this.file=e,this.options=t,Aa.assert(e instanceof Uint8Array||!!et().get("IS_BROWSER")&&(e instanceof File||e instanceof Blob),(()=>"FileChunkIterator only supports File, Blob and Uint8Array right now.")),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1048576}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise(((e,t)=>{let n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{let r=new FileReader;r.onload=n=>{let a=r.result;if(a instanceof ArrayBuffer&&(a=new Uint8Array(a)),!(a instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(a)},r.onabort=e=>t(new Error("Aborted")),r.onerror=e=>t(new Error(e.type));let a=this.file.slice(this.offset,n);r.readAsArrayBuffer(a)}this.offset=n})),done:!1}}};async function _M(e,t={},n){let r,a;"string"==typeof e?r=e:(r=e.url,a=EM(e));let s=await(n||Aa.fetch)(r,a);if(s.ok){let e=new Uint8Array(await s.arrayBuffer());return new CM(e,t)}throw new Error(s.statusText)}var EM=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function AM(e){return"string"==typeof e&&"file://"===e.slice(0,7)}var $M=class extends xM{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(AM(this.input)&&et().get("IS_NODE")){let e=H();this.input=e.readFileSync(this.input.slice(7))}return new CM(this.input,this.options)}},FM=class extends xM{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return AM(this.url)?new $M(this.url,this.fileOptions).iterator():_M(this.url,this.fileOptions)}};function RM(e,t={}){return new yM(new FM(e),t)}function DM(e){let t=LD(e);return sM((async()=>t))}function MM(e){return sM((async()=>{let t=await e();return LD((()=>t.next()))}))}async function OM(e,t){return wM.create(e,t)}async function LM(e){return bM.create(e)}var PM="3.18.0";function zM(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Aa.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}var BM=Lx.whereImpl,WM=class extends Q{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new J(this,dl())}nextDataId(){return WM.nextDataId++}write(e,t,n){this.firstUse&&(this.firstUse=!1,et().get("IS_NODE")&&Mw.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));let r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&Aa.isString(n[0])){let a=n.map((e=>Aa.encodeString(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){let t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){let t=this.data.get(e);t.refCount--}}move(e,t,n,r,a){this.data.set(e,{values:t,dtype:r,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){let{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){let e=this.readSync(n.real.dataId),t=this.readSync(n.imag.dataId);return Mw.mergeRealAndImagArrays(e,t)}return this.data.get(e).values}bufferSync(e){let t=this.readSync(e.dataId);if("string"===e.dtype)try{let n=t.map((e=>Aa.decodeString(e)));return wo(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return wo(e.shape,e.dtype,t)}makeOutput(e,t,n){return dl().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){let t=Aa.now();return e(),{kernelMs:Aa.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){zM([e],"where");let t=this.readSync(e.dataId);return BM(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};WM.nextDataId=0;var VM={};function UM(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}v(VM,{addImpl:()=>aO,bincountImpl:()=>lO,bincountReduceImpl:()=>uO,ceilImpl:()=>hO,concatImpl:()=>gO,equalImpl:()=>yO,expImpl:()=>xO,expm1Impl:()=>IO,floorImpl:()=>TO,gatherNdImpl:()=>EO,gatherV2Impl:()=>AO,greaterEqualImpl:()=>DO,greaterImpl:()=>$O,lessEqualImpl:()=>BO,lessImpl:()=>LO,linSpaceImpl:()=>UO,logImpl:()=>GO,maxImpl:()=>qO,maximumImpl:()=>KO,minimumImpl:()=>ZO,multiplyImpl:()=>eL,negImpl:()=>aL,notEqualImpl:()=>oL,prodImpl:()=>hL,rangeImpl:()=>gL,rsqrtImpl:()=>yL,scatterImpl:()=>xL,sigmoidImpl:()=>vL,simpleAbsImpl:()=>UM,sliceImpl:()=>SL,sparseFillEmptyRowsImpl:()=>CL,sparseReshapeImpl:()=>_L,sparseSegmentReductionImpl:()=>EL,sqrtImpl:()=>AL,squaredDifferenceImpl:()=>RL,stridedSliceImpl:()=>OL,stringNGramsImpl:()=>PL,stringSplitImpl:()=>BL,stringToHashBucketFastImpl:()=>WL,subImpl:()=>VL,tileImpl:()=>jL,topKImpl:()=>XL,transposeImpl:()=>pL,uniqueImpl:()=>YL});var GM=e=>{let{x:t}=e.inputs,n=e.backend;zM(t,"abs");let r=new Float32Array(Aa.sizeFromShape(t.shape)),a=n.data.get(t.dataId).values;return r=UM(a),n.makeOutput(r,t.shape,t.dtype)},HM={kernelName:ot,backendName:"cpu",kernelFunc:GM};function jM(e){return(t,n,r,a,s)=>{let i=Mw.assertAndGetBroadcastShape(t,n),o=i.length,l=Aa.computeStrides(i),u=Aa.sizeFromShape(i),p=Aa.getTypedArrayFromDType(s,u),d=t.length,c=n.length,h=Aa.computeStrides(t),f=Aa.computeStrides(n),m=Mw.getBroadcastDims(t,i),g=Mw.getBroadcastDims(n,i);if(m.length+g.length===0)for(let y=0;y<p.length;++y)p[y]=e(r[y%r.length],a[y%a.length]);else for(let y=0;y<p.length;++y){let t=Aa.indexToLoc(y,o,l),n=t.slice(-d);m.forEach((e=>n[e]=0));let s=Aa.locToIndex(n,d,h),i=t.slice(-c);g.forEach((e=>i[e]=0));let u=Aa.locToIndex(i,c,f);p[y]=e(r[s],a[u])}return[p,i]}}function qM(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=n.makeTensorInfo(r.shape,"complex64"),l=n.data.get(o.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",s),imag:n.makeTensorInfo(a.shape,"float32",i)},o}var KM={kernelName:Rt,backendName:"cpu",kernelFunc:qM};function XM(e,t,n="float32"){if("complex64"===n){let n=XM(e,t,"float32"),r=XM(e,t,"float32");return qM({inputs:{real:n,imag:r},backend:e})}let r=Aa.makeZerosTypedArray(Aa.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function YM(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var ZM={kernelName:kn,backendName:"cpu",kernelFunc:YM};function JM(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.real,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}var QM={kernelName:mr,backendName:"cpu",kernelFunc:JM};function eO(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if("complex64"===s){if("complex64"===a.dtype)return YM({inputs:{x:a},backend:n});let e=XM(n,a.shape,a.dtype),t=eO({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),r=qM({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===a.dtype){let e=JM({inputs:{input:a},backend:n}),t=eO({inputs:{x:e},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(e),t}if(!Aa.hasEncodingLoss(a.dtype,s)){let e=YM({inputs:{x:a},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}if("int32"===s){let e=n.data.get(a.dataId).values,t=Int32Array.from(e);return n.makeTensorInfo(a.shape,"int32",t)}if("bool"===s){let e=n.data.get(a.dataId).values,t=Aa.toTypedArray([0],a.dtype),[r,s]=jM(((e,t)=>e!==t?1:0))(a.shape,[],e,t,"bool");return n.makeTensorInfo(s,"bool",r)}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${s}`)}var tO={kernelName:At,backendName:"cpu",kernelFunc:eO};function nO(e,t,n,r){return null==n?({inputs:n,backend:a})=>{let{a:s,b:i}=n,o=a;zM([s,i],e);let l=o.data.get(s.dataId).values,u=o.data.get(i.dataId).values,p="string"===s.dtype?Mw.fromUint8ToStringArray(l):l,d="string"===s.dtype?Mw.fromUint8ToStringArray(u):u,c=r||s.dtype,[h,f]=t(s.shape,i.shape,p,d,c);return o.makeTensorInfo(f,c,h)}:({inputs:e,backend:a})=>{let{a:s,b:i}=e,o=a;if("complex64"===s.dtype||"complex64"===i.dtype){let e=eO({inputs:{x:s},backend:o,attrs:{dtype:"complex64"}}),t=o.data.get(e.dataId),r=t.complexTensorInfos.real,a=t.complexTensorInfos.imag,l=o.data.get(r.dataId).values,u=o.data.get(a.dataId).values,p=eO({inputs:{x:i},backend:o,attrs:{dtype:"complex64"}}),d=o.data.get(p.dataId),c=d.complexTensorInfos.real,h=d.complexTensorInfos.imag,f=o.data.get(c.dataId).values,m=o.data.get(h.dataId).values,[g,y,b]=n(s.shape,i.shape,l,u,f,m),w=o.makeTensorInfo(b,"float32",g),x=o.makeTensorInfo(b,"float32",y),v=qM({inputs:{real:w,imag:x},backend:o});return o.disposeIntermediateTensorInfo(e),o.disposeIntermediateTensorInfo(p),o.disposeIntermediateTensorInfo(w),o.disposeIntermediateTensorInfo(x),v}{let e=o.data.get(s.dataId).values,n=o.data.get(i.dataId).values,a=r||s.dtype,[l,u]=t(s.shape,i.shape,e,n,a);return o.makeTensorInfo(u,a,l)}}}function rO(e){return(t,n,r,a,s,i)=>{let o=Mw.assertAndGetBroadcastShape(t,n),l=Aa.sizeFromShape(o),u=o.length,p=Aa.computeStrides(o),d=Aa.getTypedArrayFromDType("float32",l),c=Aa.getTypedArrayFromDType("float32",l),h=Mw.getBroadcastDims(t,o),f=Mw.getBroadcastDims(n,o),m=Mw.mergeRealAndImagArrays(r,a),g=Mw.mergeRealAndImagArrays(s,i),y=t.length,b=Aa.computeStrides(t),w=n.length,x=Aa.computeStrides(n);if(h.length+f.length===0)for(let v=0;v<d.length;v++){let t=v%m.length,n=v%g.length,r=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);d[v]=r.real,c[v]=r.imag}else for(let v=0;v<d.length;v++){let t=Aa.indexToLoc(v,u,p),n=t.slice(-y);h.forEach((e=>n[e]=0));let r=Aa.locToIndex(n,y,b),a=t.slice(-w);f.forEach((e=>a[e]=0));let s=Aa.locToIndex(a,w,x),i=e(m[2*r],m[2*r+1],g[2*s],g[2*s+1]);d[v]=i.real,c[v]=i.imag}return[d,c,o]}}var aO=jM(((e,t)=>e+t)),sO=rO(((e,t,n,r)=>({real:e+n,imag:t+r}))),iO=nO(pt,aO,sO),oO={kernelName:pt,backendName:"cpu",kernelFunc:iO};function lO(e,t,n,r,a){let s=Aa.sizeFromShape(r),i=Aa.makeZerosTypedArray(a,n);for(let o=0;o<e.length;o++){let n=e[o];if(n<0)throw new Error("Input x must be non-negative!");n>=a||(i[n]+=s>0?t[o]:1)}return i}function uO(e,t,n,r=!1){let a=e.shape[0],s=e.shape[1],i=wo([a,n],t.dtype);for(let o=0;o<a;o++)for(let a=0;a<s;a++){let s=e.get(o,a);if(s<0)throw new Error("Input x must be non-negative!");s>=n||(r?i.set(1,o,s):t.size>0?i.set(i.get(o,s)+t.get(o,a),o,s):i.set(i.get(o,s)+1,o,s))}return i}function pO(e){return(t,n,r)=>{let a=Aa.getTypedArrayFromDType(n,t.length);for(let s=0;s<t.length;++s)a[s]=e(t[s],r);return a}}function dO(e,t,n){return({inputs:r,attrs:a,backend:s})=>{let{x:i}=r;if(zM(i,e),"string"===i.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");let o=s,l=o.data.get(i.dataId).values,u=Aa.sizeFromShape(i.shape),p=n||i.dtype,d=Aa.getArrayFromDType(p,u);for(let e=0;e<u;++e)d[e]=t(l[e],a);return o.makeTensorInfo(i.shape,p,d)}}function cO(e,t,n){return({inputs:r,attrs:a,backend:s})=>{let{x:i}=r;if(zM(i,e),"string"===i.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");let o=s,l=o.data.get(i.dataId).values,u=n||i.dtype,p=t(l,u,a);return o.makeTensorInfo(i.shape,u,p)}}var hO=pO((e=>Math.ceil(e))),fO=cO($t,hO),mO={kernelName:$t,backendName:"cpu",kernelFunc:fO};function gO(e,t,n,r){let a=Aa.getArrayFromDType(n,Aa.sizeFromShape(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{let n=Aa.sizeFromShape(e.shape);a.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{let s="string"===n?Mw.fromUint8ToStringArray(e.vals):e.vals,i=0;for(let n=0;n<e.shape[0];++n){let o=n*t[1]+r;for(let t=0;t<e.shape[1];++t)a[o+t]=s[i++]}r+=e.shape[1]}))}return a}var yO=jM(((e,t)=>e===t?1:0)),bO=nO(ln,yO,null,"bool"),wO={kernelName:ln,backendName:"cpu",kernelFunc:bO},xO=pO((e=>Math.exp(e))),vO=cO(un,xO,"float32"),kO={kernelName:un,backendName:"cpu",kernelFunc:vO},IO=pO((e=>Math.expm1(e))),SO=cO(dn,IO),NO={kernelName:dn,backendName:"cpu",kernelFunc:SO},TO=pO((e=>Math.floor(e))),CO=cO(mn,TO),_O={kernelName:mn,backendName:"cpu",kernelFunc:CO};function EO(e,t,n,r,a,s,i,o,l){let u=wo([r,s],n);for(let p=0;p<r;p++){let n=[],r=0;for(let t=0;t<a;t++){let s=e[p*a+t];r+=s*i[t],n.push(s)}if(r<0||r>=l/s)throw new Error(`Invalid indices: ${n} does not index into ${o}`);for(let e=0;e<s;e++)u.values[p*s+e]=t.get(...t.indexToLoc(r*s+e))}return u}function AO(e,t,n){let r=wo(n,e.dtype);for(let a=0;a<r.size;++a){let n=r.indexToLoc(a).slice(),s=n[0],i=n[2],o=t.locToIndex([s,i]);n[2]=t.values[o];let l=e.locToIndex(n);0<=l&&l<e.values.length&&(r.values[a]=e.values[l])}return r}var $O=jM(((e,t)=>e>t?1:0)),FO=nO(xn,$O,null,"bool"),RO={kernelName:xn,backendName:"cpu",kernelFunc:FO},DO=jM(((e,t)=>e>=t?1:0)),MO=nO(vn,DO,null,"bool"),OO={kernelName:vn,backendName:"cpu",kernelFunc:MO},LO=jM(((e,t)=>e<t?1:0)),PO=nO(En,LO,null,"bool"),zO={kernelName:En,backendName:"cpu",kernelFunc:PO},BO=jM(((e,t)=>e<=t?1:0)),WO=nO(An,BO,null,"bool"),VO={kernelName:An,backendName:"cpu",kernelFunc:WO};function UO(e,t,n){let r=(t-e)/(n-1),a=Aa.makeZerosTypedArray(n,"float32");a[0]=e;for(let s=1;s<a.length;s++)a[s]=a[s-1]+r;return a}var GO=pO((e=>Math.log(e))),HO=cO(Fn,GO),jO={kernelName:Fn,backendName:"cpu",kernelFunc:HO};function qO(e,t,n,r){let a=Aa.getTypedArrayFromDType(r,Aa.sizeFromShape(n));for(let s=0;s<a.length;++s){let n=s*t,r=e[n];for(let a=0;a<t;++a){let t=e[n+a];(Number.isNaN(t)||t>r)&&(r=t)}a[s]=r}return a}var KO=jM(((e,t)=>Math.max(e,t))),XO=nO(Vn,KO),YO={kernelName:Vn,backendName:"cpu",kernelFunc:XO},ZO=jM(((e,t)=>Math.min(e,t))),JO=nO(Yn,ZO),QO={kernelName:Yn,backendName:"cpu",kernelFunc:JO},eL=jM(((e,t)=>e*t)),tL=rO(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),nL=nO(er,eL,tL),rL={kernelName:er,backendName:"cpu",kernelFunc:nL};function aL(e,t,n){let r=Aa.createScalarValue(-1,n);return eL([],t,r,e,n)}function sL(e){let{inputs:t,backend:n}=e,{x:r}=t;zM(r,"neg");let a=n.data.get(r.dataId).values,[s,i]=aL(a,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,s)}var iL={kernelName:tr,backendName:"cpu",kernelFunc:sL},oL=jM(((e,t)=>e!==t?1:0)),lL=nO(nr,oL,null,"bool"),uL={kernelName:nr,backendName:"cpu",kernelFunc:lL};function pL(e,t,n,r,a){let s=t.length,i=Aa.sizeFromShape(t),o=Aa.computeStrides(t),l=Aa.computeStrides(a),u=Aa.getTypedArrayFromDType(n,Aa.sizeFromShape(a));for(let p=0;p<i;++p){let t=Aa.indexToLoc(p,s,o),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[r[e]];let a=Aa.locToIndex(n,s,l);u[a]=e[p]}return u}function dL(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{perm:s}=n;zM(a,"transpose");let i=a.shape.length,o=new Array(i);for(let p=0;p<o.length;p++)o[p]=a.shape[s[p]];let l=r.data.get(a.dataId).values,u=pL(l,a.shape,a.dtype,s,o);return{dataId:r.write(u,o,a.dtype),shape:o,dtype:a.dtype}}var cL={kernelName:sa,backendName:"cpu",kernelFunc:dL};function hL(e,t,n,r){let[a,s]=Mw.computeOutAndReduceShapes(e,r),i=Fs(t,"int32"),o=Aa.makeZerosTypedArray(Aa.sizeFromShape(a),i),l=Aa.sizeFromShape(s);for(let u=0;u<o.length;++u){let e=u*l,t=1;for(let r=0;r<l;++r)t*=n[e+r];o[u]=t}return{outVals:o,outShape:a,outDtype:i}}function fL(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;zM(a,"prod");let o=a.shape.length,l=Aa.parseAxisParam(s,a.shape),u=Mw.getAxesPermutation(l,o),p=l,d=a,c=[];null!=u&&(d=dL({inputs:{x:a},backend:n,attrs:{perm:u}}),c.push(d),p=Mw.getInnerMostAxes(p.length,o));let h=n.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=hL(d.shape,d.dtype,h,p),y=m;return i&&(y=Mw.expandShapeToKeepDim(m,l)),c.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(y,g,f)}var mL={kernelName:hr,backendName:"cpu",kernelFunc:fL};function gL(e,t,n,r){let a=e===t,s=e<t&&n<0,i=t<e&&n>1;if(a||s||i)return Aa.makeZerosTypedArray(0,r);let o=Math.abs(Math.ceil((t-e)/n)),l=Aa.makeZerosTypedArray(o,r);t<e&&1===n&&(n=-1),l[0]=e;for(let u=1;u<l.length;u++)l[u]=l[u-1]+n;return l}var yL=pO((e=>1/Math.sqrt(e))),bL=cO(Tr,yL),wL={kernelName:Tr,backendName:"cpu",kernelFunc:bL};function xL(e,t,n,r,a,s,i,o,l,u){let p=[r/a,a],d=e.values,c=t.values;if(0===r)return wo(n,t.dtype);let h=wo(p,t.dtype);"string"==typeof l||"number"==typeof l?h.values.fill(l):"boolean"==typeof l&&h.values.fill(+l);for(let f=0;f<s;f++){let e=[],s=0;for(let t=0;t<i;t++){let n=d[f*i+t];e.push(n),s+=n*o[t]}if(s<0||s>=r/a)throw new Error(`Invalid indices: ${e} does not index into ${n}`);for(let n=0;n<a;n++)u?h.values[s*a+n]+=c[f*a+n]:h.values[s*a+n]=0===t.rank?c[0]:c[f*a+n]}return h}var vL=pO((e=>1/(1+Math.exp(-e)))),kL=dO(Mr,(e=>1/(1+Math.exp(-e)))),IL={kernelName:Mr,backendName:"cpu",kernelFunc:kL};function SL(e,t,n,r,a){let s=au.isSliceContinous(r,t,n),i=Aa.sizeFromShape(n),o=Aa.computeStrides(r);if(s){let n=au.computeFlatOffset(t,o);return"string"===a?e.slice(n,n+i):e.subarray(n,n+i)}let l="string"===a?Mw.fromUint8ToStringArray(e):e,u=wo(r,a,l),p=wo(n,a);for(let d=0;d<p.size;++d){let e=p.indexToLoc(d),n=e.map(((e,n)=>e+t[n]));p.set(u.get(...n),...e)}return"string"===a?Mw.fromStringArrayToUint8(p.values):p.values}function NL(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r;zM(a,"slice");let[o,l]=au.parseSliceParams(a,s,i);au.assertParamsValid(a,o,l);let u=n.data.get(a.dataId).values,p=SL(u,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,p)}var TL={kernelName:$r,backendName:"cpu",kernelFunc:NL};function CL(e,t,n,r,a,s,i){let o=t[0],l=s[0],u=new Array(l),p=new Array(o),d=t[1];if(0===l){if(0!==o)throw new Error(Mw.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));let e=Aa.getArrayFromDType(n,0),t=Aa.getArrayFromDType(a,0);return[e,[0,d],t,u,p]}let c=!0,h=0,f=new Array(l).fill(0);for(let g=0;g<o;++g){let t=e[g*d];if(t<0)throw new Error(Mw.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,t));if(t>=l)throw new Error(Mw.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,t,l));++f[t],c=c&&t>=h,h=t}let m=!0;for(let g=0;g<l;++g){let e=0===f[g];u[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&c){let t=e,n=r;for(let e=0;e<o;++e)p[e]=e;return[t,[o,d],n,u,p]}{let t=f[l-1],s=Aa.getArrayFromDType(n,t*d),c=Aa.getArrayFromDType(a,t),h=new Array(l).fill(0);for(let n=0;n<o;++n){let t=e[n*d],a=h[t],i=(0===t?0:f[t-1])+a;h[t]++;for(let r=0;r<d;++r)s[i*d+r]=e[n*d+r];c[i]=r[n],p[n]=i}for(let e=0;e<l;++e)if(0===h[e]){let t=0===e?0:f[e-1];s[t*d+0]=e;for(let e=1;e<d;++e)s[t*d+e]=0;c[t]=i}return[s,[t,d],c,u,p]}}function _L(e,t,n,r,a){let s=Aa.sizeFromShape(r),i=t[0],o=a.length,l=[],u=1,p=-1;for(let m=0;m<o;++m){let e=a[m];if(-1===e){if(-1!==p)throw new Error(Mw.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(p,m));p=m,l.push(1)}else{if(e<0)throw new Error(Mw.getSparseReshapeNegativeOutputDimErrorMessage(m,e));u*=e,l.push(e)}}if(-1!==p){if(u<=0)throw new Error(Mw.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let e=Math.trunc(s/u);if(u*e!==s)throw new Error(Mw.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[p]=e}if(Aa.sizeFromShape(l)!==s)throw new Error(Mw.getSparseReshapeInputOutputMismatchErrorMessage(r,l));let d=r.length,c=[];if(d>0){c[d-1]=1;for(let e=d-2;e>=0;--e)c[e]=c[e+1]*r[e+1]}let h=[];if(o>0){h[o-1]=1;for(let e=o-2;e>=0;--e)h[e]=h[e+1]*l[e+1]}let f=Aa.getArrayFromDType(n,i*o);for(let m=0;m<i;++m){let t=0;for(let n=0;n<d;++n)t+=e[m*d+n]*c[n];for(let e=0;e<o;++e)f[m*o+e]=Math.trunc(t/h[e]),t%=h[e]}return[f,[i,o],l]}function EL(e,t,n,r,a,s=!1,i=0){let o=r.length,l=[t[0],e.length/t[0]],u=l[1],p=o>0?a[o-1]+1:0;if(p<0)throw new Error(Mw.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let d=t.slice();d[0]=p;let c=d.reduce(((e,t)=>e*t),1),h=Aa.getArrayFromDType(n,c);if(0===o)return p>0&&h.fill(i),[h,d];if(p<=0)throw new Error(Mw.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=0,m=1,g=0,y=a[f];for(;;){let t=0;if(m<o){if(t=a[m],y===t){++m;continue}if(y>=t)throw new Error(Mw.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(y<0||y>=p)throw new Error(Mw.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y,p));y>g&&h.fill(i,g*u,y*u);for(let n=f;n<m;++n){let t=r[n];if(t<0||t>=l[0])throw new Error(Mw.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(n,r[n],l[0]));for(let n=0;n<u;n++)h[y*u+n]+=e[t*u+n]}if(s)for(let e=0;e<u;e++)h[y*u+e]/=m-f;if(f=m,++m,g=y+1,y=t,m>o)break}return g<p&&h.fill(i,g*u,p*u),[h,d]}var AL=pO((e=>Math.sqrt(e))),$L=dO(Lr,(e=>Math.sqrt(e))),FL={kernelName:Lr,backendName:"cpu",kernelFunc:$L},RL=jM(((e,t)=>{let n=e-t;return n*n})),DL=nO(qr,RL),ML={kernelName:qr,backendName:"cpu",kernelFunc:DL};function OL(e,t,n,r){let a=wo(e,t.dtype);for(let s=0;s<a.size;s++){let e=a.indexToLoc(s),i=new Array(e.length);for(let t=0;t<i.length;t++)i[t]=e[t]*n[t]+r[t];a.set(t.get(...i),...e)}return a}var LL=class{constructor(e,t,n,r,a,s){this.separator=Aa.encodeString(e),this.nGramWidths=t,this.leftPad=Aa.encodeString(n),this.rightPad=Aa.encodeString(r),this.padWidth=a,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,a,s){for(let i=0;i<a;++i){let o=this.getPadWidth(s),l=Math.max(0,o-i),u=Math.max(0,o-(a-(i+1))),p=s-(l+u),d=t+(l>0?0:i-o),c=0;c+=l*this.leftPad.length;for(let t=0;t<p;++t)c+=e[d+t].length;c+=u*this.rightPad.length,c+=(l+u+p-1)*this.separator.length,n[r+i]=new Uint8Array(c);let h=n[r+i],f=0,m=e=>e.forEach((e=>h[f++]=e));for(let e=0;e<l;++e)m(this.leftPad),m(this.separator);for(let t=0;t<p-1;++t)m(e[d+t]),m(this.separator);if(p>0){m(e[d+p-1]);for(let e=0;e<u;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<u-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){let n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let a=1;a<r;++a){let r=t[a]>=e;if(r=r&&t[a]<=n,!r)throw new Error(`Invalid split value ${t[a]}, must be in [${e}, ${n}]`);e=t[a]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}let a=r-1,s=Aa.getArrayFromDType("int32",r);if(0===n||0===r){let e=new Array(n);for(let t=0;t<=a;++t)s[t]=0;return[e,s]}s[0]=0;for(let o=1;o<=a;++o){let e=t[o]-t[o-1],n=0;this.nGramWidths.forEach((t=>{n+=this.getNumNGrams(e,t)})),this.preserveShort&&e>0&&0===n&&(n=1),s[o]=s[o-1]+n}let i=new Array(s[a]);for(let o=0;o<a;++o){let n=t[o],r=s[o];if(this.nGramWidths.forEach((a=>{let s=t[o+1]-t[o],l=this.getNumNGrams(s,a);this.createNGrams(e,n,i,r,l,a),r+=l})),this.preserveShort&&r===s[o]){let a=t[o+1]-t[o];if(0===a)continue;let s=a+2*this.padWidth,l=1;this.createNGrams(e,n,i,r,l,s)}}return[i,s]}};function PL(e,t,n,r,a,s,i,o){return new LL(n,r,a,s,i,o).compute(e,t)}function zL(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){let a=t[0],s=e.indexOf(a);for(;-1!==s;){let t=e.subarray(0,s);(!n||0!==t.length)&&r.push(t),e=e.subarray(s+1),s=e.indexOf(a)}return void((!n||0!==e.length)&&r.push(e))}let a=0;for(let s=0;s<e.length+1;s++)if(s===e.length||-1!==t.indexOf(e[s])){let t=e.subarray(a,s);(!n||0!==t.length)&&r.push(t),a=s+1}}function BL(e,t,n){let r=e.length,a=[],s=0,i=0,o=new Array(r);for(let c=0;c<r;++c){let r=a.length;zL(e[c],t,n,a);let l=a.length-r;o[c]=l,s+=l,i=Math.max(i,l)}let l=Aa.getArrayFromDType("int32",2*s),u=new Array(s),p=[r,i],d=0;for(let c=0;c<r;++c)for(let e=0;e<o[c];++e)l[2*d]=c,l[2*d+1]=e,u[d]=a[d],++d;return[l,u,p]}function WL(e,t){let n=Aa.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=Aa.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}var VL=jM(((e,t)=>e-t)),UL=rO(((e,t,n,r)=>({real:e-n,imag:t-r}))),GL=nO(Qr,VL,UL),HL={kernelName:Qr,backendName:"cpu",kernelFunc:GL};function jL(e,t){let n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=e.shape[a]*t[a];let r=wo(n,e.dtype);for(let a=0;a<r.values.length;++a){let t=r.indexToLoc(a),n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=t[r]%e.shape[r];let s=e.locToIndex(n);r.values[a]=e.values[s]}return r}var qL=(e,t)=>{let n=t.value-e.value;return 0===n?e.index-t.index:n};function KL(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){let a=r-n+1,s=t-n+1,i=Math.log(a),o=.5*Math.exp(2*i/3),l=.5*Math.sqrt(i*o*(a-o)/a)*Math.sign(s-a/2),u=Math.max(n,Math.floor(t-s*o/a+l)),p=Math.min(r,Math.floor(t+(a-s)*o/a+l));KL(e,t,u,p)}let a=e[t],s=n,i=r;for(Aa.swap(e,n,t),qL(e[r],a)>0&&Aa.swap(e,n,r);s<i;){for(Aa.swap(e,s,i),s++,i--;qL(e[s],a)<0;)s+=1;for(;qL(e[i],a)>0;)i-=1}0===qL(e[n],a)?Aa.swap(e,n,i):(i+=1,Aa.swap(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function XL(e,t,n,r,a){let s=t[t.length-1],[i,o]=[e.length/s,s],l=Aa.getTypedArrayFromDType(n,i*r),u=Aa.getTypedArrayFromDType("int32",i*r);for(let d=0;d<i;d++){let t=d*o,n=e.subarray(t,t+o),s=new Array(n.length);n.forEach(((e,t)=>s[t]={value:e,index:t})),r<s.length&&(KL(s,r),s=s.slice(0,r)),a&&s.sort(qL);let i=d*r,p=l.subarray(i,i+r),c=u.subarray(i,i+r);for(let e=0;e<r;e++)p[e]=s[e].value,c[e]=s[e].index}let p=t.slice();return p[p.length-1]=r,[wo(p,n,l),wo(p,"int32",u)]}function YL(e,t,n,r){let a=Aa.parseAxisParam(t,n)[0],s=[1,n[0],1];for(let f=0;f<a;f++)s[0]*=n[f];s[1]=n[a];for(let f=a+1;f<n.length;f++)s[2]*=n[f];let i={},o=new Int32Array(n[a]),l=new gs(s,r,e),u=[],p=1===s[0]&&1===s[2];for(let f=0;f<n[a];f++){let t;if(p)t=e[f].toString();else{let e=[];for(let t=0;t<s[0];t++)for(let n=0;n<s[2];n++)e.push(l.get(t,f,n));t=e.join(",")}if(void 0!==i[t])o[f]=i[t];else{let e=Object.keys(i).length;i[t]=e,o[f]=e,u.push(f)}}let d=s.slice();d[1]=Object.keys(i).length;let c=new gs(d,r);u.forEach(((e,t)=>{for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)c.set(l.get(n,e,r),n,t,r)}));let h=n.slice();return h[a]=d[1],{outputValues:c.values,outputShape:h,indices:o}}Sl("cpu",(()=>new WM),1);var ZL=dO(an,(e=>e>=0?e:Math.exp(e)-1)),JL={kernelName:an,backendName:"cpu",kernelFunc:ZL};function QL(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r;zM([a],"leakyRelu");let i=Aa.sizeFromShape(a.shape),o=n.data.get(a.dataId).values,l=Aa.getTypedArrayFromDType("float32",i);for(let u=0;u<o.length;u++)l[u]=o[u]<0?s*o[u]:o[u];return n.makeTensorInfo(a.shape,"float32",l)}var eP={kernelName:_n,backendName:"cpu",kernelFunc:QL},tP=jM(((e,t)=>e<0?t*e:e));function nP(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t;zM([r,a],"prelu");let s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,[o,l]=tP(r.shape,a.shape,s,i,"float32");return n.makeTensorInfo(l,"float32",o)}var rP={kernelName:cr,backendName:"cpu",kernelFunc:nP},aP=dO(yr,(e=>Math.max(0,e))),sP={kernelName:yr,backendName:"cpu",kernelFunc:aP},iP=dO(Ir,(e=>Math.min(Math.max(0,e),6))),oP={kernelName:Ir,backendName:"cpu",kernelFunc:iP};function lP(e,t,n,r,a){if("linear"===n)return YM({inputs:{x:t},backend:e});if("relu"===n)return aP({inputs:{x:t},backend:e});if("elu"===n)return ZL({inputs:{x:t},backend:e});if("relu6"===n)return iP({inputs:{x:t},backend:e});if("prelu"===n)return nP({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return QL({inputs:{x:t},backend:e,attrs:{alpha:a}});if("sigmoid"===n)return kL({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function uP(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=Aa.sizeFromShape(a.shape),o=Aa.inferFromImplicitShape(s,i),l=Aa.sizeFromShape(o);Aa.assert(i===l,(()=>`The new shape (${o}) has ${l} elements and the old shape (${a.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(a.dataId);let u=n.data.get(a.dataId);if(null!=u.complexTensorInfos){let e=u.complexTensorInfos.real,t=u.complexTensorInfos.imag;e.shape=o,t.shape=o}return{dataId:a.dataId,shape:o,dtype:a.dtype}}var pP={kernelName:br,backendName:"cpu",kernelFunc:uP};function dP(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:i,transposeB:o}=r;zM([a,s],"matMul");let l=a.shape.length,u=s.shape.length,p=i?a.shape[l-2]:a.shape[l-1],d=o?s.shape[u-1]:s.shape[u-2],c=i?a.shape[l-1]:a.shape[l-2],h=o?s.shape[u-2]:s.shape[u-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),g=Aa.sizeFromShape(f),y=Aa.sizeFromShape(m),b=Ll.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([c,h]);Aa.assert(p===d,(()=>`Error in matMul: inner shapes (${p}) and (${d}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`));let w=i?[g,p,c]:[g,c,p],x=o?[y,h,d]:[y,d,h],v=uP({inputs:{x:a},backend:n,attrs:{shape:w}}),k=uP({inputs:{x:s},backend:n,attrs:{shape:x}}),I=i?v.shape[1]:v.shape[2],S=i?v.shape[2]:v.shape[1],N=o?k.shape[1]:k.shape[2],T=Math.max(g,y),C=n.data.get(v.dataId).values,_=n.data.get(k.dataId).values,E=Aa.computeStrides(v.shape),A=Aa.computeStrides(k.shape),[$,F,R]=i?[E[0],1,E[1]]:[E[0],E[1],1],[D,M,O]=o?[1,A[1],A[0]]:[A[1],1,A[0]],L=S*N,P=wo([T,S,N],v.dtype),z=P.values,B=n.blockSize;for(let W=0;W<T;W++)for(let e=0;e<S;e+=B)for(let t=0;t<N;t+=B)for(let n=0;n<I;n+=B){let r=Math.min(e+B,S),a=Math.min(t+B,N),s=Math.min(n+B,I);for(let i=e;i<r;i++)for(let e=t;e<a;e++){let t=0;for(let r=n;r<s;r++){let n=Math.min(W,g-1)*$,a=Math.min(W,y-1)*O,s=C[n+i*F+r*R],o=_[r*D+e*M+a];t+=s*o}z[W*L+(i*N+e)]+=t}}return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(k),n.makeTensorInfo(b,P.dtype,P.values)}var cP={kernelName:Nt,backendName:"cpu",kernelFunc:dP};function hP(e){let t,n,r,{inputs:a,backend:s,attrs:i}=e,{a:o,b:l,bias:u,preluActivationWeights:p}=a,{transposeA:d,transposeB:c,activation:h,leakyreluAlpha:f}=i,m=[];t=dP({inputs:{a:o,b:l},attrs:{transposeA:d,transposeB:c},backend:s}),u&&(n=iO({inputs:{a:t,b:u},backend:s}),m.push(t),t=n),h&&(r=lP(s,t,h,p,f),m.push(t),t=r);for(let g of m)s.disposeIntermediateTensorInfo(g);return t}var fP={kernelName:fa,backendName:"cpu",kernelFunc:hP},mP=dO(lt,(e=>Math.acos(e))),gP={kernelName:lt,backendName:"cpu",kernelFunc:mP},yP=dO(ut,(e=>Math.acosh(e))),bP={kernelName:ut,backendName:"cpu",kernelFunc:yP};function wP(e){let{inputs:t,backend:n}=e,r=t;zM(t,"addN");let a=r.map((e=>n.data.get(e.dataId).values)),s=wo(r[0].shape,r[0].dtype),i=s.values;for(let o=0;o<r.length;o++){let e=a[o];for(let t=0;t<i.length;t++)i[t]+=e[t]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}var xP={kernelName:dt,backendName:"cpu",kernelFunc:wP};function vP(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;zM(a,"all");let o=Aa.parseAxisParam(s,a.shape),l=o,u=Mw.getAxesPermutation(l,a.shape.length),p=a;null!=u&&(p=dL({inputs:{x:a},backend:n,attrs:{perm:u}}),l=Mw.getInnerMostAxes(l.length,a.shape.length)),Mw.assertAxesAreInnerMostDims("all",l,p.shape.length);let[d,c]=Mw.computeOutAndReduceShapes(p.shape,l),h=Aa.sizeFromShape(c),f=Aa.makeZerosTypedArray(Aa.sizeFromShape(d),p.dtype),m=n.data.get(p.dataId).values;for(let y=0;y<f.length;++y){let e=y*h,t=m[e];for(let n=0;n<h;++n){let r=m[e+n];t=t&&r}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(p);let g=n.makeTensorInfo(d,p.dtype,f);if(i){let e=Mw.expandShapeToKeepDim(d,o),t=uP({inputs:{x:g},backend:n,attrs:{shape:e}});return n.disposeIntermediateTensorInfo(g),t}return g}var kP={kernelName:ct,backendName:"cpu",kernelFunc:vP};function IP(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;zM(a,"any");let o=Aa.parseAxisParam(s,a.shape),l=o,u=Mw.getAxesPermutation(l,a.shape.length),p=a;null!=u&&(p=dL({inputs:{x:a},backend:n,attrs:{perm:u}}),l=Mw.getInnerMostAxes(l.length,a.shape.length)),Mw.assertAxesAreInnerMostDims("any",l,p.shape.length);let[d,c]=Mw.computeOutAndReduceShapes(p.shape,l),h=Aa.sizeFromShape(c),f=Aa.makeZerosTypedArray(Aa.sizeFromShape(d),p.dtype),m=n.data.get(p.dataId).values;for(let y=0;y<f.length;++y){let e=y*h,t=m[e];for(let n=0;n<h;++n){let r=m[e+n];t=t||r}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(p);let g=n.makeTensorInfo(d,p.dtype,f);if(i){let e=Mw.expandShapeToKeepDim(d,o),t=uP({inputs:{x:g},backend:n,attrs:{shape:e}});return n.disposeIntermediateTensorInfo(g),t}return g}var SP={kernelName:ht,backendName:"cpu",kernelFunc:IP};function NP(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;zM(a,"argMax");let i=Aa.parseAxisParam(s,a.shape),o=Mw.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(l=dL({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=Mw.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],Mw.assertAxesAreInnerMostDims("argMax",i,l.shape.length);let[p,d]=Mw.computeOutAndReduceShapes(l.shape,i),c=Aa.sizeFromShape(p),h=Aa.makeZerosTypedArray(c,"int32"),f=Aa.sizeFromShape(d),m=n.data.get(l.dataId).values;for(let g=0;g<h.length;++g){let e=g*f,t=m[e],n=0;for(let r=0;r<f;++r){let a=m[e+r];a>t&&(t=a,n=r)}h[g]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(p,"int32",h)}var TP={kernelName:ft,backendName:"cpu",kernelFunc:NP};function CP(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;zM(a,"argMin");let i=Aa.parseAxisParam(s,a.shape),o=Mw.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(l=dL({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=Mw.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],Mw.assertAxesAreInnerMostDims("argMin",i,l.shape.length);let[p,d]=Mw.computeOutAndReduceShapes(l.shape,i),c=Aa.sizeFromShape(p),h=Aa.makeZerosTypedArray(c,"int32"),f=Aa.sizeFromShape(d),m=n.data.get(l.dataId).values;for(let g=0;g<h.length;++g){let e=g*f,t=m[e],n=0;for(let r=0;r<f;++r){let a=m[e+r];a<t&&(t=a,n=r)}h[g]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(p,"int32",h)}var _P={kernelName:mt,backendName:"cpu",kernelFunc:CP},EP=dO(gt,(e=>Math.asin(e))),AP={kernelName:gt,backendName:"cpu",kernelFunc:EP},$P=dO(yt,(e=>Math.asinh(e))),FP={kernelName:yt,backendName:"cpu",kernelFunc:$P},RP=dO(bt,(e=>Math.atan(e))),DP={kernelName:bt,backendName:"cpu",kernelFunc:RP},MP=jM(((e,t)=>Math.atan2(e,t))),OP=nO(xt,MP),LP={kernelName:xt,backendName:"cpu",kernelFunc:OP},PP=dO(wt,(e=>Math.atanh(e))),zP={kernelName:wt,backendName:"cpu",kernelFunc:PP};function BP(e,t,n,r,a,s){let i=a.strideHeight,o=a.strideWidth,l=a.dilationHeight,u=a.dilationWidth,p=a.effectiveFilterHeight,d=a.effectiveFilterWidth,c=a.padInfo.top,h=a.padInfo.left,f="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=wo(a.outShape,n),g=m.values,y=a.outShape[1]*a.outShape[2]*a.outShape[3],b=a.outShape[2]*a.outShape[3],w=a.outShape[3];for(let x=0;x<a.batchSize;++x){let t=x*y,n=x*r[0];for(let m=0;m<a.inChannels;++m)for(let y=0;y<a.outHeight;++y){let x=y*i-c,v=Math.max(0,x),k=Math.min(a.inHeight,p+x),I=t+y*b;for(let t=0;t<a.outWidth;++t){let i=t*o-h,p=Math.max(0,i),c=Math.min(a.inWidth,d+i),y=f,b=0,x=0;for(let t=v;t<k;t+=l){let a=n+t*r[1];for(let t=p;t<c;t+=u){let n=a+t*r[2],i=e[n+m];"max"===s&&i>y?y=i:"avg"===s&&(b+=i,x++)}if(isNaN(y))break}let S=I+t*w+m;g[S]="avg"===s?b/x:y}}}return m}function WP(e,t,n,r,a=!1,s=!1){let i=wo(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,p=r.dilationWidth,d=r.effectiveFilterHeight,c=r.effectiveFilterWidth,h=r.padInfo.top,f=r.padInfo.left,m=wo(t,n,e);for(let g=0;g<r.batchSize;++g)for(let e=0;e<r.inChannels;++e)for(let t=0;t<r.outHeight;++t){let n=t*o-h,y=n;for(;y<0;)y+=u;let b=Math.min(r.inHeight,d+n);for(let o=0;o<r.outWidth;++o){let d=o*l-f,h=d;for(;h<0;)h+=p;let w=Math.min(r.inWidth,c+d),x=Number.NEGATIVE_INFINITY,v=-1;for(let t=y;t<b;t+=u){let i=t-n;for(let n=h;n<w;n+=p){let o=n-d,l=m.get(g,t,n,e);l>x&&(x=l,v=a?s?((g*r.inHeight+t)*r.inWidth+n)*r.inChannels+e:(t*r.inWidth+n)*r.inChannels+e:i*c+o)}}i.set(v,g,t,o,e)}}return i}function VP(e,t,n,r,a,s){let i=a.strideDepth,o=a.strideHeight,l=a.strideWidth,u=a.dilationDepth,p=a.dilationHeight,d=a.dilationWidth,c=a.effectiveFilterDepth,h=a.effectiveFilterHeight,f=a.effectiveFilterWidth,m=a.padInfo.front,g=a.padInfo.top,y=a.padInfo.left,b="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,w=wo(a.outShape,n),x=w.values,v=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],k=a.outShape[2]*a.outShape[3]*a.outShape[4],I=a.outShape[3]*a.outShape[4],S=a.outShape[4];for(let N=0;N<a.batchSize;++N){let t=N*v,n=N*r[0];for(let w=0;w<a.inChannels;++w)for(let v=0;v<a.outDepth;++v){let N=v*i-m,T=N;for(;T<0;)T+=u;let C=Math.min(a.inDepth,c+N),_=t+v*k;for(let t=0;t<a.outHeight;++t){let i=t*o-g,c=i;for(;c<0;)c+=p;let m=Math.min(a.inHeight,h+i),v=_+t*I;for(let t=0;t<a.outWidth;++t){let i=t*l-y,o=i;for(;o<0;)o+=d;let h=Math.min(a.inWidth,f+i),g=v+t*S,k=b,I=0,N=0;for(let t=T;t<C;t+=u){let a=n+t*r[1];for(let t=c;t<m;t+=p){let n=a+t*r[2];for(let t=o;t<h;t+=d){let a=n+t*r[3],i=e[a+w];if("max"===s&&i>k?k=i:"avg"===s&&(I+=i,N++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}let _=g+w;x[_]="avg"===s?I/N:k}}}}return w}function UP(e,t){let n=wo(t.outShape,"int32"),r=t.strideDepth,a=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,p=t.effectiveFilterHeight,d=t.effectiveFilterWidth,c=t.padInfo.front,h=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){let b=y*r-c,w=b;for(;w<0;)w+=i;let x=Math.min(t.inDepth,u+b);for(let r=0;r<t.outHeight;++r){let u=r*a-h,c=u;for(;c<0;)c+=o;let v=Math.min(t.inHeight,p+u);for(let a=0;a<t.outWidth;++a){let h=a*s-f,k=h;for(;k<0;)k+=l;let I=Math.min(t.inWidth,d+h),S=Number.NEGATIVE_INFINITY,N=-1;for(let t=w;t<x;t+=i){let n=t-b;for(let r=c;r<v;r+=o){let a=r-u;for(let s=k;s<I;s+=l){let i=s-h,o=e.get(m,t,r,s,g);o>=S&&(S=o,N=n*p*d+a*p+i)}}}n.set(N,m,y,r,a,g)}}}return n}function GP(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;zM(a,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,u=1;Aa.assert(Mw.eitherStridesOrDilationsAreOne(i,u),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`));let p,d=Mw.computePool2DInfo(a.shape,s,i,u,o,l);if(1===d.filterWidth&&1===d.filterHeight&&Aa.arraysEqual(d.inShape,d.outShape))p=YM({inputs:{x:a},backend:n});else{let e=n.data.get(a.dataId).values,t=Aa.computeStrides(a.shape),r=BP(e,a.shape,a.dtype,t,d,"avg");p=n.makeTensorInfo(d.outShape,a.dtype,r.values)}return p}var HP={kernelName:vt,backendName:"cpu",kernelFunc:GP};function jP(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;zM(a,"avgPool3d");let p=Mw.computePool3DInfo(a.shape,s,i,1,o,l,u),d=n.data.get(a.dataId).values,c=VP(d,a.shape,a.dtype,Aa.computeStrides(a.shape),p,"avg");return n.makeTensorInfo(c.shape,"float32",c.values)}var qP={kernelName:It,backendName:"cpu",kernelFunc:jP};function KP(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;zM([a,s],"avgPool3DGrad");let p=Mw.computePool3DInfo(s.shape,i,o,1,l,u),d=p.strideDepth,c=p.strideHeight,h=p.strideWidth,f=p.filterDepth,m=p.filterHeight,g=p.filterWidth,y=p.dilationDepth,b=p.dilationHeight,w=p.dilationWidth,x=p.effectiveFilterDepth,v=p.effectiveFilterHeight,k=p.effectiveFilterWidth,I=x-1-p.padInfo.front,S=k-1-p.padInfo.left,N=v-1-p.padInfo.top,T=wo(s.shape,"float32"),C=1/(f*m*g),_=n.bufferSync(a);for(let E=0;E<p.batchSize;++E)for(let e=0;e<p.inChannels;++e)for(let t=0;t<p.inDepth;++t)for(let n=0;n<p.inHeight;++n)for(let r=0;r<p.inWidth;++r){let a=t-I,s=n-N,i=r-S,o=0;for(let t=0;t<x;t+=y){let n=(a+t)/d;if(!(n<0||n>=p.outDepth||Math.floor(n)!==n))for(let t=0;t<v;t+=b){let r=(s+t)/c;if(!(r<0||r>=p.outHeight||Math.floor(r)!==r))for(let t=0;t<k;t+=w){let a=(i+t)/h;a<0||a>=p.outWidth||Math.floor(a)!==a||(o+=_.get(E,n,r,a,e))}}}T.set(o*C,E,t,n,r,e)}return n.makeTensorInfo(T.shape,T.dtype,T.values)}var XP={kernelName:St,backendName:"cpu",kernelFunc:KP};function YP(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;zM([a,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=r,p=Mw.computePool2DInfo(i.shape,o,l,1,u),d=p.strideHeight,c=p.strideWidth,h=p.filterHeight,f=p.filterWidth,m=p.dilationHeight,g=p.dilationWidth,y=p.effectiveFilterHeight,b=p.effectiveFilterWidth,w=b-1-p.padInfo.left,x=y-1-p.padInfo.top,v=wo(i.shape,"float32"),k=1/(h*f),I=n.data.get(a.dataId).values,S=wo(a.shape,"float32",I);for(let N=0;N<p.batchSize;++N)for(let e=0;e<p.inChannels;++e)for(let t=0;t<p.inHeight;++t)for(let n=0;n<p.inWidth;++n){let r=t-x,a=n-w,s=0;for(let t=0;t<y;t+=m){let n=(r+t)/d;if(!(n<0||n>=p.outHeight||Math.floor(n)!==n))for(let t=0;t<b;t+=g){let r=(a+t)/c;r<0||r>=p.outWidth||Math.floor(r)!==r||(s+=S.get(N,n,r,e))}}v.set(s*k,N,t,n,e)}return n.makeTensorInfo(v.shape,v.dtype,v.values)}var ZP={kernelName:kt,backendName:"cpu",kernelFunc:YP};function JP(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,scale:s,offset:i,mean:o,variance:l}=t;Aa.assert(o.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Aa.assert(null==i||o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Aa.assert(null==s||o.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),zM([a,o,l,s,i],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);let p=n.data.get(a.dataId).values,d=n.data.get(o.dataId).values,c=n.data.get(l.dataId).values,h=s?n.data.get(s.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(p.length),g=f.length,y=h.length,b=c.length,w=d.length,x=0,v=0,k=0,I=0;for(let S=0;S<p.length;++S)m[S]=f[x++]+(p[S]-d[v++])*h[k++]/Math.sqrt(c[I++]+u),x>=g&&(x=0),v>=w&&(v=0),k>=y&&(k=0),I>=b&&(I=0);return n.makeTensorInfo(a.shape,a.dtype,m)}var QP={kernelName:yn,backendName:"cpu",kernelFunc:JP};function ez(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;zM([a],"batchToSpaceND");let o=s.reduce(((e,t)=>e*t)),l=Mw.getReshaped(a.shape,s,o),u=Mw.getPermuted(l.length,s.length),p=Mw.getReshapedPermuted(a.shape,s,o),d=Mw.getSliceBeginCoords(i,s.length),c=Mw.getSliceSize(p,i,s.length),h=uP({inputs:{x:a},backend:n,attrs:{shape:l}}),f=dL({inputs:{x:h},backend:n,attrs:{perm:u}}),m=uP({inputs:{x:f},backend:n,attrs:{shape:p}}),g=NL({inputs:{x:m},backend:n,attrs:{begin:d,size:c}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var tz={kernelName:Tt,backendName:"cpu",kernelFunc:ez};function nz(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,u=lO(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}var rz={kernelName:Ct,backendName:"cpu",kernelFunc:nz};function az(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=Mw.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var sz={kernelName:Et,backendName:"cpu",kernelFunc:az},iz=dO(Ft,((e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),oz={kernelName:Ft,backendName:"cpu",kernelFunc:iz},lz=e=>{let{x:t}=e.inputs,n=e.backend,r=new Float32Array(Aa.sizeFromShape(t.shape)),a=n.data.get(t.dataId),s=a.complexTensorInfos.real,i=a.complexTensorInfos.imag,o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values;for(let u=0;u<o.length;u++){let e=o[u],t=l[u];r[u]=Math.hypot(e,t)}return n.makeOutput(r,t.shape,"float32")},uz={kernelName:Dt,backendName:"cpu",kernelFunc:lz};function pz(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.imag,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}var dz={kernelName:Sn,backendName:"cpu",kernelFunc:pz};function cz(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=Aa.parseAxisParam(a,t[0].shape)[0],i=Mw.computeOutShape(t.map((e=>e.shape)),s);if(0===Aa.sizeFromShape(i))return n.makeTensorInfo(i,t[0].dtype,[]);let o=t.filter((e=>Aa.sizeFromShape(e.shape)>0));if(1===o.length)return YM({inputs:{x:o[0]},backend:n});let l=o.map((e=>e.shape));if(Mw.assertParamsConsistent(l,s),"complex64"===o[0].dtype){let e=o.map((e=>JM({inputs:{input:e},backend:n}))),t=o.map((e=>pz({inputs:{input:e},backend:n}))),r=cz({inputs:e,backend:n,attrs:{axis:s}}),a=cz({inputs:t,backend:n,attrs:{axis:s}}),i=qM({inputs:{real:r,imag:a},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),i}let u=o.map((e=>{let t=Aa.sizeFromShape(e.shape.slice(s));return uP({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),p=u.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));i=Mw.computeOutShape(u.map((e=>e.shape)),1);let d=1===u[0].shape[0],c=gO(p,i,t[0].dtype,d),h=Mw.computeOutShape(o.map((e=>e.shape)),s),f=n.makeTensorInfo(h,t[0].dtype,c);return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}var hz={kernelName:Mt,backendName:"cpu",kernelFunc:cz};function fz(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:p}=r;zM([a,s],"conv2d");let d=Mw.convertConv2DDataFormat(l),c=Mw.computeConv2DInfo(a.shape,s.shape,i,u,o,p,!1,d),h=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.padInfo.left,b=c.padInfo.top,w="channelsLast"===c.dataFormat,x=new gs(c.outShape,a.dtype),v=Aa.computeStrides(a.shape),k=Aa.computeStrides(s.shape),I=v[0],S=w?v[1]:v[2],N=w?v[2]:1,T=w?1:v[1],C=x.strides[0],_=w?x.strides[1]:x.strides[2],E=w?x.strides[2]:1,A=w?1:x.strides[1],$=n.data.get(a.dataId).values,F=n.data.get(s.dataId).values,R=x.values;for(let D=0;D<c.batchSize;++D){let e=D*I,t=D*C;for(let n=0;n<c.outHeight;++n){let r=t+n*_,a=n*c.strideHeight-b;for(let t=0;t<h;++t){let n=a+t*m;if(n<0||n>=c.inHeight)continue;let s=t*k[0],i=e+n*S;for(let e=0;e<c.outWidth;++e){let t=r+e*E,n=e*c.strideWidth-y;for(let e=0;e<f;++e){let r=n+e*g;if(r<0||r>=c.inWidth)continue;let a=s+e*k[1],o=i+r*N,l=a;for(let e=0;e<c.inChannels;++e){let n=$[o+e*T];for(let e=0;e<c.outChannels;++e)R[t+e*A]+=n*F[l+e];l+=c.outChannels}}}}}}return n.makeTensorInfo(x.shape,x.dtype,R)}var mz={kernelName:Ot,backendName:"cpu",kernelFunc:fz};function gz(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:p}=r;zM([a,s],"conv2dBackpropFilter");let d=Mw.convertConv2DDataFormat(l),c=Mw.computeConv2DInfo(a.shape,p,i,1,o,u,!1,d),{strideHeight:h,strideWidth:f,filterHeight:m,filterWidth:g}=c,y="channelsLast"===c.dataFormat,b=new gs(c.filterShape,"float32"),w=c.padInfo.left,x=c.padInfo.top,v=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,I=new gs(a.shape,a.dtype,v),S=new gs(s.shape,s.dtype,k);for(let N=0;N<m;++N){let e=Math.max(0,Math.ceil((x-N)/h)),t=Math.min(c.outHeight,(c.inHeight+x-N)/h);for(let n=0;n<g;++n){let r=Math.max(0,Math.ceil((w-n)/f)),a=Math.min(c.outWidth,(c.inWidth+w-n)/f);for(let s=0;s<c.inChannels;++s)for(let i=0;i<c.outChannels;++i){let o=0;for(let l=0;l<c.batchSize;++l)for(let u=e;u<t;++u){let e=N+u*h-x;for(let t=r;t<a;++t){let r=n+t*f-w;o+=y?I.get(l,e,r,s)*S.get(l,u,t,i):I.get(l,s,e,r)*S.get(l,i,u,t)}}b.set(o,N,n,s,i)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var yz={kernelName:Lt,backendName:"cpu",kernelFunc:gz};function bz(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:p}=r;zM([a,s],"conv2dBackpropInput");let d=Aa.computeStrides(s.shape),c=Aa.computeStrides(a.shape),h=Mw.convertConv2DDataFormat(u),f=Mw.computeConv2DInfo(i,s.shape,o,1,l,p,!1,h),m=new gs(f.inShape,"float32"),g=m.values,y=n.data.get(a.dataId).values,b=n.data.get(s.dataId).values,[w,x,v]=d,{batchSize:k,filterHeight:I,filterWidth:S,inChannels:N,inHeight:T,inWidth:C,outChannels:_,outHeight:E,outWidth:A,strideHeight:$,strideWidth:F}=f;h=f.dataFormat;let R=I-1-f.padInfo.top,D=S-1-f.padInfo.left,M="channelsLast"===h,O=m.strides[0],L=M?m.strides[1]:m.strides[2],P=M?m.strides[2]:1,z=M?1:m.strides[1],B=c[0],W=M?c[1]:c[2],V=M?c[2]:1,U=M?1:c[1];for(let G=0;G<k;++G)for(let e=0;e<N;++e)for(let t=0;t<T;++t){let n=t-R,r=Math.max(0,Math.ceil(n/$)),a=Math.min(E,(I+n)/$);for(let s=0;s<C;++s){let i=s-D,o=Math.max(0,Math.ceil(i/F)),l=Math.min(A,(S+i)/F),u=0;for(let t=r;t<a;++t){let r=t*$-n;for(let n=o;n<l;++n){let a=n*F-i,s=B*G+W*t+V*n,o=w*(I-1-r)+x*(S-1-a)+v*e;for(let e=0;e<_;++e){let t=y[s+U*e],n=b[o+e];u+=t*n}}}let p=O*G+L*t+P*s+z*e;g[p]=u}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}var wz={kernelName:Pt,backendName:"cpu",kernelFunc:bz};function xz(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;zM([a,s],"conv3d");let u=Mw.computeConv3DInfo(a.shape,s.shape,i,l,o),{filterDepth:p,filterHeight:d,filterWidth:c,dilationDepth:h,dilationHeight:f,dilationWidth:m,padInfo:g}=u,y=g.front,b=g.left,w=g.top,x=new gs(u.outShape,a.dtype),v=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,I=x.values,S=Aa.computeStrides(a.shape),N=Aa.computeStrides(s.shape);for(let T=0;T<u.batchSize;++T){let e=T*S[0],t=T*x.strides[0];for(let n=0;n<u.outDepth;++n){let r=t+n*x.strides[1],a=n*u.strideDepth-y;for(let t=0;t<p;++t){let n=a+t*h;if(n<0||n>=u.inDepth)continue;let s=t*N[0],i=e+n*S[1];for(let e=0;e<u.outHeight;++e){let t=r+e*x.strides[2],n=e*u.strideHeight-w;for(let e=0;e<d;++e){let r=n+e*f;if(r<0||r>=u.inHeight)continue;let a=s+e*N[1],o=i+r*S[2];for(let e=0;e<u.outWidth;++e){let n=t+e*u.outChannels,r=e*u.strideWidth-b;for(let e=0;e<c;++e){let t=r+e*m;if(t<0||t>=u.inWidth)continue;let s=a+e*N[2],i=o+t*u.inChannels,l=s;for(let e=0;e<u.inChannels;++e){let t=v[i+e];for(let e=0;e<u.outChannels;++e)I[n+e]+=t*k[l+e];l+=u.outChannels}}}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}var vz={kernelName:zt,backendName:"cpu",kernelFunc:xz};function kz(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r;zM([a,s],"conv3dBackpropFilterV2");let u=Aa.computeStrides(a.shape),p=Aa.computeStrides(s.shape),d=Mw.computeConv3DInfo(a.shape,l,i,1,o),c=d.strideDepth,h=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,y=d.filterWidth,b=new gs(d.filterShape,"float32"),w=b.values,[x,v,k,I]=b.strides,S=n.data.get(s.dataId).values,[N,T,C,_]=p,E=n.data.get(a.dataId).values,[A,$,F,R]=u,D=d.padInfo.front,M=d.padInfo.left,O=d.padInfo.top;for(let L=0;L<m;++L){let e=Math.max(0,Math.ceil((D-L)/c)),t=Math.min(d.outDepth,(d.inDepth+D-L)/c),n=L*x;for(let r=0;r<g;++r){let a=Math.max(0,Math.ceil((O-r)/h)),s=Math.min(d.outHeight,(d.inHeight+O-r)/h),i=r*v+n;for(let n=0;n<y;++n){let o=Math.max(0,Math.ceil((M-n)/f)),l=Math.min(d.outWidth,(d.inWidth+M-n)/f),u=n*k+i;for(let i=0;i<d.inChannels;++i){let p=i*I+u;for(let u=0;u<d.outChannels;++u){let m=0;for(let p=0;p<d.batchSize;++p){let d=p*A,g=p*N;for(let p=e;p<t;++p){let e=(L+p*c-D)*$+d,t=p*T+g;for(let p=a;p<s;++p){let a=(r+p*h-O)*F+e,s=p*C+t;for(let e=o;e<l;++e){let t=(n+e*f-M)*R+a,r=e*_+s;m+=E[t+i]*S[r+u]}}}}w[p+u]=m}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var Iz={kernelName:Bt,backendName:"cpu",kernelFunc:kz};function Sz(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r;zM([a],"conv3dBackpropInputV2");let u=Aa.computeStrides(a.shape),p=Aa.computeStrides(s.shape),d=Mw.computeConv3DInfo(l,s.shape,o,1,i),c=new gs(d.inShape,"float32"),h=c.values,[f,m,g,y]=c.strides,b=n.data.get(a.dataId).values,[w,x,v,k]=u,I=n.data.get(s.dataId).values,[S,N,T,C]=p,{batchSize:_,filterDepth:E,filterHeight:A,filterWidth:$,inChannels:F,inDepth:R,inHeight:D,inWidth:M,outChannels:O,outDepth:L,outHeight:P,outWidth:z,strideDepth:B,strideHeight:W,strideWidth:V}=d,U=E-1-d.padInfo.front,G=A-1-d.padInfo.top,H=$-1-d.padInfo.left;for(let j=0;j<_;++j)for(let e=0;e<F;++e)for(let t=0;t<R;++t){let n=t-U,r=Math.max(0,Math.ceil(n/B)),a=Math.min(L,(E+n)/B);for(let s=0;s<D;++s){let i=s-G,o=Math.max(0,Math.ceil(i/W)),l=Math.min(P,(A+i)/W);for(let u=0;u<M;++u){let p=u-H,d=Math.max(0,Math.ceil(p/V)),c=Math.min(z,($+p)/V),_=0;for(let t=r;t<a;++t){let r=t*B-n;for(let n=o;n<l;++n){let a=n*W-i;for(let s=d;s<c;++s){let i=s*V-p,o=w*j+x*t+v*n+k*s,l=S*(E-1-r)+N*(A-1-a)+T*($-1-i)+C*e;for(let e=0;e<O;++e){let t=b[o+e],n=I[l+e];_+=t*n}}}}h[f*j+m*t+g*s+y*u+e]=_}}}return n.makeTensorInfo(c.shape,c.dtype,c.values)}var Nz={kernelName:Wt,backendName:"cpu",kernelFunc:Sz},Tz=dO(Vt,(e=>Math.cos(e))),Cz={kernelName:Vt,backendName:"cpu",kernelFunc:Tz},_z=dO(Ut,(e=>Math.cosh(e))),Ez={kernelName:Ut,backendName:"cpu",kernelFunc:_z};function Az(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,[p,d,c,h]=a.shape,f=s.shape[0],[m,g]=o,y=wo([f,m,g,h],"float32"),b=n.data.get(s.dataId).values,w=n.data.get(i.dataId).values,x=n.data.get(a.dataId).values,v=Aa.computeStrides(a.shape),k=Aa.computeStrides(y.shape);for(let I=0;I<f;I++){let e=4*I,t=b[e],n=b[e+1],r=b[e+2],a=b[e+3],s=w[I];if(s>=p)continue;let i=m>1?(r-t)*(d-1)/(m-1):0,o=g>1?(a-n)*(c-1)/(g-1):0;for(let p=0;p<m;p++){let e=m>1?t*(d-1)+p*i:.5*(t+r)*(d-1);if(e<0||e>d-1)for(let t=0;t<g;t++)for(let e=0;e<h;e++){let n=e+t*k[2]+p*k[1]+I*k[0];y.values[n]=u}else if("bilinear"===l){let t=Math.floor(e),r=Math.ceil(e),i=e-t;for(let e=0;e<g;e++){let l=g>1?n*(c-1)+e*o:.5*(n+a)*(c-1);if(l<0||l>c-1){for(let t=0;t<h;t++){let n=t+e*k[2]+p*k[1]+I*k[0];y.values[n]=u}continue}let d=Math.floor(l),f=Math.ceil(l),m=l-d;for(let n=0;n<h;n++){let a=n+d*v[2]+t*v[1]+s*v[0],o=x[a];a=n+f*v[2]+t*v[1]+s*v[0];let l=x[a];a=n+d*v[2]+r*v[1]+s*v[0];let u=x[a];a=n+f*v[2]+r*v[1]+s*v[0];let c=x[a],h=o+(l-o)*m,g=u+(c-u)*m;a=n+e*k[2]+p*k[1]+I*k[0],y.values[a]=h+(g-h)*i}}}else for(let t=0;t<g;++t){let r=g>1?n*(c-1)+t*o:.5*(n+a)*(c-1);if(r<0||r>c-1){for(let e=0;e<h;e++){let n=e+t*k[2]+p*k[1]+I*k[0];y.values[n]=u}continue}let i=Math.round(r),l=Math.round(e);for(let e=0;e<h;e++){let n=e+i*v[2]+l*v[1]+s*v[0],r=e+t*k[2]+p*k[1]+I*k[0];y.values[r]=x[n]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}var $z={kernelName:jt,backendName:"cpu",kernelFunc:Az};function Fz(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;zM(a,"cumprod");let l=Mw.getAxesPermutation([s],a.shape.length),u=a;null!=l&&(u=dL({inputs:{x:a},backend:n,attrs:{perm:l}}));let p=Mw.getInnerMostAxes(1,a.shape.length)[0];if(p!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${p}`);let d=Fs(u.dtype,"int32"),c=Aa.makeOnesTypedArray(Aa.sizeFromShape(u.shape),d),h=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<h.length;y+=f)for(let e=0;e<f;e++){let t=m(y,e);if(0===e)c[t]=i?1:h[t];else{let n=m(y,e-1);c[t]=i?h[n]*c[n]:h[t]*c[n]}}let g=n.makeTensorInfo(u.shape,d,c);if(null!=l){let e=Mw.getUndoAxesPermutation(l),t=dL({inputs:{x:g},backend:n,attrs:{perm:e}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),t}return g}var Rz={kernelName:Gt,backendName:"cpu",kernelFunc:Fz};function Dz(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;zM(a,"cumsum");let l=Mw.getAxesPermutation([s],a.shape.length),u=a;null!=l&&(u=dL({inputs:{x:a},backend:n,attrs:{perm:l}}));let p=Mw.getInnerMostAxes(1,a.shape.length)[0];if(p!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${p}`);let d=Fs(u.dtype,"int32"),c=Aa.makeZerosTypedArray(Aa.sizeFromShape(u.shape),d),h=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<h.length;y+=f)for(let e=0;e<f;e++){let t=m(y,e);if(0===e)c[t]=i?0:h[t];else{let n=m(y,e-1);c[t]=i?h[n]+c[n]:h[t]+c[n]}}let g=n.makeTensorInfo(u.shape,d,c);if(null!=l){let e=Mw.getUndoAxesPermutation(l),t=dL({inputs:{x:g},backend:n,attrs:{perm:e}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),t}return g}var Mz={kernelName:Ht,backendName:"cpu",kernelFunc:Dz};function Oz(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(1===a.shape.length){let e=n.data.get(a.dataId).values,t=n.data.get(s.dataId).values,r=lO(e,t,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,r)}if(2===a.shape.length){let e=n.bufferSync(a),t=n.bufferSync(s),r=uO(e,t,i,o);return n.makeTensorInfo(r.shape,s.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}var Lz={kernelName:qt,backendName:"cpu",kernelFunc:Oz};function Pz(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r;Aa.assert("NHWC"===i,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`));let o=a.shape[0],l=a.shape[1],u=a.shape[2],p=a.shape[3],d=l*s,c=u*s,h=p/(s*s),f=n.data.get(a.dataId).values,m=new Float32Array(o*d*c*h),g=0;for(let y=0;y<o;++y)for(let e=0;e<d;++e){let t=Math.floor(e/s),n=e%s;for(let e=0;e<c;++e){let r=Math.floor(e/s),a=e%s,i=(n*s+a)*h;for(let e=0;e<h;++e){let n=e+i+p*(r+u*(t+l*y));m[g++]=f[n]}}}return n.makeTensorInfo([o,d,c,h],a.dtype,m)}var zz={kernelName:Kt,backendName:"cpu",kernelFunc:Pz};function Bz(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;zM([a,s],"depthwiseConv2DNative");let p=Aa.computeStrides(a.shape),d=Aa.computeStrides(s.shape),c=l;null==c&&(c=[1,1]),Aa.assert(Mw.eitherStridesOrDilationsAreOne(i,c),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));let h=Mw.computeConv2DInfo(a.shape,s.shape,i,c,o,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=h,w=b.left,x=b.top,v=h.outChannels/h.inChannels,k=new gs(h.outShape,a.dtype),I=n.data.get(a.dataId).values,S=n.data.get(s.dataId).values,N=k.values;for(let T=0;T<h.batchSize;++T){let e=T*p[0],t=T*k.strides[0];for(let n=0;n<h.outHeight;++n){let r=t+n*k.strides[1],a=n*h.strideHeight-x;for(let t=0;t<f;++t){let n=a+t*g;if(n<0||n>=h.inHeight)continue;let s=t*d[0],i=e+n*p[1];for(let e=0;e<h.outWidth;++e){let t=r+e*k.strides[2],n=e*h.strideWidth-w;for(let e=0;e<m;++e){let r=n+e*y;if(r<0||r>=h.inWidth)continue;let a=s+e*d[1],o=i+r*h.inChannels,l=t,u=a;for(let e=0;e<h.inChannels;++e){let t=I[o+e];for(let e=0;e<v;++e)N[l+e]+=t*S[u+e];l+=v,u+=v}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}var Wz={kernelName:Xt,backendName:"cpu",kernelFunc:Bz};function Vz(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:p}=r;zM([a,s],"depthwiseConv2dNativeBackpropFilter");let d=Mw.computeConv2DInfo(a.shape,p,i,o,l,u,!0),{strideHeight:c,strideWidth:h,filterHeight:f,filterWidth:m}=d,g=new gs(d.filterShape,"float32"),y=d.padInfo.left,b=d.padInfo.top,w=d.outChannels/d.inChannels,x=n.data.get(a.dataId).values,v=new gs(a.shape,a.dtype,x),k=n.data.get(s.dataId).values,I=new gs(s.shape,s.dtype,k);for(let S=0;S<f;++S){let e=Math.max(0,Math.ceil((b-S)/c)),t=Math.min(d.outHeight,(d.inHeight+b-S)/c);for(let n=0;n<m;++n){let r=Math.max(0,Math.ceil((y-n)/h)),a=Math.min(d.outWidth,(d.inWidth+y-n)/h);for(let s=0;s<d.outChannels;++s){let i=Math.trunc(s/w),o=s%w,l=0;for(let u=0;u<d.batchSize;++u)for(let o=e;o<t;++o){let e=S+o*c-b;for(let t=r;t<a;++t){let r=n+t*h-y;l+=v.get(u,e,r,i)*I.get(u,o,t,s)}}g.set(l,S,n,i,o)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}var Uz={kernelName:Yt,backendName:"cpu",kernelFunc:Vz};function Gz(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:p}=r;zM([a,s],"depthwiseConv2DNativeBackpropInput");let d=Aa.computeStrides(a.shape),c=Aa.computeStrides(s.shape),h=Mw.computeConv2DInfo(p,s.shape,i,o,l,u,!0),f=new gs(h.inShape,"float32"),m=f.values,[g,y,b]=f.strides,w=n.data.get(a.dataId).values,[x,v,k]=d,I=n.data.get(s.dataId).values,[S,N,T]=c,{batchSize:C,filterHeight:_,filterWidth:E,inChannels:A,inHeight:$,inWidth:F,outChannels:R,outHeight:D,outWidth:M,strideHeight:O,strideWidth:L}=h,P=_-1-h.padInfo.top,z=E-1-h.padInfo.left,B=R/A;for(let W=0;W<C;++W)for(let e=0;e<A;++e)for(let t=0;t<$;++t){let n=t-P,r=Math.max(0,Math.ceil(n/O)),a=Math.min(D,(_+n)/O);for(let s=0;s<F;++s){let i=s-z,o=Math.max(0,Math.ceil(i/L)),l=Math.min(M,(E+i)/L),u=0;for(let t=r;t<a;++t){let r=t*O-n;for(let n=o;n<l;++n){let a=n*L-i,s=x*W+v*t+k*n,o=S*(_-1-r)+N*(E-1-a)+T*e;for(let t=0;t<B;++t){let n=e*B+t,r=w[s+n],a=I[o+t];u+=r*a}}}m[g*W+y*t+b*s+e]=u}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}var Hz={kernelName:Zt,backendName:"cpu",kernelFunc:Gz};function jz(e){let{inputs:t,backend:n}=e,{x:r}=t,a=Aa.sizeFromShape(r.shape),s=n.data.get(r.dataId).values,i=wo([a,a],r.dtype),o=i.values;for(let u=0;u<s.length;u++)o[u*a+u]=s[u];let l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}var qz={kernelName:Jt,backendName:"cpu",kernelFunc:jz},Kz={kernelName:Qt,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a}=e,{strides:s,pad:i,dilations:o}=n,l=t,u=l.data.get(r.dataId).values,p=r.shape.length,d=l.data.get(a.dataId).values,c=a.shape.length,{batchSize:h,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:w,strideHeight:x,strideWidth:v,filterHeight:k,filterWidth:I,dilationHeight:S,dilationWidth:N,outShape:T}=Mw.computeDilation2DInfo(r.shape,a.shape,s,i,"NHWC",o),C=Aa.sizeFromShape(T),_=T.length,E=Aa.getArrayFromDType(r.dtype,C);for(let A=0;A<h;++A)for(let e=0;e<y;++e){let t=e*x-w.top;for(let n=0;n<b;++n){let s=n*v-w.left;for(let i=0;i<g;++i){let o=Number.MIN_SAFE_INTEGER;for(let e=0;e<k;++e){let n=t+e*S;if(n>=0&&n<f)for(let t=0;t<I;++t){let l=s+t*N;if(l>=0&&l<m){let s=Aa.locToIndex([A,n,l,i],p,Aa.computeStrides(r.shape)),h=Aa.locToIndex([e,t,i],c,Aa.computeStrides(a.shape)),f=u[s]+d[h];f>o&&(o=f)}}}let l=Aa.locToIndex([A,e,n,i],_,Aa.computeStrides(T));E[l]=o}}}return{dataId:l.write(Aa.toTypedArray(E,r.dtype),T,r.dtype),shape:T,dtype:r.dtype}}},Xz={kernelName:tn,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a,dy:s}=e,{strides:i,pad:o,dilations:l}=n,u=t,p=Aa.toNestedArray(r.shape,u.data.get(r.dataId).values),d=Aa.toNestedArray(a.shape,u.data.get(a.dataId).values),{batchSize:c,inHeight:h,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:w,strideWidth:x,filterHeight:v,filterWidth:k,dilationHeight:I,dilationWidth:S,outShape:N}=Mw.computeDilation2DInfo(r.shape,a.shape,i,o,"NHWC",l);Aa.assert(s.rank===N.length,(()=>`Error in ${tn}, dy must have the same rank as output ${N.length}, but got ${s.rank}`));let T=Aa.toNestedArray(N,u.data.get(s.dataId).values),C=Aa.makeZerosNestedTypedArray(a.shape,a.dtype);for(let _=0;_<c;++_)for(let e=0;e<g;++e){let t=e*w-b.top;for(let n=0;n<y;++n){let r=n*x-b.left;for(let a=0;a<m;++a){let s=Number.MIN_SAFE_INTEGER,i=0,o=0;for(let e=0;e<v;++e){let n=t+e*I;if(n>=0&&n<h)for(let t=0;t<k;++t){let l=r+t*S;if(l>=0&&l<f){let r=p[_][n][l][a]+d[e][t][a];r>s&&(s=r,i=e,o=t)}}}C[i][o][a]+=T[_][e][n][a]}}}return{dataId:u.write(Aa.toTypedArray(C,r.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},Yz={kernelName:en,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a,dy:s}=e,{strides:i,pad:o,dilations:l}=n,u=t,p=Aa.toNestedArray(r.shape,u.data.get(r.dataId).values),d=Aa.toNestedArray(a.shape,u.data.get(a.dataId).values),{batchSize:c,inHeight:h,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:w,strideWidth:x,filterHeight:v,filterWidth:k,dilationHeight:I,dilationWidth:S,outShape:N}=Mw.computeDilation2DInfo(r.shape,a.shape,i,o,"NHWC",l);Aa.assert(s.rank===N.length,(()=>`Error in ${en}, dy must have the same rank as output ${N.length}, but got ${s.rank}`));let T=Aa.toNestedArray(N,u.data.get(s.dataId).values),C=Aa.makeZerosNestedTypedArray(r.shape,r.dtype);for(let _=0;_<c;++_)for(let e=0;e<g;++e){let t=e*w-b.top;for(let n=0;n<y;++n){let r=n*x-b.left;for(let a=0;a<m;++a){let s=Number.MIN_SAFE_INTEGER,i=t<0?0:t,o=r<0?0:r;for(let e=0;e<v;++e){let n=t+e*I;if(n>=0&&n<h)for(let t=0;t<k;++t){let l=r+t*S;if(l>=0&&l<f){let r=p[_][n][l][a]+d[e][t][a];r>s&&(s=r,i=n,o=l)}}}C[_][i][o][a]+=T[_][e][n][a]}}}return{dataId:u.write(Aa.toTypedArray(C,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function Zz(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{axis:i,keepDims:o}=a;zM(s,"sum"),t="bool"===s.dtype?eO({inputs:{x:s},backend:r,attrs:{dtype:"int32"}}):YM({inputs:{x:s},backend:r});let l=t.shape.length,u=Aa.parseAxisParam(i,t.shape),p=Mw.getAxesPermutation(u,l),d=u,c=t;null!=p&&(c=dL({inputs:{x:t},backend:r,attrs:{perm:p}}),d=Mw.getInnerMostAxes(d.length,l)),Mw.assertAxesAreInnerMostDims("sum",d,c.shape.length);let[h,f]=Mw.computeOutAndReduceShapes(c.shape,d),m=Mw.upcastType(c.dtype,"int32"),g=XM(r,h,m),y=Aa.sizeFromShape(f),b=r.data.get(g.dataId).values,w=r.data.get(c.dataId).values;for(let x=0;x<b.length;++x){let e=x*y,t=0;for(let n=0;n<y;++n)t+=w[e+n];b[x]=t}if(o){let e=Mw.expandShapeToKeepDim(g.shape,u),t=g;g=uP({inputs:{x:g},backend:r,attrs:{shape:e}}),r.disposeIntermediateTensorInfo(t)}return r.disposeIntermediateTensorInfo(t),null!=p&&r.disposeIntermediateTensorInfo(c),g}var Jz={kernelName:Pr,backendName:"cpu",kernelFunc:Zz};function Qz(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=Mw.decodeEinsumEquation(a,s.length);Mw.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:p}=Mw.getEinsumComputePath(o,l),d=p.length,c=null,h=i.length,f=[];for(let m=0;m<d;++m){for(let e of p[m]){let t,{permutationIndices:r,expandDims:a}=Mw.getEinsumPermutation(h,l[e]);Mw.isIdentityPermutation(r)?t=s[e]:(t=dL({inputs:{x:s[e]},backend:n,attrs:{perm:r}}),f.push(t));let i=t.shape.slice();for(let e=0;e<a.length;++e)i.splice(a[e],0,1);Aa.arraysEqual(t.shape,i)||(t=uP({inputs:{x:t},backend:n,attrs:{shape:i}}),f.push(t)),null===c?c=t:(c=nL({inputs:{a:t,b:c},backend:n}),f.push(c))}m<d-1&&(u[m]>=0&&(c=Zz({inputs:{x:c},backend:n,attrs:{axis:u[m]-(i.length-h),keepDims:!1}}),f.push(c)),h--)}for(let m of f)m!==c&&n.disposeIntermediateTensorInfo(m);return c}var eB={kernelName:rn,backendName:"cpu",kernelFunc:Qz};function tB(e){let{inputs:t,backend:n}=e,{dy:r,y:a}=t;zM([r,a],"eluGrad");let s=new Float32Array(Aa.sizeFromShape(a.shape)),i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<i.length;++l){let e=i[l];s[l]=e>=1?o[l]:o[l]*(e+1)}return n.makeTensorInfo(a.shape,"float32",s)}var nB={kernelName:sn,backendName:"cpu",kernelFunc:tB},rB=Mw.ERF_P,aB=Mw.ERF_A1,sB=Mw.ERF_A2,iB=Mw.ERF_A3,oB=Mw.ERF_A4,lB=Mw.ERF_A5,uB=dO(on,(e=>{let t=Math.sign(e),n=Math.abs(e),r=1/(1+rB*n);return t*(1-((((lB*r+oB)*r+iB)*r+sB)*r+aB)*r*Math.exp(-n*n))})),pB={kernelName:on,backendName:"cpu",kernelFunc:uB};function dB(e){let{inputs:t,backend:n,attrs:r}=e,{input:a}=t,{dim:s}=r,i=a.shape.length,o=a.shape.slice(),l=s;return s<0&&(Aa.assert(-(i+1)<=s,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+s+1),o.splice(l,0,1),uP({inputs:{x:a},backend:n,attrs:{shape:o}})}var cB={kernelName:pn,backendName:"cpu",kernelFunc:dB},hB=jM(((e,t)=>e/t)),fB=nO(nn,hB),mB={kernelName:nn,backendName:"cpu",kernelFunc:fB};function gB(e,t,n){let r=e.shape,a=r[0],s=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[a,s],p=Aa.sizeFromShape(u),d=Aa.getTypedArrayFromDType("float32",p),c=Aa.getTypedArrayFromDType("float32",p);for(let g=0;g<a;g++){let e=NL({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,s]}}),r=NL({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,s]}}),a=qM({inputs:{real:e,imag:r},backend:n}),{real:i,imag:u}=yB(a,t,n),p=Mw.mergeRealAndImagArrays(i,u);for(let t=0;t<s;t++){let e=Mw.getComplexWithIndex(p,t);d[g*s+t]=e.real,c[g*s+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a)}let h=n.makeTensorInfo(u,"float32",d),f=n.makeTensorInfo(u,"float32",c),m=qM({inputs:{real:h,imag:f},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),m}function yB(e,t,n){let r=Aa.sizeFromShape(e.shape),a=n.data.get(e.dataId),s=n.data.get(a.complexTensorInfos.real.dataId).values,i=n.data.get(a.complexTensorInfos.imag.dataId).values;if(bB(r)){let a=wB(s,i,r,t,n),o=[e.shape[0],e.shape[1]];if(t){let e=n.makeTensorInfo(o,"float32",a.real),t=n.makeTensorInfo(o,"float32",a.imag),s=n.makeTensorInfo([],"float32",Aa.createScalarValue(r,"float32")),i=YM({inputs:{x:s},backend:n}),l=mB.kernelFunc({inputs:{a:e,b:s},backend:n}),u=mB.kernelFunc({inputs:{a:t,b:i},backend:n}),p=n.data.get(l.dataId).values,d=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),{real:p,imag:d}}return a}{let e=Mw.mergeRealAndImagArrays(s,i),n=xB(e,r,t);return Mw.splitRealAndImagArrays(n)}}function bB(e){return 0===(e&e-1)}function wB(e,t,n,r,a){if(1===n)return{real:e,imag:t};let s=Mw.mergeRealAndImagArrays(e,t),i=n/2,o=Mw.complexWithEvenIndex(s),l=o.real,u=o.imag,p=[l.length],d=a.makeTensorInfo(p,"float32",l),c=a.makeTensorInfo(p,"float32",u),h=qM({inputs:{real:d,imag:c},backend:a}),f=Mw.complexWithOddIndex(s),m=f.real,g=f.imag,y=[m.length],b=a.makeTensorInfo(y,"float32",m),w=a.makeTensorInfo(y,"float32",g),x=qM({inputs:{real:b,imag:w},backend:a}),v=wB(l,u,i,r,a),k=v.real,I=v.imag,S=[k.length],N=a.makeTensorInfo(S,"float32",k),T=a.makeTensorInfo(S,"float32",I),C=qM({inputs:{real:N,imag:T},backend:a}),_=wB(m,g,i,r,a),E=_.real,A=_.imag,$=[E.length],F=a.makeTensorInfo($,"float32",E),R=a.makeTensorInfo($,"float32",A),D=qM({inputs:{real:F,imag:R},backend:a}),M=Mw.exponents(n,r),O=[M.real.length],L=a.makeTensorInfo(O,"float32",M.real),P=a.makeTensorInfo(O,"float32",M.imag),z=qM({inputs:{real:L,imag:P},backend:a}),B=nL({inputs:{a:z,b:D},backend:a}),W=iO({inputs:{a:C,b:B},backend:a}),V=GL({inputs:{a:C,b:B},backend:a}),U=JM({inputs:{input:W},backend:a}),G=JM({inputs:{input:V},backend:a}),H=pz({inputs:{input:W},backend:a}),j=pz({inputs:{input:V},backend:a}),q=cz({inputs:[U,G],backend:a,attrs:{axis:0}}),K=cz({inputs:[H,j],backend:a,attrs:{axis:0}}),X=a.data.get(q.dataId).values,Y=a.data.get(K.dataId).values;return a.disposeIntermediateTensorInfo(d),a.disposeIntermediateTensorInfo(c),a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(w),a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(N),a.disposeIntermediateTensorInfo(T),a.disposeIntermediateTensorInfo(C),a.disposeIntermediateTensorInfo(F),a.disposeIntermediateTensorInfo(R),a.disposeIntermediateTensorInfo(D),a.disposeIntermediateTensorInfo(L),a.disposeIntermediateTensorInfo(P),a.disposeIntermediateTensorInfo(z),a.disposeIntermediateTensorInfo(B),a.disposeIntermediateTensorInfo(W),a.disposeIntermediateTensorInfo(V),a.disposeIntermediateTensorInfo(U),a.disposeIntermediateTensorInfo(H),a.disposeIntermediateTensorInfo(G),a.disposeIntermediateTensorInfo(j),a.disposeIntermediateTensorInfo(q),a.disposeIntermediateTensorInfo(K),{real:X,imag:Y}}function xB(e,t,n){let r=new Float32Array(2*t);for(let a=0;a<t;a++){let s=0,i=0;for(let r=0;r<t;r++){let o=Mw.exponent(a*r,t,n),l=Mw.getComplexWithIndex(e,r);s+=l.real*o.real-l.imag*o.imag,i+=l.real*o.imag+l.imag*o.real}n&&(s/=t,i/=t),Mw.assignToTypedArray(r,s,i,a)}return r}function vB(e){let{inputs:t,backend:n}=e,{input:r}=t,a=Aa.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=a/s,o=uP({inputs:{x:r},backend:n,attrs:{shape:[i,s]}}),l=gB(o,!1,n),u=uP({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}var kB={kernelName:cn,backendName:"cpu",kernelFunc:vB};function IB(e){let{backend:t,attrs:n}=e,{shape:r,value:a,dtype:s}=n,i=s||Aa.inferDtype(a),o=Aa.getArrayFromDType(i,Aa.sizeFromShape(r));return NB(o,a,i),t.makeTensorInfo(r,i,o)}var SB={kernelName:hn,backendName:"cpu",kernelFunc:IB};function NB(e,t,n){e.fill(t)}var TB={kernelName:fn,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,a=n,s=Aa.getTypedArrayFromDType(r.dtype,Aa.sizeFromShape(r.shape)),[i,o,l,u]=r.shape,p=a.data.get(r.dataId).values;for(let d=0;d<i;d++){let e=d*l*o*u;for(let t=0;t<o;t++){let n=t*(l*u);for(let t=0;t<l;t++){let r=t*u;for(let a=0;a<u;a++){let i=Math.round(l-t-1),o=e+n+r+a,d=p[o];if(i>=0&&i<l){let t=i*u,r=e+n+t+a;d=p[r]}s[o]=d}}}}return{dataId:a.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},CB=jM(((e,t)=>Math.floor(e/t))),_B=nO(gn,CB,null,"int32"),EB={kernelName:gn,backendName:"cpu",kernelFunc:_B};function AB(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:p,dilations:d,dimRoundingMode:c,activation:h,leakyreluAlpha:f}=r,m=fz({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:p,dilations:d,dimRoundingMode:c}});if(i){let e=m;if("NCHW"===p&&1===i.shape.length&&1!==i.shape[0]){let e=uP({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=iO({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=iO({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(e)}if(h){let e=m;if("NCHW"===p&&"prelu"===h&&1===o.shape.length&&1!==o.shape[0]){let e=uP({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=lP(n,m,h,e,f),n.disposeIntermediateTensorInfo(e)}else m=lP(n,m,h,o,f);n.disposeIntermediateTensorInfo(e)}return m}var $B={kernelName:ma,backendName:"cpu",kernelFunc:AB};function FB(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:p,dilations:d,dimRoundingMode:c,activation:h,leakyreluAlpha:f}=r,m=Bz({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:p,dilations:d,dimRoundingMode:c}});if(i){let e=m;m=iO({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(h){let e=m;m=lP(n,m,h,o,f),n.disposeIntermediateTensorInfo(e)}return m}var RB={kernelName:ga,backendName:"cpu",kernelFunc:FB};function DB(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=Aa.sizeFromShape(r.shape),i=a.shape,o=i[i.length-1],[l,u,p,d]=Mw.prepareAndValidate(r,a);if(0===u)return n.makeTensorInfo(l,r.dtype,[]);let c=n.data.get(a.dataId).values,h=n.bufferSync(r),f=EO(c,h,r.dtype,u,o,p,d,r.shape,s);return n.makeTensorInfo(l,r.dtype,f.values)}var MB={kernelName:wn,backendName:"cpu",kernelFunc:DB};function OB(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r;zM([a,s],"gatherV2");let l=Aa.parseAxisParam(i,a.shape)[0],u=n.data.get(s.dataId).values,p=a.shape[l];for(let x=0;x<u.length;++x){let e=u[x];Aa.assert(e<=p-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${p-1}]`))}let d=o;null==o&&(d=0);let c=Aa.sizeFromShape(s.shape),h=Mw.segment_util.collectGatherOpShapeInfo(a,s,l,d),f=uP({inputs:{x:a},backend:n,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),m=uP({inputs:{x:s},backend:n,attrs:{shape:[h.batchSize,c/h.batchSize]}}),g=[h.batchSize,h.outerSize,c/h.batchSize,h.sliceSize],y=n.bufferSync(m),b=n.bufferSync(f),w=AO(b,y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(h.outputShape,w.dtype,w.values)}var LB={kernelName:bn,backendName:"cpu",kernelFunc:OB};function PB(e){let{inputs:t,backend:n}=e,{input:r}=t,a=Aa.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=a/s,o=uP({inputs:{x:r},backend:n,attrs:{shape:[i,s]}}),l=gB(o,!0,n),u=uP({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}var zB={kernelName:In,backendName:"cpu",kernelFunc:PB},BB=dO(Nn,(e=>Number.isFinite(e)?1:0),"bool"),WB={kernelName:Nn,backendName:"cpu",kernelFunc:BB},VB=dO(Tn,(e=>Math.abs(e)===1/0?1:0),"bool"),UB={kernelName:Tn,backendName:"cpu",kernelFunc:VB},GB=dO(Cn,(e=>Number.isNaN(e)?1:0),"bool"),HB={kernelName:Cn,backendName:"cpu",kernelFunc:GB};function jB(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=UO(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}var qB={kernelName:$n,backendName:"cpu",kernelFunc:jB},KB=dO(Rn,(e=>Math.log1p(e))),XB={kernelName:Rn,backendName:"cpu",kernelFunc:KB},YB=jM(((e,t)=>e&&t)),ZB=nO(Dn,YB,null,"bool"),JB={kernelName:Dn,backendName:"cpu",kernelFunc:ZB},QB=dO(Mn,(e=>e?0:1),"bool"),eW={kernelName:Mn,backendName:"cpu",kernelFunc:QB},tW=jM(((e,t)=>e||t)),nW=nO(On,tW,null,"bool"),rW={kernelName:On,backendName:"cpu",kernelFunc:nW};function aW(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r;zM(a,"LRN");let u=a.shape[3],p=u-1,d=n.data.get(a.dataId).values,c=Aa.sizeFromShape(a.shape),h=new Float32Array(c);function f(e){let t=e%u,n=e-t+Math.max(0,t-s),r=e-t+Math.min(t+s,p),a=0;for(;n<=r;n++){let e=d[n];a+=e*e}return a}for(let m=0;m<c;m++){let e=f(m),t=d[m]*Math.pow(i+o*e,-l);h[m]=t}return n.makeTensorInfo(a.shape,a.dtype,h)}var sW={kernelName:zn,backendName:"cpu",kernelFunc:aW};function iW(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:p}=r;zM(i,"LRNGrad");let d=Aa.sizeFromShape(i.shape),c=i.shape[3],h=n.data.get(i.dataId).values,f=n.data.get(a.dataId).values,m=n.data.get(s.dataId).values,g=new Float32Array(d),y=d;for(let b=0;b<y;b++){let e=b%c,t=b-e+Math.max(0,e-o),n=b-e+Math.min(c,e+o+1),r=0;for(let a=t;a<n;a++)r+=Math.pow(f[a],2);r=u*r+l;for(let a=t;a<n;a++){let e=-2*u*p*f[a]*m[b]/r;b===a&&(e+=Math.pow(r,-p)),e*=h[b],g[a]+=e}}return n.makeTensorInfo(i.shape,a.dtype,g)}var oW={kernelName:Bn,backendName:"cpu",kernelFunc:iW};function lW(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=n,l=a.shape,u=l.length,p=Aa.parseAxisParam(s,l),d=p,c=Mw.getAxesPermutation(d,u),h=o.data.get(a.dataId).values;if(null!=c){let e=new Array(u);for(let t=0;t<e.length;t++)e[t]=l[c[t]];h=pL(h,l,a.dtype,c,e),d=Mw.getInnerMostAxes(d.length,u),l=e}zM(a,"max"),Mw.assertAxesAreInnerMostDims("max",d,u);let[f,m]=Mw.computeOutAndReduceShapes(l,d),g=Aa.sizeFromShape(m),y=qO(h,g,f,a.dtype),b=o.write(y,f,a.dtype),w=f;return i&&(w=Mw.expandShapeToKeepDim(f,p)),{dataId:b,shape:w,dtype:a.dtype}}var uW={kernelName:Wn,backendName:"cpu",kernelFunc:lW};function pW(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;zM(a,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,u=1;Aa.assert(Mw.eitherStridesOrDilationsAreOne(i,u),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`));let p,d=Mw.computePool2DInfo(a.shape,s,i,u,o,l);if(1===d.filterWidth&&1===d.filterHeight&&Aa.arraysEqual(d.inShape,d.outShape))p=YM({inputs:{x:a},backend:n});else{let e=n.data.get(a.dataId).values,t=Aa.computeStrides(a.shape),r=BP(e,a.shape,a.dtype,t,d,"max");p=n.makeTensorInfo(d.outShape,a.dtype,r.values)}return p}var dW={kernelName:Un,backendName:"cpu",kernelFunc:pW};function cW(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;zM(a,"maxPool3d");let p=Mw.computePool3DInfo(a.shape,s,i,1,o,l,u),d=n.data.get(a.dataId).values,c=VP(d,a.shape,a.dtype,Aa.computeStrides(a.shape),p,"max");return n.makeTensorInfo(c.shape,"float32",c.values)}var hW={kernelName:Hn,backendName:"cpu",kernelFunc:cW};function fW(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;zM([a,s],"maxPool3DGrad");let p=Mw.computePool3DInfo(s.shape,i,o,1,l,u),d=n.bufferSync(s),c=UP(d,p),h=p.strideDepth,f=p.strideHeight,m=p.strideWidth,g=p.dilationDepth,y=p.dilationHeight,b=p.dilationWidth,w=p.effectiveFilterDepth,x=p.effectiveFilterHeight,v=p.effectiveFilterWidth,k=w-1-p.padInfo.front,I=v-1-p.padInfo.left,S=x-1-p.padInfo.top,N=wo(s.shape,"float32"),T=n.bufferSync(a);for(let C=0;C<p.batchSize;++C)for(let e=0;e<p.inChannels;++e)for(let t=0;t<p.inDepth;++t)for(let n=0;n<p.inHeight;++n)for(let r=0;r<p.inWidth;++r){let a=t-k,s=n-S,i=r-I,o=0;for(let t=0;t<w;t+=g){let n=(a+t)/h;if(!(n<0||n>=p.outDepth||Math.floor(n)!==n))for(let r=0;r<x;r+=y){let a=(s+r)/f;if(!(a<0||a>=p.outHeight||Math.floor(a)!==a))for(let s=0;s<v;s+=b){let l=(i+s)/m;if(l<0||l>=p.outWidth||Math.floor(l)!==l)continue;let u=w*x*v-1-c.get(C,n,a,l,e),d=t*x*v+r*v+s,h=u===d?1:0;0!==h&&(o+=T.get(C,n,a,l,e)*h)}}}N.set(o,C,t,n,r,e)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}var mW={kernelName:jn,backendName:"cpu",kernelFunc:fW};function gW(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;zM([s,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:p,dimRoundingMode:d}=r,c=Mw.computePool2DInfo(o.shape,l,u,1,p,d),h=n.data.get(o.dataId).values,f=wo(c.outShape,o.dtype,WP(h,o.shape,o.dtype,c).values),m=c.strideHeight,g=c.strideWidth,y=c.dilationHeight,b=c.dilationWidth,w=c.effectiveFilterHeight,x=c.effectiveFilterWidth,v=x-1-c.padInfo.left,k=w-1-c.padInfo.top,I=wo(o.shape,"float32"),S=n.data.get(a.dataId).values,N=wo(a.shape,"float32",S);for(let T=0;T<c.batchSize;++T)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inHeight;++t)for(let n=0;n<c.inWidth;++n){let r=t-k,a=n-v,s=0;for(let t=0;t<w;t+=y){let n=(r+t)/m;if(!(n<0||n>=c.outHeight||Math.floor(n)!==n))for(let r=0;r<x;r+=b){let i=(a+r)/g;if(i<0||i>=c.outWidth||Math.floor(i)!==i)continue;let o=w*x-1-f.get(T,n,i,e),l=t*x+r,u=o===l?1:0;0!==u&&(s+=N.get(T,n,i,e)*u)}}I.set(s,T,t,n,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}var yW={kernelName:Gn,backendName:"cpu",kernelFunc:gW};function bW(e,t,n,r,a){let s=Aa.computeStrides(t),i=BP(e,t,n,s,a,"max"),o=WP(e,t,n,a,!0,r);return[i.values,o.values]}var wW={kernelName:qn,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:a,strides:s,pad:i,includeBatchInIndex:o}=t,l=n;zM(r,"MaxPoolWithArgmax");let u=l.data.get(r.dataId).values,p=Mw.computePool2DInfo(r.shape,a,s,[1,1],i),[d,c]=bW(u,r.shape,r.dtype,o,p),h=l.write(d,p.outShape,r.dtype),f=l.write(c,p.outShape,r.dtype);return[{dataId:h,shape:p.outShape,dtype:r.dtype},{dataId:f,shape:p.outShape,dtype:"int32"}]}};function xW(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=Aa.parseAxisParam(s,a.shape),l=Mw.computeOutAndReduceShapes(a.shape,o)[1],u=Aa.sizeFromShape(l),p=[],d=n.makeTensorInfo([],"float32",new Float32Array([u]));p.push(d);let c=eO({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});p.push(c);let h=fB({inputs:{a:c,b:d},backend:n});p.push(h);let f=Zz({inputs:{x:h},backend:n,attrs:{axis:s,keepDims:i}});return p.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}var vW={kernelName:Kn,backendName:"cpu",kernelFunc:xW};function kW(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;zM(a,"min");let o=Aa.parseAxisParam(s,a.shape),l=o,u=Mw.getAxesPermutation(l,a.shape.length),p=a;null!=u&&(p=dL({inputs:{x:a},backend:n,attrs:{perm:u}}),l=Mw.getInnerMostAxes(l.length,a.shape.length)),Mw.assertAxesAreInnerMostDims("min",l,p.shape.length);let[d,c]=Mw.computeOutAndReduceShapes(p.shape,l),h=Aa.sizeFromShape(c),f=Aa.makeZerosTypedArray(Aa.sizeFromShape(d),p.dtype),m=n.data.get(p.dataId).values;for(let y=0;y<f.length;++y){let e=y*h,t=m[e];for(let n=0;n<h;++n){let r=m[e+n];(Number.isNaN(r)||r<t)&&(t=r)}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(p);let g=n.makeTensorInfo(d,p.dtype,f);if(i){let e=Mw.expandShapeToKeepDim(d,o),t=uP({inputs:{x:g},backend:n,attrs:{shape:e}});return n.disposeIntermediateTensorInfo(g),t}return g}var IW={kernelName:Xn,backendName:"cpu",kernelFunc:kW};function SW(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,mode:i}=r;zM(a,"mirrorPad");let o=s.map(((e,t)=>e[0]+a.shape[t]+e[1])),l=s.map((e=>e[0])),u=s.map(((e,t)=>e[0]+a.shape[t])),p="reflect"===i?0:1,d=n.data.get(a.dataId).values,c=a.shape.length,h=Aa.computeStrides(a.shape),f=Aa.sizeFromShape(o),m=o.length,g=Aa.computeStrides(o),y=Aa.getTypedArrayFromDType(a.dtype,f);for(let b=0;b<f;b++){let e=Aa.indexToLoc(b,m,g);for(let n=0;n<m;n++)e[n]<l[n]?e[n]=2*l[n]-e[n]-p:e[n]>=u[n]&&(e[n]=2*(u[n]-1)-e[n]+p);e=e.map(((e,t)=>e-l[t]));let t=Aa.locToIndex(e,c,h);y[b]=d[t]}return{dataId:n.write(y,o,a.dtype),shape:o,dtype:a.dtype}}var NW={kernelName:Zn,backendName:"cpu",kernelFunc:SW},TW=jM(((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),CW=nO(Jn,TW),_W={kernelName:Jn,backendName:"cpu",kernelFunc:CW},EW=I(M());function AW(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=a.shape.length,o=s;if(-1===o&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);let l=Aa.parseAxisParam([o],a.shape),u=lW({inputs:{x:a},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),p=Mw.expandShapeToKeepDim(u.shape,l),d=uP({inputs:{x:u},backend:n,attrs:{shape:p}}),c=GL({inputs:{a:a,b:d},backend:n}),h=vO({inputs:{x:c},backend:n}),f=Zz({inputs:{x:h},backend:n,attrs:{axis:l,keepDims:!1}}),m=uP({inputs:{x:f},backend:n,attrs:{shape:p}}),g=fB({inputs:{a:h,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var $W={kernelName:Wr,backendName:"cpu",kernelFunc:AW};function FW(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r;zM(a,"multinomial");let l=o?a:AW({inputs:{logits:a},backend:n,attrs:{dim:-1}}),u=l.shape[0],p=l.shape[1],d=n.data.get(l.dataId).values,c=[u,s],h=Aa.makeZerosTypedArray(Aa.sizeFromShape(c),"int32");for(let f=0;f<u;++f){let e=f*p,t=new Float32Array(p-1);t[0]=d[e];for(let a=1;a<t.length;++a)t[a]=t[a-1]+d[e+a];let n=EW.alea(i.toString()),r=f*s;for(let a=0;a<s;++a){let e=n();h[r+a]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){h[r+a]=n;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(c,"int32",h)}var RW={kernelName:Qn,backendName:"cpu",kernelFunc:FW},DW=Lx.nonMaxSuppressionV3Impl;function MW(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;zM(a,"NonMaxSuppression");let u=n.data.get(a.dataId).values,p=n.data.get(s.dataId).values,{selectedIndices:d}=DW(u,p,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}var OW={kernelName:rr,backendName:"cpu",kernelFunc:MW},LW=Lx.nonMaxSuppressionV4Impl;function PW(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;zM(a,"NonMaxSuppressionPadded");let p=n.data.get(a.dataId).values,d=n.data.get(s.dataId).values,{selectedIndices:c,validOutputs:h}=LW(p,d,i,o,l,u);return[n.makeTensorInfo([c.length],"int32",new Int32Array(c)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}var zW={kernelName:ar,backendName:"cpu",kernelFunc:PW},BW=Lx.nonMaxSuppressionV5Impl;function WW(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;zM(a,"NonMaxSuppressionWithScore");let p=n.data.get(a.dataId).values,d=n.data.get(s.dataId).values,c=i,h=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=BW(p,d,c,h,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var VW={kernelName:sr,backendName:"cpu",kernelFunc:WW};function UW(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{depth:s,onValue:i,offValue:o}=r;zM(a,"oneHot");let l=Aa.sizeFromShape(a.shape),u=new Float32Array(l*s);u.fill(o);let p=n.data.get(a.dataId).values;for(let d=0;d<l;++d)p[d]>=0&&p[d]<s&&(u[d*s+p[d]]=i);return n.makeTensorInfo([...a.shape,s],"int32",u)}var GW={kernelName:or,backendName:"cpu",kernelFunc:UW};function HW(e){let{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){let e=JM({inputs:{input:r},backend:n}),t=HW({inputs:{x:e},backend:n}),a=pz({inputs:{input:r},backend:n}),s=HW({inputs:{x:a},backend:n}),i=qM({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}return IB({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var jW={kernelName:pa,backendName:"cpu",kernelFunc:HW};function qW(e){let{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){let e=JM({inputs:{input:r},backend:n}),t=qW({inputs:{x:e},backend:n}),a=pz({inputs:{input:r},backend:n}),s=HW({inputs:{x:a},backend:n}),i=qM({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}return IB({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}var KW={kernelName:ir,backendName:"cpu",kernelFunc:qW};function XW(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return dB({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach((e=>{Aa.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),Aa.assert(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));let o=[],l=t.map((e=>{let t=dB({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),u=cz({inputs:l,backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}var YW={kernelName:lr,backendName:"cpu",kernelFunc:XW};function ZW(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;zM(a,"pad");let o=s.map(((e,t)=>e[0]+a.shape[t]+e[1])),l=s.map((e=>e[0])),u=n.data.get(a.dataId).values,p=Aa.sizeFromShape(a.shape),d=a.shape.length,c=Aa.computeStrides(a.shape),h=Aa.sizeFromShape(o),f=o.length,m=Aa.computeStrides(o),g=Aa.getTypedArrayFromDType(a.dtype,h);0!==i&&g.fill(i);for(let y=0;y<p;y++){let e=Aa.indexToLoc(y,d,c).map(((e,t)=>e+l[t])),t=Aa.locToIndex(e,f,m);g[t]=u[y]}return{dataId:n.write(g,o,a.dtype),shape:o,dtype:a.dtype}}var JW={kernelName:ur,backendName:"cpu",kernelFunc:ZW},QW=jM(((e,t)=>Math.pow(e,t))),eV=nO(dr,QW),tV={kernelName:dr,backendName:"cpu",kernelFunc:eV};function nV(e){let{backend:t,attrs:n}=e,{start:r,stop:a,dtype:s,step:i}=n,o=gL(r,a,i,s);return t.makeTensorInfo([o.length],s,o)}var rV={kernelName:fr,backendName:"cpu",kernelFunc:nV},aV=dO(gr,(e=>1/e)),sV={kernelName:gr,backendName:"cpu",kernelFunc:aV};function iV(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;zM(a,"resizeBilinear");let l=Aa.computeStrides(a.shape),[u,p]=o,[d,c,h,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(Aa.sizeFromShape([d,u,p,f])),y=[s&&u>1?c-1:c,s&&p>1?h-1:h],b=[s&&u>1?u-1:u,s&&p>1?p-1:p],w=0,x=y[0]/b[0],v=y[1]/b[1];for(let k=0;k<d;k++)for(let e=0;e<u;e++){let t;t=i?x*(e+.5)-.5:x*e;let n=Math.max(0,Math.floor(t)),r=t-n,a=Math.min(c-1,Math.ceil(t)),s=k*l[0]+n*l[1],o=k*l[0]+a*l[1];for(let e=0;e<p;e++){let t;t=i?v*(e+.5)-.5:v*e;let n=Math.max(0,Math.floor(t)),a=t-n,u=Math.min(h-1,Math.ceil(t)),p=s+n*l[2],d=o+n*l[2],c=s+u*l[2],y=o+u*l[2];for(let e=0;e<f;e++){let t=m[p+e],n=m[d+e],s=m[c+e],i=m[y+e],o=t+(s-t)*a,l=n+(i-n)*a,u=o+(l-o)*r;g[w++]=u}}}return n.makeTensorInfo([d,u,p,f],"float32",g)}var oV={kernelName:vr,backendName:"cpu",kernelFunc:iV};function lV(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;zM([s,a],"resizeBilinearGrad");let o=Aa.computeStrides(a.shape),[l,u,p,d]=a.shape,[,c,h]=s.shape,f=new Float32Array(l*u*p*d),m=[i&&c>1?u-1:u,i&&h>1?p-1:p],g=[i&&c>1?c-1:c,i&&h>1?h-1:h],y=m[0]/g[0],b=m[1]/g[1],w=n.data.get(s.dataId).values,x=0;for(let v=0;v<l;v++){let e=v*o[0];for(let t=0;t<c;t++){let n=t*y,r=Math.floor(n),a=Math.min(Math.ceil(n),u-1),s=e+r*o[1],i=e+a*o[1],l=n-r,c=1-l;for(let e=0;e<h;e++){let t=e*b,n=Math.floor(t),r=Math.min(Math.ceil(t),p-1),a=t-n,u=1-a,h=s+n*o[2],m=s+r*o[2],g=i+n*o[2],y=i+r*o[2],v=c*u,k=c*a,I=l*u,S=l*a;for(let e=0;e<d;e++){let t=w[x++];f[h+e]+=t*v,f[m+e]+=t*k,f[g+e]+=t*I,f[y+e]+=t*S}}}}return n.makeTensorInfo([l,p,u,d],"float32",f)}var uV={kernelName:kr,backendName:"cpu",kernelFunc:lV};function pV(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;zM(a,"resizeNearestNeighbor");let l=Aa.computeStrides(a.shape),[u,p]=o,[d,c,h,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(d*u*p*f),y=[s&&u>1?c-1:c,s&&p>1?h-1:h],b=[s&&u>1?u-1:u,s&&p>1?p-1:p],w=y[0]/b[0],x=y[1]/b[1],v=0;for(let k=0;k<d;k++){let e=k*l[0];for(let t=0;t<u;t++){let n=i?w*(t+.5):w*t,r=Math.min(c-1,s?Math.round(n):Math.floor(n));i&&(r=Math.max(0,r));let a=e+r*l[1];for(let e=0;e<p;e++){let t=i?x*(e+.5):x*e,n=Math.min(h-1,s?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));let r=a+n*l[2];for(let e=0;e<f;e++){let t=m[r+e];g[v++]=t}}}}return n.makeTensorInfo([d,u,p,f],a.dtype,g)}var dV={kernelName:wr,backendName:"cpu",kernelFunc:pV};function cV(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;zM([s,a],"resizeNearestNeighborGrad");let o=Aa.computeStrides(a.shape),l=Aa.computeStrides(s.shape),[u,p,d,c]=a.shape,[,h,f]=s.shape,m=new Float32Array(u*p*d*c),g=n.data.get(s.dataId).values,y=[i&&h>1?p-1:p,i&&f>1?d-1:d],b=[i&&h>1?h-1:h,i&&f>1?f-1:f],w=y[0]/b[0],x=y[1]/b[1],v=1/w,k=1/x,I=2*Math.ceil(v)+2,S=2*Math.ceil(k)+2;for(let N=0;N<u;N++){let e=N*o[0];for(let t=0;t<p;t++){let n=e+t*o[1],r=Math.floor(t*v),a=Math.floor(r-I/2);for(let s=0;s<d;s++){let r=n+s*o[2],u=Math.floor(s*k),y=Math.floor(u-S/2);for(let n=0;n<c;n++){let o=0;for(let r=0;r<I;r++){let u=r+a;if(u<0||u>=h)continue;let c=e+u*l[1],m=u*w,b=Math.min(p-1,i?Math.round(m):Math.floor(m));if(t===b)for(let e=0;e<S;e++){let t=e+y;if(t<0||t>=f)continue;let r=c+t*l[2],a=t*x,u=Math.min(d-1,i?Math.round(a):Math.floor(a));s===u&&(o+=g[r+n])}}m[r+n]=o}}}}return n.makeTensorInfo(a.shape,a.dtype,m)}var hV={kernelName:xr,backendName:"cpu",kernelFunc:cV};function fV(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r;zM(a,"reverse");let i=a.shape.length,o=Aa.parseAxisParam(s,a.shape);if(0===i)return YM({inputs:{x:a},backend:n});let l=new gs(a.shape,a.dtype),u=n.bufferSync(a);for(let p=0;p<l.size;p++){let e=l.indexToLoc(p),t=e.slice();o.forEach((e=>t[e]=a.shape[e]-1-t[e])),l.set(u.get(...t),...e)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}var mV={kernelName:Sr,backendName:"cpu",kernelFunc:fV},gV={kernelName:ha,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:a,fillValue:s,center:i}=t,o=n,l=Aa.getTypedArrayFromDType(r.dtype,Aa.sizeFromShape(r.shape)),[u,p,d,c]=r.shape,[h,f]=Mw.getImageCenter(i,p,d),m=255,g=Math.sin(a),y=Math.cos(a),b=o.data.get(r.dataId).values;for(let w=0;w<u;w++){let e=w*d*p*c;for(let t=0;t<p;t++){let n=t*(d*c);for(let r=0;r<d;r++){let a=r*c;for(let i=0;i<c;i++){let o=[u,t,r,i],w=o[2],x=o[1],v=(w-h)*y-(x-f)*g,k=(w-h)*g+(x-f)*y;v=Math.round(v+h),k=Math.round(k+f);let I=s;if("number"!=typeof s&&(I=3===i?m:s[i]),v>=0&&v<d&&k>=0&&k<p){let t=k*(d*c),n=v*c,r=e+t+n+i;I=b[r]}let S=e+n+a+i;l[S]=I}}}}return{dataId:o.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},yV=dO(Nr,(e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1})),bV={kernelName:Nr,backendName:"cpu",kernelFunc:yV};function wV(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:p,outputSize:d}=Mw.calculateShapes(s,a,i),c=!0,h=n.bufferSync(a),f=n.bufferSync(s),m=xL(h,f,i,d,u,l,o,p,0,c);return n.makeTensorInfo(i,m.dtype,m.values)}var xV={kernelName:Cr,backendName:"cpu",kernelFunc:wV};function vV(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<t?n=a+1:r=a;return r}function kV(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<=t?n=a+1:r=a;return r}function IV(e,t,n,r,a,s){let i=Aa.getArrayFromDType("int32",n*a);for(let o=0;o<n;++o){let n=e.slice(o*r,(o+1)*r),l=o*a;for(let e=0;e<a;++e)i[l+e]="left"===s?vV(n,t[e+l]):kV(n,t[e+l])}return i}function SV(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,u=IV(o,l,a.shape[0],a.shape[1],s.shape[1],i);return n.makeTensorInfo(s.shape,"int32",u)}var NV={kernelName:_r,backendName:"cpu",kernelFunc:SV};function TV(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t;zM([r,a,s],"select");let i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,p=Fs(a.dtype,s.dtype),d=Aa.makeZerosTypedArray(Aa.sizeFromShape(a.shape),p),c=0,h=0===i||i>1||1===a.shape.length?1:Aa.sizeFromShape(a.shape.slice(1));for(let f=0;f<o.length;f++)for(let e=0;e<h;e++)1===o[f]?d[c++]=l[f]:d[c++]=u[f];return n.makeTensorInfo(a.shape,p,d)}var CV={kernelName:Er,backendName:"cpu",kernelFunc:TV},_V=Mw.SELU_SCALEALPHA,EV=Mw.SELU_SCALE,AV=dO(Ar,(e=>e>=0?EV*e:_V*(Math.exp(e)-1))),$V={kernelName:Ar,backendName:"cpu",kernelFunc:AV},FV=dO(Dr,(e=>e<0?-1:e>0?1:0)),RV={kernelName:Dr,backendName:"cpu",kernelFunc:FV},DV=dO(Fr,(e=>Math.sin(e))),MV={kernelName:Fr,backendName:"cpu",kernelFunc:DV},OV=dO(Rr,(e=>Math.sinh(e))),LV={kernelName:Rr,backendName:"cpu",kernelFunc:OV},PV=1.1920928955078125e-7,zV=Math.log(PV)+2,BV=dO(Or,(e=>{let t,n=e>-zV,r=e<zV,a=Math.exp(e);return t=r?a:n?e:Math.log(1+a),t})),WV={kernelName:Or,backendName:"cpu",kernelFunc:BV};function VV(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;zM([a],"spaceToBatchND");let o=Aa.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<a.shape.length;++g)l.push([0,0]);let u=JW.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),p=Mw.getReshaped(u.shape,s,o,!1),d=Mw.getPermuted(p.length,s.length,!1),c=Mw.getReshapedPermuted(u.shape,s,o,!1),h=uP({inputs:{x:u},backend:n,attrs:{shape:p}}),f=dL({inputs:{x:h},backend:n,attrs:{perm:d}}),m=uP({inputs:{x:f},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),m}var UV={kernelName:zr,backendName:"cpu",kernelFunc:VV};function GV(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n        ${a.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);let o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,p=n.data.get(i.dataId).values[0],[d,c,h,f,m]=CL(o,r.shape,r.dtype,l,a.dtype,u,p);return[n.makeTensorInfo(c,r.dtype,d),n.makeTensorInfo([c[0]],a.dtype,h),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}var HV={kernelName:Vr,backendName:"cpu",kernelFunc:GV};function jV(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.data.get(a.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(s.dataId).values),[u,p,d]=_L(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(p,r.dtype,u),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}var qV={kernelName:Ur,backendName:"cpu",kernelFunc:jV};function KV(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,p]=EL(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(p,r.dtype,u)}var XV={kernelName:Gr,backendName:"cpu",kernelFunc:KV};function YV(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,p]=EL(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(p,r.dtype,u)}var ZV={kernelName:Hr,backendName:"cpu",kernelFunc:YV};function JV(e){let t,{inputs:n,backend:r,attrs:a}=e,{sparseIndices:s,sparseValues:i,defaultValue:o}=n,{outputShape:l}=a,{sliceRank:u,numUpdates:p,sliceSize:d,strides:c,outputSize:h}=Mw.calculateShapes(i,s,l),f=!1,m=r.bufferSync(s);switch(i.dtype){case"bool":{let e=r.bufferSync(i),n=Boolean(r.data.get(o.dataId).values[0]);t=xL(m,e,l,h,d,p,u,c,n,f);break}case"float32":{let e=r.bufferSync(i),n=r.data.get(o.dataId).values[0];t=xL(m,e,l,h,d,p,u,c,n,f);break}case"int32":{let e=r.bufferSync(i),n=r.data.get(o.dataId).values[0];t=xL(m,e,l,h,d,p,u,c,n,f);break}case"string":{let e=r.bufferSync(i),n=Aa.decodeString(r.data.get(o.dataId).values[0]);t=xL(m,e,l,h,d,p,u,c,n,f);break}default:throw new Error(`Unsupported type ${i.dtype}`)}return r.makeTensorInfo(l,t.dtype,t.values)}var QV={kernelName:jr,backendName:"cpu",kernelFunc:JV};function eU(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=Aa.parseAxisParam(i,a.shape)[0],l=Mw.prepareSplitSize(a,s,o),u=new Array(a.shape.length).fill(0),p=a.shape.slice();return l.map((e=>{let t=[...p];t[o]=e;let r=NL({inputs:{x:a},backend:n,attrs:{begin:u,size:t}});return u[o]+=e,r}))}var tU={kernelName:Br,backendName:"cpu",kernelFunc:eU},nU={kernelName:Kr,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{let{x:n}=e,r=t;zM(n,"square");let a=r.data.get(n.dataId).values,s=new Float32Array(a.length);for(let i=0;i<a.length;++i){let e=a[i];s[i]=e*e}return{dataId:r.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},rU=dO(da,((e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),aU={kernelName:da,backendName:"cpu",kernelFunc:rU};function sU(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:p,newAxisMask:d,shrinkAxisMask:c}=r;zM(a,"stridedSlice");let h,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:w,end:x,strides:v}=au.sliceInfo(a.shape,s,i,o,l,u,p,d,c);if(g)h=uP({inputs:{x:a},backend:n,attrs:{shape:m}});else if(y||b){Aa.assert(a.shape.length>=1,(()=>`Input must have rank at least 1, got: ${a.shape.length}`));let e=au.computeOutShape(w,x,v),t=NL({inputs:{x:a},backend:n,attrs:{begin:w,size:e}});h=uP({inputs:{x:t},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(t)}else{let e=n.bufferSync(a),t=OL(f,e,v,w);h=n.makeTensorInfo(m,t.dtype,t.values)}return h}var iU={kernelName:Xr,backendName:"cpu",kernelFunc:sU};function oU(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:p,dataSplits:d}=t,c=n.data.get(p.dataId).values,h=n.data.get(d.dataId).values,[f,m]=PL(c,h,a,s,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}var lU={kernelName:Yr,backendName:"cpu",kernelFunc:oU};function uU(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values[0],[u,p,d]=BL(o,l,a),c=p.length;return[n.makeTensorInfo([c,2],"int32",u),n.makeTensorInfo([c],"string",p),n.makeTensorInfo([2],"int32",new Int32Array(d))]}var pU={kernelName:Zr,backendName:"cpu",kernelFunc:uU};function dU(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let i=n.data.get(s.dataId).values,o=WL(i,a);return n.makeTensorInfo(s.shape,"int32",o)}var cU={kernelName:Jr,backendName:"cpu",kernelFunc:dU},hU=dO(ea,(e=>Math.tan(e))),fU={kernelName:ea,backendName:"cpu",kernelFunc:hU},mU=dO(ta,(e=>Math.tanh(e))),gU={kernelName:ta,backendName:"cpu",kernelFunc:mU};function yU(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;zM(a,"tile");let i=jL(n.bufferSync(a),s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}var bU={kernelName:na,backendName:"cpu",kernelFunc:yU};function wU(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r;zM(a,"topk");let o=n.data.get(a.dataId).values,[l,u]=XL(o,a.shape,a.dtype,s,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}var xU={kernelName:ra,backendName:"cpu",kernelFunc:wU};function vU(e){let{inputs:t,attrs:n,backend:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[p,d,c,h]=a.shape,[f,m]=null!=u?u:[d,c],g=[p,f,m,h],y=Aa.computeStrides(a.shape),b=y[0],w=y[1],x=y[2],v=Aa.getTypedArrayFromDType(a.dtype,Aa.sizeFromShape(g));v.fill(l);let k=r.data.get(a.dataId).values,I=r.data.get(s.dataId).values;for(let S=0;S<p;++S){let e=1===s.shape[0]?I:I.subarray(8*S,8*S+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let r=0;r<h;++r){let a,s=e[6]*n+e[7]*t+1;if(0===s)continue;let u=(e[0]*n+e[1]*t+e[2])/s,p=(e[3]*n+e[4]*t+e[5])/s,h=IU(u,c,o),f=IU(p,d,o);switch(i){case"nearest":a=EU(k,d,c,b,w,x,S,f,h,r,l);break;case"bilinear":a=AU(k,d,c,b,w,x,S,f,h,r,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let m=S*b+t*w+n*x+r;v[m]=a}return r.makeTensorInfo(g,a.dtype,v)}return{dataId:r.write(v,g,a.dtype),shape:a.shape,dtype:a.dtype}}var kU={kernelName:aa,backendName:"cpu",kernelFunc:vU};function IU(e,t,n){switch(n){case"reflect":return SU(e,t);case"wrap":return NU(e,t);case"nearest":return CU(e,t);case"constant":default:return TU(e,t)}}function SU(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{let e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return Aa.clamp(0,n,t-1)}function NU(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{let e=t-1;n-=t*Math.trunc(n/e)}return Aa.clamp(0,n,t-1)}function TU(e,t){return e}function CU(e,t){return Aa.clamp(0,e,t-1)}function _U(e,t,n,r,a,s,i,o,l,u,p){let d=i*r+o*a+l*s+u;return 0<=o&&o<t&&0<=l&&l<n?e[d]:p}function EU(e,t,n,r,a,s,i,o,l,u,p){let d=Math.round(o),c=Math.round(l);return _U(e,t,n,r,a,s,i,d,c,u,p)}function AU(e,t,n,r,a,s,i,o,l,u,p){let d=Math.floor(o),c=Math.floor(l),h=d+1,f=c+1,m=(f-l)*_U(e,t,n,r,a,s,i,d,c,u,p)+(l-c)*_U(e,t,n,r,a,s,i,d,f,u,p),g=(f-l)*_U(e,t,n,r,a,s,i,h,c,u,p)+(l-c)*_U(e,t,n,r,a,s,i,h,f,u,p);return(h-o)*m+(o-d)*g}function $U(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;zM(s,"unique");let i=r.data.get(s.dataId).values,{outputValues:o,outputShape:l,indices:u}=YL(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}var FU={kernelName:ia,backendName:"cpu",kernelFunc:$U};function RU(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a.shape.length,o=a.shape[s],l=new Array(i-1),u=0;for(let h=0;h<i;h++)h!==s&&(l[u++]=a.shape[h]);let p=new Array(i).fill(0),d=a.shape.slice();d[s]=1;let c=new Array(o);for(let h=0;h<c.length;h++){p[s]=h;let e=NL({inputs:{x:a},backend:n,attrs:{begin:p,size:d}});c[h]=uP({inputs:{x:e},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(e)}return c}var DU={kernelName:oa,backendName:"cpu",kernelFunc:RU};function MU(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r;zM(a,"unsortedSegmentSum");let o=a.shape.length,l=s.shape.length,u=[],p=[],d=o-l,c=s;for(let f=0;f<d;++f){let e=dB({inputs:{input:c},backend:n,attrs:{dim:f+1}});c=e,p.push(e)}for(let f=0;f<i;++f){let e=Aa.createScalarValue(f,"int32"),t=n.makeTensorInfo([],"int32",e),r=bO({inputs:{a:t,b:c},backend:n}),s=eO({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),i=nL({inputs:{a:s,b:a},backend:n}),o=Zz({inputs:{x:i},backend:n,attrs:{axis:0,keepDims:!1}});u.push(o),p.push(t),p.push(r),p.push(s),p.push(i),p.push(o)}let h=XW({inputs:u,backend:n,attrs:{axis:0}});return p.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}var OU={kernelName:la,backendName:"cpu",kernelFunc:MU},LU=[fP,HM,gP,bP,oO,xP,kP,SP,TP,_P,AP,FP,DP,LP,zP,HP,qP,XP,ZP,cP,QP,tz,rz,sz,tO,mO,oz,KM,uz,hz,mz,yz,wz,vz,Iz,Nz,Cz,Ez,$z,Rz,Mz,Lz,zz,Wz,Uz,Hz,qz,Kz,Xz,Yz,eB,JL,nB,wO,pB,kO,cB,NO,kB,SB,TB,_O,EB,$B,RB,MB,LB,RO,OO,ZM,zB,dz,WB,UB,HB,eP,zO,VO,qB,jO,XB,JB,eW,rW,sW,oW,uW,YO,dW,hW,mW,yW,wW,vW,IW,QO,NW,_W,RW,rL,iL,OW,zW,VW,uL,GW,KW,YW,JW,tV,rP,mL,rV,QM,mB,sV,sP,oP,pP,oV,uV,dV,hV,mV,gV,bV,wL,xV,NV,CV,$V,IL,RV,MV,LV,TL,$W,WV,UV,HV,qV,XV,ZV,QV,tU,FL,nU,ML,aU,iU,lU,pU,cU,HL,Jz,fU,gU,bU,xU,kU,cL,FU,DU,OU,jW];for(let dae of LU)Sa(dae);var PU={};v(PU,{assertNotComplex:()=>QG,bindCanvasToFramebuffer:()=>_G,bindColorTextureToFramebuffer:()=>EG,bindTextureToProgramUniformSampler:()=>CG,bindTextureUnit:()=>IG,bindVertexBufferToProgramAttribute:()=>kG,callAndCheck:()=>eG,canBeRepresented:()=>aG,createFragmentShader:()=>lG,createFramebuffer:()=>vG,createProgram:()=>hG,createStaticIndexBuffer:()=>yG,createStaticVertexBuffer:()=>gG,createTexture:()=>wG,createVertexShader:()=>oG,getBatchDim:()=>MG,getExtensionOrThrow:()=>iG,getFramebufferErrorMessage:()=>FG,getMaxTexturesInShader:()=>GG,getNumChannels:()=>bG,getProgramUniformLocation:()=>TG,getProgramUniformLocationOrThrow:()=>NG,getRowsCols:()=>OG,getShapeAs3D:()=>LG,getTextureShapeFromLogicalShape:()=>PG,getWebGLDisjointQueryTimerVersion:()=>HG,getWebGLErrorMessage:()=>sG,getWebGLMaxTextureSize:()=>WG,hasExtension:()=>jG,isCapableOfRenderingToFloatTexture:()=>KG,isDownloadFloatTextureEnabled:()=>XG,isReshapeFree:()=>BG,isWebGLFenceEnabled:()=>JG,isWebGLVersionEnabled:()=>qG,linkProgram:()=>fG,logShaderSourceAndInfoLog:()=>cG,resetMaxTextureSize:()=>VG,resetMaxTexturesInShader:()=>UG,unbindColorTextureFromFramebuffer:()=>AG,unbindTextureUnit:()=>SG,validateFramebuffer:()=>$G,validateProgram:()=>mG,validateTextureSize:()=>xG});var zU,BU,WU,VU={},UU={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function GU(e,t){VU[e]=t}function HU(e,t){if(!(e in VU)||null!=t){let n=qU(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;VU[e]=n}let n=VU[e];return null==n||n.isContextLost()?(delete VU[e],HU(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),VU[e])}function jU(e){if("undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function qU(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let n=null==t?jU(e):t;return n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete VU[e]}),!1),1===e?n.getContext("webgl",UU)||n.getContext("experimental-webgl",UU):n.getContext("webgl2",UU)}function KU(e,t){return[t,e]}function XU(e,t){return e*t}function YU(e){let t=Aa.sizeFromShape(e),n=Math.ceil(t/4);return Aa.sizeToSquarishShape(n)}function ZU(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function JU(e,t){let[n,r]=ZU(e,t);return n*r*4}function QU(e,t){let n,r,a,s,i,o,l,u,p,d,c=e;return 2===et().getNumber("WEBGL_VERSION")?(n=c.R32F,r=c.R16F,a=c.RGBA16F,s=c.RGBA32F,i=c.RED,l=4,u=1,p=c.HALF_FLOAT,d=c.FLOAT,o=c.RGBA8):(n=e.RGBA,r=e.RGBA,a=e.RGBA,s=c.RGBA,i=e.RGBA,l=4,u=4,p=null!=t?t.HALF_FLOAT_OES:null,d=e.FLOAT,o=e.RGBA),{internalFormatFloat:n,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:s,textureFormatFloat:i,downloadTextureFormat:o,downloadUnpackNumChannels:l,defaultNumChannels:u,textureTypeHalfFloat:p,textureTypeFloat:d}}function eG(e,t){let n=t();return et().getBool("DEBUG")&&tG(e),n}function tG(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+sG(e,t))}(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"})(zU||(zU={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(BU||(BU={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(WU||(WU={}));var nG=5.96e-8,rG=65504;function aG(e){return!!(et().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||nG<Math.abs(e)&&Math.abs(e)<rG)}function sG(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function iG(e,t){return RG(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}function oG(e,t){let n=RG(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(eG(e,(()=>e.shaderSource(n,t))),eG(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function lG(e,t){let n=RG(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(eG(e,(()=>e.shaderSource(n,t))),eG(e,(()=>e.compileShader(n))),et().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw cG(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var uG,pG,dG=/ERROR: [0-9]+:([0-9]+):/g;function cG(e,t){let n=dG.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);let r=+n[1],a=e.split("\n"),s=a.length.toString().length+2,i=a.map(((e,t)=>Aa.rightPad((t+1).toString(),s)+e)),o=0;for(let d=0;d<i.length;d++)o=Math.max(i[d].length,o);let l=i.slice(0,r-1),u=i.slice(r-1,r),p=i.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${Aa.rightPad(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(p.join("\n"))}function hG(e){return RG(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}function fG(e,t){if(eG(e,(()=>e.linkProgram(t))),!et().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function mG(e,t){if(eG(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function gG(e,t){let n=RG(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return eG(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),eG(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function yG(e,t){let n=RG(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return eG(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),eG(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function bG(){return 2===et().getNumber("WEBGL_VERSION")?1:4}function wG(e){return RG(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}function xG(e,t){let n=et().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){let n=`[${e}x${t}]`;throw new Error("Requested texture size "+n+" is invalid.")}if(e>n||t>n){let r=`[${e}x${t}]`,a=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+a+".")}}function vG(e){return RG(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}function kG(e,t,n,r,a,s,i){let o=e.getAttribLocation(t,n);return-1!==o&&(eG(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),eG(e,(()=>e.vertexAttribPointer(o,a,e.FLOAT,!1,s,i))),eG(e,(()=>e.enableVertexAttribArray(o))),!0)}function IG(e,t,n){DG(e,n),eG(e,(()=>e.activeTexture(e.TEXTURE0+n))),eG(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}function SG(e,t){DG(e,t),eG(e,(()=>e.activeTexture(e.TEXTURE0+t))),eG(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function NG(e,t,n){return RG(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}function TG(e,t,n){return e.getUniformLocation(t,n)}function CG(e,t,n,r){eG(e,(()=>IG(e,t,r))),eG(e,(()=>e.uniform1i(n,r)))}function _G(e){eG(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),eG(e,(()=>e.viewport(0,0,e.canvas.width,e.canvas.height))),eG(e,(()=>e.scissor(0,0,e.canvas.width,e.canvas.height)))}function EG(e,t,n){eG(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),eG(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function AG(e,t){eG(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),eG(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function $G(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+FG(e,t))}function FG(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function RG(e,t,n){let r=eG(e,(()=>t()));if(null==r)throw new Error(n);return r}function DG(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){let e=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${e}.`)}}function MG(e,t=2){return Aa.sizeFromShape(e.slice(0,e.length-t))}function OG(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function LG(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[MG(e),...OG(e)]),t}function PG(e,t=!1){let n=et().getNumber("WEBGL_MAX_TEXTURE_SIZE");t&&(n*=2,e=e.map(((t,n)=>n>=e.length-2?Aa.nearestLargerEven(e[n]):e[n])),1===e.length&&(e=[2,e[0]])),2!==e.length&&(e=Aa.squeezeShape(e).newShape);let r=Aa.sizeFromShape(e);if(e.length<=1&&r<=n)return[1,r];if(2===e.length&&e[0]<=n&&e[1]<=n)return e;if(3===e.length&&e[0]*e[1]<=n&&e[2]<=n)return[e[0]*e[1],e[2]];if(3===e.length&&e[0]<=n&&e[1]*e[2]<=n)return[e[0],e[1]*e[2]];if(4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n)return[e[0]*e[1]*e[2],e[3]];if(4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n)return[e[0],e[1]*e[2]*e[3]];if(t){let t=MG(e),n=2,a=2;return e.length&&([n,a]=OG(e)),r=t*(n/2)*(a/2),Aa.sizeToSquarishShape(r).map((e=>2*e))}return Aa.sizeToSquarishShape(r)}function zG(e){return e%2===0}function BG(e,t){if(e=e.slice(-2),t=t.slice(-2),Aa.arraysEqual(e,t)||!e.length||!t.length||0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){let n=e.slice(-1)[0],r=t.slice(-1)[0];if(n===r||zG(n)&&zG(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&zG(e[0])&&zG(t[0])}function WG(e){if(null==uG){let t=HU(e);uG=t.getParameter(t.MAX_TEXTURE_SIZE)}return uG}function VG(){uG=null}function UG(){pG=null}function GG(e){if(null==pG){let t=HU(e);pG=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,pG)}function HG(e){if(0===e)return 0;let t,n=HU(e);return t=jG(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:jG(n,"EXT_disjoint_timer_query")?1:0,t}function jG(e,t){return null!=e.getExtension(t)}function qG(e){try{if(null!=HU(e))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function KG(e){if(0===e)return!1;let t=HU(e);if(1===e){if(!jG(t,"OES_texture_float"))return!1}else if(!jG(t,"EXT_color_buffer_float"))return!1;return YG(t)}function XG(e){if(0===e)return!1;let t=HU(e);if(1!==e){if(jG(t,"EXT_color_buffer_float"))return YG(t);let e="EXT_color_buffer_half_float";if(jG(t,e)){let n=t.getExtension(e);return ZG(t,n)}return!1}return!(!jG(t,"OES_texture_float")||!jG(t,"WEBGL_color_buffer_float"))&&YG(t)}function YG(e){let t=QU(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);let r=1,a=1;e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,r,a,0,t.textureFormatFloat,t.textureTypeFloat,null);let s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(s),i}function ZG(e,t){let n=QU(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);let a=1,s=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,a,s,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(i),o}function JG(e){return 2===e&&null!=HU(e).fenceSync}function QG(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Aa.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}var eH=et();function tH(){let e,t,n,r,a,s,i,o,l,u;return 2===et().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",a="texture",s="outputColor",i="out vec4 outputColor;",o="\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",a="texture2D",s="gl_FragColor",i="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:a,output:s,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function nH(e,t,n="index"){let r=Aa.computeStrides(t);return r.map(((t,a)=>{let s=`int ${e[a]} = ${n} / ${t}`,i=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${t}`:`index -= ${e[a]} * ${t}`;return`${s}; ${i};`})).join("")}function rH(e,t,n="index"){let r=Aa.computeStrides(t);return r.map(((t,a)=>{let s=`int ${e[a]} = ${n} / outShapeStrides[${a}]`,i=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * outShapeStrides[${a}]`:`index -= ${e[a]} * outShapeStrides[${a}]`;return`${s}; ${i};`})).join("")}function aH(e,t){let n=e.length,r=e.map((e=>`${t}[${e}]`)),a=new Array(n-1);a[n-2]=r[n-1];for(let s=n-3;s>=0;--s)a[s]=`(${a[s+1]} * ${r[s+1]})`;return a}function sH(e,t,n="index"){let r=e.map(((e,t)=>t)),a=aH(r,t);return a.map(((t,r)=>{let s=`int ${e[r]} = ${n} / ${a[r]}`,i=r===a.length-1?`int ${e[r+1]} = ${n} - ${e[r]} * ${a[r]}`:`index -= ${e[r]} * ${a[r]}`;return`${s}; ${i};`})).join("")}function iH(e){let t=Aa.computeStrides(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}function oH(){return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n"}eH.registerFlag("HAS_WEBGL",(()=>eH.getNumber("WEBGL_VERSION")>0)),eH.registerFlag("WEBGL_VERSION",(()=>qG(2)?2:qG(1)?1:0)),eH.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),eH.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===eH.get("WEBGL_VERSION"))),eH.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),eH.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),eH.registerFlag("WEBGL_PACK",(()=>eH.getBool("HAS_WEBGL"))),eH.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>eH.getBool("WEBGL_PACK"))),eH.registerFlag("WEBGL_PACK_CLIP",(()=>eH.getBool("WEBGL_PACK"))),eH.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>eH.getBool("WEBGL_PACK"))),eH.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>eH.getBool("WEBGL_PACK"))),eH.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>eH.getBool("WEBGL_PACK"))),eH.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>eH.getBool("WEBGL_PACK"))),eH.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>eH.getBool("WEBGL_PACK"))),eH.registerFlag("WEBGL_PACK_REDUCE",(()=>eH.getBool("WEBGL_PACK"))),eH.registerFlag("WEBGL_LAZILY_UNPACK",(()=>eH.getBool("WEBGL_PACK"))),eH.registerFlag("WEBGL_CONV_IM2COL",(()=>eH.getBool("WEBGL_PACK"))),eH.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>WG(eH.getNumber("WEBGL_VERSION")))),eH.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>GG(eH.getNumber("WEBGL_VERSION")))),eH.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{let e=eH.getNumber("WEBGL_VERSION");return 0===e?0:HG(e)})),eH.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>eH.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Ks.isMobile())),eH.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>KG(eH.getNumber("WEBGL_VERSION")))),eH.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!eH.getBool("WEBGL_FORCE_F16_TEXTURES")&&eH.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),eH.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>XG(eH.getNumber("WEBGL_VERSION")))),eH.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>JG(eH.getNumber("WEBGL_VERSION")))),eH.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>eH.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),eH.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),eH.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>Ks.isMobile()?1:-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),eH.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),eH.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),eH.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),eH.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128));var lH="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:uH}=Mw;function pH(e,t,n){let r=[];if(e.forEach((e=>{let t=Aa.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){let{uniformShape:t}=JH(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`);break;default:break}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break;default:break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));let a,s,i=r.join("\n"),o=e.map((e=>hH(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),l=t.texShape,u=tH(),p=gH(u),d=wH(u);return t.isPacked?(a=fH(t.logicalShape,l,n.enableShapeUniforms),s=bH(u)):(a=mH(t.logicalShape,l,n.enableShapeUniforms),s=yH(u)),n.packedInputs&&(d+=IH),[d,p,s,i,a,o,n.userCode].join("\n")}function dH(e,t=!1){let n=e.shapeInfo.logicalShape;switch(n.length){case 0:return LH(e,t);case 1:return zH(e,t);case 2:return WH(e,t);case 3:return UH(e,t);case 4:return HH(e,t);case 5:return jH(e);case 6:return qH(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function cH(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return OH(e);case 1:return PH(e,t);case 2:return BH(e,t);case 3:return VH(e,t);default:return GH(e,t)}}function hH(e,t,n=!1,r){let a="";a+=n?cH(e,r):dH(e,r);let s=e.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(a+=n?XH(e,t):YH(e,t)),a}function fH(e,t,n){switch(e.length){case 0:return SH();case 1:return NH(e,t,n);case 2:return RH(e,t,n);case 3:return CH(e,t,n);default:return EH(e,t,n)}}function mH(e,t,n){switch(e.length){case 0:return SH();case 1:return TH(e,t,n);case 2:return DH(e,t,n);case 3:return _H(e,t,n);case 4:return AH(e,t,n);case 5:return $H(e,t);case 6:return FH(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function gH(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}function yH(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}function bH(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}function wH(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${xH}\n    ${vH}\n    ${kH}\n  `}var xH="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",vH="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",kH="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",IH="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function SH(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function NH(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}function TH(e,t,n){return 1===t[0]?n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}function CH(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[2]/2),s=a*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}function _H(e,t,n){if(n)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${rH(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`;let r=nH(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}function EH(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[e.length-1]/2),s=a*Math.ceil(e[e.length-2]/2),i=s,o="",l="b, r, c";for(let u=2;u<e.length-1;u++)i*=e[e.length-u-1],o=`\n      int b${u} = index / ${i};\n      index -= b${u} * ${i};\n    `+o,l=`b${u}, `+l;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec${e.length}(${l});\n    }\n  `}function AH(e,t,n){if(n)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${rH(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `;let r=nH(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}function $H(e,t){let n=nH(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}function FH(e,t){let n=nH(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}function RH(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Aa.arraysEqual(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;let a=Math.ceil(e[1]/2);return n?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}function DH(e,t,n){return Aa.arraysEqual(e,t)?n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===e[1]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:n?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}function MH(e){return`offset${e}`}function OH(e){let t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=tH();return`\n    vec4 ${n}() {\n      return ${r.texture2D}(${t}, halfCR);\n    }\n  `}function LH(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;let[a,s]=e.shapeInfo.texShape;if(1===a&&1===s)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;let i=MH(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `;let[o,l]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${o}, ${l}, ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}function PH(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e.shapeInfo.texShape,s=tH();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `;let i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}function zH(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${KH(e)}\n      }\n    `;let a=e.shapeInfo.texShape,s=a[0],i=a[1];if(1===i&&1===s)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;let o=MH(n);return 1===i?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:1===s?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${i}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}function BH(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=s[0],o=s[1],l=tH();if(null!=s&&Aa.arraysEqual(n,s))return t?`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${a}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;let u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],p=Math.ceil(n[1]/2);return`\n    vec4 ${a}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${p}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}function WH(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape;if(null!=s&&Aa.arraysEqual(n,s)){if(t)return`\n      float ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;let e=s[0],n=s[1];return`\n    float ${a}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}let{newShape:i,keptDims:o}=Aa.squeezeShape(n),l=i;if(l.length<n.length){let n=QH(e,l),r=["row","col"];return`\n      ${dH(n,t)}\n      float ${a}(int row, int col) {\n        return ${a}(${ej(r,o)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${KH(e)}\n      }\n    `;let u=s[0],p=s[1],d=MH(r);return 1===p?t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===u?t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${p}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${a}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${a}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${u}, ${p}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}function VH(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===n[0]){let r=n.slice(1),s=[1,2],i=QH(e,r),o=["b","row","col"];return`\n        ${cH(i,t)}\n        vec4 ${a}(int b, int row, int col) {\n          return ${a}(${ej(o,s)});\n        }\n      `}let o=tH();if(t)return`\n    vec4 ${a}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `;let l=i[0],u=i[1],p=Math.ceil(n[2]/2),d=p*Math.ceil(n[1]/2);return`\n    vec4 ${a}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${d}, ${p}, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `}function UH(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=Aa.squeezeShape(n),u=o;if(u.length<n.length){let n=QH(e,u),r=["row","col","depth"];return`\n        ${dH(n,t)}\n        float ${a}(int row, int col, int depth) {\n          return ${a}(${ej(r,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${i}, 1)));\n        ${KH(e)}\n      }\n    `;let p=e.shapeInfo.texShape,d=p[0],c=p[1],h=e.shapeInfo.flatOffset;if(c===s&&null==h)return t?`\n      float ${a}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${a}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${c}.0, ${d}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(c===i&&null==h)return t?`\n      float ${a}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}.0, ${d}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;let f=MH(r);return t?`\n    float ${a}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * ${s} + col * ${i} + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${a}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${i} + depth + ${f};\n        vec2 uv = uvFromFlat(${d}, ${c}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}function GH(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=tH();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${a.texture2D}(${n}, uv);\n    }\n  `;let s=e.shapeInfo.logicalShape,i=s.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],p=l[1],d=Math.ceil(s[i-1]/2),c=d*Math.ceil(s[i-2]/2),h="int b, int row, int col",f=`b * ${c} + (row / 2) * ${d} + (col / 2)`;for(let m=2;m<i-1;m++)h=`int b${m}, `+h,c*=s[i-m-1],f=`b${m} * ${c} + `+f;return`\n    vec4 ${r}(${h}) {\n      int index = ${f};\n      int texR = index / ${p};\n      int texC = index - texR * ${p};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${u});\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}function HH(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[3],i=n[2]*s,o=n[1]*i,{newShape:l,keptDims:u}=Aa.squeezeShape(n);if(l.length<n.length){let n=QH(e,l),r=["row","col","depth","depth2"];return`\n      ${dH(n,t)}\n      float ${a}(int row, int col, int depth, int depth2) {\n        return ${a}(${ej(r,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${i}, ${s}, 1)));\n        ${KH(e)}\n      }\n    `;let p=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,c=d[0],h=d[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(h===o&&null==p)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${h}.0, ${c}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(h===s&&null==p)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${h}.0, ${c}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;let y=MH(r);return t?`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${c}, ${h}, index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `}function jH(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t[4],s=t[3]*a,i=t[2]*s,o=t[1]*i,{newShape:l,keptDims:u}=Aa.squeezeShape(t);if(l.length<t.length){let t=QH(e,l),n=["row","col","depth","depth2","depth3"];return`\n      ${dH(t)}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${ej(n,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${i}, ${s}, ${a})) +\n          depth3;\n        ${KH(e)}\n      }\n    `;let p=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,c=d[0],h=d[1];if(h===o&&null==p)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${s}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${h}.0, ${c}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(h===a&&null==p)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${h}.0, ${c}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;let f=MH(n);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} + depth * ${s} +\n          depth2 * ${a} + depth3 + ${f};\n      vec2 uv = uvFromFlat(${c}, ${h}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}function qH(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:a,keptDims:s}=Aa.squeezeShape(t);if(a.length<t.length){let t=QH(e,a),n=["row","col","depth","depth2","depth3","depth4"];return`\n      ${dH(t)}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${ej(n,s)});\n      }\n    `}let i=t[5],o=t[4]*i,l=t[3]*o,u=t[2]*l,p=t[1]*u;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${p}, ${u}, ${l}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${KH(e)}\n      }\n    `;let d=e.shapeInfo.flatOffset,c=e.shapeInfo.texShape,h=c[0],f=c[1];if(f===p&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${o}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===i&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;let m=MH(n);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${p} + col * ${u} + depth * ${l} +\n          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};\n      vec2 uv = uvFromFlat(${h}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}function KH(e){let t=e.name,n=Aa.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function XH(e,t){let n,r=e.name,a=r.charAt(0).toUpperCase()+r.slice(1),s="get"+a+"AtOutCoords",i=e.shapeInfo.logicalShape.length,o=t.logicalShape.length,l=uH(e.shapeInfo.logicalShape,t.logicalShape),u=ZH(o),p=o-i,d=["x","y","z","w","u","v"];n=0===i?"":o<2&&l.length>=1?"coords = 0;":l.map((e=>`coords.${d[e+p]} = 0;`)).join("\n");let c="";c=o<2&&i>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${d[t+p]}`)).join(", ");let h="return outputValue;",f=1===Aa.sizeFromShape(e.shapeInfo.logicalShape),m=1===Aa.sizeFromShape(t.logicalShape);if(1!==i||f||m){if(f&&!m)h=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(l.length){let e=i-2,t=i-1;l.indexOf(e)>-1&&l.indexOf(t)>-1?h="return vec4(outputValue.x);":l.indexOf(e)>-1?h="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":l.indexOf(t)>-1&&(h="return vec4(outputValue.xx, outputValue.zz);")}}else h="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${u} coords = getOutputCoords();\n      ${n}\n      vec4 outputValue = get${a}(${c});\n      ${h}\n    }\n  `}function YH(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&null==e.shapeInfo.flatOffset&&Aa.arraysEqual(i,s))return`\n      float ${a}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;let u,p=ZH(l),d=uH(e.shapeInfo.logicalShape,t.logicalShape),c=l-o,h=["x","y","z","w","u","v"];u=0===o?"":l<2&&d.length>=1?"coords = 0;":d.map((e=>`coords.${h[e+c]} = 0;`)).join("\n");let f="";return f=l<2&&o>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${h[t+c]}`)).join(", "),`\n    float ${a}() {\n      ${p} coords = getOutputCoords();\n      ${u}\n      return get${r}(${f});\n    }\n  `}function ZH(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function JH(e,t,n){let{newShape:r,keptDims:a}=Aa.squeezeShape(t),s=t.length,i=e&&3===s&&1===t[0],o=i?t.slice(1):r,l=!e&&s>1&&!Aa.arraysEqual(t,n)&&r.length<s||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:a}}function QH(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function ej(e,t){return t.map((t=>e[t])).join(", ")}function tj(e,t,n,r){let a=n.map(((e,n)=>{let r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),s=a.map((e=>e.shapeInfo)),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=pH(a,i,t),l=lG(e.gl,o),u=e.createProgram(l);return et().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i},nj(e,t,u))}function nj(e,t,n){let r,a,s,i={},o={},l={},u=[],p=null,d=null;d=e.getUniformLocation(n,"NAN",!1),1===et().getNumber("WEBGL_VERSION")&&(p=e.getUniformLocation(n,"INFINITY",!1));let c=!1;for(let h=0;h<t.variableNames.length;h++){let r=t.variableNames[h];i[r]=e.getUniformLocation(n,r,c),i[`offset${r}`]=e.getUniformLocation(n,`offset${r}`,c),t.enableShapeUniforms&&(o[`${r}Shape`]=e.getUniformLocation(n,`${r}Shape`,c),l[`${r}TexShape`]=e.getUniformLocation(n,`${r}TexShape`,c))}return t.enableShapeUniforms&&(r=e.getUniformLocation(n,"outShape",c),s=e.getUniformLocation(n,"outShapeStrides",c),a=e.getUniformLocation(n,"outTexShape",c)),t.customUniforms&&t.customUniforms.forEach(((t,r)=>{u[r]=e.getUniformLocation(n,t.name,c)})),{uniformLocations:i,customUniformLocations:u,infLoc:p,nanLoc:d,inShapesLocations:o,inTexShapesLocations:l,outShapeLocation:r,outShapeStridesLocation:s,outTexShapeLocation:a}}function rj(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{let r=e.logicalShape,a=t[n],s=a.shape;if(!Aa.arraysEqual(r,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${s} must match`);if(e.isUniform&&a.isUniform)return;let i=e.texShape,o=a.isUniform?null:a.texData.texShape;if(!Aa.arraysEqual(i,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${o} must match`)}))}function aj(e,t,n,r,a){t.program.enableShapeUniforms||(rj(t.inShapeInfos,n),rj([t.outShapeInfo],[r]));let s=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):e.setOutputMatrixTexture(s.texture,i[0],i[1]),e.setProgram(t.webGLProgram),1===et().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach(((n,r)=>{let a=t.program.variableNames[r],s=t.uniformLocations[a],i=t.uniformLocations[`offset${a}`],o=t.inShapesLocations[`${a}Shape`],l=t.inTexShapesLocations[`${a}TexShape`];if(o){let{uniformShape:r}=JH(t.program.packedInputs,n.shape,n.texData.texShape);switch(r.length){case 1:e.gl.uniform1iv(o,new Int32Array(r));break;case 2:e.gl.uniform2iv(o,new Int32Array(r));break;case 3:e.gl.uniform3iv(o,new Int32Array(r));break;case 4:e.gl.uniform4iv(o,new Int32Array(r));break;default:break}}if(l&&e.gl.uniform2i(l,n.texData.texShape[0],n.texData.texShape[1]),null!=s){if(n.isUniform){if(Aa.sizeFromShape(n.shape)<2)e.gl.uniform1f(s,n.uniformValues[0]);else{let t=n.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(s,t)}return}null!=n.texData.slice&&null!=i&&e.gl.uniform1i(i,n.texData.slice.flatOffset),e.setInputMatrixTexture(n.texData.texture.texture,s,r)}}));let o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape));break;default:break}if(t.outShapeStridesLocation){let n=Aa.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n));break;default:break}}t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&a&&t.program.customUniforms.forEach(((n,r)=>{let s=t.customUniformLocations[r],i=a[r];if("float"===n.type)e.gl.uniform1fv(s,i);else if("vec2"===n.type)e.gl.uniform2fv(s,i);else if("vec3"===n.type)e.gl.uniform3fv(s,i);else if("vec4"===n.type)e.gl.uniform4fv(s,i);else if("int"===n.type)e.gl.uniform1iv(s,i);else if("ivec2"===n.type)e.gl.uniform2iv(s,i);else if("ivec3"===n.type)e.gl.uniform3iv(s,i);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(s,i)}})),e.executeProgram()}function sj(e,t,n){let r="";t.concat(n).forEach((t=>{let a=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){let s=t.texData.texShape,{useSqueezeShape:i,uniformShape:o,keptDims:l}=JH(e.packedInputs,t.shape,s),u="",p="",d="";if(1===o.length&&e.packedInputs){let e=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];u=`${e[0]>1}_${e[1]>1}`}else if(2!==o.length||e.packedInputs){if(o.length>2&&!e.packedInputs){let e=Aa.computeStrides(o);d=`${e[0]===s[1]}_${e[e.length-1]===s[1]}`}}else p=`${o[0]>1}_${o[1]>1}`;let c=t.shape.length,h=2===o.length&&Aa.arraysEqual(t.shape,s),f=1===Aa.sizeFromShape(t.shape),m=Mw.getBroadcastDims(t.shape,n.shape),g=!e.packedInputs&&c===n.shape.length&&Aa.arraysEqual(s,n.texData.texShape),y=e.packedInputs||o.length>2?"":`${s[0]>1}_${s[1]>1}`;r+=`${c}_${g}_${i?l:""}_${o.length}_${f}_${m}_${h}_${u}_${p}_${d}_${y}_${a}`}else{let e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${a}`}}));let a=e.userCode,s=e.constructor.name;return s+="_"+r+"_"+a+`${et().getNumber("WEBGL_VERSION")}`,s}function ij(e){return et().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var oj=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=zU.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=tH();this.outputShape=e,this.enableShapeUniforms=ij(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?rH(["r","c","d"],e):nH(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}},lj=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=zU.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=tH();this.outputShape=e,this.enableShapeUniforms=ij(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?rH(["r","c","d"],e):nH(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}},uj=class{constructor(e){this.variableNames=["A"],this.outTexUsage=BU.DOWNLOAD;let t=tH();this.outputShape=e,this.userCode=`\n      ${lH}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}},pj=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=BU.DOWNLOAD;let t=tH();this.outputShape=e,this.userCode=`\n      ${lH}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}},dj=class{constructor(e,t=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=tH();this.outputShape=e,this.enableShapeUniforms=ij(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)"),this.userCode=`\n      ${this.enableShapeUniforms?oH():iH(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / texShape[1];\n        int c = imod(flatIndex, texShape[1]);\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n        vec4 values = ${n.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${n.output} = vec4(${r}, 0., 0., 0.);\n      }\n    `}},cj=class{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=tH();this.outputShape=e,this.enableShapeUniforms=ij(this.outputShape.length);let r="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let s=0;s<=1;s++)for(let t=0;t<=1;t++){let a=2*s+t;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${t} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${t};\n          if (localCoords[1] + ${s} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${s};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${a}] = values[0];\n            } else if (offset == 1) {\n              result[${a}] = values[1];\n            } else if (offset == 2) {\n              result[${a}] = values[2];\n            } else {\n              result[${a}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?oH():iH(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${a};\n        }\n    `}},hj={};function fj(e){let t=tH(),n=`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;return oG(e,n)}function mj(e){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return gG(e,t)}function gj(e){let t=new Uint16Array([0,1,2,2,1,3]);return yG(e,t)}function yj(e,t,n,r,a,s){xG(t,n);let i=wG(e),o=e.TEXTURE_2D;return eG(e,(()=>e.bindTexture(o,i))),eG(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),eG(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),eG(e,(()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST))),eG(e,(()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===et().getNumber("WEBGL_VERSION")?eG(e,(()=>e.texImage2D(o,0,r,t,n,0,a,s,null))):eG(e,(()=>e.texStorage2D(o,1,r,t,n))),eG(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:i,texShape:[n,t]}}function bj(e){return e.internalFormatFloat}function wj(e,t,n,r){let[a,s]=KU(t,n);return yj(e,a,s,bj(r),r.textureFormatFloat,e.FLOAT)}function xj(e){return e.internalFormatHalfFloat}function vj(e,t,n,r){let[a,s]=KU(t,n);return yj(e,a,s,xj(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function kj(e){return e.downloadTextureFormat}function Ij(e,t,n,r){let[a,s]=KU(t,n);return yj(e,a,s,kj(r),e.RGBA,e.UNSIGNED_BYTE)}function Sj(e){return e.internalFormatPackedFloat}function Nj(e,t,n,r){let[a,s]=ZU(t,n);return yj(e,a,s,Sj(r),e.RGBA,e.FLOAT)}function Tj(e){return e.internalFormatPackedHalfFloat}function Cj(e,t,n,r){let[a,s]=ZU(t,n);return yj(e,a,s,Tj(r),e.RGBA,r.textureTypeHalfFloat)}function _j(e,t,n){return eG(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),kG(e,t,"clipSpacePos",n,3,20,0)&&kG(e,t,"uv",n,2,20,12)}function Ej(e,t,n,r,a,s){let i,o,l;eG(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),a instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=s.internalFormatPackedFloat),i.set(a),2===et().getNumber("WEBGL_VERSION")?eG(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i))):eG(e,(()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i))),eG(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function Aj(e,t,n){eG(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===et().getNumber("WEBGL_VERSION")?eG(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):eG(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===et().getNumber("WEBGL_VERSION")?eG(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):eG(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),eG(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function $j(e,t,n,r){let a=e.createBuffer();eG(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,a)));let s=16*t*n;return eG(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ))),eG(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),eG(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),a}function Fj(e,t,n){let r=e,a=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}function Rj(e,t,n,r){let[a,s]=KU(t,n),i=4,o=new Uint8Array(XU(t*n,i));return eG(e,(()=>e.readPixels(0,0,a,s,r.downloadTextureFormat,e.UNSIGNED_BYTE,o))),new Float32Array(o.buffer)}function Dj(e,t,n,r,a,s,i,o){let l=e,u=new Float32Array(JU(s,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function Mj(e,t,n){let r=new Float32Array(t*n*4);return eG(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}v(hj,{bindVertexProgramAttributeStreams:()=>_j,createBufferFromOutputTexture:()=>$j,createFloat16MatrixTexture:()=>vj,createFloat16PackedMatrixTexture:()=>Cj,createFloat32MatrixTexture:()=>wj,createIndexBuffer:()=>gj,createPackedMatrixTexture:()=>Nj,createUnsignedBytesMatrixTexture:()=>Ij,createVertexBuffer:()=>mj,createVertexShader:()=>fj,downloadByteEncodedFloatMatrixFromOutputTexture:()=>Rj,downloadFloat32MatrixFromBuffer:()=>Fj,downloadMatrixFromPackedOutputTexture:()=>Mj,downloadPackedMatrixFromBuffer:()=>Dj,getInternalFormatForFloat16MatrixTexture:()=>xj,getInternalFormatForFloat16PackedMatrixTexture:()=>Tj,getInternalFormatForFloat32MatrixTexture:()=>bj,getInternalFormatForPackedMatrixTexture:()=>Sj,getInternalFormatForUnsignedBytesMatrixTexture:()=>kj,uploadDenseMatrixToTexture:()=>Ej,uploadPixelDataToTexture:()=>Aj});var Oj=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];let t=et().getNumber("WEBGL_VERSION");null!=e?(this.gl=e,GU(t,e)):this.gl=HU(t);let n="WEBGL_color_buffer_float",r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===et().getNumber("WEBGL_VERSION")){let e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=iG(this.gl,e),jG(this.gl,t))this.textureHalfFloatExtension=iG(this.gl,t);else if(et().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),jG(this.gl,r))this.colorBufferHalfFloatExtension=iG(this.gl,r);else if(et().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",jG(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!jG(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=mj(this.gl),this.indexBuffer=gj(this.gl),this.framebuffer=vG(this.gl),this.textureConfig=QU(this.gl,this.textureHalfFloatExtension)}get debug(){return et().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;eG(e,(()=>e.finish())),eG(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),eG(e,(()=>e.deleteFramebuffer(this.framebuffer))),eG(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),eG(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),eG(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),wj(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),vj(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),Ij(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),Aj(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),Ej(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),Cj(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),Nj(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(AG(this.gl,this.framebuffer),this.outputTexture=null),eG(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>Rj(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,a,s){return Dj(this.gl,e,t,n,r,a,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return Fj(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let r=$j(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(et().getBool("WEBGL_FENCE_API_ENABLED")){let r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let e=r.clientWaitSync(a,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=a}else et().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,et().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>Mj(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();let t=this.gl;null==this.vertexShader&&(this.vertexShader=fj(t));let n=hG(t);return eG(t,(()=>t.attachShader(n,this.vertexShader))),eG(t,(()=>t.attachShader(n,e))),fG(t,n),this.debug&&mG(t,n),this.vertexAttrsAreBound||(this.setProgram(n),this.vertexAttrsAreBound=_j(t,this.program,this.vertexBuffer)),n}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&eG(this.gl,(()=>this.gl.deleteProgram(e)))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&mG(this.gl,this.program),eG(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?NG(this.gl,e,t):TG(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),eG(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),CG(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[r,a]=ZU(t,n);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&mG(this.gl,this.program),$G(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;this.debug&&this.debugValidate(),eG(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),eG(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=iG(this.gl,2===et().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===et().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===et().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Aa.repeatedTry((()=>this.disposed||this.isQueryAvailable(e,et().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,et().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){let t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{let t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){let t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{let t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){let e=Lj(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){let{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),!(this.itemsToPoll.length>1)&&Aa.repeatedTry((()=>(this.pollItems(),0===this.itemsToPoll.length)))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),EG(this.gl,e,this.framebuffer),this.debug&&$G(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(EG(this.gl,this.outputTexture,this.framebuffer),this.debug&&$G(this.gl)):AG(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let r=this.gl;EG(r,e,this.framebuffer),this.debug&&$G(r),this.outputTexture=e,eG(r,(()=>r.viewport(0,0,t,n))),eG(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),eG(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}};function Lj(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}var{addImpl:Pj,bincountImpl:zj,bincountReduceImpl:Bj,ceilImpl:Wj,concatImpl:Vj,equalImpl:Uj,expImpl:Gj,expm1Impl:Hj,floorImpl:jj,gatherNdImpl:qj,gatherV2Impl:Kj,greaterImpl:Xj,greaterEqualImpl:Yj,lessImpl:Zj,lessEqualImpl:Jj,linSpaceImpl:Qj,logImpl:eq,maxImpl:tq,maximumImpl:nq,minimumImpl:rq,multiplyImpl:aq,negImpl:sq,notEqualImpl:iq,prodImpl:oq,rangeImpl:lq,rsqrtImpl:uq,scatterImpl:pq,sigmoidImpl:dq,simpleAbsImpl:cq,sliceImpl:hq,sparseFillEmptyRowsImpl:fq,sparseReshapeImpl:mq,sparseSegmentReductionImpl:gq,sqrtImpl:yq,stridedSliceImpl:bq,stringNGramsImpl:wq,stringSplitImpl:xq,stringToHashBucketFastImpl:vq,subImpl:kq,tileImpl:Iq,topKImpl:Sq,transposeImpl:Nq,uniqueImpl:Tq}=VM;function Cq(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function _q(e,t){return 1===t?[e]:Cq(e,t)}function Eq(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}var Aq=class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=ij(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{let e=_q("rc",this.rank),t=ZH(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),a=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${a}));\n          }\n        }\n      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let a=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let t=2;t<this.rank;t++)a=`${e[e.length-1-t]},`+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(e){let t=this.getSourceCoordsArr(e);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}},$q=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=ij(this.outputShape.length);let n="";for(let r=0;r<4;r++){let e="thisRC = rc;";r%2===1&&(e+="thisRC.z += 1;"),r>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${r}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${r>0?"}":""}\n      `}this.userCode=`\n      ${Fq(t,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?oH():iH(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}};function Fq(e,t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t?sH(["r","c","d"],"inputShape"):nH(["r","c","d"],e)}\n      return ivec3(r, c, d);\n    }\n  `}var Rq=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){let r=Pq(t,n),a=zq(e,r,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);let s,i=Mq(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();let e=this.freeTextures[a].shift();return this.usedTextures[a].push(e),e}return r===WU.PACKED_2X2_FLOAT32?s=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===WU.PACKED_2X2_FLOAT16?s=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===WU.UNPACKED_FLOAT32?s=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===WU.UNPACKED_FLOAT16?s=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===WU.PACKED_4X1_UNSIGNED_BYTE&&(s=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(s),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),s}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;let a=Pq(n,r),s=zq(t,a,r);s in this.freeTextures||(this.freeTextures[s]=[]);let i=Mq(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=et().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let l=this.usedTextures[s],u=l.indexOf(e);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(u,1),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(let e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(let e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function Dq(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F||t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function Mq(e,t,n,r,a){let s,i=Oq(t,r);if(a){let[t,n]=ZU(e[0],e[1]);s=t*n}else{let[t,n]=KU(e[0],e[1]);s=t*n}let o=Dq(n,i);return s*o}function Oq(e,t){switch(e){case WU.PACKED_2X2_FLOAT32:return Sj(t);case WU.PACKED_2X2_FLOAT16:return Tj(t);case WU.UNPACKED_FLOAT32:return bj(t);case WU.UNPACKED_FLOAT16:return xj(t);case WU.PACKED_4X1_UNSIGNED_BYTE:return kj(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function Lq(e){return et().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?WU.PACKED_2X2_FLOAT32:WU.UNPACKED_FLOAT32:e?WU.PACKED_2X2_FLOAT16:WU.UNPACKED_FLOAT16}function Pq(e,t){if(e===BU.UPLOAD)return WU.PACKED_2X2_FLOAT32;if(e===BU.RENDER||null==e)return Lq(t);if(e===BU.DOWNLOAD||e===BU.PIXELS)return WU.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function zq(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var Bq=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=ij(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}},Wq="if (isnan(x)) return x;",Vq="return x;",Uq="return abs(x);",Gq="return (x >= 0.0) ? x : (exp(x) - 1.0);",Hq=Wq+"\n  return (x < 0.0) ? 0.0 : x;\n",jq=Wq+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",qq="return x;",Kq="return 1.0 / (1.0 + exp(-1.0 * x));",Xq="return x;",Yq="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",Zq="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Jq="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Qq="return 1.0 / (1.0 + exp(-1.0 * x));",eK=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=ij(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}},tK=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=ij(this.outputShape.length);let t=e.length,n=_q("rc",t),r=ZH(t),a=Eq(t,n),s=n.slice(-2),i=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${a});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}},nK=Lx.whereImpl,rK=1e-7,aK=1e-4,sK={};function iK(e){return e in sK||(sK[e]={}),sK[e]}var oK=et().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),lK=600;function uK(){return null==et().global.screen?1024:et().global.screen.height*et().global.screen.width*window.devicePixelRatio*lK/1024/1024}var pK=class extends Q{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!et().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof Oj)t=e;else{let n=HU(et().getNumber("WEBGL_VERSION"),e);t=new Oj(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let e=HU(et().getNumber("WEBGL_VERSION"));t=new Oj(e),this.binaryCache=iK(et().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Rq(this.gpgpu),this.numMBBeforeWarning=uK(),this.texData=new J(this,dl())}nextDataId(){return pK.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,n){if((et().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||et().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:BU.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){let t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){let t=this.texData.get(e);t.refCount--}}move(e,t,n,r,a){if(et().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:BU.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:a,slice:s,shape:i,isPacked:o}=t;if(null!=s){let t;t=o?new eK(i,qq):new Bq(i,qq);let n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:r}],r),a=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;let l,u,p=null!=this.activeTimers;if(p&&(l=Aa.now()),"complex64"===r){let e=this.readSync(a.real.dataId),t=this.readSync(a.imag.dataId);u=Mw.mergeRealAndImagArrays(e,t)}else u=this.getValuesFromTexture(e);return p&&(this.downloadWaitMs+=Aa.now()-l),this.convertAndCacheOnCPU(e,u)}async read(e){if(this.pendingRead.has(e)){let t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}let t=this.texData.get(e),{values:n,shape:r,slice:a,dtype:s,complexTensorInfos:i,isPacked:o}=t;if(null!=a){let t;t=o?new eK(r,qq):new Bq(r,qq);let n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:s}],s),a=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if(et().getBool("DEBUG")&&!et().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===et().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,u,p=null;if("complex64"!==s&&et().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);let t=this.texData.get(l.dataId);p=this.gpgpu.createBufferFromTexture(t.texture.texture,...YU(r))}if(this.pendingRead.set(e,[]),"complex64"!==s&&await this.gpgpu.createAndWaitForFence(),"complex64"===s){let e=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]),t=e[0],n=e[1];u=Mw.mergeRealAndImagArrays(t,n)}else if(null==p)u=this.getValuesFromTexture(e);else{let e=Aa.sizeFromShape(r);u=this.gpgpu.downloadFloat32MatrixFromBuffer(p,e)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=p){let e=this.gpgpu.gl;eG(e,(()=>e.deleteBuffer(p)))}let d=this.convertAndCacheOnCPU(e,u),c=this.pendingRead.get(e);return this.pendingRead.delete(e),c.forEach((e=>e(d))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&dl().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e,t={}){let n=this.texData.get(e),{values:r,shape:a,slice:s,dtype:i,isPacked:o,texture:l}=n;if("complex64"===i)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=s){let n;n=o?new eK(a,qq):new Bq(a,qq);let r=this.runWebGLProgram(n,[{dataId:e,shape:a,dtype:i}],i),s=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),s}if(null==l)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let u=this.decode(e,t.customTexShape),p=dl().makeTensorFromTensorInfo(u),d=this.texData.get(u.dataId);return Object.assign({tensorRef:p},d.texture)}bufferSync(e){let t=this.readSync(e.dataId);if("string"===e.dtype)try{let n=t.map((e=>Aa.decodeString(e)));return wo(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return wo(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){let n=e[t];if(!aG(n))throw et().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(e){let{shape:t,dtype:n,isPacked:r}=this.texData.get(e),a=Aa.sizeFromShape(t);if(et().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let n=this.decode(e),r=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...YU(t)).subarray(0,a);return this.disposeIntermediateTensorInfo(n),s}let s=et().getBool("WEBGL_PACK")&&!0===r,i=s?LG(t):t,o=s?new pj(i):new uj(i),l=this.runWebGLProgram(o,[{shape:i,dtype:n,dataId:e}],"float32"),u=this.texData.get(l.dataId),p=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(l),p}timerAvailable(){return et().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){let t=this.activeTimers,n=[],r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();let a=Aa.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),s=Aa.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);let i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(et().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let e=await Promise.all(a);i.kernelMs=Aa.sum(e),i.getExtraProfileInfo=()=>e.map(((e,t)=>({name:s[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return et().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Aa.now(),endMs:null}}endTimer(e){return et().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Aa.now(),e)}async getQueryTime(e){if(et().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);let t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:t,dtype:n,texShape:r,usage:a,isPacked:s,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,a,s)));let u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=oK){return et().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&Aa.sizeFromShape(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){Mw.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let t=e.dataSync();return nK(e.shape,t)}packedUnaryOp(e,t,n){let r=new eK(e.shape,t),a=this.compileAndRun(r,[e],n);return dl().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){let t=cq(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(et().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Uq,e.dtype);let t=new Bq(e.shape,Uq),n=this.compileAndRun(t,[e]);return dl().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&Aa.isString(n[0])){let a=n.map((e=>Aa.encodeString(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return dl().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){let t=new tK(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){let t=new Aq(e.shape),n=!0;return this.runWebGLProgram(t,[e],e.dtype,null,n)}packedReshape(e,t){let n=[MG(e.shape),...OG(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},a=[MG(t),...OG(t)],s=new $q(a,n),i=!0,o=[n],l=this.runWebGLProgram(s,[r],e.dtype,o,i);return{dataId:l.dataId,shape:t,dtype:l.dtype}}decode(e,t){let n=this.texData.get(e),{isPacked:r,shape:a,dtype:s}=n;if(null!=t){let e=Aa.sizeFromShape(a),n=t[0]*t[1]*4;Aa.assert(e<=n,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}let i,o=LG(a);i=r?new lj(o):new oj(o);let l=!0,u=[null!=t?t:YU(o)],p=this.runWebGLProgram(i,[{shape:o,dtype:s,dataId:e}],s,u,l,t);return{dtype:s,shape:a,dataId:p.dataId}}runWebGLProgram(e,t,n,r,a=!1,s){let i=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(i.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===zU.DENSE){let t=null!=s?s:YU(e.outputShape);o.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(o.usage=e.outTexUsage),0===Aa.sizeFromShape(i.shape))return o.values=Aa.getTypedArrayFromDType(i.dtype,0),i;let l=[],u=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&Aa.sizeFromShape(t.shape)<=et().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),l.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!BG(n.shape,t.shape)){let e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),l.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(i.dataId);let p,d={shape:i.shape,texData:o,isUniform:!1},c=sj(e,u,d),h=this.getAndSaveBinary(c,(()=>tj(this.gpgpu,e,u,d))),f=null!=this.activeTimers;f&&(p=this.startTimer()),et().get("ENGINE_COMPILE_ONLY")||aj(this.gpgpu,h,u,d,r),l.forEach((e=>this.disposeIntermediateTensorInfo(e))),f&&(p=this.endTimer(p),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(p)}));let m=et().get("WEBGL_FLUSH_THRESHOLD");if(m>0){let e=Aa.now();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!et().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===a){let e=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),e}return i}compileAndRun(e,t,n,r,a=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,r,a)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(et().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]})),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=fl((()=>{if(!et().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=et().getBool("DEBUG");et().set("DEBUG",!1);let t=this.abs(Bc(1e-8)).dataSync()[0];if(et().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?rK:aK}uploadToGPU(e){let t=this.texData.get(e),{shape:n,dtype:r,values:a,texture:s,usage:i,isPacked:o}=t;if(null!=s)return;let l,u=null!=this.activeTimers;u&&(l=Aa.now());let p=t.texShape;if(null==p&&(p=PG(n,o),t.texShape=p),null!=a){let e,s=LG(n),i=p[1],d=p[0],c=a instanceof Uint8Array||a instanceof Uint8ClampedArray;(o||!c)&&([i,d]=ZU(p[0],p[1])),e=o?new cj(s,c):new dj(s,c);let h=c?[d,i]:p,f=this.makeTensorInfo(h,r),m=this.texData.get(f.dataId);m.usage=c?BU.PIXELS:BU.UPLOAD,m.texShape=h,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),i,d,a);let g=[[d,i]],y=!0,b=this.runWebGLProgram(e,[f],r,g,y),w=this.texData.get(b.dataId);t.texShape=w.texShape,t.isPacked=w.isPacked,t.usage=w.usage,et().get("ENGINE_COMPILE_ONLY")?this.disposeData(b.dataId):(t.texture=w.texture,t.values=null,this.texData.delete(b.dataId)),this.disposeIntermediateTensorInfo(f),u&&(this.uploadWaitMs+=Aa.now()-l)}else{let e=this.acquireTexture(p,i,r,o);t.texture=e}}convertAndCacheOnCPU(e,t){let n=this.texData.get(e),{dtype:r}=n;return this.releaseGPUData(e),null!=t&&(n.values=dK(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){let e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*Aa.bytesPerElement(t)}checkCompileCompletion(){for(let[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){let e=[];if(this.gpgpu.parallelCompilationExtension){for(let[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(let[,t]of Object.entries(this.binaryCache)){let n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Dw(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(cG(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let[,e]of Object.entries(this.binaryCache)){let{uniformLocations:t,customUniformLocations:n,infLoc:r,nanLoc:a,inShapesLocations:s,inTexShapesLocations:i,outShapeLocation:o,outShapeStridesLocation:l,outTexShapeLocation:u}=nj(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=a,e.inShapesLocations=s,e.inTexShapesLocations=i,e.outShapeLocation=o,e.outShapeStridesLocation=l,e.outTexShapeLocation=u}}};function dK(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){let n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}pK.nextDataId=0;var cK="3.18.0";function hK(){et().set("WEBGL_FORCE_F16_TEXTURES",!0)}Ks.isBrowser()&&Sl("webgl",(()=>new pK),2);var fK={forceHalfFloat:hK},mK="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n",gK=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=Mw.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=ij(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}},yK="\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n",bK=class{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Mw.assertAndGetBroadcastShape(t,n);let a=this.outputShape.length;this.enableShapeUniforms=ij(a);let s="";if(r)if(0===a||1===Aa.sizeFromShape(this.outputShape))s="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(s=`\n          ${ZH(a)} coords = getOutputCoords();\n        `,1===a)this.enableShapeUniforms?s+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":s+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{let e=_q("coords",a);this.enableShapeUniforms?s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= outShape[${a} - 2];\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= outShape[${a} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= ${this.outputShape[a-2]};\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= ${this.outputShape[a-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${s}\n\n        setOutput(result);\n      }\n    `}};function wK(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var xK={kernelName:kn,backendName:"webgl",kernelFunc:wK};function vK(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(s.dataId),o=wK({inputs:{x:r},backend:n}),l=wK({inputs:{x:a},backend:n});return i.complexTensorInfos={real:o,imag:l},s}var kK={kernelName:Rt,backendName:"webgl",kernelFunc:vK},IK="return (a < 0.) ? b * a : a;",SK="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";function NK(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r,i=n.makeTensorInfo([],"float32",Aa.createScalarValue(s,"float32")),o=et().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new bK(SK,a.shape,i.shape):new gK(IK,a.shape,i.shape),l=n.runWebGLProgram(o,[a,i],"float32");return n.disposeIntermediateTensorInfo(i),l}var TK={kernelName:_n,backendName:"webgl",kernelFunc:NK},CK="return (a < 0.) ? b * a : a;",_K="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";function EK(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=et().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new bK(_K,r.shape,a.shape):new gK(CK,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],"float32")}var AK={kernelName:cr,backendName:"webgl",kernelFunc:EK},$K="if (isnan(x)) return x;",FK="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n",RK="\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n";function DK({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:a,backend:s})=>{let{x:i}=a,o=s,l=r||i.dtype;if(o.shouldExecuteOnCPU([i])&&null!=n){let e=o.texData.get(i.dataId),t=n(e.values,l);return o.makeTensorInfo(i.shape,l,t)}let u,p=et().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t;return u=p?new eK(i.shape,t):new Bq(i.shape,e),o.runWebGLProgram(u,[i],l)}}function MK({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:a,dtype:s}){return({inputs:i,backend:o})=>{let{a:l,b:u}=i,p=o;if(r&&"complex64"===l.dtype){let t=p.texData.get(l.dataId),n=p.texData.get(u.dataId),[r,a]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{let[n,r]=t,a={dataId:n.dataId,dtype:n.dtype,shape:l.shape},s={dataId:r.dataId,dtype:r.dtype,shape:u.shape},i=new gK(e,l.shape,u.shape);return p.runWebGLProgram(i,[a,s],Fs(n.dtype,r.dtype))})),s=vK({inputs:{real:r,imag:a},backend:p});return p.disposeIntermediateTensorInfo(r),p.disposeIntermediateTensorInfo(a),s}let d=s||Fs(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||p.shouldExecuteOnCPU([l,u]))&&null!=a){let e=p.texData.get(l.dataId).values,t=p.texData.get(u.dataId).values,n="string"===l.dtype?Mw.fromUint8ToStringArray(e):e,r="string"===l.dtype?Mw.fromUint8ToStringArray(t):t,[s,i]=a(l.shape,u.shape,n,r,d),o=p.makeTensorInfo(i,d),c=p.texData.get(o.dataId);return c.values=s,o}let c,h=et().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t;return c=h?new bK(t,l.shape,u.shape,n):new gK(e,l.shape,u.shape),p.runWebGLProgram(c,[l,u],d)}}function OK(e,t=!1){if("linear"===e)return t?Xq:Vq;if("relu"===e)return t?Zq:Hq;if("elu"===e)return t?Yq:Gq;if("relu6"===e)return t?Jq:jq;if("prelu"===e)return t?_K:CK;if("leakyrelu"===e)return t?SK:IK;if("sigmoid"===e)return t?Qq:Kq;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var LK=class{constructor(e,t,n,r=!1,a=!1,s=!1,i=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=ij(this.outputShape.length);let u=r?e[1]:e[2],p=Math.ceil(u/2),d=r?"i * 2, rc.y":"rc.y, i * 2",c=a?"rc.z, i * 2":"i * 2, rc.z",h=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],m="",g="";i&&(m=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,g="result = activation(result);");let y=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let b="rc.x",w="rc.x";e[0]<t[0]?b=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(w=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${p}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${p}; i++) {\n          int batchA = ${b};\n          int batchB = ${w};\n          vec4 a = getMatrixA(batchA, ${d});\n          vec4 b = getMatrixB(batchB, ${c});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${h[0]} * ${f[0]});\n          result += (${h[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${y}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}},PK={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},zK=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Mw.assertAndGetBroadcastShape(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}},BK="return a * b;";function WK(e){let t,{inputs:n,backend:r}=e,{a:a,b:s}=n,i=Mw.upcastType(a.dtype,s.dtype);if("complex64"===a.dtype){let e=r.texData.get(a.dataId),t=r.texData.get(s.dataId),n=new zK(PK.REAL,a.shape,s.shape),i=new zK(PK.IMAG,a.shape,s.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape}],l=r.runWebGLProgram(n,o,"float32"),u=r.runWebGLProgram(i,o,"float32"),p=vK({inputs:{real:l,imag:u},backend:r});return r.disposeIntermediateTensorInfo(l),r.disposeIntermediateTensorInfo(u),p}if(r.shouldExecuteOnCPU([a,s])){let e=r.texData.get(a.dataId),t=r.texData.get(s.dataId),[n,o]=aq(a.shape,s.shape,e.values,t.values,i),l=r.makeTensorInfo(o,i),u=r.texData.get(l.dataId);return u.values=n,l}return t=et().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new bK(BK,a.shape,s.shape):new gK(BK,a.shape,s.shape),r.runWebGLProgram(t,[a,s],i)}var VK={kernelName:er,backendName:"webgl",kernelFunc:WK};function UK(e,t,n){let r=[MG(e.shape),...OG(e.shape)],a={dtype:e.dtype,shape:r,dataId:e.dataId},s=[MG(t),...OG(t)],i=new $q(s,r),o=!0,l=[r],u=n.runWebGLProgram(i,[a],e.dtype,l,o);return{dataId:u.dataId,shape:t,dtype:u.dtype}}function GK(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=n,o=Aa.sizeFromShape(a.shape),l=Aa.inferFromImplicitShape(s,o),u=Aa.sizeFromShape(l);Aa.assert(o===u,(()=>`The new shape (${l}) has ${u} elements and the old shape (${a.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`));let p=i.texData.get(a.dataId);return!p.isPacked||BG(a.shape,l)||null!==p.texture&&BG(p.shape,l)?(i.incRef(a.dataId),{dataId:a.dataId,shape:l,dtype:a.dtype}):UK(a,l,i)}var HK={kernelName:br,backendName:"webgl",kernelFunc:GK},jK=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let i=4*Math.floor(n/4),o=n%4,l="sumValue += dot(values, ones);";if(null!=t){let e=1/t;l=`sumValue += dot(values * ${Aa.isInt(e)?e.toPrecision(2):e}, ones);`}let u="";a%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}},qK=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let i="0.0",o="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",o="min"):"max"===t&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");let u=4*Math.floor(n/4),p=n%4,d=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,c="vec4";"all"===t?(i="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",c="bvec4"):"any"===t&&(i="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",c="bvec4");let h="";a%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${h}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${c} values = ${c}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===p}) {\n          ${c} values = ${c}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${2===p}) {\n          ${c} values = ${c}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${3===p}) {\n          ${c} values = ${c}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${l});\n      }\n    `}};function KK(e){let t=[];for(;0===t.length||1!==t[t.length-1].outSize;){let n=t.length?t[t.length-1].outSize:e[1],r=Mw.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}function XK(e,t,n,r){let a=KK(e.shape),s=e;for(let i=0;i<a.length;i++){let o,l,{inSize:u,windowSize:p,outSize:d}=a[i];o="mean"===n?0===i?new jK({windowSize:p,inSize:u,batchSize:e.shape[0],outSize:d},u):new jK({windowSize:p,inSize:u,batchSize:e.shape[0],outSize:d}):new qK({windowSize:p,inSize:u,batchSize:e.shape[0],outSize:d},n),l=s,s=r.runWebGLProgram(o,[s],t),l.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(l)}return s}var YK=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[t[s]];this.outputShape=n,this.rank=n.length;let r=ZH(this.rank),a=ZK(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${a}));\n    }\n    `}};function ZK(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let a=0;a<e.length;a++)r[e[a]]=n[a];return r.join()}var JK=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let u=0;u<n.length;u++)n[u]=e[t[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let r=ZH(this.rank),a=Cq("rc",this.rank),s=new Array(this.rank);for(let u=0;u<t.length;u++)s[t[u]]=a[u];let i=`vec2(${s.slice(-2).join()})`,o=`++${a[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${a[this.rank-1]};\n      if(++${a[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}};function QK(e,t,n){let r=et().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new JK(e.shape,t):new YK(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function eX(e,t,n,r){let a=t,s=e.shape.length,i=Aa.parseAxisParam(a,e.shape),o=i,l=Mw.getAxesPermutation(o,s),u=null!=l,p=e;u&&(p=QK(e,l,r),o=Mw.getInnerMostAxes(o.length,s)),Mw.assertAxesAreInnerMostDims("sum",o,s);let[d,c]=Mw.computeOutAndReduceShapes(p.shape,o),h=d;n&&(h=Mw.expandShapeToKeepDim(d,i));let f=Aa.sizeFromShape(c),m=Aa.sizeFromShape(e.shape)/f,g=GK({inputs:{x:p},attrs:{shape:[m,f]},backend:r}),y=Rs(e.dtype),b=XK(g,y,"sum",r),w=GK({inputs:{x:b},attrs:{shape:h},backend:r});return r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(b),u&&r.disposeIntermediateTensorInfo(p),w}function tX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;return eX(a,s,i,n)}var nX={kernelName:Pr,backendName:"webgl",kernelFunc:tX};function rX(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{perm:i}=a,o=r,l=s.shape.length,u=new Array(l);for(let p=0;p<u.length;p++)u[p]=s.shape[i[p]];if(o.shouldExecuteOnCPU([s])){let e=o.texData.get(s.dataId).values,n=Nq(e,s.shape,s.dtype,i,u);t=o.makeTensorInfo(u,s.dtype);let r=o.texData.get(t.dataId);r.values=n}else t=QK(s,i,o);return t}var aX={kernelName:sa,backendName:"webgl",kernelFunc:rX},sX=1e3;function iX({a:e,b:t,transposeA:n,transposeB:r,backend:a,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){let u=e.shape.length,p=t.shape.length,d=n?e.shape[u-2]:e.shape[u-1],c=r?t.shape[p-1]:t.shape[p-2],h=n?e.shape[u-1]:e.shape[u-2],f=r?t.shape[p-2]:t.shape[p-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),y=Aa.sizeFromShape(m),b=Aa.sizeFromShape(g),w=Ll.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([h,f]);Aa.assert(d===c,(()=>`Error in matMul: inner shapes (${d}) and (${c}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`));let x,v=n?[y,d,h]:[y,h,d],k=r?[b,f,c]:[b,c,f],I=GK({inputs:{x:e},backend:a,attrs:{shape:v}}),S=GK({inputs:{x:t},backend:a,attrs:{shape:k}}),N=[I,S],T=Math.max(y,b),C=n?I.shape[1]:I.shape[2],_=null!=s,E=null!=i,A="leakyrelu"===l,$=null!=l?OK(l,!0):null,F=_||E||A||null!=$;if((1===h||1===f)&&C>sX&&!1===F){let e=I,t=S;n&&(e=rX({inputs:{x:I},backend:a,attrs:{perm:[0,2,1]}}),N.push(e)),r&&(t=rX({inputs:{x:S},backend:a,attrs:{perm:[0,2,1]}}),N.push(t));let s=1!==f,i=1===f,o=e;s&&(o=GK({inputs:{x:e},backend:a,attrs:{shape:[T,C,1]}}),N.push(o));let l=1===f?2:1,u=t;i&&(u=GK({inputs:{x:t},backend:a,attrs:{shape:[T,1,C]}}),N.push(u));let p=WK({inputs:{a:o,b:u},backend:a});x=tX({inputs:{x:p},backend:a,attrs:{axis:l,keepDims:!0}}),N.push(p)}else{let l=Fs(e.dtype,t.dtype),u=new LK(v,k,[T,h,f],n,r,_,$,E,A),p=[I,S];if(null!=s&&p.push(s),E&&p.push(i),A){let e=a.makeTensorInfo([],"float32",Aa.createScalarValue(o,"float32"));p.push(e),N.push(e)}x=a.runWebGLProgram(u,p,l)}let R=GK({inputs:{x:x},backend:a,attrs:{shape:w}});N.push(x);for(let D of N)a.disposeIntermediateTensorInfo(D);return R}function oX(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:p,leakyreluAlpha:d}=r;return iX({a:a,b:s,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:d,activation:p})}var lX={kernelName:fa,backendName:"webgl",kernelFunc:oX},uX="return abs(x);";function pX(e){let t,{inputs:n,backend:r}=e,{x:a}=n;if(r.shouldExecuteOnCPU([a])&&"complex64"!==a.dtype){let e=r.texData.get(a.dataId),t=cq(e.values);return r.makeTensorInfo(a.shape,a.dtype,t)}return t=et().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new eK(a.shape,uX):new Bq(a.shape,uX),r.runWebGLProgram(t,[a],a.dtype)}var dX={kernelName:ot,backendName:"webgl",kernelFunc:pX},cX=Wq+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n",hX=DK({opSnippet:cX}),fX={kernelName:lt,backendName:"webgl",kernelFunc:hX},mX=Wq+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));",gX=DK({opSnippet:mX}),yX={kernelName:ut,backendName:"webgl",kernelFunc:gX},bX="return a + b;",wX=MK({opSnippet:bX,packedOpSnippet:bX,supportsComplex:!0,cpuKernelImpl:Pj}),xX={kernelName:pt,backendName:"webgl",kernelFunc:wX},vX=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));let n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));let r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}},kX=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));let n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));let r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}};function IX(e){let{inputs:t,backend:n}=e,r=t;if(1===r.length)return wK({inputs:{x:r[0]},backend:n});if(r.length>et().get("WEBGL_MAX_TEXTURES_IN_SHADER")){let e=Math.floor(r.length/2),t=IX({inputs:r.slice(0,e),backend:n}),a=IX({inputs:r.slice(e),backend:n});return IX({inputs:[t,a],backend:n})}let a=r.map((e=>e.dtype)).reduce(((e,t)=>Fs(e,t))),s=r.map((e=>e.shape)),i=et().getBool("WEBGL_PACK")?new kX(r[0].shape,s):new vX(r[0].shape,s);return n.runWebGLProgram(i,r,a)}var SX={kernelName:dt,backendName:"webgl",kernelFunc:IX};function NX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=Aa.parseAxisParam(s,a.shape),u=l,p=Mw.getAxesPermutation(u,o),d=a;null!=p&&(d=rX({inputs:{x:a},backend:n,attrs:{perm:p}}),u=Mw.getInnerMostAxes(u.length,o)),Mw.assertAxesAreInnerMostDims("all",u,o);let c,[h,f]=Mw.computeOutAndReduceShapes(d.shape,u),m=Aa.sizeFromShape(f),g=GK({inputs:{x:d},backend:n,attrs:{shape:[-1,m]}}),y=XK(g,g.dtype,"all",n);if(i){let e=Mw.expandShapeToKeepDim(h,l);c=GK({inputs:{x:y},backend:n,attrs:{shape:e}})}else c=GK({inputs:{x:y},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),null!=p&&n.disposeIntermediateTensorInfo(d),c}var TX={kernelName:ct,backendName:"webgl",kernelFunc:NX};function CX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=Aa.parseAxisParam(s,a.shape),u=l,p=Mw.getAxesPermutation(u,o),d=a;null!=p&&(d=rX({inputs:{x:a},backend:n,attrs:{perm:p}}),u=Mw.getInnerMostAxes(u.length,o)),Mw.assertAxesAreInnerMostDims("any",u,o);let c,[h,f]=Mw.computeOutAndReduceShapes(d.shape,u),m=Aa.sizeFromShape(f),g=GK({inputs:{x:d},backend:n,attrs:{shape:[-1,m]}}),y=XK(g,g.dtype,"any",n);if(i){let e=Mw.expandShapeToKeepDim(h,l);c=GK({inputs:{x:y},backend:n,attrs:{shape:e}})}else c=GK({inputs:{x:y},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),null!=p&&n.disposeIntermediateTensorInfo(d),c}var _X={kernelName:ht,backendName:"webgl",kernelFunc:CX},EX=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:r,batchSize:a,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,s];let i="max"===t?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}},AX=class{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Aa.assert(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));let a=e[e.length-1],s=Math.ceil(a/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");let i,o,l=this.outputShape,u=l.length,p=ZH(u),d=_q("coords",u);if(1===s){o=u+1;let e=ZH(o);i=`\n        ${e} sourceLocR = ${e}(${d.join()}, 0);\n        ++${d[u-1]};\n        ${e} sourceLocG = ${e}(${d.join()}, 0);\n        ++${d[u-2]};\n        ${e} sourceLocA = ${e}(${d.join()}, 0);\n        --${d[u-1]};\n        ${e} sourceLocB = ${e}(${d.join()}, 0);\n        --${d[u-2]};`}else o=u,i=`\n        ${p} sourceLocR = coords;\n        ++${d[u-1]};\n        ${p} sourceLocG = coords;\n        ++${d[u-2]};\n        ${p} sourceLocA = coords;\n        --${d[u-1]};\n        ${p} sourceLocB = coords;\n        --${d[u-2]};`;let c=["x","y","z","w","u","v"].slice(0,o),h="."+c[o-1],f=c.map((e=>"int "+e)),m=_q("sourceLocR",o-1).concat("inIdx.r"),g=_q("sourceLocG",o-1).concat("inIdx.g"),y=_q("sourceLocB",o-1).concat("inIdx.b"),b=_q("sourceLocA",o-1).concat("inIdx.a"),w="max"===n?"greaterThan":"lessThan",x=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,v=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,k=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${c.join()}),\n                                          vec2(${c.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${c.join()}),\n                               vec2(${c.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${p} coords = getOutputCoords();\n        bool hasNextCol = ${d[u-1]} < ${l[u-1]-1};\n        bool hasNextRow = ${d[u-2]} < ${l[u-2]-1};\n        ${i}\n        ivec4 srcIdx = ivec4(sourceLocR${h}, sourceLocG${h},\n          sourceLocB${h}, sourceLocA${h}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${v};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${x}\n          vec4 candidate = ${v};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${w}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}};function $X(e,t,n,r=null){let a=t.shape[0],s=t.shape[1];null!=r&&(a=r.shape[0],s=r.shape[1]);let i=Mw.computeOptimalWindowSize(s),o={windowSize:i,inSize:s,batchSize:a,outSize:Math.ceil(s/i)},l=new EX(o,n,null==r),u=[t];null!=r&&u.push(r);let p=e.runWebGLProgram(l,u,"int32");if(1===p.shape[1])return p;let d=$X(e,t,n,p);return e.disposeIntermediateTensorInfo(p),d}function FX(e,t,n,r=null){let a=null!=r?r.shape:t.shape,s=a[a.length-1],i=Mw.computeOptimalWindowSize(s),o=new AX(a,i,n,null==r),l=null==r?[t]:[t,r],u=e.runWebGLProgram(o,l,"int32");if(u.shape.length===t.shape.length){let r=FX(e,t,n,u);return e.disposeIntermediateTensorInfo(u),r}return u}function RX(e,t,n,r){let a=[n];if(Mw.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,t.shape.length),!et().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let n=[],s=e.texData.get(t.dataId),i=null!==s&&s.isPacked,o=t;i&&(o=e.unpackTensor(t),n.push(o));let[l,u]=Mw.computeOutAndReduceShapes(o.shape,a),p=Aa.sizeFromShape(u),d=GK({inputs:{x:o},backend:e,attrs:{shape:[-1,p]}});n.push(d);let c=$X(e,d,r);n.push(c);let h=GK({inputs:{x:c},backend:e,attrs:{shape:l}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),h}return FX(e,t,r)}function DX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r,i=Aa.parseAxisParam(s,a.shape),o=Mw.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(l=rX({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=Mw.getInnerMostAxes(i.length,l.shape.length)),Mw.assertAxesAreInnerMostDims("argMax",[i[0]],l.shape.length);let p=RX(n,l,i[0],"max");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}var MX={kernelName:ft,backendName:"webgl",kernelFunc:DX};function OX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r,i=Aa.parseAxisParam(s,a.shape),o=Mw.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(l=rX({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=Mw.getInnerMostAxes(i.length,l.shape.length)),Mw.assertAxesAreInnerMostDims("argMin",[i[0]],l.shape.length);let p=RX(n,l,i[0],"min");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}var LX={kernelName:mt,backendName:"webgl",kernelFunc:OX},PX=Wq+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n",zX=DK({opSnippet:PX}),BX={kernelName:gt,backendName:"webgl",kernelFunc:zX},WX=Wq+"return log(x + sqrt(x * x + 1.0));",VX=DK({opSnippet:WX}),UX={kernelName:yt,backendName:"webgl",kernelFunc:VX},GX=Wq+"\n  return atan(x);\n",HX=DK({opSnippet:GX}),jX={kernelName:bt,backendName:"webgl",kernelFunc:HX},qX=FK+"\n  return atan(a, b);\n",KX="\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  "+RK+"\n  return result;\n",XX=MK({opSnippet:qX,packedOpSnippet:KX}),YX={kernelName:xt,backendName:"webgl",kernelFunc:XX},ZX=Wq+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;",JX=DK({opSnippet:ZX}),QX={kernelName:wt,backendName:"webgl",kernelFunc:JX},eY=class{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,p=e.effectiveFilterHeight,d=e.effectiveFilterWidth,c=e.padInfo.top,h=e.padInfo.left;this.outputShape=e.outShape;let f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,y="0.0";if(f||(y="-1.0 / 1e-20"),n){let t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${o});\n        const ivec2 pads = ivec2(${c}, ${h});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${p};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?a?m:g:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b="max",w=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(w="avgValue / count");let x=4*Math.floor(s/4),v=s%4,k=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${b}(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${c}, ${h});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${p};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${x}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${k}\n          }\n\n          int xC = xCCorner + ${x};\n          if (${1===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${k}\n          } else if (${2===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${k}\n          } else if (${3===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${k}\n          }\n        }\n        setOutput(${w});\n      }\n    `}},tY=class{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,p=e.dilationHeight,d=e.dilationWidth,c=e.effectiveFilterDepth,h=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;let b="avg"===t,w="0.0";if(b||(w="-1.0 / 1e-20"),n){let t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${o}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${c};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${h};\n                wR += ${p}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${h} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let x="max",v=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(v="avgValue / count");let k=4*Math.floor(s/4),I=s%4,S=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${x}(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${o}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${w};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${w});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h};\n            wR += ${p}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${k}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${S}\n            }\n\n            int xC = xCCorner + ${k};\n            if (${1===I}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${2===I}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${3===I}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${S}\n            }\n          }\n          setOutput(${v});\n        }\n      }\n    `}};function nY(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;QG(a,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,u=1;Aa.assert(Mw.eitherStridesOrDilationsAreOne(i,u),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`));let p=Mw.computePool2DInfo(a.shape,s,i,u,o,l);if(1===p.filterWidth&&1===p.filterHeight&&Aa.arraysEqual(p.inShape,p.outShape))return wK({inputs:{x:a},backend:n});let d=new eY(p,"avg",!1);return n.runWebGLProgram(d,[a],"float32")}var rY={kernelName:vt,backendName:"webgl",kernelFunc:nY};function aY(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,p=[1,1,1],d=Mw.computePool3DInfo(a.shape,s,i,p,o,l,u),c=new tY(d,"avg",!1);return n.runWebGLProgram(c,[a],"float32")}var sY={kernelName:It,backendName:"webgl",kernelFunc:aY},iY=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.top,p=l-1-e.padInfo.left,d=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${p});\n      const float avgMultiplier = float(${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${s}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},oY=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,p=e.effectiveFilterDepth,d=e.effectiveFilterHeight,c=e.effectiveFilterWidth,h=p-1-e.padInfo.front,f=d-1-e.padInfo.top,m=c-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${h}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${p};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${a}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${d};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${c};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};function lY(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:p}=r,d=[1,1,1],c=Mw.computePool3DInfo(i.shape,o,l,d,u,p),h=new oY(c);return n.runWebGLProgram(h,[a],i.dtype)}var uY={kernelName:St,backendName:"webgl",kernelFunc:lY};function pY(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;QG([a,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=r,p=Mw.computePool2DInfo(i.shape,o,l,1,u),d=new iY(p);return n.runWebGLProgram(d,[a],i.dtype)}var dY={kernelName:kt,backendName:"webgl",kernelFunc:pY};function cY(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:i,transposeB:o}=r;return iX({a:a,b:s,transposeA:i,transposeB:o,backend:n})}var hY={kernelName:Nt,backendName:"webgl",kernelFunc:cY},fY=class{constructor(e,t,n,r,a,s){this.outputShape=[],this.variableNames=["x","mean","variance"],Mw.assertAndGetBroadcastShape(e,t),Mw.assertAndGetBroadcastShape(e,n);let i="0.0";null!=r&&(Mw.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";null!=a&&(Mw.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${s}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}},mY=class{constructor(e,t,n,r,a,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Mw.assertAndGetBroadcastShape(e,t),Mw.assertAndGetBroadcastShape(e,n);let i="vec4(0.0)";null!=r&&(Mw.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=a&&(Mw.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${s}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}},gY=({inputs:e,backend:t,attrs:n})=>{let{x:r,mean:a,variance:s,offset:i,scale:o}=e;Aa.assert(a.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Aa.assert(null==i||a.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Aa.assert(null==o||a.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:l}=n;null==l&&(l=.001);let u=[r,a,s],p=null;null!=i&&(p=i.shape,u.push(i));let d=null;null!=o&&(d=o.shape,u.push(o));let c=et().getBool("WEBGL_PACK_NORMALIZATION")?new mY(r.shape,a.shape,s.shape,p,d,l):new fY(r.shape,a.shape,s.shape,p,d,l);return t.runWebGLProgram(c,u,u[0].dtype)},yY={kernelName:yn,backendName:"webgl",kernelFunc:gY},bY=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=ZH(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n,r=xY(this.rank),a=e.map(((e,t)=>`sourceLoc.${wY[t]} = start[${t}] + coords.${wY[t]};`));n=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${a.join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${n}\n        setOutput(getSource(${r}));\n      }\n    `}},wY=["x","y","z","w","u","v"];function xY(e){if(1===e)return"sourceLoc";if(e<=6)return wY.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}var vY=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=ZH(this.rank),n=_q("coords",this.rank),r=_q("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,s=`getChannel(getSource(${r.join()}), ${a})`,i=`\n      result.x = ${s};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${s};\n        --${r[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${s};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${s};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${i}\n        ${o}\n        setOutput(result);\n      }\n    `}};function kY(e,t,n,r){let a=r.texData.get(e.dataId),s=r.makeTensorInfo(n,e.dtype),i=r.texData.get(s.dataId);Object.assign(i,a),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=au.computeFlatOffset(t,Aa.computeStrides(e.shape));a.slice&&(o+=a.slice.flatOffset),i.slice={flatOffset:o,origDataId:a.slice&&a.slice.origDataId||e.dataId};let l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),s}function IY(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r,[o,l]=au.parseSliceParams(a,s,i);if(au.assertParamsValid(a,o,l),0===Aa.sizeFromShape(l))return n.makeTensorInfo(l,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||"string"===a.dtype){let e=n.texData.get(a.dataId),t=hq(e.values,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,t)}let{isPacked:u}=n.texData.get(a.dataId),p=au.isSliceContinous(a.shape,o,l);if(u||!p){let e=et().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new vY(l):new bY(l),t=[o];return n.runWebGLProgram(e,[a],a.dtype,t)}return n.uploadToGPU(a.dataId),kY(a,o,l,n)}var SY={kernelName:$r,backendName:"webgl",kernelFunc:IY},NY=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;Aa.assert(a.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));let o=s.reduce(((e,t)=>e*t)),l=Mw.getReshaped(a.shape,s,o),u=Mw.getPermuted(l.length,s.length),p=Mw.getReshapedPermuted(a.shape,s,o),d=Mw.getSliceBeginCoords(i,s.length),c=Mw.getSliceSize(p,i,s.length),h=[],f=GK({inputs:{x:a},backend:n,attrs:{shape:l}}),m=rX({inputs:{x:f},backend:n,attrs:{perm:u}}),g=GK({inputs:{x:m},backend:n,attrs:{shape:p}}),y=IY({inputs:{x:g},backend:n,attrs:{begin:d,size:c}});return h.push(f),h.push(m),h.push(g),h.forEach((e=>n.disposeIntermediateTensorInfo(e))),y},TY={kernelName:Tt,backendName:"webgl",kernelFunc:NY};function CY(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=n.readSync(a.dataId),l=n.readSync(s.dataId),u=zj(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}var _Y={kernelName:Ct,backendName:"webgl",kernelFunc:CY};function EY(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.readSync(r.dataId),i=n.readSync(a.dataId),o=Mw.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var AY={kernelName:Et,backendName:"webgl",kernelFunc:EY},$Y="return float(a != b);",FY=MK({opSnippet:$Y,cpuKernelImpl:iq,dtype:"bool"}),RY={kernelName:nr,backendName:"webgl",kernelFunc:FY};function DY(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.texData.get(r.dataId);return wK({inputs:{x:a.complexTensorInfos.real},backend:n})}var MY={kernelName:mr,backendName:"webgl",kernelFunc:DY},OY="return float(int(x));";function LY(e,t){let n=new Bq(e.shape,OY),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function PY(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if("complex64"===s){if("complex64"===a.dtype)return wK({inputs:{x:a},backend:n});let e=kf(a.shape),t=PY({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),r=vK({inputs:{real:t,imag:e},backend:n});return e.dispose(),n.disposeIntermediateTensorInfo(t),r}if("complex64"===a.dtype){let e=DY({inputs:{input:a},backend:n}),t=PY({inputs:{x:e},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(e),t}if(!Aa.hasEncodingLoss(a.dtype,s)){let e=wK({inputs:{x:a},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}if("int32"===s)return LY(a,n);if("bool"===s){let e=n.makeTensorInfo([],"bool",Aa.getTypedArrayFromDType("bool",1)),t=FY({inputs:{a:a,b:e},backend:n});return n.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${s}`)}var zY={kernelName:At,backendName:"webgl",kernelFunc:PY},BY="return ceil(x);",WY=DK({opSnippet:BY,packedOpSnippet:BY,cpuKernelImpl:Wj}),VY={kernelName:$t,backendName:"webgl",kernelFunc:WY},UY=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}},GY=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}};function HY(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{clipValueMin:i,clipValueMax:o}=a;t=et().getBool("WEBGL_PACK_CLIP")?new GY(s.shape):new UY(s.shape);let l=[[i],[o]];return r.runWebGLProgram(t,[s],s.dtype,l)}var jY={kernelName:Ft,backendName:"webgl",kernelFunc:HY},qY=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}};function KY(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function XY(e){let{inputs:t,backend:n}=e,{x:r}=t,a=n.texData.get(r.dataId),s=new qY(r.shape),i=[KY(r,a.complexTensorInfos.real),KY(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(s,i,i[0].dtype)}var YY={kernelName:Dt,backendName:"webgl",kernelFunc:XY},ZY=class{constructor(e){this.outputShape=[],this.outputShape=Mw.computeOutShape(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));let t=new Array(e.length-1);t[0]=e[0][1];for(let s=1;s<t.length;s++)t[s]=t[s-1]+e[s][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<t.length;s++){let e=t[s-1];n.push(`else if (yC < ${t[s]}) setOutput(getT${s}(yR, yC-${e}));`)}let r=t.length,a=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${a}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}},JY=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Mw.computeOutShape(e,t);let n=this.outputShape,r=n.length,a=ZH(r),s=_q("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));let o=new Array(e.length-1);o[0]=e[0][t];for(let f=1;f<o.length;f++)o[f]=o[f-1]+e[f][t];let l=i[t],u=i.slice(-2),p=i.join(),d=`if (${l} < ${o[0]}) {\n        return getChannel(\n            getT0(${p}), vec2(${u.join()}));\n        }`;for(let f=1;f<o.length;f++){let e=o[f-1];d+=`\n        if (${l} < ${o[f]}  && ${l} >= ${o[f-1]}) {\n          return getChannel(\n            getT${f}(${QY(i,l,e)}),\n            vec2(${QY(u,l,e)}));\n        }`}let c=o.length,h=o[o.length-1];d+=`\n        return getChannel(\n          getT${c}(${QY(i,l,h)}),\n          vec2(${QY(u,l,h)}));`,this.userCode=`\n      float getValue(${i.map((e=>"int "+e))}) {\n        ${d}\n      }\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${s}), 0., 0., 0.);\n\n        ${s[r-1]} = ${s[r-1]} + 1;\n        if (${s[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${s});\n        }\n\n        ${s[r-2]} = ${s[r-2]} + 1;\n        if (${s[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${s});\n        }\n\n        ${s[r-1]} = ${s[r-1]} - 1;\n        if (${s[r-2]} < ${n[r-2]} &&\n            ${s[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${s});\n        }\n        setOutput(result);\n      }\n    `}};function QY(e,t,n){let r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}function eZ(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.texData.get(r.dataId);return wK({inputs:{x:a.complexTensorInfos.imag},backend:n})}var tZ={kernelName:Sn,backendName:"webgl",kernelFunc:eZ};function nZ(e,t,n){let r=e[0].dtype;if("complex64"===r){let r=e.map((e=>DY({inputs:{input:e},backend:n}))),a=e.map((e=>eZ({inputs:{input:e},backend:n}))),s=nZ(r,t,n),i=nZ(a,t,n),o=vK({inputs:{real:s,imag:i},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),a.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),o}let a=n.shouldExecuteOnCPU(e);if("string"===r&&(a=!0),a){let a=e.map((e=>{let r=Aa.sizeFromShape(e.shape.slice(t));return GK({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})})),s=a.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),i=Mw.computeOutShape(a.map((e=>e.shape)),1),o=1===a[0].shape[0],l=Vj(s,i,r,o),u=Mw.computeOutShape(e.map((e=>e.shape)),t),p=n.makeTensorInfo(u,r,l);return a.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}if(e.length>et().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let r=Math.floor(e.length/2),a=nZ(e.slice(0,r),t,n),s=nZ(e.slice(r),t,n),i=nZ([a,s],t,n);return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}if(et().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].shape.length>1){let a=new JY(e.map((e=>e.shape)),t);return n.runWebGLProgram(a,e,r)}let{tensors2D:s,outShape:i}=rZ(e,t,n),o=new ZY(s.map((e=>e.shape))),l=n.runWebGLProgram(o,s,r);s.forEach((e=>n.disposeIntermediateTensorInfo(e)));let u=GK({inputs:{x:l},attrs:{shape:i},backend:n});return n.disposeIntermediateTensorInfo(l),u}function rZ(e,t,n){let r=Mw.computeOutShape(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>GK({inputs:{x:e},attrs:{shape:[-1,Aa.sizeFromShape(e.shape.slice(t))]},backend:n}))),outShape:r}}function aZ(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=Aa.parseAxisParam(a,t[0].shape)[0],i=Mw.computeOutShape(t.map((e=>e.shape)),s);if(0===Aa.sizeFromShape(i))return n.makeTensorInfo(i,t[0].dtype,[]);let o=t.filter((e=>Aa.sizeFromShape(e.shape)>0));if(1===o.length)return wK({inputs:{x:o[0]},backend:n});let l=o.map((e=>e.shape));return Mw.assertParamsConsistent(l,s),nZ(o,s,n)}var sZ={kernelName:Mt,backendName:"webgl",kernelFunc:aZ},iZ=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let s=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,p=e.dilationWidth,d=e.filterHeight,c=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,y=m?2:3,b=m?3:1,w="",x="";n&&(w=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,x="result = activation(result);");let v=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${w}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${c}; wC++) {\n            int xC = xCCorner + wC * ${p};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${h}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${h}) *\n                    getW(wR, wC, ${h}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${h}, xR, xC) *\n                    getW(wR, wC, ${h}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2),\n                getW(wR, wC, ${h} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1),\n                  getX(batch, xR, xC, ${h} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC),\n                  getX(batch, ${h} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${v}\n        ${x}\n        setOutput(result);\n      }\n    `}},oZ=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,p=e.filterDepth,d=e.filterHeight,c=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${a}, ${s}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${p}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${c}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${h}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${h}) *\n                  getW(wF, wR, wC, ${h}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1),\n                  getX(batch, xF, xR, xC, ${h} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2),\n                  getW(wF, wR, wC, ${h} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},lZ=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=ij(this.outputShape.length);let{dataFormat:n}=t,r=tH(),a="channelsLast"===n,s=a?0:1,i=a?1:2,o=this.enableShapeUniforms?"if(blockIndex < outShape[1] && pos < outShape[0]) {":`if(blockIndex < ${e[1]} && pos < ${e[0]}) {`,l="";for(let u=0;u<=1;u++)for(let e=0;e<=1;e++)l+=`\n          blockIndex = rc.y + ${e};\n          pos = rc.x + ${u};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${s}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${i}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${a}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*u+e}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*u+e}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${r.output} = result;\n      }\n    `}};function uZ({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let l,u=e.shape,p=r.texData.get(e.dataId),d=n.inChannels,c=u[0]*u[1]*u[2],h=n.outChannels,f="channelsLast"===n.dataFormat,m=!1,g=!1,y=[];if(null!=s&&!f&&3===s.shape.length){let e=rX({inputs:{x:s},backend:r,attrs:{perm:[1,2,0]}});y.push(e),s=e}if((1!==c&&1!==h||!(d>sX))&&p.isPacked&&f&&null!=p.texture&&u[2]%2!==0&&Aa.arraysEqual(p.shape.slice(-3),u.slice(-3))){let d=u[0]*u[1]*(u[2]+1),c={dataId:e.dataId,shape:[1,d,n.inChannels],dtype:e.dtype},h=p.shape;p.shape=p.shape.slice(),p.shape[p.shape.length-2]++,Aa.assert(BG(p.shape,c.shape),(()=>`packed reshape ${p.shape} to ${c.shape} isn't free`));let f=GK({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});y.push(f);let b=iX({a:c,b:f,backend:r,transposeA:m,transposeB:g,bias:a,activation:o,preluActivationWeights:s,leakyreluAlpha:i}),w=r.texData.get(b.dataId);Aa.assert(w.isPacked,(()=>"batchMatMul result is expected to be packed")),p.shape=h,w.shape=n.outShape,l=wK({inputs:{x:b},backend:r}),l.shape=n.outShape,y.push(b)}else{let u=f?e:rX({inputs:{x:e},backend:r,attrs:{perm:[0,2,3,1]}}),p=u.shape,d=p[0]*p[1]*p[2],c=GK({inputs:{x:u},backend:r,attrs:{shape:[1,d,n.inChannels]}}),h=GK({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),b=iX({a:c,b:h,transposeA:m,transposeB:g,backend:r,bias:a,activation:o,preluActivationWeights:s,leakyreluAlpha:i}),w=[n.batchSize,n.outHeight,n.outWidth,n.outChannels],x=GK({inputs:{x:b},backend:r,attrs:{shape:w}});l=f?x:rX({inputs:{x:x},backend:r,attrs:{perm:[0,3,1,2]}}),f||(y.push(u),y.push(x)),y.push(c),y.push(h),y.push(b)}for(let b of y)r.disposeIntermediateTensorInfo(b);return l}function pZ({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let{filterWidth:l,filterHeight:u,inChannels:p,outWidth:d,outHeight:c,dataFormat:h}=n,f="channelsLast"===h,m=l*u*p,g=c*d,y=[m,g],b=!0,w=!1,x=[];if(null!=s&&!f&&3===s.shape.length){let e=rX({inputs:{x:s},backend:r,attrs:{perm:[1,2,0]}});x.push(e),s=e}let v=GK({inputs:{x:e},backend:r,attrs:{shape:e.shape.slice(1)}}),k=GK({inputs:{x:t},backend:r,attrs:{shape:[1,m,Aa.sizeFromShape(t.shape)/m]}});x.push(v),x.push(k);let I=new lZ(y,n),S=[v.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],N=r.runWebGLProgram(I,[v],"float32",S),T=GK({inputs:{x:N},backend:r,attrs:{shape:[1,y[0],y[1]]}});x.push(N),x.push(T);let C=null!=a,_=null!=s,E="leakyrelu"===o,A=o?OK(o,!0):null,$=new LK(T.shape,k.shape,[1,g,n.outChannels],b,w,C,A,_,E),F=[T,k];if(a&&F.push(a),_&&F.push(s),E){let e=r.makeTensorInfo([],"float32",Aa.createScalarValue(i,"float32"));F.push(e),x.push(e)}let R=r.runWebGLProgram($,F,"float32"),D=[1,c,d,n.outChannels],M=GK({inputs:{x:R},backend:r,attrs:{shape:D}}),O=f?M:rX({inputs:{x:M},backend:r,attrs:{perm:[0,3,1,2]}});f||x.push(M),x.push(R);for(let L of x)r.disposeIntermediateTensorInfo(L);return O}function dZ(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s,filter:i}=n,{strides:o,pad:l,dataFormat:u,dilations:p,dimRoundingMode:d}=a,c=Mw.convertConv2DDataFormat(u),h=Mw.computeConv2DInfo(s.shape,i.shape,o,p,l,d,!1,c);if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(et().getBool("WEBGL_CONV_IM2COL")&&1===s.shape[0])t=pZ({x:s,filter:i,convInfo:h,backend:r});else{let e=new iZ(h);t=r.runWebGLProgram(e,[s,i],"float32")}else t=uZ({x:s,filter:i,convInfo:h,backend:r});let f=GK({inputs:{x:t},backend:r,attrs:{shape:h.outShape}});return r.disposeIntermediateTensorInfo(t),f}var cZ={kernelName:Ot,backendName:"webgl",kernelFunc:dZ},hZ=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              if (${s}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},fZ=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=s?1:2,u=s?2:3,p=s?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${p}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${s}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},mZ=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${a};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${s};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${i};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},gZ=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${o}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${a}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};function yZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:p}=r,d=Mw.convertConv2DDataFormat(l),c=Mw.computeConv2DInfo(a.shape,p,i,1,o,u,!1,d),h=new hZ(c);return n.runWebGLProgram(h,[a,s],"float32")}var bZ={kernelName:Lt,backendName:"webgl",kernelFunc:yZ};function wZ(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:p}=r,d=Mw.convertConv2DDataFormat(u),c=Mw.computeConv2DInfo(i,s.shape,o,1,l,p,!1,d),h=new fZ(c);return n.runWebGLProgram(h,[a,s],"float32")}var xZ={kernelName:Pt,backendName:"webgl",kernelFunc:wZ};function vZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,u=Mw.computeConv3DInfo(a.shape,s.shape,i,l,o),p=new oZ(u);return n.runWebGLProgram(p,[a,s],"float32")}var kZ={kernelName:zt,backendName:"webgl",kernelFunc:vZ};function IZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r,u=Mw.computeConv3DInfo(a.shape,l,i,1,o),p=new mZ(u);return n.runWebGLProgram(p,[a,s],"float32")}var SZ={kernelName:Bt,backendName:"webgl",kernelFunc:IZ};function NZ(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r,u=Mw.computeConv3DInfo(l,s.shape,o,1,i),p=new gZ(u);return n.runWebGLProgram(p,[a,s],"float32")}var TZ,CZ={kernelName:Wt,backendName:"webgl",kernelFunc:NZ},_Z=$K+"\n  return cos(x);\n",EZ=DK({opSnippet:_Z}),AZ={kernelName:Vt,backendName:"webgl",kernelFunc:EZ},$Z="\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n",FZ=DK({opSnippet:$Z}),RZ={kernelName:Ut,backendName:"webgl",kernelFunc:FZ},DZ=class{constructor(e,t,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[s,i,o,l]=e,[u]=t,[p,d]=n;this.outputShape=[u,p,d,l];let c="bilinear"===r?1:0,[h,f]=[i-1+".0",o-1+".0"],[m,g,y]=p>1?[""+(i-1)/(p-1),"(y2-y1) * height_ratio",`y1*${h} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${h}`],[b,w,x]=d>1?[""+(o-1)/(d-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${s}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${w};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${h} ) {\n          setOutput(float(${a}));\n          return;\n        }\n        float in_x = ${x};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${a}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${c} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}},MZ=e=>{let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,p=new DZ(a.shape,s.shape,o,l,u);return n.runWebGLProgram(p,[a,s,i],"float32")},OZ={kernelName:jt,backendName:"webgl",kernelFunc:MZ};(function(e){e.Prod="*",e.Sum="+"})(TZ||(TZ={}));var LZ=class{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let a=this.outputShape.length,s=this.op===TZ.Prod?"1.0":"0.0",i=n?s:`getX(${PZ(a,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1],l="",u="";n?(l=r?"end != "+(o-1):"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${ZH(a)} coords = getOutputCoords();\n        int end = ${zZ(a,"coords",this.op)};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${u};\n          ${zZ(a,"coords",this.op)} = idx;\n          val ${this.op}= getX(${PZ(a,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}};function PZ(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function zZ(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function BZ(e,t,n,r,a,s){let i=t.shape.length,o=Mw.getAxesPermutation([r],i),l=t;null!=o&&(l=rX({inputs:{x:t},backend:n,attrs:{perm:o}}));let u=Mw.getInnerMostAxes(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);let p=l.shape[u],d=wK({inputs:{x:l},backend:n});for(let c=0;c<=Math.ceil(Math.log2(p))-1;c++){let t=new LZ(e,l.shape,!1,s),r=[[c]],a=d;d=n.runWebGLProgram(t,[d],d.dtype,r),n.disposeIntermediateTensorInfo(a)}if(a){let t=new LZ(e,l.shape,a,s),r=d;d=n.runWebGLProgram(t,[d],d.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=o){let e=Mw.getUndoAxesPermutation(o),t=rX({inputs:{x:d},backend:n,attrs:{perm:e}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(l),t}return d}function WZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return BZ(TZ.Prod,a,n,s,i,o)}var VZ={kernelName:Gt,backendName:"webgl",kernelFunc:WZ};function UZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return BZ(TZ.Sum,a,n,s,i,o)}var GZ={kernelName:Ht,backendName:"webgl",kernelFunc:UZ};function HZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(1===a.shape.length){let e=n.readSync(a.dataId),t=n.readSync(s.dataId),r=zj(e,t,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,r)}if(2===a.shape.length){let e=n.bufferSync(a),t=n.bufferSync(s),r=Bj(e,t,i,o);return n.makeTensorInfo(r.shape,s.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}var jZ={kernelName:qt,backendName:"webgl",kernelFunc:HZ},qZ=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function KZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r,o=a.shape[0],l="NHWC"===i?a.shape[1]:a.shape[2],u="NHWC"===i?a.shape[2]:a.shape[3],p="NHWC"===i?a.shape[3]:a.shape[1],d=l*s,c=u*s,h=p/(s*s),f="NHWC"===i?[o,d,c,h]:[o,h,d,c],m=new qZ(f,s,i);return n.runWebGLProgram(m,[a],a.dtype)}var XZ={kernelName:Kt,backendName:"webgl",kernelFunc:KZ},YZ=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=ij(this.outputShape.length);let s=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels,l="",u="";n&&(l=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,u="result = activation(result);");let p=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${s}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${p}\n        ${u}\n        setOutput(result);\n      }\n    `}},ZZ=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=ij(this.outputShape.length);let s=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,p=e.filterWidth,d=p,c="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<p;g++)c+=`\n          vec4 xTexelC${2*g};\n          int xTexelC${2*g}Ready;\n          vec4 xTexelC${2*g+1};\n          int xTexelC${2*g+1}Ready;\n          vec4 xC${g};`;c+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let g=0;g<p;g++)c+=`\n          xTexelC${2*g} = vec4(0.0);\n          xTexelC${2*g}Ready = 0;\n          xTexelC${2*g+1} = vec4(0.0);\n          xTexelC${2*g+1}Ready = 0;\n          xC${g} = vec4(0.0);`;c+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let g=0;g<(d+1)/2;g++){let e=2*g;if(c+=`\n          xC = xCCorner + ${e*l};\n          `,1===o){if(e<p&&(i%2===1?(c+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n              `,c+=1===l&&e>0?`\n                xC${e} = vec4(xTexelC${e-2}.zw, xTexelC${e}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${e} = vec4(previous.zw, xTexelC${e}.xy);\n                  } else {\n                    xC${e} = vec4(0.0, 0.0, xTexelC${e}.xy);\n                  }\n                  `):c+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xC${e} = xTexelC${e};\n                `,e+1<p)){let t=i%2===0?Aa.nearestLargerEven(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(c+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${t};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                    xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${e+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${e+1}Ready = 1;\n                  }\n                  `,l>1&&(c+=`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                      xTexelC${e} = getX(batch, xR, xCOffset, d1);\n                      xTexelC${e}Ready = 1;\n                    }\n                    `),c+=`\n                  xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.xy);\n                  `):c+=1===t?`\n                    xC${e+1} = xTexelC${e};\n                    `:`\n                    xCOffset = xC + ${t};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                      xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${e+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${e+1}Ready = 1;\n                    }\n\n                    xC${e+1} = xTexelC${e+1};\n                    `}}else e<p&&(i%2===1?(c+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n              `,e+1<p&&(c+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${e+1} = vec4(xTexelC${e+1}.xy, final.xy);\n                `)):(c+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(\n                  xTexelC${e}.xy, xTexelC${e+1}.xy);\n              `,e+1<p&&(c+=`\n                  xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n                `)));e<p&&(c+=`\n            wTexel = getW(r, ${e}, d1, q);\n            dotProd += xC${e} * vec4(wTexel.xz, wTexel.xz);\n          `,e+1<p&&(c+=`\n              wTexel = getW(r, ${e+1}, d1, q);\n              dotProd += xC${e+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}c+="\n    }\n  ",c+="\n      }\n    ";let h="",f="";n&&(h=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,f="result = activation(result);");let m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${h}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${s};\n        int q = d2 - d1 * ${s};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${c}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${f}\n        setOutput(result);\n      }\n    `}};function JZ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r,p=l;null==p&&(p=[1,1]),Aa.assert(Mw.eitherStridesOrDilationsAreOne(i,p),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${p}'`));let d,c=Mw.computeConv2DInfo(a.shape,s.shape,i,p,o,u,!0);d=et().getBool("WEBGL_PACK_DEPTHWISECONV")&&c.strideWidth<=2&&c.outChannels/c.inChannels===1?new ZZ(c):new YZ(c);let h=[[c.padInfo.top,c.padInfo.left],[c.strideHeight,c.strideWidth],[c.dilationHeight,c.dilationWidth],[c.inHeight,c.inWidth]];return n.runWebGLProgram(d,[a,s],"float32",h)}var QZ={kernelName:Xt,backendName:"webgl",kernelFunc:JZ},eJ=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${s} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},tJ=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};function nJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:p}=r,d=Mw.computeConv2DInfo(a.shape,p,i,o,l,u,!0),c=new eJ(d);return n.runWebGLProgram(c,[a,s],"float32")}var rJ={kernelName:Yt,backendName:"webgl",kernelFunc:nJ};function aJ(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:p}=r,d=Mw.computeConv2DInfo(p,s.shape,i,o,l,u,!0),c=new tJ(d);return n.runWebGLProgram(c,[a,s],"float32")}var sJ={kernelName:Zt,backendName:"webgl",kernelFunc:aJ},iJ=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}};function oJ(e){let{inputs:t,backend:n}=e,{x:r}=t,a=[...r.shape,...r.shape],s=Aa.sizeFromShape(r.shape),i=GK({inputs:{x:r},backend:n,attrs:{shape:[s]}}),o=new iJ(s),l=n.runWebGLProgram(o,[i],i.dtype),u=GK({inputs:{x:l},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}var lJ={kernelName:Jt,backendName:"webgl",kernelFunc:oJ},uJ=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:r,strideHeight:a,strideWidth:s,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:p,left:d}=r;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${s});\n      const ivec2 pads = ivec2(${p}, ${d});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}};function pJ(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s,filter:i}=n,{strides:o,pad:l,dilations:u}=a,p=Mw.computeDilation2DInfo(s.shape,i.shape,o,l,"NHWC",u),d=new uJ(p);t=r.runWebGLProgram(d,[s,i],"float32");let c=GK({inputs:{x:t},backend:r,attrs:{shape:p.outShape}});return r.disposeIntermediateTensorInfo(t),c}var dJ={kernelName:Qt,backendName:"webgl",kernelFunc:pJ};function cJ(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=Mw.decodeEinsumEquation(a,s.length);Mw.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:p}=Mw.getEinsumComputePath(o,l),d=p.length,c=null,h=i.length,f=[];for(let m=0;m<d;++m){for(let e of p[m]){let t,{permutationIndices:r,expandDims:a}=Mw.getEinsumPermutation(h,l[e]);Mw.isIdentityPermutation(r)?t=s[e]:(t=rX({inputs:{x:s[e]},backend:n,attrs:{perm:r}}),f.push(t));let i=t.shape.slice();for(let e=0;e<a.length;++e)i.splice(a[e],0,1);Aa.arraysEqual(t.shape,i)||(t=GK({inputs:{x:t},backend:n,attrs:{shape:i}}),f.push(t)),null===c?c=t:(c=WK({inputs:{a:t,b:c},backend:n}),f.push(c))}m<d-1&&(u[m]>=0&&(c=tX({inputs:{x:c},backend:n,attrs:{axis:u[m]-(i.length-h),keepDims:!1}}),f.push(c)),h--)}for(let m of f)m!==c&&n.disposeIntermediateTensorInfo(m);return c}var hJ={kernelName:rn,backendName:"webgl",kernelFunc:cJ},fJ="return (x >= 0.0) ? x : (exp(x) - 1.0);",mJ="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",gJ=DK({opSnippet:fJ,packedOpSnippet:mJ}),yJ={kernelName:an,backendName:"webgl",kernelFunc:gJ},bJ="return (b >= 1.0) ? a : a * (b + 1.0);",wJ="\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",xJ=e=>{let{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=et().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new bK(wJ,r.shape,a.shape):new gK(bJ,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],r.dtype)},vJ={kernelName:sn,backendName:"webgl",kernelFunc:xJ},kJ="\n  return vec4(equal(a, b));\n",IJ="return float(a == b);",SJ=MK({opSnippet:IJ,packedOpSnippet:kJ,dtype:"bool",cpuKernelImpl:Uj}),NJ={kernelName:ln,backendName:"webgl",kernelFunc:SJ},TJ=`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${Mw.ERF_P};\n  float a1 = ${Mw.ERF_A1};\n  float a2 = ${Mw.ERF_A2};\n  float a3 = ${Mw.ERF_A3};\n  float a4 = ${Mw.ERF_A4};\n  float a5 = ${Mw.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`,CJ=DK({opSnippet:TJ}),_J={kernelName:on,backendName:"webgl",kernelFunc:CJ},EJ=$K+"\n  return exp(x);\n",AJ="\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",$J=DK({opSnippet:EJ,packedOpSnippet:AJ,cpuKernelImpl:Gj,dtype:"float32"}),FJ={kernelName:un,backendName:"webgl",kernelFunc:$J};function RJ(e){let{inputs:t,attrs:n,backend:r}=e,{dim:a}=n,{input:s}=t,i=s.shape.length,o=s.shape.slice(),l=a;return a<0&&(Aa.assert(-(i+1)<=a,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+a+1),o.splice(l,0,1),GK({inputs:{x:s},backend:r,attrs:{shape:o}})}var DJ={kernelName:pn,backendName:"webgl",kernelFunc:RJ},MJ="return exp(x) - 1.0;",OJ=DK({opSnippet:MJ,packedOpSnippet:MJ,cpuKernelImpl:Hj}),LJ={kernelName:dn,backendName:"webgl",kernelFunc:OJ},PJ=class{constructor(e,t,n){this.variableNames=["real","imag"];let r=t[1];this.outputShape=t;let a,s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=n?`${r}.0`:"1.0";if("real"===e)a="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${i};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}};function zJ(e,t,n){let r=n.texData.get(e.dataId),a=Aa.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],i=a/s,o=GK({inputs:{x:e},backend:n,attrs:{shape:[i,s]}}),l=o.shape,u=new PJ("real",l,t),p=new PJ("imag",l,t),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],c=n.runWebGLProgram(u,d,"float32"),h=n.runWebGLProgram(p,d,"float32"),f=vK({inputs:{real:c,imag:h},backend:n});n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h);let m=GK({inputs:{x:f},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(f),m}function BJ(e){let{inputs:t,backend:n}=e,{input:r}=t;return zJ(r,!1,n)}var WJ={kernelName:cn,backendName:"webgl",kernelFunc:BJ},VJ=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}};function UJ(e){let{backend:t,attrs:n}=e,{shape:r,value:a}=n,{dtype:s}=n;if(s=s||Aa.inferDtype(a),"string"===s){let e=Aa.getArrayFromDType(s,Aa.sizeFromShape(r));return e.fill(a),t.makeTensorInfo(r,s,e)}{let e=new VJ(r,a),n=[[a]];return t.runWebGLProgram(e,[],s,n)}}var GJ,HJ={kernelName:hn,backendName:"webgl",kernelFunc:UJ},jJ=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}},qJ={kernelName:fn,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{let{image:n}=e,r=t,a=new jJ(n.shape);return r.runWebGLProgram(a,[n],n.dtype)}},KJ="return floor(x);",XJ=DK({opSnippet:KJ,packedOpSnippet:KJ,cpuKernelImpl:jj}),YJ={kernelName:mn,backendName:"webgl",kernelFunc:XJ},ZJ="\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",JJ="\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",QJ=MK({opSnippet:ZJ,packedOpSnippet:JJ,dtype:"int32"}),eQ={kernelName:gn,backendName:"webgl",kernelFunc:QJ},tQ=class{constructor(e){this.variableNames=["A"];let t=tH(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}},nQ=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=tH(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}},rQ={kernelName:ca,backendName:"webgl",kernelFunc:aQ};function aQ(e){let{inputs:t,backend:n,attrs:r}=e,{pixels:a}=t,{numChannels:s}=r,i="undefined"!=typeof HTMLVideoElement&&a instanceof HTMLVideoElement,o="undefined"!=typeof HTMLImageElement&&a instanceof HTMLImageElement,[l,u]=i?[a.videoWidth,a.videoHeight]:[a.width,a.height],p=[u,l],d=[u,l,s];(o||i)&&(null==GJ&&(GJ=document.createElement("canvas").getContext("2d")),GJ.canvas.width=l,GJ.canvas.height=u,GJ.drawImage(a,0,0,l,u),a=GJ.canvas);let c=n.makeTensorInfo(p,"int32");n.texData.get(c.dataId).usage=BU.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(c.dataId),a);let h=et().getBool("WEBGL_PACK")?new nQ(d):new tQ(d),f=n.runWebGLProgram(h,[c],"int32");return n.disposeData(c.dataId),f}function sQ(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s,filter:i,bias:o,preluActivationWeights:l}=n,{strides:u,pad:p,dataFormat:d,dilations:c,dimRoundingMode:h,activation:f,leakyreluAlpha:m}=a,g=Mw.convertConv2DDataFormat(d),y=Mw.computeConv2DInfo(s.shape,i.shape,u,c,p,h,!1,g),b=[];if(1!==y.filterHeight||1!==y.filterWidth||1!==y.dilationHeight||1!==y.dilationWidth||1!==y.strideHeight||1!==y.strideWidth||"SAME"!==y.padInfo.type&&"VALID"!==y.padInfo.type)if(et().getBool("WEBGL_CONV_IM2COL")&&1===s.shape[0])t=pZ({x:s,filter:i,convInfo:y,backend:r,bias:o,activation:f,preluActivationWeights:l,leakyreluAlpha:m});else{let e=null!=o,n=null!=l,a="leakyrelu"===f,u=f?OK(f,!1):null,p=new iZ(y,e,u,n,a),c=[s,i],h=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){let t=GK({inputs:{x:e},backend:r,attrs:{shape:[e.shape[0],1,1]}});return b.push(t),t}return e};if(e&&c.push(h(o,d)),n&&c.push(h(l,d)),a){let e=r.makeTensorInfo([],"float32",Aa.createScalarValue(m,"float32"));c.push(e),b.push(e)}t=r.runWebGLProgram(p,c,"float32")}else t=uZ({x:s,filter:i,convInfo:y,backend:r,bias:o,activation:f,preluActivationWeights:l,leakyreluAlpha:m});let w=GK({inputs:{x:t},backend:r,attrs:{shape:y.outShape}});return b.push(t),b.forEach((e=>r.disposeIntermediateTensorInfo(e))),w}var iQ={kernelName:ma,backendName:"webgl",kernelFunc:sQ};function oQ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:p,dimRoundingMode:d,activation:c,leakyreluAlpha:h}=r,f=[],m=p;null==m&&(m=[1,1]),Aa.assert(Mw.eitherStridesOrDilationsAreOne(l,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));let g,y=Mw.computeConv2DInfo(a.shape,s.shape,l,m,u,d,!0),b=et().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels===1,w=c?OK(c,b):null,x=[a,s],v=null!=i,k=null!=o,I="leakyrelu"===c;if(v&&x.push(i),k&&x.push(o),I){let e=n.makeTensorInfo([],"float32",Aa.createScalarValue(h,"float32"));x.push(e),f.push(e)}g=b?new ZZ(y,v,w,k,I):new YZ(y,v,w,k,I);let S=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],N=n.runWebGLProgram(g,x,"float32",S);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),N}var lQ={kernelName:ga,backendName:"webgl",kernelFunc:oQ},uQ=class{constructor(e,t,n){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=n;let r=ZH(t.length),a=ZH(n.length),s=this.sliceDim>1?"strides[j]":"strides";this.userCode=`\n        ${r} strides = ${r}(${this.strides});\n         void main() {\n          ${a} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${s};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}};function pQ(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=a.shape,i=s[s.length-1],o=Aa.sizeFromShape(r.shape),[l,u,p,d]=Mw.prepareAndValidate(r,a),c=GK({inputs:{x:a},backend:n,attrs:{shape:[u,i]}}),h=GK({inputs:{x:r},backend:n,attrs:{shape:[Aa.sizeFromShape(r.shape)/p,p]}});if(n.shouldExecuteOnCPU([r,a])||"string"===r.dtype){let e=n.readSync(a.dataId),t=n.bufferSync(r),s=qj(e,t,r.dtype,u,i,p,d,r.shape,o);return n.makeTensorInfo(l,r.dtype,s.values)}let f=new uQ(i,d,[u,p]),m=n.runWebGLProgram(f,[h,c],h.dtype),g=GK({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),g}var dQ={kernelName:wn,backendName:"webgl",kernelFunc:pQ},cQ=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=ZH(this.rank),r=hQ(e,2);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}};function hQ(e,t){let n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let a=0;a<e.length;a++)2===a?r.push("index"):r.push(`${n[a]}`);return r.join()}function fQ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r,l=Aa.parseAxisParam(i,a.shape)[0];if(et().get("DEBUG")){let e=n.readSync(s.dataId),t=a.shape[l];for(let n=0;n<e.length;++n){let r=e[n];Aa.assert(r<=t-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`))}}let u=Mw.segment_util.collectGatherOpShapeInfo(a,s,l,o),p=Aa.sizeFromShape(s.shape),d=[],c=GK({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),h=GK({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,p/u.batchSize]}});d.push(c),d.push(h);let f=[u.batchSize,u.outerSize,p/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([a,s])||"string"===a.dtype){let e=n.bufferSync(h),t=n.bufferSync(c),r=Kj(t,e,f);return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u.outputShape,r.dtype,r.values)}let m=new cQ(c.shape,f),g=n.runWebGLProgram(m,[c,h],c.dtype);d.push(g);let y=GK({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}var mQ={kernelName:bn,backendName:"webgl",kernelFunc:fQ},gQ="return float(a > b);",yQ="\n  return vec4(greaterThan(a, b));\n",bQ=MK({opSnippet:gQ,packedOpSnippet:yQ,cpuKernelImpl:Xj,dtype:"bool"}),wQ={kernelName:xn,backendName:"webgl",kernelFunc:bQ},xQ="return float(a >= b);",vQ="\n  return vec4(greaterThanEqual(a, b));\n",kQ=MK({opSnippet:xQ,packedOpSnippet:vQ,dtype:"bool",cpuKernelImpl:Yj}),IQ={kernelName:vn,backendName:"webgl",kernelFunc:kQ};function SQ(e){let{inputs:t,backend:n}=e,{input:r}=t;return zJ(r,!0,n)}var NQ={kernelName:In,backendName:"webgl",kernelFunc:SQ},TQ="return float(!isnan(x) && !isinf(x));",CQ=DK({opSnippet:TQ,dtype:"bool"}),_Q={kernelName:Nn,backendName:"webgl",kernelFunc:CQ},EQ="return float(isinf(x));",AQ=DK({opSnippet:EQ,dtype:"bool"}),$Q={kernelName:Tn,backendName:"webgl",kernelFunc:AQ},FQ="return float(isnan(x));",RQ=DK({opSnippet:FQ,dtype:"bool"}),DQ={kernelName:Cn,backendName:"webgl",kernelFunc:RQ},MQ="return float(a < b);",OQ="\n  return vec4(lessThan(a, b));\n",LQ=MK({opSnippet:MQ,packedOpSnippet:OQ,cpuKernelImpl:Zj,dtype:"bool"}),PQ={kernelName:En,backendName:"webgl",kernelFunc:LQ},zQ="return float(a <= b);",BQ="\n  return vec4(lessThanEqual(a, b));\n",WQ=MK({opSnippet:zQ,packedOpSnippet:BQ,cpuKernelImpl:Jj,dtype:"bool"}),VQ={kernelName:An,backendName:"webgl",kernelFunc:WQ};function UQ(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=Qj(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}var GQ={kernelName:$n,backendName:"webgl",kernelFunc:UQ},HQ=$K+"\n  return x < 0.0 ? 0./0. : log(x);\n",jQ="\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",qQ=DK({opSnippet:HQ,packedOpSnippet:jQ,cpuKernelImpl:eq}),KQ={kernelName:Fn,backendName:"webgl",kernelFunc:qQ},XQ=$K+"\n  return log(1.0 + x);\n",YQ=DK({opSnippet:XQ}),ZQ={kernelName:Rn,backendName:"webgl",kernelFunc:YQ},JQ="return float(a >= 1.0 && b >= 1.0);",QQ="\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",e0=MK({opSnippet:JQ,packedOpSnippet:QQ,dtype:"bool"}),t0={kernelName:Dn,backendName:"webgl",kernelFunc:e0},n0="return float(!(x >= 1.0));",r0=DK({opSnippet:n0}),a0={kernelName:Mn,backendName:"webgl",kernelFunc:r0},s0="return float(a >= 1.0 || b >= 1.0);",i0="\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",o0=MK({opSnippet:s0,packedOpSnippet:i0,dtype:"bool"}),l0={kernelName:On,backendName:"webgl",kernelFunc:o0},u0=class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[];let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;o=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${s}; j <= ${s}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}},p0=class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;o=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${s};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${s}; j <= ${s}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}},d0=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r,u=et().getBool("WEBGL_PACK_NORMALIZATION")?new p0(a.shape,s,i,o,l):new u0(a.shape,s,i,o,l);return n.runWebGLProgram(u,[a],a.dtype)},c0={kernelName:zn,backendName:"webgl",kernelFunc:d0},h0=class{constructor(e,t,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=a,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${a})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${a});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}},f0=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:p}=r,d=new h0(a.shape,o,l,u,p);return n.runWebGLProgram(d,[a,s,i],a.dtype)},m0={kernelName:Bn,backendName:"webgl",kernelFunc:f0};function g0(e,t,n,r){let a=Aa.sizeFromShape(t),s=Aa.sizeFromShape(e.shape)/a,i=GK({inputs:{x:e},attrs:{shape:[s,a]},backend:r}),o=XK(i,e.dtype,"max",r),l=GK({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),l}function y0(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=a.shape.length,l=Aa.parseAxisParam(s,a.shape),u=l,p=Mw.getAxesPermutation(u,o),d=null!=p,c=n.shouldExecuteOnCPU([a]),h=a;if(d){if(c){let e=n.texData.get(h.dataId).values,t=new Array(o);for(let n=0;n<t.length;n++)t[n]=a.shape[p[n]];let r=Nq(e,a.shape,a.dtype,p,t);h=n.makeTensorInfo(t,a.dtype);let s=n.texData.get(h.dataId);s.values=r}else h=QK(a,p,n);u=Mw.getInnerMostAxes(u.length,o)}Mw.assertAxesAreInnerMostDims("max",u,o);let f,[m,g]=Mw.computeOutAndReduceShapes(h.shape,u),y=m;if(i&&(y=Mw.expandShapeToKeepDim(m,l)),c){let e=n.texData.get(h.dataId).values,t=tq(e,Aa.sizeFromShape(g),y,a.dtype);f=n.makeTensorInfo(y,a.dtype);let r=n.texData.get(f.dataId);r.values=t}else f=g0(h,g,y,n);return d&&n.disposeIntermediateTensorInfo(h),f}var b0={kernelName:Wn,backendName:"webgl",kernelFunc:y0},w0=mK+"\n  return max(a, b);\n",x0="\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  "+yK+"\n  return result;\n",v0=MK({opSnippet:w0,packedOpSnippet:x0,cpuKernelImpl:nq}),k0={kernelName:Vn,backendName:"webgl",kernelFunc:v0};function I0(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;QG(a,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,u=1;Aa.assert(Mw.eitherStridesOrDilationsAreOne(i,u),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`));let p=Mw.computePool2DInfo(a.shape,s,i,u,o,l);if(1===p.filterWidth&&1===p.filterHeight&&Aa.arraysEqual(p.inShape,p.outShape))return wK({inputs:{x:a},backend:n});let d=new eY(p,"max",!1);return n.runWebGLProgram(d,[a],a.dtype)}var S0={kernelName:Un,backendName:"webgl",kernelFunc:I0};function N0(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=r,p=[1,1,1],d=Mw.computePool3DInfo(a.shape,s,i,p,o,u,l),c=new tY(d,"max",!1);return n.runWebGLProgram(c,[a],a.dtype)}var T0={kernelName:Hn,backendName:"webgl",kernelFunc:N0},C0=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,s=e.effectiveFilterWidth,i=a-1-e.padInfo.top,o=s-1-e.padInfo.left,l=a*s-1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${a};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${s} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},_0=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,p=o-1-e.padInfo.front,d=l-1-e.padInfo.top,c=u-1-e.padInfo.left,h=o*l*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${d}, ${c});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${a}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${s}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${i}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${h} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};function E0(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:p}=r,d=[1,1,1],c=Mw.computePool3DInfo(i.shape,o,l,d,u,p),h=new tY(c,"max",!0),f=n.runWebGLProgram(h,[i],i.dtype),m=new _0(c),g=n.runWebGLProgram(m,[a,f],i.dtype);return n.disposeIntermediateTensorInfo(f),g}var A0={kernelName:jn,backendName:"webgl",kernelFunc:E0};function $0(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;QG([s,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:p,dimRoundingMode:d}=r,c=Mw.computePool2DInfo(o.shape,l,u,1,p,d),h=!0,f=new eY(c,"max",h),m=n.runWebGLProgram(f,[o],o.dtype),g=new C0(c),y=n.runWebGLProgram(g,[a,m],o.dtype);return n.disposeIntermediateTensorInfo(m),y}var F0={kernelName:Gn,backendName:"webgl",kernelFunc:$0};function R0(e,t,n,r){let a=new eY(n,"max",!1),s=r.runWebGLProgram(a,[e],"float32");a=new eY(n,"max",!0,!0,t);let i=r.runWebGLProgram(a,[e],"float32");return[s,i]}var D0={kernelName:qn,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:a,strides:s,pad:i,includeBatchInIndex:o}=t,l=n;Aa.assert(4===r.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`));let u=[1,1];Aa.assert(Mw.eitherStridesOrDilationsAreOne(s,u),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`));let p=Mw.computePool2DInfo(r.shape,a,s,u,i),[d,c]=R0(r,o,p,l);return[d,c]}};function M0(e,t,n,r){let a=Aa.sizeFromShape(t),s=Aa.sizeFromShape(e.shape)/a,i=GK({inputs:{x:e},attrs:{shape:[s,a]},backend:r}),o=XK(i,"float32","mean",r),l=GK({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),l}var O0={kernelName:Kn,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{keepDims:a,axis:s}=t,i=n,o=r.shape.length,l=Aa.parseAxisParam(s,r.shape),u=l,p=Mw.getAxesPermutation(u,o),d=null!=p,c=i.shouldExecuteOnCPU([r]),h=[],f=r;if(d){if(c){let e=i.texData.get(f.dataId).values,t=new Array(o);for(let s=0;s<t.length;s++)t[s]=r.shape[p[s]];let n=Nq(e,r.shape,r.dtype,p,t);f=i.makeTensorInfo(t,r.dtype);let a=i.texData.get(f.dataId);a.values=n}else f=QK(r,p,i);h.push(f),u=Mw.getInnerMostAxes(u.length,o)}Mw.assertAxesAreInnerMostDims("sum",u,o);let[m,g]=Mw.computeOutAndReduceShapes(f.shape,u),y=m;a&&(y=Mw.expandShapeToKeepDim(m,l));let b=M0(f,g,y,i);for(let w of h)i.disposeIntermediateTensorInfo(w);return b}};function L0(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=Aa.parseAxisParam(s,a.shape),u=l,p=Mw.getAxesPermutation(u,o),d=a;null!=p&&(d=rX({inputs:{x:a},backend:n,attrs:{perm:p}}),u=Mw.getInnerMostAxes(u.length,a.shape.length)),Mw.assertAxesAreInnerMostDims("min",u,o);let c,[h,f]=Mw.computeOutAndReduceShapes(d.shape,u),m=Aa.sizeFromShape(f),g=GK({inputs:{x:d},backend:n,attrs:{shape:[-1,m]}}),y=XK(g,g.dtype,"min",n);if(i){let e=Mw.expandShapeToKeepDim(h,l);c=GK({inputs:{x:y},backend:n,attrs:{shape:e}})}else c=GK({inputs:{x:y},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),null!=p&&n.disposeIntermediateTensorInfo(d),c}var P0={kernelName:Xn,backendName:"webgl",kernelFunc:L0},z0=mK+"\n  return min(a, b);\n",B0="\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  "+yK+"\n  return result;\n",W0=MK({opSnippet:z0,packedOpSnippet:B0,cpuKernelImpl:rq}),V0={kernelName:Yn,backendName:"webgl",kernelFunc:W0},U0=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=ZH(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l="reflect"===n?0:1;this.userCode=1!==r?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${a} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${s};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}},G0=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=ZH(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=_q("rc",r),l=_q("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,p=1===r?"source":`vec2(${l.slice(-2).join()})`,d="reflect"===n?0:1,c="";if(1===r){let e=`\n        ${a} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${d};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${d};\n        }\n        source -= start;\n      `;c=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${p});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${p});\n        }\n      `}else{let e=`\n        ${a} source = rc;\n        ${a} lt = ${a}(lessThan(source, start));\n        ${a} gte = ${a}(greaterThanEqual(source, end));\n        ${a} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${d}) +\n                gte * ((end - 1) * 2 - source + ${d});\n        source -= start;\n      `;c=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${p});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${p});\n        }\n        rc = outputLoc;\n        ${o[r-2]} += 1;\n        if(${o[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${l.join()}), ${p});\n          ${o[r-1]} += 1;\n          if(${u}) {\n            ${e}\n            result[3] = getChannel(getX(${l.join()}), ${p});\n          }\n        }\n      `}this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${c}\n        setOutput(result);\n      }\n    `}},H0=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{paddings:a,mode:s}=n,i=et().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new G0(r.shape,a,s):new U0(r.shape,a,s);return t.runWebGLProgram(i,[r],r.dtype)},j0={kernelName:Zn,backendName:"webgl",kernelFunc:H0},q0="if (b == 0.0) return NAN;\n  return mod(a, b);",K0="\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  "+yK+"\n  return result;\n",X0=MK({opSnippet:q0,packedOpSnippet:K0}),Y0={kernelName:Jn,backendName:"webgl",kernelFunc:X0},Z0=class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}},J0="\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",Q0="\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",e1=MK({opSnippet:J0,packedOpSnippet:Q0,checkOutOfBounds:!0}),t1={kernelName:nn,backendName:"webgl",kernelFunc:e1},n1="return a - b;",r1=MK({opSnippet:n1,packedOpSnippet:n1,supportsComplex:!0,cpuKernelImpl:kq}),a1={kernelName:Qr,backendName:"webgl",kernelFunc:r1};function s1(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=Aa.parseAxisParam([s],a.shape),o=y0({inputs:{x:a},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=Mw.expandShapeToKeepDim(o.shape,i),u=GK({inputs:{x:o},backend:n,attrs:{shape:l}}),p=r1({inputs:{a:a,b:u},backend:n}),d=$J({inputs:{x:p},backend:n}),c=tX({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:!1}}),h=GK({inputs:{x:c},backend:n,attrs:{shape:l}}),f=e1({inputs:{a:d,b:h},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),f}var i1={kernelName:Wr,backendName:"webgl",kernelFunc:s1};function o1(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r,l=o?a:s1({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),u=l.shape[0],p=l.shape[1],d=new Z0(u,p,s),c=[[i]],h=n.runWebGLProgram(d,[l],"int32",c);return o||n.disposeIntermediateTensorInfo(l),h}var l1={kernelName:Qn,backendName:"webgl",kernelFunc:o1},u1=Wq+"\n  return -x;\n",p1="\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n";function d1(e){let t,{inputs:n,backend:r}=e,{x:a}=n;if(r.shouldExecuteOnCPU([a])){let e=r.texData.get(a.dataId),[t,n]=sq(e.values,a.shape,a.dtype);return r.makeTensorInfo(n,a.dtype,t)}return t=et().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new eK(a.shape,p1):new Bq(a.shape,u1),r.runWebGLProgram(t,[a],a.dtype)}var c1={kernelName:tr,backendName:"webgl",kernelFunc:d1},h1=Lx.nonMaxSuppressionV3Impl;function f1(e){Mw.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(a.dataId),p=n.readSync(s.dataId),{selectedIndices:d}=h1(u,p,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}var m1={kernelName:rr,backendName:"webgl",kernelFunc:f1},g1=Lx.nonMaxSuppressionV4Impl;function y1(e){Mw.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,p=n.readSync(a.dataId),d=n.readSync(s.dataId),{selectedIndices:c,validOutputs:h}=g1(p,d,i,o,l,u);return[n.makeTensorInfo([c.length],"int32",new Int32Array(c)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}var b1={kernelName:ar,backendName:"webgl",kernelFunc:y1},w1=Lx.nonMaxSuppressionV5Impl;function x1(e){Mw.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,p=n.readSync(a.dataId),d=n.readSync(s.dataId),c=i,h=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=w1(p,d,c,h,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var v1={kernelName:sr,backendName:"webgl",kernelFunc:x1},k1=class{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}},I1=e=>{let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{depth:s,onValue:i,offValue:o}=r,l=Aa.sizeFromShape(a.shape),u=new k1(l,s,i,o),p=GK({inputs:{x:a},backend:n,attrs:{shape:[l]}}),d=n.runWebGLProgram(u,[p],a.dtype);n.disposeIntermediateTensorInfo(p);let c=[...a.shape,s],h=GK({inputs:{x:d},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(d),h},S1={kernelName:or,backendName:"webgl",kernelFunc:I1};function N1(e){let{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){let e=DY({inputs:{input:r},backend:n}),t=N1({inputs:{x:e},backend:n}),a=eZ({inputs:{input:r},backend:n}),s=N1({inputs:{x:a},backend:n}),i=vK({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}return UJ({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}var T1={kernelName:pa,backendName:"webgl",kernelFunc:N1};function C1(e){let{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){let e=DY({inputs:{input:r},backend:n}),t=C1({inputs:{x:e},backend:n}),a=eZ({inputs:{input:r},backend:n}),s=N1({inputs:{x:a},backend:n}),i=vK({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}return UJ({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}var _1={kernelName:ir,backendName:"webgl",kernelFunc:C1};function E1(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return RJ({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach((e=>{Aa.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),Aa.assert(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));let o=[],l=t.map((e=>{let t=RJ({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),u=aZ({inputs:l,backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}var A1={kernelName:lr,backendName:"webgl",kernelFunc:E1},$1=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=ZH(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${a} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${s};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}},F1=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=ZH(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=_q("rc",r),l=_q("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,p=1===r?"source":`vec2(${l.slice(-2).join()})`,d=[`${a} rc = outputLoc;`,`${o[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${o[r-2]} += 1;\n       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;\n         if(${u}) {`],c=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",h="";for(let f=0,m=1===r?2:4;f<m;f++)h+=`\n        ${d[f]}\n        if (${c}) {\n          result[${f}] = float(value);\n        } else {\n          ${a} source = rc - start;\n          result[${f}] = getChannel(getX(${l.join()}), ${p});\n        }\n      `;h+=1===r?"} ":"}}",this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}},R1=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;if(0===Aa.sizeFromShape(a.shape)){let e=s.map(((e,t)=>e[0]+a.shape[t]+e[1]));return UJ({backend:n,attrs:{shape:e,value:i,dtype:a.dtype}})}let o=et().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new F1(a.shape,s,i):new $1(a.shape,s,i),l=[[i]];return n.runWebGLProgram(o,[a],a.dtype,l)},D1={kernelName:ur,backendName:"webgl",kernelFunc:R1},M1="\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",O1="\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  "+yK+"\n  return result;\n",L1=MK({opSnippet:M1,packedOpSnippet:O1}),P1={kernelName:dr,backendName:"webgl",kernelFunc:L1};function z1(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{axis:i,keepDims:o}=a,l=s.shape.length,u=[],p=Aa.parseAxisParam(i,s.shape),d=p,c=Mw.getAxesPermutation(d,l),h=s;if(null!=c&&(h=rX({inputs:{x:s},backend:r,attrs:{perm:c}}),d=Mw.getInnerMostAxes(d.length,l),u.push(h)),Mw.assertAxesAreInnerMostDims("prod",d,l),r.shouldExecuteOnCPU([h])){let e=r.texData.get(h.dataId).values,{outVals:n,outShape:a,outDtype:s}=oq(h.shape,h.dtype,e,d);t=r.makeTensorInfo(a,s,n)}else{let[e,n]=Mw.computeOutAndReduceShapes(h.shape,d),a=Aa.sizeFromShape(n),i=GK({inputs:{x:h},backend:r,attrs:{shape:[-1,a]}}),o=Rs(s.dtype),l=XK(i,o,"prod",r);t=GK({inputs:{x:l},backend:r,attrs:{shape:e}}),u.push(i),u.push(l)}if(o){u.push(t);let e=Mw.expandShapeToKeepDim(t.shape,p);t=GK({inputs:{x:t},backend:r,attrs:{shape:e}})}return u.forEach((e=>r.disposeIntermediateTensorInfo(e))),t}var B1={kernelName:hr,backendName:"webgl",kernelFunc:z1},W1=e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:i}=n,o=lq(r,a,s,i);return t.makeTensorInfo([o.length],i,o)},V1={kernelName:fr,backendName:"webgl",kernelFunc:W1},U1="return 1.0 / x;",G1=DK({opSnippet:U1}),H1={kernelName:gr,backendName:"webgl",kernelFunc:G1},j1=Wq+"\n  return (x < 0.0) ? 0.0 : x;\n",q1="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",K1=DK({opSnippet:j1,packedOpSnippet:q1}),X1={kernelName:yr,backendName:"webgl",kernelFunc:K1},Y1=Wq+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",Z1="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",J1=DK({opSnippet:Y1,packedOpSnippet:Z1}),Q1={kernelName:Ir,backendName:"webgl",kernelFunc:J1},e2=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u,p=[r&&t>1?i-1:i,r&&n>1?o-1:o],d=[r&&t>1?t-1:t,r&&n>1?n-1:n];u=a?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${p[0]/d[0]},\n          ${p[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${u};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}},t2=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u,p=[r&&t>1?i-1:i,r&&n>1?o-1:o],d=[r&&t>1?t-1:t,r&&n>1?n-1:n];u=a?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${p[0]/d[0]},\n          ${p[1]/d[1]},\n          ${p[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${u};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}};function n2(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,p=et().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new t2(a.shape,l,u,s,i):new e2(a.shape,l,u,s,i);return n.runWebGLProgram(p,[a],"float32")}var r2={kernelName:vr,backendName:"webgl",kernelFunc:n2},a2=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],p=o[1]/l[1],d=1/u,c=1/p,h=2*Math.ceil(d)+2,f=2*Math.ceil(c)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${p});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${c});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}};function s2(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new a2(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}var i2={kernelName:kr,backendName:"webgl",kernelFunc:s2},o2=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u,p=[r&&t>1?i-1:i,r&&n>1?o-1:o],d=[r&&t>1?t-1:t,r&&n>1?n-1:n],c=r?"0.5":"0.0";u=a?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${p[0]/d[0]},\n          ${p[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${u};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${c})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}},l2=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u,p=[r&&t>1?i-1:i,r&&n>1?o-1:o],d=[r&&t>1?t-1:t,r&&n>1?n-1:n],c=r?"0.5":"0.0";u=a?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${p[0]/d[0]},\n          ${p[1]/d[1]},\n          ${p[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${u};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${c})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}};function u2(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,p=et().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new l2(a.shape,l,u,s,i):new o2(a.shape,l,u,s,i);return n.runWebGLProgram(p,[a],a.dtype)}var p2={kernelName:wr,backendName:"webgl",kernelFunc:u2},d2=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],p=o[1]/l[1],d=1/u,c=1/p,h=2*Math.ceil(d)+2,f=2*Math.ceil(c)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${p});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${c});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${a}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}};function c2(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new d2(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}var h2={kernelName:xr,backendName:"webgl",kernelFunc:c2},f2=class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);let r=n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`,a=e.map(((e,t)=>r(t))).join(","),s=ZH(n);this.userCode=`\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}},m2=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let r=_q("rc",n),a=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=ZH(n);function o(e){return d(e)}function l(e){return e[n-1]="("+e[n-1]+" + 1)",d(e)}function u(e){return e[n-2]="("+e[n-2]+" + 1)",d(e)}function p(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",d(e)}function d(t){let n=e.map(((e,n)=>c(n,t))),r=n.join(","),a=n.slice(-2).join(",");return`getChannel(getX(${r}), vec2(${a}))`}function c(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${a}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${o(r.slice())};\n          if(${a}){\n            result.g = ${l(r.slice())};\n          }\n          if(${s}) {\n            result.b = ${u(r.slice())};\n            if(${a}) {\n              result.a = ${p(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}};function g2(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,i=a.shape.length,o=Aa.parseAxisParam(s,a.shape);if(0===i)return wK({inputs:{x:a},backend:n});let l=et().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new m2(a.shape,o):new f2(a.shape,o);return n.runWebGLProgram(l,[a],a.dtype)}var y2={kernelName:Sr,backendName:"webgl",kernelFunc:g2},b2=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],r=e[2];this.outputShape=e;let a="";a="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${a}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}},w2={kernelName:ha,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:a,fillValue:s,center:i}=t,o=n,l=new b2(r.shape,s),[u,p]=Mw.getImageCenter(i,r.shape[1],r.shape[2]),d=[[u,p,Math.sin(a),Math.cos(a)]];return o.runWebGLProgram(l,[r],r.dtype,d)}},x2="\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n",v2=DK({opSnippet:x2}),k2={kernelName:Nr,backendName:"webgl",kernelFunc:v2},I2="return inversesqrt(x);",S2=DK({opSnippet:I2,cpuKernelImpl:uq}),N2={kernelName:Tr,backendName:"webgl",kernelFunc:S2},T2=class{constructor(e,t,n,r,a,s,i=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;let o=ZH(a.length),l=ZH(s.length),u="";1===n?u="i":2===n&&(u="i, j");let p=`getIndices(${u})`,d="";1===r?d="i":2===r&&(d="i, coords[1]");let c=`getUpdates(${d})`,h=t>1?"strides[j]":"strides";this.userCode=`\n        ${o} strides = ${o}(${a});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${p});\n              flattenedIndex += index * ${h};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${c};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}};function C2(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:p,outputSize:d}=Mw.calculateShapes(s,a,i),c=[d/u,u];if(0===d)return n.makeTensorInfo(i,a.dtype);let h=GK({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),f=GK({inputs:{x:s},backend:n,attrs:{shape:[l,u]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),g=new T2(l,o,h.shape.length,f.shape.length,p,c),y=n.runWebGLProgram(g,[f,h,m],f.dtype),b=GK({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),b}var _2={kernelName:Cr,backendName:"webgl",kernelFunc:C2},E2=class{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];let a="while (left < right) {",s=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=2===et().getNumber("WEBGL_VERSION")?a:s,o="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${i}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${o} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}};function A2(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=new E2(a.shape[0],a.shape[1],s.shape[1],i),l=[[a.shape[1]]];return n.runWebGLProgram(o,[a,s],"int32",l)}var $2={kernelName:_r,backendName:"webgl",kernelFunc:A2},F2=class{constructor(e,t,n){let r,a;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)a="resRC",r="resRC";else{let n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],i=[];for(let r=0;r<t.length;r++)i.push(`${n[r]}`),r<e&&s.push(`${n[r]}`);r=s.join(),a=i.join()}let s=ZH(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${a}));\n        } else {\n          setOutput(getB(${a}));\n        }\n      }\n    `}};function R2(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,i=new F2(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(i,[r,a,s],Fs(a.dtype,s.dtype))}var D2={kernelName:Er,backendName:"webgl",kernelFunc:R2},M2=`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${Mw.SELU_SCALEALPHA};\n  float scale = ${Mw.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`,O2=DK({opSnippet:M2}),L2={kernelName:Ar,backendName:"webgl",kernelFunc:O2},P2=$K+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",z2="\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",B2=DK({opSnippet:P2,packedOpSnippet:z2,cpuKernelImpl:dq}),W2={kernelName:Mr,backendName:"webgl",kernelFunc:B2},V2="\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n",U2=DK({opSnippet:V2}),G2={kernelName:Dr,backendName:"webgl",kernelFunc:U2},H2=$K+"\n  return sin(x);\n",j2=DK({opSnippet:H2}),q2={kernelName:Fr,backendName:"webgl",kernelFunc:j2},K2="\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n",X2=DK({opSnippet:K2}),Y2={kernelName:Rr,backendName:"webgl",kernelFunc:X2},Z2="\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n",J2=DK({opSnippet:Z2}),Q2={kernelName:Or,backendName:"webgl",kernelFunc:J2},e3=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;Aa.assert(a.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));let o=s.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...i);for(let y=1+s.length;y<a.shape.length;++y)l.push([0,0]);let u=[],p=R1({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),d=Mw.getReshaped(p.shape,s,o,!1),c=Mw.getPermuted(d.length,s.length,!1),h=Mw.getReshapedPermuted(p.shape,s,o,!1),f=GK({inputs:{x:p},backend:n,attrs:{shape:d}}),m=rX({inputs:{x:f},backend:n,attrs:{perm:c}}),g=GK({inputs:{x:m},backend:n,attrs:{shape:h}});return u.push(p),u.push(f),u.push(m),u.forEach((e=>n.disposeIntermediateTensorInfo(e))),g},t3={kernelName:zr,backendName:"webgl",kernelFunc:e3};function n3(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n         ${a.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);let o=n.readSync(r.dataId),l=n.readSync(a.dataId),u=n.readSync(s.dataId),p=n.readSync(i.dataId)[0],[d,c,h,f,m]=fq(o,r.shape,r.dtype,l,a.dtype,u,p);return[n.makeTensorInfo(c,r.dtype,d),n.makeTensorInfo([c[0]],a.dtype,h),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}var r3={kernelName:Vr,backendName:"webgl",kernelFunc:n3};function a3(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.readSync(a.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(s.dataId)),[u,p,d]=mq(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(p,r.dtype,u),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}var s3={kernelName:Ur,backendName:"webgl",kernelFunc:a3};function i3(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${s.shape}`);let i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,p]=gq(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(p,r.dtype,u)}var o3={kernelName:Gr,backendName:"webgl",kernelFunc:i3};function l3(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${s.shape}`);let i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,p]=gq(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(p,r.dtype,u)}var u3={kernelName:Hr,backendName:"webgl",kernelFunc:l3};function p3(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:p,strides:d,outputSize:c}=Mw.calculateShapes(s,a,o),h=!1;if("string"===s.dtype){let e=n.bufferSync(a),t=n.bufferSync(s),r=Aa.decodeString(n.readSync(i.dataId)[0]),f=pq(e,t,o,c,p,u,l,d,r,h);return n.makeTensorInfo(o,f.dtype,f.values)}let f=new T2(u,l,a.shape.length,s.shape.length,d,[c,1],h),m=n.runWebGLProgram(f,[s,a,i],s.dtype),g=GK({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}var d3={kernelName:jr,backendName:"webgl",kernelFunc:p3};function c3(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=Aa.parseAxisParam(i,a.shape)[0],l=Mw.prepareSplitSize(a,s,o),u=a.shape.length,p=new Array(u).fill(0),d=a.shape.slice();return l.map((e=>{let t=[...d];t[o]=e;let r=IY({inputs:{x:a},backend:n,attrs:{begin:p,size:t}});return p[o]+=e,r}))}var h3={kernelName:Br,backendName:"webgl",kernelFunc:c3},f3="return sqrt(x);",m3=DK({opSnippet:f3,packedOpSnippet:f3,cpuKernelImpl:yq}),g3={kernelName:Lr,backendName:"webgl",kernelFunc:m3},y3="return x * x;",b3=DK({opSnippet:y3}),w3={kernelName:Kr,backendName:"webgl",kernelFunc:b3},x3="return (a - b) * (a - b);",v3=MK({opSnippet:x3,packedOpSnippet:x3}),k3={kernelName:qr,backendName:"webgl",kernelFunc:v3};function I3({inputs:e,attrs:t,backend:n}){let{x:r}=e,a=Wq+`\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `,s=new Bq(r.shape,a);return n.runWebGLProgram(s,[r],r.dtype)}var S3={kernelName:da,backendName:"webgl",kernelFunc:I3},N3=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;let r=n.length,a=ZH(n.length),s=ZH(n.length),i="";if(1===r)i="coords * strides + begin";else{let e=0;i=n.map(((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${a} begin = ${a}(${e});\n      ${a} strides = ${a}(${t});\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}};function T3(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{begin:i,end:o,strides:l,beginMask:u,endMask:p,ellipsisMask:d,newAxisMask:c,shrinkAxisMask:h}=a,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:w,end:x,strides:v}=au.sliceInfo(s.shape,i,o,l,u,p,d,c,h);if(g)t=GK({inputs:{x:s},backend:r,attrs:{shape:m}});else if(y||b){Aa.assert(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));let e=au.computeOutShape(w,x,v),n=IY({inputs:{x:s},backend:r,attrs:{begin:w,size:e}});t=GK({inputs:{x:n},backend:r,attrs:{shape:m}}),r.disposeIntermediateTensorInfo(n)}else if(r.shouldExecuteOnCPU([s])){let e=r.readSync(s.dataId),n=wo(s.shape,s.dtype,e),a=bq(f,n,v,w);t=r.makeTensorInfo(m,s.dtype,a.values)}else{let e=new N3(w,v,f);t=r.runWebGLProgram(e,[s],s.dtype)}let k=GK({inputs:{x:t},backend:r,attrs:{shape:m}});return r.disposeIntermediateTensorInfo(t),k}var C3={kernelName:Xr,backendName:"webgl",kernelFunc:T3};function _3(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:p,dataSplits:d}=t,c=n.readSync(p.dataId),h=n.readSync(d.dataId),[f,m]=wq(c,h,a,s,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}var E3={kernelName:Yr,backendName:"webgl",kernelFunc:_3};function A3(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.readSync(s.dataId),l=n.readSync(i.dataId)[0],[u,p,d]=xq(o,l,a),c=p.length;return[n.makeTensorInfo([c,2],"int32",u),n.makeTensorInfo([c],"string",p),n.makeTensorInfo([2],"int32",new Int32Array(d))]}var $3={kernelName:Zr,backendName:"webgl",kernelFunc:A3};function F3(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let i=n.readSync(s.dataId),o=vq(i,a);return n.makeTensorInfo(s.shape,"int32",o)}var R3={kernelName:Jr,backendName:"webgl",kernelFunc:F3},D3="return tan(x);",M3=DK({opSnippet:D3}),O3={kernelName:ea,backendName:"webgl",kernelFunc:M3},L3="\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n",P3=DK({opSnippet:L3}),z3={kernelName:ta,backendName:"webgl",kernelFunc:P3},B3=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[s]*t[s];this.outputShape=n,this.rank=n.length;let r=ZH(this.rank),a=W3(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${a}));\n      }\n    `}};function W3(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let a=0;a<e.length;a++)r.push(`imod(${n[a]}, ${e[a]})`);return r.join()}function V3(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;if("string"===a.dtype||a.shape.length>5){let e=n.readSync(a.dataId),t="string"===a.dtype?e.map((e=>Aa.decodeString(e))):e,r=wo(a.shape,a.dtype,t),i=Iq(r,s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}let i=new B3(a.shape,s);return n.runWebGLProgram(i,[a],a.dtype)}var U3={kernelName:na,backendName:"webgl",kernelFunc:V3},G3=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}},H3=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}};function j3(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function q3(e){let t=1;for(;t<e;)t*=2;return t}function K3(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r,o=et().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=et().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=a.shape,p=u[u.length-1];if(n.shouldExecuteOnCPU([a])||p<o||s>l){let e=n.readSync(a.dataId),[t,r]=Sq(e,u,a.dtype,s,i);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===s)return u[u.length-1]=0,[n.makeTensorInfo(u,a.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===p)return[a,UJ({attrs:{shape:u,dtype:"int32",value:0},backend:n})];let d=n.texData.get(a.dataId),c=null!==d&&d.isPacked,h=c?n.unpackTensor(a):a,f=Aa.sizeFromShape(u)/p,m=GK({inputs:{x:h},attrs:{shape:[f,p]},backend:n});c&&j3(n,h);let g=q3(s),y=q3(p),b=null,w=()=>null===b?[m,m]:[m,b],x=(e,t,r)=>{let a=w(),s=new G3(r),i=[[p],[null===b?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],o=b;b=n.runWebGLProgram(s,a,"int32",i),j3(n,o)};for(let N=1;N<g;N*=2){let e=2*N;for(let t=N;t>=1;t/=2)x(e,t,[f,y])}for(let N=y;N>g;N/=2){let e=w(),t=new H3([f,N/2]),r=[[p],[null===b?1:0],[g]],a=b;b=n.runWebGLProgram(t,e,"int32",r),j3(n,a);let s=g/2,i=2*s;for(let n=s;n>=1;n/=2)x(i,n,b.shape)}let v=b;b=IY({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,s]}}),j3(n,v);let k=fQ({inputs:{x:m,indices:b},backend:n,attrs:{axis:1,batchDims:1}});j3(n,m);let I=u.slice(0,-1);I.push(s),v=b,b=GK({inputs:{x:b},attrs:{shape:I},backend:n}),j3(n,v);let S=k;return k=GK({inputs:{x:k},attrs:{shape:I},backend:n}),j3(n,S),[k,b]}var X3={kernelName:ra,backendName:"webgl",kernelFunc:K3},Y3=class{constructor(e,t,n,r,a,s){this.variableNames=["Image","Transforms"],this.outputShape=s;let i,o="nearest"===n?1:2;switch(r){case"constant":i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4;break;default:i=1;break}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${i} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${a});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${a});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${o} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}};function Z3(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[p,d,c,h]=a.shape,[f,m]=null!=u?u:[d,c],g=[p,f,m,h],y=new Y3(d,c,i,o,l,g);return n.runWebGLProgram(y,[a,s],"float32")}var J3={kernelName:aa,backendName:"webgl",kernelFunc:Z3};function Q3(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;QG(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=r.readSync(s.dataId),{outputValues:o,outputShape:l,indices:u}=Tq(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}var e4={kernelName:ia,backendName:"webgl",kernelFunc:Q3};function t4(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a,o=i.shape.length,l=a.shape[s],u=new Array(o-1),p=0;for(let m=0;m<o;m++)m!==s&&(u[p++]=i.shape[m]);let d=[],c=new Array(o).fill(0),h=i.shape.slice();h[s]=1;let f=new Array(l);for(let m=0;m<f.length;m++){c[s]=m;let e=IY({inputs:{x:i},backend:n,attrs:{begin:c,size:h}}),t=GK({inputs:{x:e},backend:n,attrs:{shape:u}});f[m]=t,d.push(e)}return d.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}var n4={kernelName:oa,backendName:"webgl",kernelFunc:t4},r4=class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,r=e.batchSize,a=e.inSize,s=e.numSegments,i=s*Math.ceil(a/n);this.outputShape=[r,i];let o="0.0",l="sumValue",u=4*Math.floor(n/4),p=n%4,d="\n        sumValue += dot(values, segFilter);\n    ",c="";a%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `);let h="";a%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${o};\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${s})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${s})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===p}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${d}\n        } else if (${2===p}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${d}\n        } else if (${3===p}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${d}\n        }\n        setOutput(${l});\n      }\n    `}};function a4(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r,o=a.shape.length,l=[],u=0,p=Mw.getAxesPermutation([u],o),d=a;null!=p&&(d=rX({inputs:{x:a},backend:n,attrs:{perm:p}}),l.push(d),u=Mw.getInnerMostAxes(1,o)[0]);let c=Mw.segment_util.computeOutShape(d.shape,u,i),h=Aa.sizeFromShape([d.shape[u]]),f=GK({inputs:{x:d},backend:n,attrs:{shape:[-1,h]}});l.push(f);let m=Rs(a.dtype),g=(e,t,r,a,s)=>{let i=e.shape[0],o=e.shape[1],u=Mw.segment_util.segOpComputeOptimalWindowSize(o,s),p={windowSize:u,inSize:o,batchSize:i,numSegments:s},d=new r4(p,t),c=n.compileAndRun(d,[e,r],a);if(l.push(c),c.shape[1]===s)return c;let h=W1({backend:n,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),f=V3({inputs:{x:h},backend:n,attrs:{reps:[o/u]}});return l.push(h),l.push(f),g(c,t,f,a,s)},y=g(f,"unsortedSegmentSum",s,m,i),b=GK({inputs:{x:y},backend:n,attrs:{shape:c}}),w=b;if(null!=p){l.push(b);let e=Mw.getUndoAxesPermutation(p);w=rX({inputs:{x:w},backend:n,attrs:{perm:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),w}var s4,i4,o4,l4={kernelName:la,backendName:"webgl",kernelFunc:a4},u4=[lX,dX,fX,yX,xX,SX,TX,_X,MX,LX,BX,UX,jX,YX,QX,rY,sY,uY,dY,hY,yY,TY,_Y,AY,zY,VY,jY,kK,YY,sZ,cZ,bZ,xZ,kZ,SZ,CZ,AZ,RZ,OZ,VZ,GZ,jZ,XZ,QZ,rJ,sJ,lJ,dJ,hJ,yJ,vJ,NJ,_J,FJ,DJ,LJ,WJ,HJ,qJ,YJ,eQ,rQ,iQ,lQ,dQ,mQ,wQ,IQ,xK,NQ,tZ,_Q,$Q,DQ,TK,PQ,VQ,GQ,KQ,ZQ,t0,a0,l0,c0,m0,b0,k0,S0,T0,A0,F0,D0,O0,P0,V0,j0,Y0,l1,VK,c1,m1,b1,v1,RY,S1,_1,A1,D1,P1,AK,B1,V1,MY,t1,H1,X1,Q1,HK,r2,i2,p2,h2,y2,w2,k2,N2,_2,$2,D2,L2,W2,G2,q2,Y2,SY,i1,Q2,t3,r3,s3,o3,u3,d3,h3,g3,w3,k3,S3,C3,E3,$3,R3,a1,nX,O3,z3,U3,X3,J3,aX,e4,n4,l4,T1];for(let dae of u4)Sa(dae);function p4(e){o4=e.wasm.cwrap(fa,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function d4(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s,bias:i,preluActivationWeights:o}=t;if("float32"!==a.dtype||"float32"!==s.dtype)throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:l,transposeB:u,activation:p,leakyreluAlpha:d}=r,c=n.dataIdMap.get(a.dataId).id,h=n.dataIdMap.get(s.dataId).id,f=0;if(null!=i){let e=n.dataIdMap.get(i.dataId);if(1!==e.shape.length)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${e.shape.length}.`);f=e.id}let m=null==o?0:n.dataIdMap.get(o.dataId).id,g=i4[p];if(null==g)throw new Error(`${p} activation not yet supported for FusedConv2D in the wasm backend.`);let y=l?a.shape[2]:a.shape[1],b=u?s.shape[1]:s.shape[2],w=Ll.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)),x=n.makeOutput([...w,y,b],a.dtype),v=n.dataIdMap.get(x.dataId).id,k=new Uint8Array(new Int32Array(a.shape).buffer),I=new Uint8Array(new Int32Array(s.shape).buffer);return o4(c,k,a.shape.length,h,I,s.shape.length,l,u,g,f,m,d||0,v),x}(function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"})(s4||(s4={})),function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"}(i4||(i4={}));var c4={kernelName:fa,backendName:"wasm",setupFunc:p4,kernelFunc:d4};function h4(e,t){let n;function r(t){n=t.wasm.cwrap(e,null,["number","number","number"])}function a(e){let{backend:r,inputs:{x:a}}=e,s=r.dataIdMap.get(a.dataId).id,i=r.makeOutput(a.shape,t||a.dtype),o=r.dataIdMap.get(i.dataId).id;return 0===Aa.sizeFromShape(i.shape)||n(s,s4[a.dtype],o),i}return{kernelName:e,backendName:"wasm",setupFunc:r,kernelFunc:a}}var f4=h4(ot);function m4(e,t,n){let r;function a(t){r=t.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])}function s(e){let{backend:t,inputs:a}=e,{a:s,b:i}=a,o=t.dataIdMap.get(s.dataId).id,l=t.dataIdMap.get(i.dataId).id,u=null!=n?n:s.dtype,p=Mw.assertAndGetBroadcastShape(s.shape,i.shape),d=t.makeOutput(p,u);if(0===Aa.sizeFromShape(p))return d;let c=new Uint8Array(new Int32Array(s.shape).buffer),h=new Uint8Array(new Int32Array(i.shape).buffer),f=t.dataIdMap.get(d.dataId).id;return r(o,c,s.shape.length,l,h,i.shape.length,s4[s.dtype],f),d}return{kernelName:e,backendName:"wasm",setupFunc:a,kernelFunc:s}}var g4,y4=!0,b4=m4(pt,y4);function w4(e){g4=e.wasm.cwrap(dt,null,["array","number","number","number"])}function x4(e){let{inputs:t,backend:n}=e,r=n.makeOutput(t[0].shape,t[0].dtype);if(0===Aa.sizeFromShape(r.shape))return r;let a=t.map((e=>n.dataIdMap.get(e.dataId).id)),s=new Uint8Array(new Int32Array(a).buffer),i=n.dataIdMap.get(r.dataId).id;return g4(s,a.length,s4[r.dtype],i),r}var v4={kernelName:dt,backendName:"wasm",setupFunc:w4,kernelFunc:x4};function k4(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype),a=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(r).set(a),r}var I4,S4={kernelName:kn,backendName:"wasm",kernelFunc:k4};function N4(e){I4=e.wasm.cwrap(sa,null,["number","array","number","number","number","array","number"])}function T4(e){let{inputs:t,backend:n,attrs:r}=e,[a,s]=_4(t.x.shape,r.perm),i=!0;for(let f=0;f<s.length;f++)s[f]!==f&&(i=!1);let o=C4(t.x.shape,r.perm),l={dataId:t.x.dataId,shape:a,dtype:t.x.dtype};if(i){let e=k4({inputs:t,backend:n});return e.shape=o,e}let u=n.makeOutput(o,l.dtype),p=n.dataIdMap.get(l.dataId).id,d=n.dataIdMap.get(u.dataId).id,c=new Uint8Array(new Int32Array(s).buffer),h=new Uint8Array(new Int32Array(l.shape).buffer);return I4(p,h,l.shape.length,s4[l.dtype],d,c,s.length),u}function C4(e,t){let n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];return n}function _4(e,t){let n=[],r=[];for(let a=0;a<e.length;++a)1!==e[a]&&n.push(e[a]),1!==e[t[a]]&&r.push(t[a]);for(let a=0;a<r.length;++a){let e=-1;for(let t=0;t<r.length;++t)r[t]>=a&&(-1===e||r[e]>r[t])&&(e=t);r[e]=a}return[n,r]}var E4,A4={kernelName:sa,backendName:"wasm",kernelFunc:T4,setupFunc:N4};function $4(e,t,n){let r=e.shape,a=e.shape.length,s=Aa.parseAxisParam(t,r),i=s,o=Mw.getAxesPermutation(i,a),l=null,u=!1;if(null!=o){let t=new Array(a);for(let e=0;e<t.length;e++)t[e]=r[o[e]];i=Mw.getInnerMostAxes(i.length,a),l=T4({inputs:{x:e},attrs:{perm:o},backend:n});let s=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(l.dataId).id!==s&&(u=!0)}return{transposed:l,originalAxes:s,axes:i,inputWasTransposed:u}}function F4(e){E4=e.wasm.cwrap(ct,null,["number, number, number"])}function R4(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:p,originalAxes:d,inputWasTransposed:c}=$4(i,a,t);if(c){let e=t.dataIdMap.get(u.dataId).id;l=u,o=e}let h=l.shape.length;Mw.assertAxesAreInnerMostDims("all",p,h);let[f,m]=Mw.computeOutAndReduceShapes(l.shape,p),g=Aa.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(0!==Aa.sizeFromShape(l.shape)){let e=t.dataIdMap.get(y.dataId).id;E4(o,g,e)}if(c&&t.disposeData(u.dataId),s){let e=Mw.expandShapeToKeepDim(y.shape,d);y.shape=e}return y}var D4,M4={kernelName:ct,backendName:"wasm",setupFunc:F4,kernelFunc:R4};function O4(e){D4=e.wasm.cwrap(ht,null,["number, number, number"])}function L4(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:p,originalAxes:d,inputWasTransposed:c}=$4(i,a,t);if(c){let e=t.dataIdMap.get(u.dataId).id;l=u,o=e}let h=l.shape.length;Mw.assertAxesAreInnerMostDims("any",p,h);let[f,m]=Mw.computeOutAndReduceShapes(l.shape,p),g=Aa.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(0!==Aa.sizeFromShape(l.shape)){let e=t.dataIdMap.get(y.dataId).id;D4(o,g,e)}if(c&&t.disposeData(u.dataId),s){let e=Mw.expandShapeToKeepDim(y.shape,d);y.shape=e}return y}var P4,z4={kernelName:ht,backendName:"wasm",setupFunc:O4,kernelFunc:L4};function B4(e){P4=e.wasm.cwrap(ft,null,["number","number","number","number","number"])}function W4(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a}=r,{x:s}=n,i=t.dataIdMap.get(s.dataId).id,o=i,l=s,{transposed:u,axes:p,inputWasTransposed:d}=$4(s,a,t);if(d){let e=t.dataIdMap.get(u.dataId).id;e!==i&&(l=u,o=e)}let c=l.shape.slice(0,-1),h=t.makeOutput(c,"int32"),f=t.dataIdMap.get(h.dataId).id,m=Aa.sizeFromShape(h.shape),g=l.shape[p[0]];return P4(o,s4[l.dtype],m,g,f),d&&t.disposeData(u.dataId),h}var V4,U4={kernelName:ft,backendName:"wasm",kernelFunc:W4,setupFunc:B4};function G4(e){V4=e.wasm.cwrap(vt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function H4(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,s=r.dataIdMap.get(a.dataId).id,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,p=Mw.computePool2DInfo(a.shape,i,o,1,l,u),d=p.filterHeight,c=p.filterWidth,h=p.padInfo.top,f=p.padInfo.right,m=p.padInfo.bottom,g=p.padInfo.left,y=p.strideHeight,b=p.strideWidth,w=p.inChannels;if("channelsLast"!==p.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);if(1!==p.dilationWidth||1!==p.dilationHeight)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${p.dilationHeight}, ${p.dilationWidth}].`);let x=r.makeOutput(p.outShape,"float32"),v=r.dataIdMap.get(x.dataId).id;return V4(s,a.shape[0],a.shape[1],a.shape[2],d,c,h,f,m,g,y,b,w,v),x}var j4={kernelName:vt,backendName:"wasm",setupFunc:G4,kernelFunc:H4};function q4(e){let{inputs:t,attrs:n}=e,{x:r}=t,{shape:a}=n,s=Aa.sizeFromShape(r.shape),i=Aa.inferFromImplicitShape(a,s);return Aa.assert(s===Aa.sizeFromShape(i),(()=>`new shape: ${i}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`)),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:i,dtype:r.dtype}}var K4,X4={kernelName:br,backendName:"wasm",kernelFunc:q4};function Y4(e){K4=e.wasm.cwrap(Nt,null,["number","array","number","number","array","number","number","number","number"])}function Z4(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:i,transposeB:o}=r;if("float32"!==a.dtype||"float32"!==s.dtype)throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let l=a.shape.length,u=s.shape.length,p=i?a.shape[l-2]:a.shape[l-1],d=o?s.shape[u-1]:s.shape[u-2],c=i?a.shape[l-1]:a.shape[l-2],h=o?s.shape[u-2]:s.shape[u-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),g=Aa.sizeFromShape(f),y=Aa.sizeFromShape(m),b=Ll.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([c,h]);Aa.assert(p===d,(()=>`Error in matMul: inner shapes (${p}) and (${d}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`));let w=i?[g,p,c]:[g,c,p],x=o?[y,h,d]:[y,d,h],v=q4({inputs:{x:a},backend:n,attrs:{shape:w}}),k=q4({inputs:{x:s},backend:n,attrs:{shape:x}}),I=n.dataIdMap.get(v.dataId).id,S=n.dataIdMap.get(k.dataId).id,N=i?v.shape[2]:v.shape[1],T=o?k.shape[1]:k.shape[2],C=Math.max(g,y),_=n.makeOutput([C,N,T],v.dtype),E=n.dataIdMap.get(_.dataId).id,A=new Uint8Array(new Int32Array(v.shape).buffer),$=new Uint8Array(new Int32Array(k.shape).buffer);return K4(I,A,v.shape.length,S,$,k.shape.length,i,o,E),n.disposeData(v.dataId),n.disposeData(k.dataId),_.shape=b,_}var J4={kernelName:Nt,backendName:"wasm",setupFunc:Y4,kernelFunc:Z4};function Q4(e){let{inputs:{x:t},attrs:{begin:n,size:r},backend:a}=e,[s,i]=au.parseSliceParams(t,n,r),o=au.isSliceContinous(t.shape,s,i),l=a.readSync(t.dataId),u=a.makeOutput(i,t.dtype),p=Aa.computeStrides(t.shape),d=a.dataIdMap.get(u.dataId);if(o){let e=au.computeFlatOffset(s,p);return"string"===t.dtype?d.stringBytes=l.slice(e,e+Aa.sizeFromShape(i)):a.typedArrayFromHeap(u).set(l.subarray(e,e+Aa.sizeFromShape(i))),u}if("string"===t.dtype){let e=SL(l,s,i,t.shape,t.dtype);return d.stringBytes=e,u}let c=a.typedArrayFromHeap(u),h=t.shape.length;if(2===h)e5(l,p[0],c,s,i);else if(3===h)t5(l,p[0],p[1],c,s,i);else if(4===h)n5(l,p[0],p[1],p[2],c,s,i);else{let e=SL(l,s,i,t.shape,t.dtype);c.set(e)}return u}function e5(e,t,n,r,a){let s=0,i=r[0],o=r[1],l=i+a[0];for(let u=i;u<l;u++){let r=u*t+o;n.set(e.subarray(r,r+a[1]),s),s+=a[1]}}function t5(e,t,n,r,a,s){let i=0,o=a[0],l=a[1],u=a[2],p=o+s[0],d=l+s[1];for(let c=o;c<p;c++)for(let a=l;a<d;a++){let o=c*t+a*n+u;r.set(e.subarray(o,o+s[2]),i),i+=s[2]}}function n5(e,t,n,r,a,s,i){let o=0,l=s[0],u=s[1],p=s[2],d=l+i[0],c=u+i[1],h=p+i[2],f=s[3];for(let m=l;m<d;m++)for(let s=u;s<c;s++)for(let l=p;l<h;l++){let u=m*t+s*n+l*r+f;a.set(e.subarray(u,u+i[3]),o),o+=i[3]}}var r5={kernelName:$r,backendName:"wasm",kernelFunc:Q4};function a5(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r,o=s.reduce(((e,t)=>e*t)),l=Mw.getReshaped(a.shape,s,o),u=Mw.getPermuted(l.length,s.length),p=Mw.getReshapedPermuted(a.shape,s,o),d=Mw.getSliceBeginCoords(i,s.length),c=Mw.getSliceSize(p,i,s.length),h=q4({inputs:{x:a},backend:n,attrs:{shape:l}}),f=T4({inputs:{x:h},backend:n,attrs:{perm:u}}),m=q4({inputs:{x:f},backend:n,attrs:{shape:p}}),g=Q4({inputs:{x:m},backend:n,attrs:{begin:d,size:c}});return n.disposeData(h.dataId),n.disposeData(f.dataId),n.disposeData(h.dataId),g}var s5={kernelName:Tt,backendName:"wasm",kernelFunc:a5};function i5(e){let{inputs:{x:t},attrs:{dtype:n},backend:r}=e,a=r.makeOutput(t.shape,n),s=r.typedArrayFromHeap(t);return r.typedArrayFromHeap(a).set(s),a}var o5,l5={kernelName:At,backendName:"wasm",kernelFunc:i5},u5=h4($t);function p5(e){o5=e.wasm.cwrap(Ft,null,["number","number","number","number"])}function d5(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:s,clipValueMax:i}=r,o=n.dataIdMap.get(a.dataId).id,l=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(l.dataId).id;return o5(o,s,i,u),l}var c5={kernelName:Ft,backendName:"wasm",setupFunc:p5,kernelFunc:d5};function h5(e){let{inputs:t,backend:n}=e,r=Aa.parseAxisParam(e.attrs.axis,t[0].shape)[0],a=Mw.computeOutShape(t.map((e=>e.shape)),r),s=t.filter((e=>Aa.sizeFromShape(e.shape)>0));if(1===s.length)return k4({inputs:{x:s[0]},backend:n});let i=n.makeOutput(a,t[0].dtype);if(0===Aa.sizeFromShape(a))return i;let o=s.map((e=>e.shape));if(Mw.assertParamsConsistent(o,r),"string"===s[0].dtype){let e=s.map((e=>{let t=Aa.sizeFromShape(e.shape.slice(r));return q4({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),o=e.map((e=>({vals:n.readSync(e.dataId),shape:e.shape})));a=Mw.computeOutShape(e.map((e=>e.shape)),1);let l=1===e[0].shape[0],u=gO(o,a,t[0].dtype,l),p=Mw.computeOutShape(s.map((e=>e.shape)),r);i.shape=p;let d=n.dataIdMap.get(i.dataId);return d.stringBytes=Mw.fromStringArrayToUint8(u),e.forEach((e=>n.disposeData(e.dataId))),i}let l=Aa.sizeFromShape(s[0].shape.slice(0,r)),u=0,p=s.map((e=>{let t=Aa.sizeFromShape(e.shape.slice(r));return u+=t,t})),d=s.map((e=>n.typedArrayFromHeap(e))),c=n.typedArrayFromHeap(i);for(let h=0;h<l;h++){let e=h*u;for(let t=0;t<d.length;t++){let n=p[t],r=h*n,a=d[t].subarray(r,r+n);c.set(a,e),e+=n}}return i}var f5,m5={kernelName:Mt,backendName:"wasm",kernelFunc:h5};function g5(e){f5=e.wasm.cwrap(Ot,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function y5(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,i=r.dataIdMap.get(a.dataId).id,o=r.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:p,dimRoundingMode:d,dataFormat:c}=n,h=Mw.convertConv2DDataFormat(c),f=Mw.computeConv2DInfo(a.shape,s.shape,l,u,p,d,!1,h),m=f.filterHeight,g=f.filterWidth,y=f.padInfo.top,b=f.padInfo.right,w=f.padInfo.bottom,x=f.padInfo.left,v=f.dilationHeight,k=f.dilationWidth,I=f.strideHeight,S=f.strideWidth,N=f.inChannels,T=f.outChannels,C="SAME"===f.padInfo.type?1:0;if("channelsLast"!==f.dataFormat)throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let _=r.makeOutput(f.outShape,"float32"),E=r.dataIdMap.get(_.dataId).id;return f5(i,a.shape[0],a.shape[1],a.shape[2],o,m,g,y,b,w,x,C,v,k,I,S,N,T,E),_}var b5,w5={kernelName:Ot,backendName:"wasm",setupFunc:g5,kernelFunc:y5};function x5(e){b5=e.wasm.cwrap(Pt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function v5(e){let{backend:t,inputs:n,attrs:r}=e,{dy:a,filter:s}=n,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,inputShape:p}=r,d=1,c=Mw.convertConv2DDataFormat(l),h=Mw.computeConv2DInfo(p,s.shape,i,d,o,u,!1,c),{batchSize:f,filterHeight:m,filterWidth:g,inChannels:y,inHeight:b,inWidth:w,outChannels:x,outHeight:v,outWidth:k,strideHeight:I,strideWidth:S}=h,N=m-1-h.padInfo.top,T=g-1-h.padInfo.left,C="channelsLast"===h.dataFormat,_=Aa.computeStrides(h.inShape),E=Aa.computeStrides(a.shape),[A,$,F]=Aa.computeStrides(s.shape),R=_[0],D=C?_[1]:_[2],M=C?_[2]:1,O=C?1:_[1],L=E[0],P=C?E[1]:E[2],z=C?E[2]:1,B=C?1:E[1],W=t.makeOutput(h.inShape,"float32"),V=t.dataIdMap.get(W.dataId).id,U=t.dataIdMap.get(a.dataId).id,G=t.dataIdMap.get(s.dataId).id;return b5(U,G,f,m,g,b,w,y,v,k,x,I,S,N,T,A,$,F,R,D,M,O,L,P,z,B,V),W}var k5,I5,S5={kernelName:Pt,backendName:"wasm",setupFunc:x5,kernelFunc:v5},N5=h4(Vt),T5=h4(Ut);function C5(e){I5=e.wasm.cwrap(jt,null,["number","number","number","number","array","number","number","number","number","number"])}function _5(e){let t,{backend:n,inputs:r,attrs:a}=e,{method:s,extrapolationValue:i,cropSize:o}=a,{image:l,boxes:u,boxInd:p}=r,d=u.shape[0],[c,h]=o,f=[d,c,h,l.shape[3]],m=n.dataIdMap.get(l.dataId);"float32"!==l.dtype&&(t=i5({backend:n,inputs:{x:l},attrs:{dtype:"float32"}}),m=n.dataIdMap.get(t.dataId));let g=m.id,y=n.dataIdMap.get(u.dataId).id,b=n.dataIdMap.get(p.dataId).id,w=n.makeOutput(f,"float32"),x=n.dataIdMap.get(w.dataId).id,v=new Uint8Array(new Int32Array(l.shape).buffer);return I5(g,y,b,d,v,c,h,k5[s],i,x),null!=t&&n.disposeData(t.dataId),w}(function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"})(k5||(k5={}));var E5,A5={kernelName:jt,backendName:"wasm",setupFunc:C5,kernelFunc:_5};function $5(e){E5=e.wasm.cwrap(Gt,null,["number","number","number","number","number","number"])}function F5(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r,l=a.shape.length;Aa.assert("float32"===a.dtype||"int32"===a.dtype,(()=>`cumprod does not support ${a.dtype} tensors in the WASM backend`));let u=Mw.getAxesPermutation([s],l),p=a;null!==u&&(p=T4({inputs:{x:a},attrs:{perm:u},backend:n}));let d=Mw.getInnerMostAxes(1,l)[0];Mw.assertAxesAreInnerMostDims("cumprod",[d],l);let c=n.makeOutput(p.shape,p.dtype),h=p.shape[d],f=n.dataIdMap.get(p.dataId).id,m=n.dataIdMap.get(c.dataId).id;E5(f,i?1:0,o?1:0,h,m,s4[a.dtype]);let g=c;if(null!==u){let e=Mw.getUndoAxesPermutation(u);g=T4({inputs:{x:c},attrs:{perm:e},backend:n}),n.disposeData(p.dataId),n.disposeData(c.dataId)}return g}var R5,D5={kernelName:Gt,backendName:"wasm",setupFunc:$5,kernelFunc:F5};function M5(e){R5=e.wasm.cwrap(Ht,null,["number","number","number","number","number","number"])}function O5(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r,l=a.shape.length;Aa.assert("float32"===a.dtype||"int32"===a.dtype,(()=>`cumsum does not support ${a.dtype} tensors in the WASM backend`));let u=Mw.getAxesPermutation([s],l),p=a;null!==u&&(p=T4({inputs:{x:a},attrs:{perm:u},backend:n}));let d=Mw.getInnerMostAxes(1,l)[0];Mw.assertAxesAreInnerMostDims("cumsum",[d],l);let c=n.makeOutput(p.shape,p.dtype),h=p.shape[d],f=n.dataIdMap.get(p.dataId).id,m=n.dataIdMap.get(c.dataId).id;R5(f,i?1:0,o?1:0,h,m,s4[a.dtype]);let g=c;if(null!==u){let e=Mw.getUndoAxesPermutation(u);g=T4({inputs:{x:c},attrs:{perm:e},backend:n}),n.disposeData(p.dataId),n.disposeData(c.dataId)}return g}var L5,P5={kernelName:Ht,backendName:"wasm",setupFunc:M5,kernelFunc:O5};function z5(e){L5=e.wasm.cwrap(Kt,null,["number","number","number","array","number","array","array","number","number"])}function B5(e){let{backend:t,inputs:n,attrs:r}=e,{x:a}=n,{blockSize:s,dataFormat:i}=r,o=a.shape[0],l="NHWC"===i?a.shape[1]:a.shape[2],u="NHWC"===i?a.shape[2]:a.shape[3],p="NHWC"===i?a.shape[3]:a.shape[1],d=l*s,c=u*s,h=p/(s*s),f="NHWC"===i?[o,d,c,h]:[o,h,d,c],m=t.makeOutput(f,"float32"),g=t.dataIdMap.get(a.dataId).id,y=new Uint8Array(new Int32Array(Aa.computeStrides(a.shape)).buffer),b=new Uint8Array(new Int32Array(f).buffer),w=new Uint8Array(new Int32Array(Aa.computeStrides(f)).buffer),x=t.dataIdMap.get(m.dataId).id;return L5(g,s,"NHWC"===i?1:0,y,a.shape.length-1,b,w,f.length,x),m}var W5,V5={kernelName:Kt,backendName:"wasm",setupFunc:z5,kernelFunc:B5};function U5(e){W5=e.wasm.cwrap(Xt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function G5(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,i=r.dataIdMap.get(a.dataId).id,o=r.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:p,dimRoundingMode:d}=n,c=null==u?[1,1]:u,h=Mw.computeConv2DInfo(a.shape,s.shape,l,c,p,d,!0),f=h.filterHeight,m=h.filterWidth,g=h.padInfo.top,y=h.padInfo.right,b=h.padInfo.bottom,w=h.padInfo.left,x=h.dilationHeight,v=h.dilationWidth,k=h.strideHeight,I=h.strideWidth,S=h.inChannels,N=h.outChannels,T="SAME"===h.padInfo.type?1:0;if("channelsLast"!==h.dataFormat)throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${h.dataFormat}'. Please use 'channelsLast'.`);let C=r.makeOutput(h.outShape,"float32"),_=r.dataIdMap.get(C.dataId).id;return W5(i,a.shape[0],a.shape[1],a.shape[2],o,f,m,g,y,b,w,T,x,v,k,I,S,N,_),C}var H5={kernelName:Xt,backendName:"wasm",setupFunc:U5,kernelFunc:G5},j5=h4(an),q5=!1,K5=m4(ln,q5,"bool"),X5=h4(un,"float32");function Y5(e){let{inputs:t,attrs:n,backend:r}=e,{input:a}=t,{dim:s}=n,i=a.shape.length,o=a.shape.slice(),l=s;return s<0&&(Aa.assert(-(i+1)<=s,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+s+1),o.splice(l,0,1),q4({inputs:{x:a},backend:r,attrs:{shape:o}})}var Z5={kernelName:pn,backendName:"wasm",kernelFunc:Y5};function J5(e){let{attrs:{shape:t,value:n,dtype:r},backend:a}=e,s=a.makeOutput(t,r);return a.typedArrayFromHeap(s).fill(n),s}var Q5,e6={kernelName:hn,backendName:"wasm",kernelFunc:J5};function t6(e){Q5=e.wasm.cwrap(fn,null,["number","number","number","number","number","number"])}function n6(e){let{inputs:t,backend:n}=e,{image:r}=t,a=n.makeOutput(r.shape,r.dtype),s=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(a.dataId).id,[o,l,u,p]=r.shape;return Q5(s,o,l,u,p,i),a}var r6,a6={kernelName:fn,backendName:"wasm",kernelFunc:n6,setupFunc:t6},s6=h4(mn),i6=!1,o6=m4(gn,i6);function l6(e){r6=e.wasm.cwrap(yn,null,["number","number","number","number","number","number","number"])}function u6(e){let{backend:t,inputs:n,attrs:r}=e,{varianceEpsilon:a}=r,{x:s,mean:i,variance:o,offset:l,scale:u}=n,p=t.dataIdMap.get(s.dataId).id,d=t.dataIdMap.get(i.dataId).id,c=t.dataIdMap.get(o.dataId).id,h=null!=l?t.dataIdMap.get(l.dataId).id:0,f=null!=u?t.dataIdMap.get(u.dataId).id:0,m=t.makeOutput(s.shape,s.dtype);if(0===Aa.sizeFromShape(s.shape))return m;let g=t.dataIdMap.get(m.dataId).id;return r6(p,d,c,h,f,a,g),m}var p6,d6={kernelName:yn,backendName:"wasm",setupFunc:l6,kernelFunc:u6};function c6(e){p6=e.wasm.cwrap(ma,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function h6(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:p,dataFormat:d,dimRoundingMode:c,activation:h,leakyreluAlpha:f}=n,m=Mw.computeConv2DInfo(a.shape,s.shape,l,p,u,c),g=i4[h];if(null==g)throw new Error(`${h} activation not yet supported for FusedConv2D in the wasm backend.`);let y=r.dataIdMap.get(a.dataId).id,b=r.dataIdMap.get(s.dataId).id,w=m.outChannels,x=0;if(null!=i){let e=r.dataIdMap.get(i.dataId);if(1!==e.shape.length)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==w)throw new Error(`FusedConv2D bias shape (${e.shape}) does not match the number of output channels (${w})`);x=e.id}let v=m.filterHeight,k=m.filterWidth,I=m.padInfo.top,S=m.padInfo.right,N=m.padInfo.bottom,T=m.padInfo.left,C=m.dilationHeight,_=m.dilationWidth,E=m.strideHeight,A=m.strideWidth,$=m.inChannels,F="SAME"===m.padInfo.type?1:0,R=m.batchSize,D=m.inHeight,M=m.inWidth;if("NHWC"!==d)throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let O=r.makeOutput(m.outShape,"float32"),L=r.dataIdMap.get(O.dataId).id,P=null==o?0:r.dataIdMap.get(o.dataId).id;return p6(y,R,D,M,b,v,k,x,I,S,N,T,F,C,_,E,A,$,w,g,P,f||0,L),O}var f6,m6={kernelName:ma,backendName:"wasm",setupFunc:c6,kernelFunc:h6};function g6(e){f6=e.wasm.cwrap(ga,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function y6(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:p,dataFormat:d,dimRoundingMode:c,activation:h,leakyreluAlpha:f}=n,m=Mw.computeConv2DInfo(a.shape,s.shape,l,p,u,c,!0),g=i4[h];if(null==g)throw new Error(`${h} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let y=r.dataIdMap.get(a.dataId).id,b=r.dataIdMap.get(s.dataId).id,w=m.outChannels,x=0;if(null!=i){let e=r.dataIdMap.get(i.dataId);if(1!==e.shape.length)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==w)throw new Error(`FusedDepthwiseConv2D bias shape (${e.shape}) does not match the number of output channels (${w})`);x=e.id}let v=m.filterHeight,k=m.filterWidth,I=m.padInfo.top,S=m.padInfo.right,N=m.padInfo.bottom,T=m.padInfo.left,C=m.dilationHeight,_=m.dilationWidth,E=m.strideHeight,A=m.strideWidth,$=m.inChannels,F="SAME"===m.padInfo.type?1:0,R=m.batchSize,D=m.inHeight,M=m.inWidth;if("NHWC"!==d)throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let O=r.makeOutput(m.outShape,"float32"),L=r.dataIdMap.get(O.dataId).id,P=null==o?0:r.dataIdMap.get(o.dataId).id;return f6(y,R,D,M,b,v,k,x,I,S,N,T,F,C,_,E,A,$,w,g,P,f||0,L),O}var b6,w6={kernelName:ga,backendName:"wasm",setupFunc:g6,kernelFunc:y6};function x6(e){b6=e.wasm.cwrap(wn,null,["number","number","number","number","number","number","array","number"])}function v6(e){let{backend:t,inputs:n}=e,{params:r,indices:a}=n,[s,i,o,l]=Jl.prepareAndValidate(r,a),u=t.makeOutput(s,r.dtype);if(0===i)return u;let p=a.shape,d=p[p.length-1],c=t.dataIdMap.get(r.dataId).id,h=t.dataIdMap.get(a.dataId).id,f=new Uint8Array(new Int32Array(l).buffer),m=t.dataIdMap.get(u.dataId).id;return b6(c,s4[r.dtype],h,i,d,o,f,m),u}var k6,I6={kernelName:wn,backendName:"wasm",setupFunc:x6,kernelFunc:v6};function S6(e){k6=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function N6(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,indices:s}=n,{axis:i,batchDims:o}=r,l=Aa.parseAxisParam(i,a.shape)[0],u=t.readSync(s.dataId),p=a.shape[l];for(let I=0;I<u.length;++I){let e=u[I];Aa.assert(e<=p-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${p-1}]`))}let d=Mw.segment_util.collectGatherOpShapeInfo(a,s,l,o),c=q4({inputs:{x:a},attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]},backend:t}),h=Aa.sizeFromShape(s.shape),f=q4({inputs:{x:s},attrs:{shape:[d.batchSize,h/d.batchSize]},backend:t}),m=[d.batchSize,d.outerSize,h/d.batchSize,d.sliceSize],g=t.makeOutput(m,a.dtype);if(0===Aa.sizeFromShape(a.shape))return g;let y=c.shape.length-1,b=t.dataIdMap.get(c.dataId).id,w=t.dataIdMap.get(f.dataId).id,x=t.dataIdMap.get(g.dataId).id,v=new Uint8Array(new Int32Array(Aa.computeStrides(c.shape)).buffer),k=new Uint8Array(new Int32Array(Aa.computeStrides(m)).buffer);return k6(b,s4[a.dtype],v,y,w,d.batchSize,k,x),t.disposeData(c.dataId),t.disposeData(f.dataId),g.shape=d.outputShape,g}var T6,C6={kernelName:bn,backendName:"wasm",setupFunc:S6,kernelFunc:N6},_6=!1,E6=m4(xn,_6,"bool"),A6=!1,$6=m4(vn,A6,"bool");function F6(e){T6=e.wasm.cwrap(_n,null,["number","number","number","number"])}function R6(e){let{inputs:{x:t},attrs:{alpha:n},backend:r}=e,a=r.dataIdMap.get(t.dataId).id,s=r.makeOutput(t.shape,"float32");if(0!==Aa.sizeFromShape(t.shape)){let e=r.dataIdMap.get(s.dataId).id;T6(a,s4[t.dtype],n,e)}return s}var D6,M6={kernelName:_n,backendName:"wasm",setupFunc:F6,kernelFunc:R6},O6=!1,L6=m4(En,O6,"bool"),P6=!1,z6=m4(An,P6,"bool"),B6=h4(Fn),W6=!1,V6=m4(Dn,W6,"bool");function U6(e){D6=e.wasm.cwrap(Wn,null,["number","number","number","number"])}function G6(e){let{backend:t,inputs:n,attrs:r}=e,{reductionIndices:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:p,originalAxes:d,inputWasTransposed:c}=$4(i,a,t);if(c){let e=t.dataIdMap.get(u.dataId).id;l=u,o=e}let h=l.shape.length;Mw.assertAxesAreInnerMostDims("max",p,h);let[f,m]=Mw.computeOutAndReduceShapes(l.shape,p),g=Aa.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(0!==Aa.sizeFromShape(l.shape)){let e=t.dataIdMap.get(y.dataId).id;D6(o,s4[i.dtype],g,e)}if(c&&t.disposeData(u.dataId),s){let e=Mw.expandShapeToKeepDim(y.shape,d);y.shape=e}return y}var H6,j6={kernelName:Wn,backendName:"wasm",setupFunc:U6,kernelFunc:G6},q6=!1,K6=m4(Vn,q6);function X6(e){H6=e.wasm.cwrap(Un,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Y6(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,s=r.dataIdMap.get(a.dataId).id;Aa.assert("float32"===a.dtype,(()=>`Error in MaxPool: only float32 input is supported. Got ${a.dtype}.`));let{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,p=Mw.computePool2DInfo(a.shape,i,o,1,l,u),d=p.filterHeight,c=p.filterWidth,h=p.padInfo.top,f=p.padInfo.right,m=p.padInfo.bottom,g=p.padInfo.left,y=p.dilationHeight,b=p.dilationWidth,w=p.strideHeight,x=p.strideWidth,v=p.inChannels,k=p.outChannels;if("channelsLast"!==p.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);let I=r.makeOutput(p.outShape,"float32"),S=r.dataIdMap.get(I.dataId).id;return H6(s,a.shape[0],a.shape[1],a.shape[2],d,c,h,f,m,g,y,b,w,x,v,k,S),I}var Z6,J6={kernelName:Un,backendName:"wasm",setupFunc:X6,kernelFunc:Y6};function Q6(e){Z6=e.wasm.cwrap(Kn,null,["number, number, number"])}function e8(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:p,axes:d,originalAxes:c,inputWasTransposed:h}=$4(i,a,t),f=d;if(h){let e=t.dataIdMap.get(p.dataId).id;e!==o&&(u=p,l=e,f=Mw.getInnerMostAxes(f.length,u.shape.length))}Mw.assertAxesAreInnerMostDims("mean",f,u.shape.length);let[m,g]=Mw.computeOutAndReduceShapes(u.shape,f),y=Aa.sizeFromShape(g),b=u;"float32"!==u.dtype&&(b=i5({backend:t,inputs:{x:u},attrs:{dtype:"float32"}}),l=t.dataIdMap.get(b.dataId).id);let w=t.makeOutput(m,"float32");if(0!==Aa.sizeFromShape(u.shape)){let e=t.dataIdMap.get(w.dataId).id;Z6(l,y,e)}if(h&&t.disposeData(p.dataId),s){let e=Mw.expandShapeToKeepDim(w.shape,c);w.shape=e}return"float32"!==u.dtype&&t.disposeData(b.dataId),w}var t8,n8={kernelName:Kn,backendName:"wasm",setupFunc:Q6,kernelFunc:e8};function r8(e){t8=e.wasm.cwrap(Xn,null,["number","number","number","number"])}function a8(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:p,axes:d,originalAxes:c,inputWasTransposed:h}=$4(i,a,t);if(h){let e=t.dataIdMap.get(p.dataId).id;e!==o&&(u=p,l=e)}let f=u.shape.length;Mw.assertAxesAreInnerMostDims("min",d,f);let[m,g]=Mw.computeOutAndReduceShapes(u.shape,d),y=Aa.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(0!==Aa.sizeFromShape(u.shape)){let e=t.dataIdMap.get(b.dataId).id;t8(l,s4[i.dtype],y,e)}if(h&&t.disposeData(p.dataId),s){let e=Mw.expandShapeToKeepDim(b.shape,c);b.shape=e}return b}var s8,i8,o8={kernelName:Xn,backendName:"wasm",setupFunc:r8,kernelFunc:a8},l8=!1,u8=m4(Yn,l8);function p8(e){i8=e.wasm.cwrap(Zn,null,["number","array","number","number","array","array","number","number"])}function d8(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,mode:a}}=e,s=r.map(((e,n)=>e[0]+t.shape[n]+e[1])),i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),p=r.map((e=>e[0])),d=r.map((e=>e[1])),c=new Uint8Array(new Int32Array(p).buffer),h=new Uint8Array(new Int32Array(d).buffer);return i8(i,u,t.shape.length,s4[t.dtype],c,h,s8[a],l),o}(function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"})(s8||(s8={}));var c8,h8={kernelName:Zn,backendName:"wasm",kernelFunc:d8,setupFunc:p8},f8=!0,m8=m4(er,f8),g8=h4(tr);function y8(e,t){let n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),r=n[0],a=n[1],s=n[2],i=n[3];return e.wasm._free(t),{pSelectedIndices:r,selectedSize:a,pSelectedScores:s,pValidOutputs:i}}function b8(e){c8=e.wasm.cwrap(rr,"number",["number","number","number","number","number"])}function w8(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i}=r,{boxes:o,scores:l}=n,u=t.dataIdMap.get(o.dataId).id,p=t.dataIdMap.get(l.dataId).id,d=c8(u,p,s,a,i),{pSelectedIndices:c,selectedSize:h,pSelectedScores:f,pValidOutputs:m}=y8(t,d);return t.wasm._free(f),t.wasm._free(m),t.makeOutput([h],"int32",c)}var x8,v8={kernelName:rr,backendName:"wasm",setupFunc:b8,kernelFunc:w8};function k8(e){x8=e.wasm.cwrap(ar,"number",["number","number","number","number","number","bool"])}function I8(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i,padToMaxOutputSize:o}=r,{boxes:l,scores:u}=n,p=t.dataIdMap.get(l.dataId).id,d=t.dataIdMap.get(u.dataId).id,c=x8(p,d,s,a,i,o),{pSelectedIndices:h,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=y8(t,c);t.wasm._free(m);let y=t.makeOutput([f],"int32",h),b=t.makeOutput([],"int32",g);return[y,b]}var S8,N8={kernelName:ar,backendName:"wasm",setupFunc:k8,kernelFunc:I8};function T8(e){S8=e.wasm.cwrap(sr,"number",["number","number","number","number","number","number"])}function C8(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i,softNmsSigma:o}=r,{boxes:l,scores:u}=n,p=t.dataIdMap.get(l.dataId).id,d=t.dataIdMap.get(u.dataId).id,c=S8(p,d,s,a,i,o),{pSelectedIndices:h,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=y8(t,c);t.wasm._free(g);let y=t.makeOutput([f],"int32",h),b=t.makeOutput([f],"float32",m);return[y,b]}var _8,E8={kernelName:sr,backendName:"wasm",setupFunc:T8,kernelFunc:C8},A8=!1,$8=m4(nr,A8,"bool");function F8(e){_8=e.wasm.cwrap(or,null,["number","number","number","number","number"])}function R8(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{depth:s,onValue:i,offValue:o}=r,l=n.makeOutput([...a.shape,s],"int32"),u=n.dataIdMap.get(l.dataId).id,p=n.dataIdMap.get(a.dataId).id;return _8(p,s,i,o,u),l}var D8={kernelName:or,backendName:"wasm",setupFunc:F8,kernelFunc:R8};function M8(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(1),r}var O8={kernelName:ir,backendName:"wasm",kernelFunc:M8};function L8(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return Y5({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach((e=>{Aa.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),Aa.assert(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));let o=[],l=t.map((e=>{let t=Y5({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),u=h5({inputs:l,backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeData(e.dataId))),u}var P8,z8={kernelName:lr,backendName:"wasm",kernelFunc:L8};function B8(e){P8=e.wasm.cwrap(ur,null,["number","array","number","number","array","array","number","number"])}function W8(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,constantValue:a}}=e,s=r.map(((e,n)=>e[0]+t.shape[n]+e[1]));if(0===Aa.sizeFromShape(t.shape))return J5({backend:n,attrs:{shape:s,value:a,dtype:t.dtype}});let i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),p=r.map((e=>e[0])),d=r.map((e=>e[1])),c=new Uint8Array(new Int32Array(p).buffer),h=new Uint8Array(new Int32Array(d).buffer);return P8(i,u,t.shape.length,s4[t.dtype],c,h,a,l),o}var V8,U8={kernelName:ur,backendName:"wasm",kernelFunc:W8,setupFunc:B8},G8=!1,H8=m4(dr,G8);function j8(e){V8=e.wasm.cwrap(cr,null,["number","number","number"])}function q8(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(a.dataId).id,o=s,l=r,u=l;"float32"!==l.dtype&&(u=i5({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),o=n.dataIdMap.get(u.dataId).id);let p=n.makeOutput(r.shape,"float32"),d=n.dataIdMap.get(p.dataId).id;return V8(o,i,d),"float32"!==l.dtype&&n.disposeData(u.dataId),p}var K8,X8={kernelName:cr,backendName:"wasm",setupFunc:j8,kernelFunc:q8};function Y8(e){K8=e.wasm.cwrap(hr,null,["number","number","number","number"])}function Z8(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:p,axes:d,originalAxes:c,inputWasTransposed:h}=$4(i,a,t),f=d;if(h){let e=t.dataIdMap.get(p.dataId).id;e!==o&&(u=p,l=e,f=Mw.getInnerMostAxes(f.length,u.shape.length))}Mw.assertAxesAreInnerMostDims("prod",f,u.shape.length);let[m,g]=Mw.computeOutAndReduceShapes(u.shape,f),y=Aa.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(0!==Aa.sizeFromShape(u.shape)){let e=t.dataIdMap.get(b.dataId).id;K8(l,y,s4[b.dtype],e)}if(h&&t.disposeData(p.dataId),s){let e=Mw.expandShapeToKeepDim(b.shape,c);b.shape=e}return b}var J8,Q8={kernelName:hr,backendName:"wasm",setupFunc:Y8,kernelFunc:Z8},e7=e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:i}=n,o=gL(r,a,s,i),l=t.makeOutput([o.length],i);return t.typedArrayFromHeap(l).set(o),l},t7={kernelName:fr,backendName:"wasm",kernelFunc:e7},n7=!0,r7=m4(nn,n7),a7=h4(yr),s7=h4(Ir);function i7(e){J8=e.wasm.cwrap(vr,null,["number","number","number","number","number","number","number","number","number","number"])}function o7(e){let t,{backend:n,inputs:r,attrs:a}=e,{images:s}=r,{alignCorners:i,halfPixelCenters:o,size:l}=a,[u,p]=l,[d,c,h,f]=s.shape,m=[d,u,p,f],g=n.dataIdMap.get(s.dataId);"float32"!==g.dtype&&(t=i5({backend:n,inputs:{x:s},attrs:{dtype:"float32"}}),g=n.dataIdMap.get(t.dataId));let y=g.id,b=n.makeOutput(m,"float32");if(0===Aa.sizeFromShape(s.shape))return b;let w=n.dataIdMap.get(b.dataId).id;return J8(y,d,c,h,f,u,p,i?1:0,o?1:0,w),null!=t&&n.disposeData(t.dataId),b}var l7,u7={kernelName:vr,backendName:"wasm",setupFunc:i7,kernelFunc:o7};function p7(e){l7=e.wasm.cwrap(Sr,null,["number","array","number","array","number","number"])}function d7(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,i=Aa.parseAxisParam(s,a.shape);if(0===a.shape.length)return k4({inputs:{x:a},backend:n});let o=n.makeOutput(a.shape,a.dtype),l=n.dataIdMap.get(a.dataId).id,u=n.dataIdMap.get(o.dataId).id,p=new Uint8Array(new Int32Array(i).buffer),d=new Uint8Array(new Int32Array(a.shape).buffer);l7(l,p,i.length,d,a.shape.length,u);let c=q4({inputs:{x:o},attrs:{shape:a.shape},backend:n});return n.disposeData(o.dataId),c}var c7,h7={kernelName:Sr,backendName:"wasm",kernelFunc:d7,setupFunc:p7};function f7(e){c7=e.wasm.cwrap(ha,null,["number","number","number","number","number","number","number","number","array","number","number"])}function m7(e){let{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{radians:s,fillValue:i,center:o}=r,l=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(a.dataId).id,p=n.dataIdMap.get(l.dataId).id,[d,c,h,f]=a.shape,[m,g]=Mw.getImageCenter(o,c,h),y=0===i,b=255,w="number"==typeof i?[i,i,i,y?0:b]:[...i,b],x=new Uint8Array(new Int32Array(w).buffer);return c7(u,d,c,h,f,s,m,g,x,w.length,p),l}var g7,y7={kernelName:ha,backendName:"wasm",kernelFunc:m7,setupFunc:f7},b7=h4(Nr),w7=h4(Tr);function x7(e){g7=e.wasm.cwrap(Cr,null,["number","number","number","number","number","number","array","number","number"])}function v7(e){let{backend:t,inputs:n,attrs:r}=e,{indices:a,updates:s}=n,{shape:i}=r,o=t.makeOutput(i,s.dtype);if(0===Aa.sizeFromShape(i))return o;let{sliceRank:l,numUpdates:u,sliceSize:p,strides:d,outputSize:c}=eu.calculateShapes(s,a,i),h=t.dataIdMap.get(a.dataId).id,f=t.dataIdMap.get(s.dataId).id,m=new Uint8Array(new Int32Array(d).buffer),g=t.dataIdMap.get(o.dataId).id;return g7(h,f,s4[s.dtype],l,u,p,m,c,g),o}var k7,I7={kernelName:Cr,backendName:"wasm",setupFunc:x7,kernelFunc:v7};function S7(e){k7=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function N7(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,i=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(a.dataId).id,l=n.dataIdMap.get(s.dataId).id,u=n.makeOutput(a.shape,a.dtype),p=n.dataIdMap.get(u.dataId).id,d=r.shape.length,c=a.shape.length,h=0===d||d>1||1===c?1:Aa.sizeFromShape(a.shape.slice(1));return k7(i,o,l,h,p),u}var T7,C7={kernelName:Er,backendName:"wasm",kernelFunc:N7,setupFunc:S7};function _7(e){T7=e.wasm.cwrap(Mr,null,["number","number"])}function E7(e){let{backend:t,inputs:{x:n}}=e,r=t.dataIdMap.get(n.dataId).id,a=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(a.dataId).id;return 0===Aa.sizeFromShape(a.shape)||T7(r,s),a}var A7,$7={kernelName:"Sigmoid",backendName:"wasm",setupFunc:_7,kernelFunc:E7},F7=h4(Fr);function R7(e){A7=e.wasm.cwrap(Wr,null,["number","number","number","number"])}function D7(e){let{backend:t,inputs:{logits:n},attrs:{dim:r}}=e,a=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),i=t.dataIdMap.get(s.dataId).id,o=n.shape[r],l=Aa.sizeFromShape(n.shape)/o;return 0===Aa.sizeFromShape(s.shape)||A7(a,i,o,l),s}var M7={kernelName:Wr,backendName:"wasm",setupFunc:R7,kernelFunc:D7};function O7(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r,o=Aa.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<a.shape.length;++g)l.push([0,0]);let u=U8.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),p=Mw.getReshaped(u.shape,s,o,!1),d=Mw.getPermuted(p.length,s.length,!1),c=Mw.getReshapedPermuted(u.shape,s,o,!1),h=q4({inputs:{x:u},backend:n,attrs:{shape:p}}),f=T4({inputs:{x:h},backend:n,attrs:{perm:d}}),m=q4({inputs:{x:f},backend:n,attrs:{shape:c}});return n.disposeData(u.dataId),n.disposeData(h.dataId),n.disposeData(f.dataId),m}var L7,P7={kernelName:zr,backendName:"wasm",kernelFunc:O7};function z7(e){L7=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function B7(e){let t,{backend:n,inputs:r}=e,{indices:a,values:s,denseShape:i,defaultValue:o}=r,l=a.shape[0],u=a.shape[1],p=n.readSync(i.dataId)[0],d=[l+p,u],c=n.dataIdMap.get(a.dataId).id,h=n.dataIdMap.get(s.dataId).id,f=n.dataIdMap.get(o.dataId).id,m=n.makeOutput(d,a.dtype),g=n.dataIdMap.get(m.dataId).id,y=n.makeOutput(d.slice(0,1),s.dtype),b=n.dataIdMap.get(y.dataId).id,w=n.makeOutput([p],"bool"),x=n.dataIdMap.get(w.dataId).id,v=n.makeOutput([l],a.dtype),k=n.dataIdMap.get(v.dataId).id,I=n.makeOutput([4],"int32"),S=n.dataIdMap.get(I.dataId).id,N=L7(c,h,s4[s.dtype],l,p,u,f,g,b,x,k,S),T=n.readSync(I.dataId);switch(T[0]){case 1:t=Mw.getSparseFillEmptyRowsIndicesDenseShapeMismatch(T[1]);break;case 2:t=Mw.getSparseFillEmptyRowsNegativeIndexErrorMessage(T[1],T[2]);break;case 3:t=Mw.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(T[1],T[2],T[3]);break;default:t=""}if(n.disposeData(I.dataId),t)throw n.disposeData(m.dataId),n.disposeData(y.dataId),n.disposeData(w.dataId),n.disposeData(v.dataId),new Error(t);let C=m,_=y;return N!==d[0]&&(C=Q4({inputs:{x:m},attrs:{begin:0,size:[N,u]},backend:n}),_=Q4({inputs:{x:y},attrs:{begin:0,size:N},backend:n}),n.disposeData(m.dataId),n.disposeData(y.dataId)),[C,_,w,v]}var W7,V7={kernelName:Vr,backendName:"wasm",setupFunc:z7,kernelFunc:B7};function U7(e){W7=e.wasm.cwrap(Ur,null,["number","number","number","number","number","number","number"])}function G7(e){let{backend:t,inputs:n}=e,{inputIndices:r,inputShape:a,newShape:s}=n;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=t.dataIdMap.get(r.dataId).id,o=t.dataIdMap.get(a.dataId).id,l=t.dataIdMap.get(s.dataId).id,u=r.shape[0],p=Aa.sizeFromShape(s.shape),d=t.makeOutput([u,p],r.dtype),c=t.dataIdMap.get(d.dataId).id,h=t.makeOutput([p],s.dtype),f=t.dataIdMap.get(h.dataId).id,m=t.makeOutput([3],"int32"),g=t.dataIdMap.get(m.dataId).id;W7(i,o,l,u,c,f,g);let y,b=t.readSync(m.dataId);switch(b[0]){case 0:y=Mw.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(b[1],b[2]);break;case 1:y=Mw.getSparseReshapeNegativeOutputDimErrorMessage(b[1],b[2]);break;case 2:y=Mw.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let e=Array.from(t.readSync(a.dataId)),n=Array.from(t.readSync(h.dataId));y=Mw.getSparseReshapeInputOutputMultipleErrorMessage(e,n);break}case 4:{let e=Array.from(t.readSync(a.dataId)),n=Array.from(t.readSync(h.dataId));y=Mw.getSparseReshapeInputOutputMismatchErrorMessage(e,n);break}default:y=""}if(t.disposeData(m.dataId),y)throw t.disposeData(d.dataId),t.disposeData(h.dataId),new Error(y);return[d,h]}var H7,j7={kernelName:Ur,backendName:"wasm",setupFunc:U7,kernelFunc:G7};function q7(e){H7=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function K7(e,t){let{backend:n,inputs:r}=e,{data:a,indices:s,segmentIds:i}=r,o=s.shape[0],l=n.readSync(i.dataId,o-1,o)[0],u=o>0?l+1:0;if(u<0)throw new Error(Mw.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let p=a.shape.slice();p[0]=u;let d=n.dataIdMap.get(a.dataId).id,c=n.dataIdMap.get(s.dataId).id,h=n.dataIdMap.get(i.dataId).id,f=n.makeOutput(p,a.dtype),m=n.dataIdMap.get(f.dataId).id,g=n.makeOutput([4],"int32"),y=n.dataIdMap.get(g.dataId).id;H7(d,s4[a.dtype],a.shape[0],c,h,m,y,t,0);let b,w=n.readSync(g.dataId);switch(w[0]){case 0:b=Mw.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break;case 1:b=Mw.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break;case 2:b=Mw.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(w[1],w[2]);break;case 3:b=Mw.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(w[1],w[2],w[3]);break;default:b=""}if(n.disposeData(g.dataId),b)throw n.disposeData(f.dataId),new Error(b);return f}function X7(e){return K7(e,!0)}var Y7={kernelName:Gr,backendName:"wasm",setupFunc:q7,kernelFunc:X7};function Z7(e){return K7(e,!1)}var J7={kernelName:Hr,backendName:"wasm",setupFunc:q7,kernelFunc:Z7};function Q7(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=n,o=Aa.parseAxisParam(i,a.shape)[0],l=Mw.prepareSplitSize(a,s,o),u=new Array(a.shape.length).fill(0),p=a.shape.slice();return l.map((e=>{let t=[...p];t[o]=e;let n=Q4({inputs:{x:a},attrs:{begin:u,size:t},backend:r});return u[o]+=e,n}))}var e9,t9={kernelName:Br,backendName:"wasm",kernelFunc:Q7},n9=h4(Lr),r9=h4(Kr),a9=!0,s9=m4(qr,a9);function i9(e){e9=e.wasm.cwrap(da,null,["number","number","number","number"])}function o9(e){let{backend:t,inputs:n,attrs:r}=e,{alpha:a}=r,{x:s}=n,i=t.dataIdMap.get(s.dataId).id,o=t.makeOutput(s.shape,s.dtype),l=t.dataIdMap.get(o.dataId).id;return e9(i,a,s4[s.dtype],l),o}var l9,u9={kernelName:da,backendName:"wasm",setupFunc:i9,kernelFunc:o9};function p9(e){l9=e.wasm.cwrap(Xr,null,["number","array","number","array","array","array","array","array","number","number"])}function d9(e){let t,{backend:n,inputs:r,attrs:a}=e,{x:s}=r,{begin:i,end:o,strides:l,beginMask:u,endMask:p,ellipsisMask:d,newAxisMask:c,shrinkAxisMask:h}=a,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:w,end:x,strides:v}=au.sliceInfo(s.shape,i,o,l,u,p,d,c,h);if(g)t=q4({inputs:{x:s},backend:n,attrs:{shape:m}});else if(y||b){Aa.assert(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));let e=au.computeOutShape(w,x,v),r=Q4({inputs:{x:s},backend:n,attrs:{begin:w,size:e}});t=q4({inputs:{x:r},backend:n,attrs:{shape:m}}),n.disposeData(r.dataId)}else{let e=n.makeOutput(f,"float32"),r=n.dataIdMap.get(s.dataId).id,a=new Uint8Array(new Int32Array(Aa.computeStrides(s.shape)).buffer),i=new Uint8Array(new Int32Array(w).buffer),o=new Uint8Array(new Int32Array(x).buffer),l=new Uint8Array(new Int32Array(v).buffer),u=new Uint8Array(new Int32Array(f).buffer),p=new Uint8Array(new Int32Array(Aa.computeStrides(f)).buffer),d=n.dataIdMap.get(e.dataId).id;l9(r,a,s.shape.length,i,o,l,u,p,f.length,d),t=q4({inputs:{x:e},backend:n,attrs:{shape:m}}),n.disposeData(e.dataId)}return t}var c9,h9={kernelName:Xr,backendName:"wasm",setupFunc:p9,kernelFunc:d9},f9=!0,m9=m4(Qr,f9);function g9(e){c9=e.wasm.cwrap(Pr,null,["number","number","number","number"])}function y9(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:p,axes:d,originalAxes:c,inputWasTransposed:h}=$4(i,a,t),f=d;if(h){let e=t.dataIdMap.get(p.dataId).id;e!==o&&(u=p,l=e,f=Mw.getInnerMostAxes(f.length,u.shape.length))}Mw.assertAxesAreInnerMostDims("sum",f,u.shape.length);let[m,g]=Mw.computeOutAndReduceShapes(u.shape,f),y=Aa.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(0!==Aa.sizeFromShape(u.shape)){let e=t.dataIdMap.get(b.dataId).id;c9(l,y,s4[b.dtype],e)}if(h&&t.disposeData(p.dataId),s){let e=Mw.expandShapeToKeepDim(b.shape,c);b.shape=e}return b}var b9,w9={kernelName:Pr,backendName:"wasm",setupFunc:g9,kernelFunc:y9},x9=h4(ea),v9=h4(ta);function k9(e){b9=e.wasm.cwrap(na,null,["number","array","number","array","number","number"])}function I9(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,s=n.dataIdMap.get(a.dataId).id,{reps:i}=r,o=new Array(a.shape.length);for(let c=0;c<o.length;c++)o[c]=a.shape[c]*i[c];let l=new Uint8Array(new Int32Array(a.shape).buffer),u=new Uint8Array(new Int32Array(o).buffer),p=n.makeOutput(o,a.dtype),d=n.dataIdMap.get(p.dataId).id;return b9(s,l,a.shape.length,u,o.length,s4[p.dtype],d),p}var S9,N9={kernelName:na,backendName:"wasm",setupFunc:k9,kernelFunc:I9};function T9(e){S9=e.wasm.cwrap(ra,null,["number","array","number","number","number","bool","number","number"])}var C9,_9=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{k:a,sorted:s}=n,i=t.dataIdMap.get(r.dataId).id,o=new Uint8Array(new Int32Array(r.shape).buffer),l=r.shape.slice();l[l.length-1]=a;let u=t.makeOutput(l,r.dtype),p=t.dataIdMap.get(u.dataId).id,d=t.makeOutput(l,"int32"),c=t.dataIdMap.get(d.dataId).id;return S9(i,o,r.shape.length,s4[r.dtype],a,s,p,c),[u,d]},E9={kernelName:ra,backendName:"wasm",setupFunc:T9,kernelFunc:_9};function A9(e){C9=e.wasm.cwrap(aa,null,["number","number","bool","number","number","number","number","number","number","array","number","number","number","number","number"])}function $9(e){let t,{backend:n,inputs:r,attrs:a}=e,{image:s,transforms:i}=r,{interpolation:o,fillMode:l,fillValue:u,outputShape:p}=a,[d,c,h,f]=s.shape,[m,g]=null!=p?p:[c,h],y=[d,m,g,f],b=new Uint8Array(new Int32Array(Aa.computeStrides(s.shape)).buffer),w=n.makeOutput(y,s.dtype),x=n.dataIdMap.get(w.dataId).id,v=n.dataIdMap.get(s.dataId).id,k=n.dataIdMap.get(i.dataId).id,I="nearest"===o?1:2;switch(l){case"constant":t=1;break;case"reflect":t=2;break;case"wrap":t=3;break;case"nearest":t=4;break;default:t=1;break}return C9(v,k,i.shape[0]>1,d,m,g,f,h,c,b,s.shape.length-1,I,t,u,x),w}var F9={kernelName:aa,backendName:"wasm",setupFunc:A9,kernelFunc:$9};function R9(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a.shape[s],o=a.shape.length,l=new Array(o-1),u=0;for(let h=0;h<o;h++)h!==s&&(l[u++]=a.shape[h]);let p=new Array(i),d=new Array(o).fill(0),c=a.shape.slice();c[s]=1;for(let h=0;h<p.length;h++)d[s]=h,p[h]=Q4({inputs:{x:a},attrs:{begin:d,size:c},backend:n});return p.map((({dataId:e,dtype:t})=>({dataId:e,dtype:t,shape:l})))}var D9={kernelName:oa,backendName:"wasm",kernelFunc:R9};function M9(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(0),r}var O9={kernelName:pa,backendName:"wasm",kernelFunc:M9},L9=[c4,f4,b4,v4,M4,z4,U4,j4,J4,s5,l5,u5,c5,m5,w5,S5,N5,T5,A5,D5,P5,V5,H5,j5,K5,X5,Z5,e6,a6,s6,o6,d6,m6,w6,I6,C6,E6,$6,S4,M6,L6,z6,B6,V6,j6,K6,J6,n8,o8,u8,h8,m8,g8,v8,N8,E8,$8,D8,O8,z8,U8,H8,X8,Q8,t7,r7,a7,s7,X4,u7,h7,y7,b7,w7,I7,C7,$7,F7,r5,M7,P7,V7,j7,Y7,J7,t9,n9,r9,s9,u9,h9,m9,w9,x9,v9,N9,E9,F9,A4,D9,O9];for(let dae of L9)Sa(dae);var P9=et();P9.registerFlag("WASM_HAS_SIMD_SUPPORT",(async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11])))),P9.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",(async()=>{if(P9.get("IS_NODE"))return!1;try{return(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(pae){return!1}}));var z9=I(Y()),B9='"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",function(data){onmessage({data:data})});var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8"))},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"\n");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=((info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports});self.onmessage=(e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob==="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module).then(function(instance){Module=instance})}else if(e.data.cmd==="run"){Module["__performance_now_clock_drift"]=performance.now()-e.data.time;Module["__emscripten_thread_init"](e.data.threadInfoStruct,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInit();try{var result=Module["invokeEntryPoint"](e.data.start_routine,e.data.arg);if(Module["keepRuntimeAlive"]()){Module["PThread"].setExitStatus(result)}else{Module["__emscripten_thread_exit"](result)}}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processThreadQueue"){if(Module["_pthread_self"]()){Module["_emscripten_current_thread_process_queued_calls"]()}}else if(e.data.cmd==="processProxyingQueue"){if(Module["_pthread_self"]()){Module["_emscripten_proxy_execute_queue"](e.data.queue)}}else{err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){err("worker.js onmessage() captured an uncaught exception: "+ex);if(ex&&ex.stack)err(ex.stack);if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}});',W9=I(Z()),V9=class extends Q{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(tee),nee=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new J(this,dl())}write(e,t,n){let r={id:this.dataIdNextNumber++};return this.move(r,e,t,n,1),r}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=Aa.now();return e(),{kernelMs:Aa.now()-t}}move(e,t,n,r,a){let s=this.dataIdNextNumber++;if("string"===r){let i=t;return void this.dataIdMap.set(e,{id:s,stringBytes:i,shape:n,dtype:r,memoryOffset:null,refCount:a})}let i=Aa.sizeFromShape(n),o=i*Aa.bytesPerElement(r),l=this.wasm._malloc(o);this.dataIdMap.set(e,{id:s,memoryOffset:l,shape:n,dtype:r,refCount:a}),this.wasm.tfjs.registerTensor(s,i,l),null!=t&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),l)}async read(e){return this.readSync(e)}readSync(e,t,n){let{memoryOffset:r,dtype:a,shape:s,stringBytes:i}=this.dataIdMap.get(e);if("string"===a)return null!=t&&0!==t||!(null==n||n>=i.length)?i.slice(t,n):i;t=t||0,n=n||Aa.sizeFromShape(s);let o=Aa.bytesPerElement(a),l=this.wasm.HEAPU8.slice(r+t*o,r+n*o);return j9(l.buffer,a)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);null!=t&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n){let r;if(null==n)r=this.write(null,e,t);else{let a=this.dataIdNextNumber++;r={id:a},this.dataIdMap.set(r,{id:a,memoryOffset:n,shape:e,dtype:t,refCount:1});let s=Aa.sizeFromShape(e);this.wasm.tfjs.registerTensor(a,s,n)}return{dataId:r,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){let r=this.wasm.HEAPU8.buffer,{memoryOffset:a}=this.dataIdMap.get(n),s=Aa.sizeFromShape(e);switch(t){case"float32":return new Float32Array(r,a,s);case"int32":return new Int32Array(r,a,s);case"bool":return new Uint8Array(r,a,s);default:throw new Error(`Unknown dtype ${t}`)}}};function U9(e){return(t,n)=>(Aa.fetch(e,{credentials:"same-origin"}).then((r=>{r.ok||t.env.a(`failed to load wasm binary file at '${e}'`),r.arrayBuffer().then((e=>{WebAssembly.instantiate(e,t).then((e=>{n(e.instance,e.module)}))}))})),{})}function G9(e,t,n){if(null!=K9)return K9;let r="tfjs-backend-wasm.wasm";return e&&t?r="tfjs-backend-wasm-threaded-simd.wasm":e&&(r="tfjs-backend-wasm-simd.wasm"),null!=Y9&&null!=Y9[r]?Y9[r]:n+r}async function H9(){let[e,t]=await Promise.all([et().getAsync("WASM_HAS_SIMD_SUPPORT"),et().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise(((n,r)=>{let a={locateFile:(n,r)=>{if(n.endsWith(".worker.js")){let e=B9.replace(/\n/g,"\\n"),t=new Blob([e],{type:"application/javascript"});return URL.createObjectURL(t)}return n.endsWith(".wasm")?G9(e,t,null!=X9?X9:r):r+n}};J9&&(a.instantiateWasm=U9(G9(e,t,null!=X9?X9:"")));let s,i=!1;a.onAbort=()=>{i||Z9||(Z9=!0,r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))},t&&e&&null==K9?(a.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+z9.default.toString()],{type:"text/javascript"}),s=(0,z9.default)(a)):s=(0,W9.default)(a),s.then((e=>{i=!0,Z9=!1;let t=null;e.tfjs={init:e.cwrap("init",null,[]),initWithThreadsCount:e.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:e.cwrap("get_threads_count","number",[]),registerTensor:e.cwrap("register_tensor",null,["number","number","number"]),disposeData:e.cwrap("dispose_data",t,["number"]),dispose:e.cwrap("dispose",t,[])},n({wasm:e})}))}))}function j9(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}var q9=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],K9=null,X9=null,Y9={},Z9=!1,J9=!1;function Q9(e,t=!1){if(ul("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),Z9)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");K9=e,J9=t}function eee(e,t=!1){if(Z9)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if("string"==typeof e)X9=e;else{Y9=e;let t=q9.filter((e=>null==Y9[e]));if(t.length>0)throw new Error(`There were no entries found for the following binaries: ${t.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}J9=t}var tee=-1,nee=-1;function ree(e){tee=e}function aee(){if(-1===nee)throw new Error("WASM backend not initialized.");return nee}var see="3.18.0",iee=2;Sl("wasm",(async()=>{let{wasm:e}=await H9();return new V9(e)}),iee);var oee="3.18.0",lee="3.18.0",uee="3.18.0",pee="3.18.0",dee="3.18.0",cee="3.18.0",hee="3.18.0",fee="3.18.0",mee={tfjs:oee,"tfjs-core":lee,"tfjs-data":uee,"tfjs-layers":pee,"tfjs-converter":dee,"tfjs-backend-cpu":cee,"tfjs-backend-webgl":hee,"tfjs-backend-wasm":fee},gee={};function yee(e,t,n=!1){if(e.beginPath(),t.slice(1).forEach((({x:n,y:r},a)=>{let s=t[a];e.moveTo(s.x,s.y),e.lineTo(n,r)})),n){let n=t[t.length-1],r=t[0];if(!n||!r)return;e.moveTo(n.x,n.y),e.lineTo(r.x,r.y)}e.stroke()}c(gee,{AnchorPosition:()=>cte,DrawBox:()=>gte,DrawBoxOptions:()=>mte,DrawFaceLandmarks:()=>mne,DrawFaceLandmarksOptions:()=>fne,DrawTextField:()=>fte,DrawTextFieldOptions:()=>hte,drawContour:()=>yee,drawDetections:()=>yte,drawFaceExpressions:()=>pne,drawFaceLandmarks:()=>gne});var bee={};c(bee,{computeReshapedDimensions:()=>Eee,getCenterPoint:()=>Aee,isDimensions:()=>_ee,isEven:()=>Tee,isFloat:()=>Nee,isTensor:()=>xee,isTensor1D:()=>vee,isTensor2D:()=>kee,isTensor3D:()=>Iee,isTensor4D:()=>See,isValidNumber:()=>Fee,isValidProbablitiy:()=>Ree,range:()=>$ee,round:()=>Cee});var wee=class{constructor(e,t){if(!Fee(e)||!Fee(t))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:e,height:t})}`);this._width=e,this._height=t}get width(){return this._width}get height(){return this._height}reverse(){return new wee(1/this.width,1/this.height)}};function xee(e,t){return e instanceof ks&&e.shape.length===t}function vee(e){return xee(e,1)}function kee(e){return xee(e,2)}function Iee(e){return xee(e,3)}function See(e){return xee(e,4)}function Nee(e){return e%1!==0}function Tee(e){return e%2===0}function Cee(e,t=2){let n=10**t;return Math.floor(e*n)/n}function _ee(e){return e&&e.width&&e.height}function Eee({width:e,height:t},n){let r=n/Math.max(t,e);return new wee(Math.round(e*r),Math.round(t*r))}function Aee(e){return e.reduce(((e,t)=>e.add(t)),new Dee(0,0)).div(new Dee(e.length,e.length))}function $ee(e,t,n){return Array(e).fill(0).map(((e,r)=>t+r*n))}function Fee(e){return!!e&&e!==1/0&&e!==-1/0&&!Number.isNaN(e)||0===e}function Ree(e){return Fee(e)&&e>=0&&e<=1}var Dee=class{constructor(e,t){this._x=e,this._y=t}get x(){return this._x}get y(){return this._y}add(e){return new Dee(this.x+e.x,this.y+e.y)}sub(e){return new Dee(this.x-e.x,this.y-e.y)}mul(e){return new Dee(this.x*e.x,this.y*e.y)}div(e){return new Dee(this.x/e.x,this.y/e.y)}abs(){return new Dee(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new Dee(Math.floor(this.x),Math.floor(this.y))}},Mee=class{static isRect(e){return!!e&&[e.x,e.y,e.width,e.height].every(Fee)}static assertIsValidBox(e,t,n=!1){if(!Mee.isRect(e))throw new Error(`${t} - invalid box: ${JSON.stringify(e)}, expected object with properties x, y, width, height`);if(!n&&(e.width<0||e.height<0))throw new Error(`${t} - width (${e.width}) and height (${e.height}) must be positive numbers`)}constructor(e,t=!0){let n=e||{},r=[n.left,n.top,n.right,n.bottom].every(Fee),a=[n.x,n.y,n.width,n.height].every(Fee);if(!a&&!r)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(n)}`);let[s,i,o,l]=a?[n.x,n.y,n.width,n.height]:[n.left,n.top,n.right-n.left,n.bottom-n.top];Mee.assertIsValidBox({x:s,y:i,width:o,height:l},"Box.constructor",t),this._x=s,this._y=i,this._width=o,this._height=l}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new Dee(this.left,this.top)}get topRight(){return new Dee(this.right,this.top)}get bottomLeft(){return new Dee(this.left,this.bottom)}get bottomRight(){return new Dee(this.right,this.bottom)}round(){let[e,t,n,r]=[this.x,this.y,this.width,this.height].map((e=>Math.round(e)));return new Mee({x:e,y:t,width:n,height:r})}floor(){let[e,t,n,r]=[this.x,this.y,this.width,this.height].map((e=>Math.floor(e)));return new Mee({x:e,y:t,width:n,height:r})}toSquare(){let{x:e,y:t,width:n,height:r}=this,a=Math.abs(n-r);return n<r&&(e-=a/2,n+=a),r<n&&(t-=a/2,r+=a),new Mee({x:e,y:t,width:n,height:r})}rescale(e){let t=_ee(e)?e.width:e,n=_ee(e)?e.height:e;return new Mee({x:this.x*t,y:this.y*n,width:this.width*t,height:this.height*n})}pad(e,t){let[n,r,a,s]=[this.x-e/2,this.y-t/2,this.width+e,this.height+t];return new Mee({x:n,y:r,width:a,height:s})}clipAtImageBorders(e,t){let{x:n,y:r,right:a,bottom:s}=this,i=Math.max(n,0),o=Math.max(r,0),l=a-i,u=s-o,p=Math.min(l,e-i),d=Math.min(u,t-o);return new Mee({x:i,y:o,width:p,height:d}).floor()}shift(e,t){let{width:n,height:r}=this,a=this.x+e,s=this.y+t;return new Mee({x:a,y:s,width:n,height:r})}padAtBorders(e,t){let n=this.width+1,r=this.height+1,a=1,s=1,i=n,o=r,l=this.left,u=this.top,p=this.right,d=this.bottom;return p>t&&(i=-p+t+n,p=t),d>e&&(o=-d+e+r,d=e),l<1&&(o=2-l,l=1),u<1&&(o=2-u,u=1),{dy:s,edy:o,dx:a,edx:i,y:u,ey:d,x:l,ex:p,w:n,h:r}}calibrate(e){return new Mee({left:this.left+e.left*this.width,top:this.top+e.top*this.height,right:this.right+e.right*this.width,bottom:this.bottom+e.bottom*this.height}).toSquare().round()}},Oee=class extends Mee{constructor(e,t,n,r,a=!1){super({left:e,top:t,right:n,bottom:r},a)}},Lee=class{constructor(e,t,n,r,a){this._imageDims=new wee(a.width,a.height),this._score=e,this._classScore=t,this._className=n,this._box=new Mee(r).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new Mee(this._box).rescale(this.imageDims.reverse())}forSize(e,t){return new Lee(this.score,this.classScore,this.className,this.relativeBox,{width:e,height:t})}},Pee=class extends Lee{constructor(e,t,n){super(e,e,"",t,n)}forSize(e,t){let{score:n,relativeBox:r,imageDims:a}=super.forSize(e,t);return new Pee(n,r,a)}};function zee(e,t,n=!0){let r=Math.max(0,Math.min(e.right,t.right)-Math.max(e.left,t.left)),a=Math.max(0,Math.min(e.bottom,t.bottom)-Math.max(e.top,t.top)),s=r*a;return n?s/(e.area+t.area-s):s/Math.min(e.area,t.area)}function Bee(e){let t=e.map((e=>e.x)),n=e.map((e=>e.y)),r=t.reduce(((e,t)=>t<e?t:e),1/0),a=n.reduce(((e,t)=>t<e?t:e),1/0),s=t.reduce(((e,t)=>e<t?t:e),0),i=n.reduce(((e,t)=>e<t?t:e),0);return new Oee(r,a,s,i)}function Wee(e,t,n,r=!0){let a=t.map(((e,t)=>({score:e,boxIndex:t}))).sort(((e,t)=>e.score-t.score)).map((e=>e.boxIndex)),s=[];for(;a.length>0;){let t=a.pop();s.push(t);let i=a,o=[];for(let n=0;n<i.length;n++){let a=i[n],s=e[t],l=e[a];o.push(zee(s,l,r))}a=a.filter(((e,t)=>o[t]<=n))}return s}function Vee(e,t){return fl((()=>{let[n,r,a]=t,s=lh([...e.shape.slice(0,3),1],n,"float32"),i=lh([...e.shape.slice(0,3),1],r,"float32"),o=lh([...e.shape.slice(0,3),1],a,"float32"),l=Kp([s,i,o],3);return Kh(e,l)}))}function Uee(e,t=!1){return fl((()=>{let[n,r]=e.shape.slice(1);if(n===r)return e;let a=Math.abs(n-r),s=Math.round(a*(t?.5:1)),i=n>r?2:1,o=t=>{let n=e.shape.slice();return n[i]=t,lh(n,0,"float32")},l=o(s),u=a-l.shape[i],p=[t&&u?o(u):null,e,l].filter((e=>!!e)).map((e=>vo(e,"float32")));return Kp(p,i)}))}function Gee(e){return 1/(1+Math.exp(-e))}var Hee,jee=class extends Mee{constructor(e,t,n,r,a=!1){super({x:e,y:t,width:n,height:r},a)}},qee=.5,Kee=.43,Xee=.45,Yee=class{constructor(e,t,n=new Dee(0,0)){let{width:r,height:a}=t;this._imgDims=new wee(r,a),this._shift=n,this._positions=e.map((e=>e.mul(new Dee(r,a)).add(n)))}get shift(){return new Dee(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map((e=>e.sub(this._shift).div(new Dee(this.imageWidth,this.imageHeight))))}forSize(e,t){return new this.constructor(this.relativePositions,{width:e,height:t})}shiftBy(e,t){return new this.constructor(this.relativePositions,this._imgDims,new Dee(e,t))}shiftByPoint(e){return this.shiftBy(e.x,e.y)}align(e,t={}){if(e){let n=e instanceof Pee?e.box.floor():new Mee(e);return this.shiftBy(n.x,n.y).align(null,t)}let{useDlibAlignment:n,minBoxPadding:r}={useDlibAlignment:!1,minBoxPadding:.2,...t};return n?this.alignDlib():this.alignMinBbox(r)}alignDlib(){let e=this.getRefPointsForAlignment(),[t,n,r]=e,a=e=>r.sub(e).magnitude(),s=(a(t)+a(n))/2,i=Math.floor(s/Xee),o=Aee(e),l=Math.floor(Math.max(0,o.x-qee*i)),u=Math.floor(Math.max(0,o.y-Kee*i));return new jee(l,u,Math.min(i,this.imageWidth+l),Math.min(i,this.imageHeight+u))}alignMinBbox(e){let t=Bee(this.positions);return t.pad(t.width*e,t.height*e)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}},Zee=class extends Yee{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(Aee)}};function Jee(e){return e.detection instanceof Pee}function Qee(e,t){return{...e,detection:t}}function ete(){let e=window.fetch;if(!e)throw new Error("fetch - missing fetch implementation for browser environment");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D:CanvasRenderingContext2D,Image:HTMLImageElement,ImageData:ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),createVideoElement:()=>document.createElement("video"),fetch:e,readFile:()=>{throw new Error("readFile - filesystem not available for browser environment")}}}function tte(){return"object"==typeof n.g&&"undefined"!=typeof process&&null!=process.versions&&null!=process.versions.node}function nte(e){let t="";if(!e&&tte())try{e=d("fs")}catch(n){t=n.toString()}return{readFile:e?t=>new Promise(((n,r)=>{e.readFile(t,((e,t)=>e?r(e):n(t)))})):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${t}`)}}}function rte(){let e=n.g.Canvas||n.g.HTMLCanvasElement,t=n.g.Image||n.g.HTMLImageElement,r=n.g.Video||n.g.HTMLVideoElement,a=()=>{if(e)return new e;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},s=()=>{if(t)return new t;throw new Error("createImageElement - missing Image implementation for nodejs environment")},i=()=>{if(r)return new r;throw new Error("createVideoElement - missing Video implementation for nodejs environment")},o=n.g.fetch,l=nte();return{Canvas:e||class{},CanvasRenderingContext2D:n.g.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:n.g.ImageData||class{},Video:n.g.HTMLVideoElement||class{},createCanvasElement:a,createImageElement:s,createVideoElement:i,fetch:o,...l}}function ate(){return"object"==typeof window&&"undefined"!=typeof document&&"undefined"!=typeof HTMLImageElement&&"undefined"!=typeof HTMLCanvasElement&&"undefined"!=typeof HTMLVideoElement&&"undefined"!=typeof ImageData&&"undefined"!=typeof CanvasRenderingContext2D}function ste(){if(!Hee)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return Hee}function ite(e){Hee=e}function ote(){return ate()?ite(ete()):tte()?ite(rte()):null}function lte(e){if(Hee||ote(),!Hee)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:t=Hee.Canvas,Image:n=Hee.Image}=e;Hee.Canvas=t,Hee.Image=n,Hee.createCanvasElement=e.createCanvasElement||(()=>new t),Hee.createImageElement=e.createImageElement||(()=>new n),Hee.ImageData=e.ImageData||Hee.ImageData,Hee.Video=e.Video||Hee.Video,Hee.fetch=e.fetch||Hee.fetch,Hee.readFile=e.readFile||Hee.readFile}var ute={getEnv:ste,setEnv:ite,initialize:ote,createBrowserEnv:ete,createFileSystem:nte,createNodejsEnv:rte,monkeyPatch:lte,isBrowser:ate,isNodejs:tte};function pte(e){return ute.isNodejs()||"string"!=typeof e?e:document.getElementById(e)}function dte(e){let{Canvas:t,CanvasRenderingContext2D:n}=ute.getEnv();if(e instanceof n)return e;let r=pte(e);if(!(r instanceof t))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let a=r.getContext("2d");if(!a)throw new Error("resolveContext2d - canvas 2d context is null");return a}ote();var cte=(e=>(e.TOP_LEFT="TOP_LEFT",e.TOP_RIGHT="TOP_RIGHT",e.BOTTOM_LEFT="BOTTOM_LEFT",e.BOTTOM_RIGHT="BOTTOM_RIGHT",e))(cte||{}),hte=class{constructor(e={}){let{anchorPosition:t,backgroundColor:n,fontColor:r,fontSize:a,fontStyle:s,padding:i}=e;this.anchorPosition=t||"TOP_LEFT",this.backgroundColor=n||"rgba(0, 0, 0, 0.5)",this.fontColor=r||"rgba(255, 255, 255, 1)",this.fontSize=a||14,this.fontStyle=s||"Georgia",this.padding=i||4}},fte=class{constructor(e,t,n={}){this.text="string"==typeof e?[e]:e instanceof fte?e.text:e,this.anchor=t,this.options=new hte(n)}measureWidth(e){let{padding:t}=this.options;return this.text.map((t=>e.measureText(t).width)).reduce(((e,t)=>e<t?t:e),0)+2*t}measureHeight(){let{fontSize:e,padding:t}=this.options;return this.text.length*e+2*t}getUpperLeft(e,t){let{anchorPosition:n}=this.options,r="BOTTOM_RIGHT"===n||"TOP_RIGHT"===n,a="BOTTOM_LEFT"===n||"BOTTOM_RIGHT"===n,s=this.measureWidth(e),i=this.measureHeight(),o=r?this.anchor.x-s:this.anchor.x,l=a?this.anchor.y-i:this.anchor.y;if(t){let{width:e,height:n}=t,r=Math.max(Math.min(o,e-s),0),a=Math.max(Math.min(l,n-i),0);return{x:r,y:a}}return{x:o,y:l}}draw(e){let t=pte(e),n=dte(t),{backgroundColor:r,fontColor:a,fontSize:s,fontStyle:i,padding:o}=this.options;n.font=`${s}px ${i}`;let l=this.measureWidth(n),u=this.measureHeight();n.fillStyle=r;let p=this.getUpperLeft(n,t);n.fillRect(p.x,p.y,l,u),n.fillStyle=a,this.text.forEach(((e,t)=>{let r=o+p.x,a=o+p.y+(t+1)*s;n.fillText(e,r,a)}))}},mte=class{constructor(e={}){let{boxColor:t,lineWidth:n,label:r,drawLabelOptions:a}=e;this.boxColor=t||"rgba(0, 0, 255, 1)",this.lineWidth=n||2,this.label=r;let s={anchorPosition:"BOTTOM_LEFT",backgroundColor:this.boxColor};this.drawLabelOptions=new hte({...s,...a})}},gte=class{constructor(e,t={}){this.box=new Mee(e),this.options=new mte(t)}draw(e){let t=dte(e),{boxColor:n,lineWidth:r}=this.options,{x:a,y:s,width:i,height:o}=this.box;t.strokeStyle=n,t.lineWidth=r,t.strokeRect(a,s,i,o);let{label:l}=this.options;l&&new fte([l],{x:a-r/2,y:s},this.options.drawLabelOptions).draw(e)}};function yte(e,t){(Array.isArray(t)?t:[t]).forEach((t=>{let n=t instanceof Pee?t.score:Jee(t)?t.detection.score:void 0,r=t instanceof Pee?t.box:Jee(t)?t.detection.box:new Mee(t),a=n?`${Cee(n)}`:void 0;new gte(r,{label:a}).draw(e)}))}function bte(e){let{Image:t,Video:n}=ute.getEnv();return e instanceof t&&e.complete||e instanceof n&&e.readyState>=3}function wte(e){return new Promise(((t,n)=>{function r(e){!e.currentTarget||(e.currentTarget.removeEventListener("load",a),e.currentTarget.removeEventListener("error",r),n(e))}function a(e){!e.currentTarget||(e.currentTarget.removeEventListener("load",a),e.currentTarget.removeEventListener("error",r),t(e))}(e instanceof ute.getEnv().Canvas||bte(e))&&t(null),e.addEventListener("load",a),e.addEventListener("error",r)}))}function xte(e){let{Image:t,Video:n}=ute.getEnv();return e instanceof t?new wee(e.naturalWidth,e.naturalHeight):e instanceof n?new wee(e.videoWidth,e.videoHeight):new wee(e.width,e.height)}function vte({width:e,height:t}){let{createCanvasElement:n}=ute.getEnv(),r=n();return r.width=e,r.height=t,r}function kte(e,t){let{ImageData:n}=ute.getEnv();if(!(e instanceof n)&&!bte(e))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:r,height:a}=t||xte(e),s=vte({width:r,height:a});return e instanceof n?dte(s).putImageData(e,0,0):dte(s).drawImage(e,0,0,r,a),s}async function Ite(e,t){let n=t||ute.getEnv().createCanvasElement(),[r,a,s]=e.shape.slice(See(e)?1:0),i=fl((()=>e.as3D(r,a,s).toInt()));return await Vl.toPixels(i,n),i.dispose(),n}function Ste(e){let{Image:t,Canvas:n,Video:r}=ute.getEnv();return e instanceof t||e instanceof n||e instanceof r}function Nte(e,t,n=!1){let{Image:r,Canvas:a}=ute.getEnv();if(!(e instanceof r||e instanceof a))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");if(t<=0)return vte({width:1,height:1});let s=xte(e),i=t/Math.max(s.height,s.width),o=i*s.width,l=i*s.height,u=vte({width:t,height:t}),p=e instanceof a?e:kte(e),d=Math.abs(o-l)/2,c=n&&o<l?d:0,h=n&&l<o?d:0;return p.width>0&&p.height>0&&dte(u).drawImage(p,c,h,o,l),u}var Tte=class{constructor(e,t=!1){if(this._imageTensors=[],this._canvases=[],this._treatAsBatchInput=!1,this._inputDimensions=[],this._inputSize=0,!Array.isArray(e))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${e}`);this._treatAsBatchInput=t,this._batchSize=e.length,e.forEach(((e,t)=>{if(Iee(e))return this._imageTensors[t]=e,void(this._inputDimensions[t]=e.shape);if(See(e)){let n=e.shape[0];if(1!==n)throw new Error(`NetInput - tf.Tensor4D with batchSize ${n} passed, but not supported in input array`);return this._imageTensors[t]=e,void(this._inputDimensions[t]=e.shape.slice(1))}let n=e instanceof ute.getEnv().Canvas?e:kte(e);this._canvases[t]=n,this._inputDimensions[t]=[n.height,n.width,3]}))}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return $ee(this.batchSize,0,1).map(((e,t)=>this.getReshapedInputDimensions(t)))}getInput(e){return this.canvases[e]||this.imageTensors[e]}getInputDimensions(e){return this._inputDimensions[e]}getInputHeight(e){return this._inputDimensions[e][0]}getInputWidth(e){return this._inputDimensions[e][1]}getReshapedInputDimensions(e){if("number"!=typeof this.inputSize)throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");let t=this.getInputWidth(e),n=this.getInputHeight(e);return Eee({width:t,height:n},this.inputSize)}toBatchTensor(e,t=!0){return this._inputSize=e,fl((()=>{let n=$ee(this.batchSize,0,1).map((n=>{let r=this.getInput(n);if(r instanceof ks){let n=See(r)?r:th(r);return n=Uee(n,t),(n.shape[1]!==e||n.shape[2]!==e)&&(n=bw.resizeBilinear(n,[e,e],!1,!1)),n.as3D(e,e,3)}if(r instanceof ute.getEnv().Canvas)return Vl.fromPixels(Nte(r,e,t));throw new Error(`toBatchTensor - at batchIdx ${n}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${r}`)}));return Ng(n.map((e=>vo(e,"float32")))).as4D(this.batchSize,e,e,3)}))}};async function Cte(e){if(e instanceof Tte)return e;let t=Array.isArray(e)?e:[e];if(!t.length)throw new Error("toNetInput - empty array passed as input");let n=t=>Array.isArray(e)?` at input index ${t}:`:"",r=t.map(pte);return r.forEach(((e,r)=>{if(!Ste(e)&&!Iee(e)&&!See(e))throw"string"==typeof t[r]?new Error(`toNetInput -${n(r)} string passed, but could not resolve HTMLElement for element id ${t[r]}`):new Error(`toNetInput -${n(r)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(See(e)){let t=e.shape[0];if(1!==t)throw new Error(`toNetInput -${n(r)} tf.Tensor4D with batchSize ${t} passed, but not supported in input array`)}})),await Promise.all(r.map((e=>Ste(e)&&wte(e)))),new Tte(r,Array.isArray(e))}async function _te(e,t){let{Canvas:n}=ute.getEnv(),r=e;if(!(e instanceof n)){let t=await Cte(e);if(t.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let a=t.getInput(0);r=a instanceof n?a:await Ite(a)}let a=dte(r);return t.map((e=>e instanceof Pee?e.forSize(r.width,r.height).box.floor():e)).map((e=>e.clipAtImageBorders(r.width,r.height))).map((({x:e,y:t,width:n,height:r})=>{let s=vte({width:n,height:r});return n>0&&r>0&&dte(s).putImageData(a.getImageData(e,t,n,r),0,0),s}))}async function Ete(e,t){if(!Iee(e)&&!See(e))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(See(e)&&e.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return fl((()=>{let[n,r,a]=e.shape.slice(See(e)?1:0);return t.map((e=>e instanceof Pee?e.forSize(r,n).box:e)).map((e=>e.clipAtImageBorders(r,n))).filter((e=>e.width>0&&e.height>0)).map((({x:t,y:s,width:i,height:o})=>sg(e.as3D(n,r,a),[s,t,0],[o,i,a])))}))}async function Ate(e,t){let{fetch:n}=ute.getEnv(),r=await n(e,t);if(!(r.status<400))throw new Error(`failed to fetch: (${r.status}) ${r.statusText}, from url: ${r.url}`);return r}async function $te(e){return(await Ate(e)).json()}function Fte(e,t){let n=`${t}-weights_manifest.json`;if(!e)return{modelBaseUri:"",manifestUri:n};if("/"===e)return{modelBaseUri:"/",manifestUri:`/${n}`};let r=e.startsWith("http://")?"http://":e.startsWith("https://")?"https://":"";e=e.replace(r,"");let a=e.split("/").filter((e=>e)),s=e.endsWith(".json")?a[a.length-1]:n,i=r+(e.endsWith(".json")?a.slice(0,a.length-1):a).join("/");return i=e.startsWith("/")?`/${i}`:i,{modelBaseUri:i,manifestUri:"/"===i?`/${s}`:`${i}/${s}`}}async function Rte(e,t){let{manifestUri:n,modelBaseUri:r}=Fte(e,t),a=await $te(n);return To.loadWeights(a,r)}function Dte(e,t,n=!1){let{width:r,height:a}=n?xte(t):t;return e.width=r,e.height=a,{width:r,height:a}}var Mte=class{constructor(e){this._params=void 0,this._paramMappings=[],this._name=e}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(e){let{obj:t,objProp:n}=this.traversePropertyPath(e);return t[n]}reassignParamFromPath(e,t){let{obj:n,objProp:r}=this.traversePropertyPath(e);n[r].dispose(),n[r]=t}getParamList(){return this._paramMappings.map((({paramPath:e})=>({path:e,tensor:this.getParamFromPath(e)})))}getTrainableParams(){return this.getParamList().filter((e=>e.tensor instanceof Ss))}getFrozenParams(){return this.getParamList().filter((e=>!(e.tensor instanceof Ss)))}variable(){this.getFrozenParams().forEach((({path:e,tensor:t})=>{this.reassignParamFromPath(e,t.variable())}))}freeze(){this.getTrainableParams().forEach((({path:e,tensor:t})=>{let n=pi(t.dataSync());t.dispose(),this.reassignParamFromPath(e,n)}))}dispose(e=!0){this.getParamList().forEach((t=>{if(e&&t.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${t.path}`);t.tensor.dispose()})),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map((({tensor:e})=>Array.from(e.dataSync()))).reduce(((e,t)=>e.concat(t))))}async load(e){e instanceof Float32Array?this.extractWeights(e):await this.loadFromUri(e)}async loadFromUri(e){if(e&&"string"!=typeof e)throw new Error(`${this._name}.loadFromUri - expected model uri`);let t=await Rte(e,this.getDefaultModelName());this.loadFromWeightMap(t)}async loadFromDisk(e){if(e&&"string"!=typeof e)throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:t}=ute.getEnv(),{manifestUri:n,modelBaseUri:r}=Fte(e,this.getDefaultModelName()),a=e=>Promise.all(e.map((e=>t(e).then((e=>e.buffer))))),s=To.weightsLoaderFactory(a),i=JSON.parse((await t(n)).toString()),o=await s(i,r);this.loadFromWeightMap(o)}loadFromWeightMap(e){let{paramMappings:t,params:n}=this.extractParamsFromWeightMap(e);this._paramMappings=t,this._params=n}extractWeights(e){let{paramMappings:t,params:n}=this.extractParams(e);this._paramMappings=t,this._params=n}traversePropertyPath(e){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let t=e.split("/").reduce(((t,n)=>{if(!t.nextObj.hasOwnProperty(n))throw new Error(`traversePropertyPath - object does not have property ${n}, for path ${e}`);return{obj:t.nextObj,objProp:n,nextObj:t.nextObj[n]}}),{nextObj:this.params}),{obj:n,objProp:r}=t;if(!n||!r||!(n[r]instanceof ks))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${e}`);return{obj:n,objProp:r}}};function Ote(e,t,n){return fl((()=>{let r=Hm(e,t.depthwise_filter,t.pointwise_filter,n,"same");return r=Gu(r,t.bias),r}))}function Lte(e,t,n=!1){return fl((()=>{let r=Nm(n?Gu(Rd(e,t.conv0.filters,[2,2],"same"),t.conv0.bias):Ote(e,t.conv0,[2,2])),a=Ote(r,t.conv1,[1,1]),s=Nm(Gu(r,a)),i=Ote(s,t.conv2,[1,1]);return Nm(Gu(r,Gu(a,i)))}))}function Pte(e,t,n=!1,r=!0){return fl((()=>{let a=Nm(n?Gu(Rd(e,t.conv0.filters,r?[2,2]:[1,1],"same"),t.conv0.bias):Ote(e,t.conv0,r?[2,2]:[1,1])),s=Ote(a,t.conv1,[1,1]),i=Nm(Gu(a,s)),o=Ote(i,t.conv2,[1,1]),l=Nm(Gu(a,Gu(s,o))),u=Ote(l,t.conv3,[1,1]);return Nm(Gu(a,Gu(s,Gu(o,u))))}))}function zte(e,t,n="same",r=!1){return fl((()=>{let a=Gu(Rd(e,t.filters,[1,1],n),t.bias);return r?Nm(a):a}))}function Bte(e,t){Object.keys(e).forEach((n=>{t.some((e=>e.originalPath===n))||e[n].dispose()}))}function Wte(e,t){return(n,r,a,s)=>{let i=Dg(e(n*r*a*a),[a,a,n,r]),o=Fg(e(r));return t.push({paramPath:`${s}/filters`},{paramPath:`${s}/bias`}),{filters:i,bias:o}}}function Vte(e,t){return(n,r,a)=>{let s=Rg(e(n*r),[n,r]),i=Fg(e(r));return t.push({paramPath:`${a}/weights`},{paramPath:`${a}/bias`}),{weights:s,bias:i}}}var Ute=class{constructor(e,t,n){this.depthwise_filter=e,this.pointwise_filter=t,this.bias=n}};function Gte(e,t){return(n,r,a)=>{let s=Dg(e(9*n),[3,3,n,1]),i=Dg(e(n*r),[1,1,n,r]),o=Fg(e(r));return t.push({paramPath:`${a}/depthwise_filter`},{paramPath:`${a}/pointwise_filter`},{paramPath:`${a}/bias`}),new Ute(s,i,o)}}function Hte(e){return t=>{let n=e(`${t}/depthwise_filter`,4),r=e(`${t}/pointwise_filter`,4),a=e(`${t}/bias`,1);return new Ute(n,r,a)}}function jte(e,t){return(n,r,a)=>{let s=e[n];if(!xee(s,r))throw new Error(`expected weightMap[${n}] to be a Tensor${r}D, instead have ${s}`);return t.push({originalPath:n,paramPath:a||n}),s}}function qte(e){let t=e;function n(e){let n=t.slice(0,e);return t=t.slice(e),n}function r(){return t}return{extractWeights:n,getRemainingWeights:r}}function Kte(e,t){let n=Wte(e,t),r=Gte(e,t);function a(e,t,a,s=!1){let i=s?n(e,t,3,`${a}/conv0`):r(e,t,`${a}/conv0`),o=r(t,t,`${a}/conv1`),l=r(t,t,`${a}/conv2`);return{conv0:i,conv1:o,conv2:l}}function s(e,t,n,s=!1){let{conv0:i,conv1:o,conv2:l}=a(e,t,n,s),u=r(t,t,`${n}/conv3`);return{conv0:i,conv1:o,conv2:l,conv3:u}}return{extractDenseBlock3Params:a,extractDenseBlock4Params:s}}function Xte(e){let t=[],{extractWeights:n,getRemainingWeights:r}=qte(e),{extractDenseBlock4Params:a}=Kte(n,t),s=a(3,32,"dense0",!0),i=a(32,64,"dense1"),o=a(64,128,"dense2"),l=a(128,256,"dense3");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o,dense3:l}}}function Yte(e){return t=>{let n=e(`${t}/filters`,4),r=e(`${t}/bias`,1);return{filters:n,bias:r}}}function Zte(e,t){let n=jte(e,t),r=Yte(n),a=Hte(n);function s(e,t=!1){let n=t?r(`${e}/conv0`):a(`${e}/conv0`),s=a(`${e}/conv1`),i=a(`${e}/conv2`);return{conv0:n,conv1:s,conv2:i}}function i(e,t=!1){let n=t?r(`${e}/conv0`):a(`${e}/conv0`),s=a(`${e}/conv1`),i=a(`${e}/conv2`),o=a(`${e}/conv3`);return{conv0:n,conv1:s,conv2:i,conv3:o}}return{extractDenseBlock3Params:s,extractDenseBlock4Params:i}}function Jte(e){let t=[],{extractDenseBlock4Params:n}=Zte(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2"),dense3:n("dense3")};return Bte(e,t),{params:r,paramMappings:t}}var Qte=class extends Mte{constructor(){super("FaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceFeatureExtractor - load model before inference");return fl((()=>{let n=vo(e.toBatchTensor(112,!0),"float32"),r=Vee(n,[122.782,117.001,104.298]).div(255),a=Pte(r,t.dense0,!0);return a=Pte(a,t.dense1),a=Pte(a,t.dense2),a=Pte(a,t.dense3),a=Gp(a,[7,7],[2,2],"valid"),a}))}async forward(e){return this.forwardInput(await Cte(e))}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeightMap(e){return Jte(e)}extractParams(e){return Xte(e)}};function ene(e,t){return fl((()=>Gu(rl(e,t.weights),t.bias)))}function tne(e,t,n){let r=[],{extractWeights:a,getRemainingWeights:s}=qte(e),i=Vte(a,r)(t,n,"fc");if(0!==s().length)throw new Error(`weights remaing after extract: ${s().length}`);return{paramMappings:r,params:{fc:i}}}function nne(e){let t=[],n=jte(e,t);function r(e){let t=n(`${e}/weights`,2),r=n(`${e}/bias`,1);return{weights:t,bias:r}}let a={fc:r("fc")};return Bte(e,t),{params:a,paramMappings:t}}function rne(e){let t={},n={};return Object.keys(e).forEach((r=>{let a=r.startsWith("fc")?n:t;a[r]=e[r]})),{featureExtractorMap:t,classifierMap:n}}var ane=class extends Mte{constructor(e,t){super(e),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return fl((()=>{let n=e instanceof Tte?this.faceFeatureExtractor.forwardInput(e):e;return ene(n.as2D(n.shape[0],-1),t.fc)}))}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return tne(e,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=rne(e);return this.faceFeatureExtractor.loadFromWeightMap(t),nne(n)}extractParams(e){let t=this.getClassifierChannelsIn(),n=this.getClassifierChannelsOut(),r=n*t+n,a=e.slice(0,e.length-r),s=e.slice(e.length-r);return this.faceFeatureExtractor.extractWeights(a),this.extractClassifierParams(s)}},sne=["neutral","happy","sad","angry","fearful","disgusted","surprised"],ine=class{constructor(e){if(this.neutral=0,this.happy=0,this.sad=0,this.angry=0,this.fearful=0,this.disgusted=0,this.surprised=0,7!==e.length)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${e.length}`);sne.forEach(((t,n)=>{this[t]=e[n]}))}asSortedArray(){return sne.map((e=>({expression:e,probability:this[e]}))).sort(((e,t)=>t.probability-e.probability))}},one=class extends ane{constructor(e=new Qte){super("FaceExpressionNet",e)}forwardInput(e){return fl((()=>ug(this.runNet(e))))}async forward(e){return this.forwardInput(await Cte(e))}async predictExpressions(e){let t=await Cte(e),n=await this.forwardInput(t),r=await Promise.all(jg(n).map((async e=>{let t=e.dataSync();return e.dispose(),t})));n.dispose();let a=r.map((e=>new ine(e)));return t.isBatchInput?a:a[0]}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}};function lne(e){return e.expressions instanceof ine}function une(e,t){return{...e,expressions:t}}function pne(e,t,n=.1,r){(Array.isArray(t)?t:[t]).forEach((t=>{let a=t instanceof ine?t:lne(t)?t.expressions:void 0;if(!a)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let s=a.asSortedArray().filter((e=>e.probability>n)),i=Jee(t)?t.detection.box.bottomLeft:r||new Dee(0,0);new fte(s.map((e=>`${e.expression} (${Cee(e.probability)})`)),i).draw(e)}))}function dne(e){return Jee(e)&&e.landmarks instanceof Yee&&e.unshiftedLandmarks instanceof Yee&&e.alignedRect instanceof Pee}function cne(e){let t=(e,t,n,r)=>Math.atan2(r-t,n-e)%Math.PI,n={roll:void 0,pitch:void 0,yaw:void 0};if(!e||!e._positions||68!==e._positions.length)return n;let r=e._positions;n.roll=-t(r[36]._x,r[36]._y,r[45]._x,r[45]._y),n.pitch=t(0,Math.abs(r[0]._x-r[30]._x)/r[30]._x,Math.PI,Math.abs(r[16]._x-r[30]._x)/r[30]._x);let a=r.reduce(((e,t)=>e<t._y?e:t._y),1/0),s=r.reduce(((e,t)=>e>t._y?e:t._y),-1/0);return n.yaw=Math.PI*(e._imgDims._height/(s-a)/1.4-1),n}function hne(e,t){let{box:n}=e.detection,r=t.shiftBy(n.x,n.y),a=r.align(),{imageDims:s}=e.detection,i=new Pee(e.detection.score,a.rescale(s.reverse()),s),o=cne(t);return{...e,landmarks:r,unshiftedLandmarks:t,alignedRect:i,angle:o}}var fne=class{constructor(e={}){let{drawLines:t=!0,drawPoints:n=!0,lineWidth:r,lineColor:a,pointSize:s,pointColor:i}=e;this.drawLines=t,this.drawPoints=n,this.lineWidth=r||1,this.pointSize=s||2,this.lineColor=a||"rgba(0, 255, 255, 1)",this.pointColor=i||"rgba(255, 0, 255, 1)"}},mne=class{constructor(e,t={}){this.faceLandmarks=e,this.options=new fne(t)}draw(e){let t=dte(e),{drawLines:n,drawPoints:r,lineWidth:a,lineColor:s,pointSize:i,pointColor:o}=this.options;if(n&&this.faceLandmarks instanceof Zee&&(t.strokeStyle=s,t.lineWidth=a,yee(t,this.faceLandmarks.getJawOutline()),yee(t,this.faceLandmarks.getLeftEyeBrow()),yee(t,this.faceLandmarks.getRightEyeBrow()),yee(t,this.faceLandmarks.getNose()),yee(t,this.faceLandmarks.getLeftEye(),!0),yee(t,this.faceLandmarks.getRightEye(),!0),yee(t,this.faceLandmarks.getMouth(),!0)),r){t.strokeStyle=o,t.fillStyle=o;let e=e=>{t.beginPath(),t.arc(e.x,e.y,i,0,2*Math.PI),t.fill()};this.faceLandmarks.positions.forEach(e)}}};function gne(e,t){(Array.isArray(t)?t:[t]).forEach((t=>{let n=t instanceof Yee?t:dne(t)?t.landmarks:void 0;if(!n)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new mne(n).draw(e)}))}function yne(e,t){let n=Wte(e,t),r=Gte(e,t);function a(e,t,a){let s=r(e,t,`${a}/separable_conv0`),i=r(t,t,`${a}/separable_conv1`),o=n(e,t,1,`${a}/expansion_conv`);return{separable_conv0:s,separable_conv1:i,expansion_conv:o}}function s(e,t){let n=r(e,e,`${t}/separable_conv0`),a=r(e,e,`${t}/separable_conv1`),s=r(e,e,`${t}/separable_conv2`);return{separable_conv0:n,separable_conv1:a,separable_conv2:s}}return{extractConvParams:n,extractSeparableConvParams:r,extractReductionBlockParams:a,extractMainBlockParams:s}}function bne(e,t){let n=[],{extractWeights:r,getRemainingWeights:a}=qte(e),{extractConvParams:s,extractSeparableConvParams:i,extractReductionBlockParams:o,extractMainBlockParams:l}=yne(r,n),u=s(3,32,3,"entry_flow/conv_in"),p=o(32,64,"entry_flow/reduction_block_0"),d=o(64,128,"entry_flow/reduction_block_1"),c={conv_in:u,reduction_block_0:p,reduction_block_1:d},h={};$ee(t,0,1).forEach((e=>{h[`main_block_${e}`]=l(128,`middle_flow/main_block_${e}`)}));let f=o(128,256,"exit_flow/reduction_block"),m=i(256,512,"exit_flow/separable_conv"),g={reduction_block:f,separable_conv:m};if(0!==a().length)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:n,params:{entry_flow:c,middle_flow:h,exit_flow:g}}}function wne(e,t){let n=jte(e,t),r=Yte(n),a=Hte(n);function s(e){let t=a(`${e}/separable_conv0`),n=a(`${e}/separable_conv1`),s=r(`${e}/expansion_conv`);return{separable_conv0:t,separable_conv1:n,expansion_conv:s}}function i(e){let t=a(`${e}/separable_conv0`),n=a(`${e}/separable_conv1`),r=a(`${e}/separable_conv2`);return{separable_conv0:t,separable_conv1:n,separable_conv2:r}}return{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:s,extractMainBlockParams:i}}function xne(e,t){let n=[],{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:s,extractMainBlockParams:i}=wne(e,n),o=r("entry_flow/conv_in"),l=s("entry_flow/reduction_block_0"),u=s("entry_flow/reduction_block_1"),p={conv_in:o,reduction_block_0:l,reduction_block_1:u},d={};$ee(t,0,1).forEach((e=>{d[`main_block_${e}`]=i(`middle_flow/main_block_${e}`)}));let c=s("exit_flow/reduction_block"),h=a("exit_flow/separable_conv"),f={reduction_block:c,separable_conv:h};return Bte(e,n),{params:{entry_flow:p,middle_flow:d,exit_flow:f},paramMappings:n}}function vne(e,t,n){return Gu(Rd(e,t.filters,n,"same"),t.bias)}function kne(e,t,n=!0){let r=n?Nm(e):e;return r=Ote(r,t.separable_conv0,[1,1]),r=Ote(Nm(r),t.separable_conv1,[1,1]),r=hf(r,[3,3],[2,2],"same"),r=Gu(r,vne(e,t.expansion_conv,[2,2])),r}function Ine(e,t){let n=Ote(Nm(e),t.separable_conv0,[1,1]);return n=Ote(Nm(n),t.separable_conv1,[1,1]),n=Ote(Nm(n),t.separable_conv2,[1,1]),n=Gu(n,e),n}var Sne=class extends Mte{constructor(e){super("TinyXception"),this._numMainBlocks=e}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyXception - load model before inference");return fl((()=>{let n=vo(e.toBatchTensor(112,!0),"float32"),r=Vee(n,[122.782,117.001,104.298]).div(255),a=Nm(vne(r,t.entry_flow.conv_in,[2,2]));return a=kne(a,t.entry_flow.reduction_block_0,!1),a=kne(a,t.entry_flow.reduction_block_1),$ee(this._numMainBlocks,0,1).forEach((e=>{a=Ine(a,t.middle_flow[`main_block_${e}`])})),a=kne(a,t.exit_flow.reduction_block),a=Nm(Ote(a,t.exit_flow.separable_conv,[1,1])),a}))}async forward(e){return this.forwardInput(await Cte(e))}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeightMap(e){return xne(e,this._numMainBlocks)}extractParams(e){return bne(e,this._numMainBlocks)}};function Nne(e){let t=[],{extractWeights:n,getRemainingWeights:r}=qte(e),a=Vte(n,t),s=a(512,1,"fc/age"),i=a(512,2,"fc/gender");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{fc:{age:s,gender:i}}}}function Tne(e){let t=[],n=jte(e,t);function r(e){let t=n(`${e}/weights`,2),r=n(`${e}/bias`,1);return{weights:t,bias:r}}let a={fc:{age:r("fc/age"),gender:r("fc/gender")}};return Bte(e,t),{params:a,paramMappings:t}}var Cne=(e=>(e.FEMALE="female",e.MALE="male",e))(Cne||{}),_ne=class extends Mte{constructor(e=new Sne(2)){super("AgeGenderNet"),this._faceFeatureExtractor=e}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return fl((()=>{let n=e instanceof Tte?this.faceFeatureExtractor.forwardInput(e):e,r=Gp(n,[7,7],[2,2],"valid").as2D(n.shape[0],-1),a=ene(r,t.fc.age).as1D(),s=ene(r,t.fc.gender);return{age:a,gender:s}}))}forwardInput(e){return fl((()=>{let{age:t,gender:n}=this.runNet(e);return{age:t,gender:ug(n)}}))}async forward(e){return this.forwardInput(await Cte(e))}async predictAgeAndGender(e){let t=await Cte(e),n=await this.forwardInput(t),r=jg(n.age),a=jg(n.gender),s=r.map(((e,t)=>({ageTensor:e,genderTensor:a[t]}))),i=await Promise.all(s.map((async({ageTensor:e,genderTensor:t})=>{let n=e.dataSync()[0],r=t.dataSync()[0],a=r>.5,s=a?"male":"female",i=a?r:1-r;return e.dispose(),t.dispose(),{age:n,gender:s,genderProbability:i}})));return n.age.dispose(),n.gender.dispose(),t.isBatchInput?i:i[0]}getDefaultModelName(){return"age_gender_model"}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return Nne(e)}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=rne(e);return this.faceFeatureExtractor.loadFromWeightMap(t),Tne(n)}extractParams(e){let t=e.slice(0,e.length-1539),n=e.slice(e.length-1539);return this.faceFeatureExtractor.extractWeights(t),this.extractClassifierParams(n)}},Ene=class extends ane{postProcess(e,t,n){let r=n.map((({width:e,height:n})=>{let r=t/Math.max(n,e);return{width:e*r,height:n*r}})),a=r.length;return fl((()=>{let n=(e,t)=>Ng([lh([68],e,"float32"),lh([68],t,"float32")],1).as2D(1,136).as1D(),s=(e,t)=>{let{width:n,height:a}=r[e];return t(n,a)?Math.abs(n-a)/2:0},i=e=>s(e,((e,t)=>e<t)),o=e=>s(e,((e,t)=>t<e));return e.mul(lh([a,136],t,"float32")).sub(Ng(Array.from(Array(a),((e,t)=>n(i(t),o(t)))))).div(Ng(Array.from(Array(a),((e,t)=>n(r[t].width,r[t].height)))))}))}forwardInput(e){return fl((()=>{let t=this.runNet(e);return this.postProcess(t,e.inputSize,e.inputDimensions.map((([e,t])=>({height:e,width:t}))))}))}async forward(e){return this.forwardInput(await Cte(e))}async detectLandmarks(e){let t=await Cte(e),n=fl((()=>jg(this.forwardInput(t)))),r=await Promise.all(n.map((async(e,n)=>{let r=Array.from(e.dataSync()),a=r.filter(((e,t)=>Tee(t))),s=r.filter(((e,t)=>!Tee(t)));return new Zee(Array(68).fill(0).map(((e,t)=>new Dee(a[t],s[t]))),{height:t.getInputHeight(n),width:t.getInputWidth(n)})})));return n.forEach((e=>e.dispose())),t.isBatchInput?r:r[0]}getClassifierChannelsOut(){return 136}},Ane=class extends Ene{constructor(e=new Qte){super("FaceLandmark68Net",e)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}};function $ne(e){let t=[],{extractDenseBlock3Params:n}=Zte(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2")};return Bte(e,t),{params:r,paramMappings:t}}function Fne(e){let t=[],{extractWeights:n,getRemainingWeights:r}=qte(e),{extractDenseBlock3Params:a}=Kte(n,t),s=a(3,32,"dense0",!0),i=a(32,64,"dense1"),o=a(64,128,"dense2");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o}}}var Rne=class extends Mte{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyFaceFeatureExtractor - load model before inference");return fl((()=>{let n=vo(e.toBatchTensor(112,!0),"float32"),r=Vee(n,[122.782,117.001,104.298]).div(255),a=Lte(r,t.dense0,!0);return a=Lte(a,t.dense1),a=Lte(a,t.dense2),a=Gp(a,[14,14],[2,2],"valid"),a}))}async forward(e){return this.forwardInput(await Cte(e))}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeightMap(e){return $ne(e)}extractParams(e){return Fne(e)}},Dne=class extends Ene{constructor(e=new Rne){super("FaceLandmark68TinyNet",e)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}};function Mne(e,t){return Gu(Yu(e,t.weights),t.biases)}function One(e,t,n,r,a="same"){let{filters:s,bias:i}=t.conv,o=Rd(e,s,n,a);return o=Gu(o,i),o=Mne(o,t.scale),r?Nm(o):o}function Lne(e,t){return One(e,t,[1,1],!0)}function Pne(e,t){return One(e,t,[1,1],!1)}function zne(e,t){return One(e,t,[2,2],!0,"valid")}function Bne(e,t){function n(t,n,r){let a=e(t),s=a.length/(n*r*r);if(Nee(s))throw new Error(`depth has to be an integer: ${s}, weights.length: ${a.length}, numFilters: ${n}, filterSize: ${r}`);return fl((()=>Dl(Dg(a,[n,s,r,r]),[2,3,1,0])))}function r(r,a,s,i){let o=n(r,a,s),l=Fg(e(a));return t.push({paramPath:`${i}/filters`},{paramPath:`${i}/bias`}),{filters:o,bias:l}}function a(n,r){let a=Fg(e(n)),s=Fg(e(n));return t.push({paramPath:`${r}/weights`},{paramPath:`${r}/biases`}),{weights:a,biases:s}}function s(e,t,n,s){let i=r(e,t,n,`${s}/conv`),o=a(t,`${s}/scale`);return{conv:i,scale:o}}function i(e,t,n,r,a=!1){let i=s((a?.5:1)*e,t,n,`${r}/conv1`),o=s(e,t,n,`${r}/conv2`);return{conv1:i,conv2:o}}return{extractConvLayerParams:s,extractResidualLayerParams:i}}function Wne(e){let{extractWeights:t,getRemainingWeights:n}=qte(e),r=[],{extractConvLayerParams:a,extractResidualLayerParams:s}=Bne(t,r),i=a(4704,32,7,"conv32_down"),o=s(9216,32,3,"conv32_1"),l=s(9216,32,3,"conv32_2"),u=s(9216,32,3,"conv32_3"),p=s(36864,64,3,"conv64_down",!0),d=s(36864,64,3,"conv64_1"),c=s(36864,64,3,"conv64_2"),h=s(36864,64,3,"conv64_3"),f=s(147456,128,3,"conv128_down",!0),m=s(147456,128,3,"conv128_1"),g=s(147456,128,3,"conv128_2"),y=s(589824,256,3,"conv256_down",!0),b=s(589824,256,3,"conv256_1"),w=s(589824,256,3,"conv256_2"),x=s(589824,256,3,"conv256_down_out"),v=fl((()=>Dl(Rg(t(32768),[128,256]),[1,0])));if(r.push({paramPath:"fc"}),0!==n().length)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{conv32_down:i,conv32_1:o,conv32_2:l,conv32_3:u,conv64_down:p,conv64_1:d,conv64_2:c,conv64_3:h,conv128_down:f,conv128_1:m,conv128_2:g,conv256_down:y,conv256_1:b,conv256_2:w,conv256_down_out:x,fc:v},paramMappings:r}}function Vne(e,t){let n=jte(e,t);function r(e){let t=n(`${e}/scale/weights`,1),r=n(`${e}/scale/biases`,1);return{weights:t,biases:r}}function a(e){let t=n(`${e}/conv/filters`,4),a=n(`${e}/conv/bias`,1),s=r(e);return{conv:{filters:t,bias:a},scale:s}}function s(e){return{conv1:a(`${e}/conv1`),conv2:a(`${e}/conv2`)}}return{extractConvLayerParams:a,extractResidualLayerParams:s}}function Une(e){let t=[],{extractConvLayerParams:n,extractResidualLayerParams:r}=Vne(e,t),a=n("conv32_down"),s=r("conv32_1"),i=r("conv32_2"),o=r("conv32_3"),l=r("conv64_down"),u=r("conv64_1"),p=r("conv64_2"),d=r("conv64_3"),c=r("conv128_down"),h=r("conv128_1"),f=r("conv128_2"),m=r("conv256_down"),g=r("conv256_1"),y=r("conv256_2"),b=r("conv256_down_out"),{fc:w}=e;if(t.push({originalPath:"fc",paramPath:"fc"}),!kee(w))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${w}`);let x={conv32_down:a,conv32_1:s,conv32_2:i,conv32_3:o,conv64_down:l,conv64_1:u,conv64_2:p,conv64_3:d,conv128_down:c,conv128_1:h,conv128_2:f,conv256_down:m,conv256_1:g,conv256_2:y,conv256_down_out:b,fc:w};return Bte(e,t),{params:x,paramMappings:t}}function Gne(e,t){let n=Lne(e,t.conv1);return n=Pne(n,t.conv2),n=Gu(n,e),n=Nm(n),n}function Hne(e,t){let n=zne(e,t.conv1);n=Pne(n,t.conv2);let r=Gp(e,2,2,"valid"),a=kf(r.shape),s=r.shape[3]!==n.shape[3];if(r.shape[1]!==n.shape[1]||r.shape[2]!==n.shape[2]){let e=[...n.shape];e[1]=1;let t=kf(e);n=Kp([n,t],1);let r=[...n.shape];r[2]=1;let a=kf(r);n=Kp([n,a],2)}return r=s?Kp([r,a],3):r,n=Gu(r,n),n=Nm(n),n}var jne=class extends Mte{constructor(){super("FaceRecognitionNet")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceRecognitionNet - load model before inference");return fl((()=>{let n=vo(e.toBatchTensor(150,!0),"float32"),r=Vee(n,[122.782,117.001,104.298]).div(255),a=zne(r,t.conv32_down);a=hf(a,3,2,"valid"),a=Gne(a,t.conv32_1),a=Gne(a,t.conv32_2),a=Gne(a,t.conv32_3),a=Hne(a,t.conv64_down),a=Gne(a,t.conv64_1),a=Gne(a,t.conv64_2),a=Gne(a,t.conv64_3),a=Hne(a,t.conv128_down),a=Gne(a,t.conv128_1),a=Gne(a,t.conv128_2),a=Hne(a,t.conv256_down),a=Gne(a,t.conv256_1),a=Gne(a,t.conv256_2),a=Hne(a,t.conv256_down_out);let s=a.mean([1,2]);return rl(s,t.fc)}))}async forward(e){return this.forwardInput(await Cte(e))}async computeFaceDescriptor(e){var t;if(null!=(t=null==e?void 0:e.shape)&&t.some((e=>e<=0)))return new Float32Array(128);let n=await Cte(e),r=fl((()=>jg(this.forwardInput(n)))),a=await Promise.all(r.map((e=>e.data())));return r.forEach((e=>e.dispose())),n.isBatchInput?a:a[0]}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeightMap(e){return Une(e)}extractParams(e){return Wne(e)}};function qne(e,t){return{...e,descriptor:t}}function Kne(e,t){return{...e,age:t}}function Xne(e,t,n){return{...e,gender:t,genderProbability:n}}function Yne(e,t){function n(n,r){let a=Dg(e(9*n),[3,3,n,1]),s=Fg(e(n)),i=Fg(e(n)),o=Fg(e(n)),l=Fg(e(n));return t.push({paramPath:`${r}/filters`},{paramPath:`${r}/batch_norm_scale`},{paramPath:`${r}/batch_norm_offset`},{paramPath:`${r}/batch_norm_mean`},{paramPath:`${r}/batch_norm_variance`}),{filters:a,batch_norm_scale:s,batch_norm_offset:i,batch_norm_mean:o,batch_norm_variance:l}}function r(n,r,a,s,i){let o=Dg(e(n*r*a*a),[a,a,n,r]),l=Fg(e(r));return t.push({paramPath:`${s}/filters`},{paramPath:`${s}/${i?"batch_norm_offset":"bias"}`}),{filters:o,bias:l}}function a(e,t,n,a){let{filters:s,bias:i}=r(e,t,n,a,!0);return{filters:s,batch_norm_offset:i}}function s(e,t,r){let s=n(e,`${r}/depthwise_conv`),i=a(e,t,1,`${r}/pointwise_conv`);return{depthwise_conv:s,pointwise_conv:i}}function i(){let e=a(3,32,3,"mobilenetv1/conv_0"),t=s(32,64,"mobilenetv1/conv_1"),n=s(64,128,"mobilenetv1/conv_2"),r=s(128,128,"mobilenetv1/conv_3"),i=s(128,256,"mobilenetv1/conv_4"),o=s(256,256,"mobilenetv1/conv_5"),l=s(256,512,"mobilenetv1/conv_6"),u=s(512,512,"mobilenetv1/conv_7"),p=s(512,512,"mobilenetv1/conv_8"),d=s(512,512,"mobilenetv1/conv_9"),c=s(512,512,"mobilenetv1/conv_10"),h=s(512,512,"mobilenetv1/conv_11"),f=s(512,1024,"mobilenetv1/conv_12"),m=s(1024,1024,"mobilenetv1/conv_13");return{conv_0:e,conv_1:t,conv_2:n,conv_3:r,conv_4:i,conv_5:o,conv_6:l,conv_7:u,conv_8:p,conv_9:d,conv_10:c,conv_11:h,conv_12:f,conv_13:m}}function o(){let e=a(1024,256,1,"prediction_layer/conv_0"),t=a(256,512,3,"prediction_layer/conv_1"),n=a(512,128,1,"prediction_layer/conv_2"),s=a(128,256,3,"prediction_layer/conv_3"),i=a(256,128,1,"prediction_layer/conv_4"),o=a(128,256,3,"prediction_layer/conv_5"),l=a(256,64,1,"prediction_layer/conv_6"),u=a(64,128,3,"prediction_layer/conv_7"),p=r(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),d=r(512,9,1,"prediction_layer/box_predictor_0/class_predictor"),c=r(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),h=r(1024,18,1,"prediction_layer/box_predictor_1/class_predictor"),f=r(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),m=r(512,18,1,"prediction_layer/box_predictor_2/class_predictor"),g=r(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),y=r(256,18,1,"prediction_layer/box_predictor_3/class_predictor"),b=r(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),w=r(256,18,1,"prediction_layer/box_predictor_4/class_predictor"),x=r(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),v=r(128,18,1,"prediction_layer/box_predictor_5/class_predictor");return{conv_0:e,conv_1:t,conv_2:n,conv_3:s,conv_4:i,conv_5:o,conv_6:l,conv_7:u,box_predictor_0:{box_encoding_predictor:p,class_predictor:d},box_predictor_1:{box_encoding_predictor:c,class_predictor:h},box_predictor_2:{box_encoding_predictor:f,class_predictor:m},box_predictor_3:{box_encoding_predictor:g,class_predictor:y},box_predictor_4:{box_encoding_predictor:b,class_predictor:w},box_predictor_5:{box_encoding_predictor:x,class_predictor:v}}}return{extractMobilenetV1Params:i,extractPredictionLayerParams:o}}function Zne(e){let t=[],{extractWeights:n,getRemainingWeights:r}=qte(e),{extractMobilenetV1Params:a,extractPredictionLayerParams:s}=Yne(n,t),i=a(),o=s(),l={extra_dim:Ul(n(20472),[1,5118,4])};if(t.push({paramPath:"output_layer/extra_dim"}),0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{params:{mobilenetv1:i,prediction_layer:o,output_layer:l},paramMappings:t}}function Jne(e,t){let n=jte(e,t);function r(e,t,r){let a=n(`${e}/Conv2d_${t}_pointwise/weights`,4,`${r}/filters`),s=n(`${e}/Conv2d_${t}_pointwise/convolution_bn_offset`,1,`${r}/batch_norm_offset`);return{filters:a,batch_norm_offset:s}}function a(e){let t=`mobilenetv1/conv_${e}`,a=`MobilenetV1/Conv2d_${e}_depthwise`,s=`${t}/depthwise_conv`,i=`${t}/pointwise_conv`,o=n(`${a}/depthwise_weights`,4,`${s}/filters`),l=n(`${a}/BatchNorm/gamma`,1,`${s}/batch_norm_scale`),u=n(`${a}/BatchNorm/beta`,1,`${s}/batch_norm_offset`),p=n(`${a}/BatchNorm/moving_mean`,1,`${s}/batch_norm_mean`),d=n(`${a}/BatchNorm/moving_variance`,1,`${s}/batch_norm_variance`);return{depthwise_conv:{filters:o,batch_norm_scale:l,batch_norm_offset:u,batch_norm_mean:p,batch_norm_variance:d},pointwise_conv:r("MobilenetV1",e,i)}}function s(){return{conv_0:r("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:a(1),conv_2:a(2),conv_3:a(3),conv_4:a(4),conv_5:a(5),conv_6:a(6),conv_7:a(7),conv_8:a(8),conv_9:a(9),conv_10:a(10),conv_11:a(11),conv_12:a(12),conv_13:a(13)}}function i(e,t){let r=n(`${e}/weights`,4,`${t}/filters`),a=n(`${e}/biases`,1,`${t}/bias`);return{filters:r,bias:a}}function o(e){let t=i(`Prediction/BoxPredictor_${e}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${e}/box_encoding_predictor`),n=i(`Prediction/BoxPredictor_${e}/ClassPredictor`,`prediction_layer/box_predictor_${e}/class_predictor`);return{box_encoding_predictor:t,class_predictor:n}}function l(){return{conv_0:r("Prediction",0,"prediction_layer/conv_0"),conv_1:r("Prediction",1,"prediction_layer/conv_1"),conv_2:r("Prediction",2,"prediction_layer/conv_2"),conv_3:r("Prediction",3,"prediction_layer/conv_3"),conv_4:r("Prediction",4,"prediction_layer/conv_4"),conv_5:r("Prediction",5,"prediction_layer/conv_5"),conv_6:r("Prediction",6,"prediction_layer/conv_6"),conv_7:r("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:o(0),box_predictor_1:o(1),box_predictor_2:o(2),box_predictor_3:o(3),box_predictor_4:o(4),box_predictor_5:o(5)}}return{extractMobilenetV1Params:s,extractPredictionLayerParams:l}}function Qne(e){let t=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:r}=Jne(e,t),a=e["Output/extra_dim"];if(t.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!Iee(a))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${a}`);let s={mobilenetv1:n(),prediction_layer:r(),output_layer:{extra_dim:a}};return Bte(e,t),{params:s,paramMappings:t}}function ere(e,t,n){return fl((()=>{let r=Rd(e,t.filters,n,"same");return r=Gu(r,t.batch_norm_offset),Id(r,0,6)}))}var tre=.0010000000474974513;function nre(e,t,n){return fl((()=>{let r=sc(e,t.filters,n,"same");return r=od(r,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,tre),Id(r,0,6)}))}function rre(e){return[2,4,6,12].some((t=>t===e))?[2,2]:[1,1]}function are(e,t){return fl((()=>{let n,r=ere(e,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach(((e,t)=>{let a=t+1,s=rre(a);r=nre(r,e.depthwise_conv,s),r=ere(r,e.pointwise_conv,[1,1]),11===a&&(n=r)})),null===n)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:r,conv11:n}}))}function sre(e,t,n){let r=e.arraySync(),a=Math.min(r[t][0],r[t][2]),s=Math.min(r[t][1],r[t][3]),i=Math.max(r[t][0],r[t][2]),o=Math.max(r[t][1],r[t][3]),l=Math.min(r[n][0],r[n][2]),u=Math.min(r[n][1],r[n][3]),p=Math.max(r[n][0],r[n][2]),d=Math.max(r[n][1],r[n][3]),c=(i-a)*(o-s),h=(p-l)*(d-u);if(c<=0||h<=0)return 0;let f=Math.max(a,l),m=Math.max(s,u),g=Math.min(i,p),y=Math.min(o,d),b=Math.max(g-f,0)*Math.max(y-m,0);return b/(c+h-b)}function ire(e,t,n,r,a){let s=e.shape[0],i=Math.min(n,s),o=t.map(((e,t)=>({score:e,boxIndex:t}))).filter((e=>e.score>a)).sort(((e,t)=>t.score-e.score)),l=e=>e<=r?1:0,u=[];return o.forEach((t=>{if(u.length>=i)return;let n=t.score;for(let r=u.length-1;r>=0;--r){let n=sre(e,t.boxIndex,u[r]);if(0!==n&&(t.score*=l(n),t.score<=a))break}n===t.score&&u.push(t.boxIndex)})),u}function ore(e){let t=jg(Dl(e,[1,0])),n=[Kh(t[2],t[0]),Kh(t[3],t[1])],r=[Gu(t[0],Ku(n[0],2)),Gu(t[1],Ku(n[1],2))];return{sizes:n,centers:r}}function lre(e,t){let{sizes:n,centers:r}=ore(e),a=jg(Dl(t,[1,0])),s=Ku(Yu(Qc(Ku(a[2],5)),n[0]),2),i=Gu(Yu(Ku(a[0],10),n[0]),r[0]),o=Ku(Yu(Qc(Ku(a[3],5)),n[1]),2),l=Gu(Yu(Ku(a[1],10),n[1]),r[1]);return Dl(Ng([Kh(i,s),Kh(l,o),Gu(i,s),Gu(l,o)]),[1,0])}function ure(e,t,n){return fl((()=>{let r=e.shape[0],a=lre(Vp(sh(n.extra_dim,[r,1,1]),[-1,4]),Vp(e,[-1,4]));a=Vp(a,[r,a.shape[0]/r,4]);let s=Yp(Jp(t,[0,0,1],[-1,-1,-1])),i=Jp(s,[0,0,0],[-1,-1,1]);i=Vp(i,[r,i.shape[1]]);let o=jg(a),l=jg(i);return{boxes:o,scores:l}}))}function pre(e,t){return fl((()=>{let n=e.shape[0],r=Vp(zte(e,t.box_encoding_predictor),[n,-1,1,4]),a=Vp(zte(e,t.class_predictor),[n,-1,3]);return{boxPredictionEncoding:r,classPrediction:a}}))}function dre(e,t,n){return fl((()=>{let r=ere(e,n.conv_0,[1,1]),a=ere(r,n.conv_1,[2,2]),s=ere(a,n.conv_2,[1,1]),i=ere(s,n.conv_3,[2,2]),o=ere(i,n.conv_4,[1,1]),l=ere(o,n.conv_5,[2,2]),u=ere(l,n.conv_6,[1,1]),p=ere(u,n.conv_7,[2,2]),d=pre(t,n.box_predictor_0),c=pre(e,n.box_predictor_1),h=pre(a,n.box_predictor_2),f=pre(i,n.box_predictor_3),m=pre(l,n.box_predictor_4),g=pre(p,n.box_predictor_5),y=Kp([d.boxPredictionEncoding,c.boxPredictionEncoding,h.boxPredictionEncoding,f.boxPredictionEncoding,m.boxPredictionEncoding,g.boxPredictionEncoding],1),b=Kp([d.classPrediction,c.classPrediction,h.classPrediction,f.classPrediction,m.classPrediction,g.classPrediction],1);return{boxPredictions:y,classPredictions:b}}))}var cre=class{constructor({minConfidence:e,maxResults:t}={}){if(this._name="SsdMobilenetv1Options",this._minConfidence=e||.5,this._maxResults=t||100,"number"!=typeof this._minConfidence||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if("number"!=typeof this._maxResults)throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}},hre=class extends Mte{constructor(){super("SsdMobilenetv1")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("SsdMobilenetv1 - load model before inference");return fl((()=>{let n=vo(e.toBatchTensor(512,!1),"float32"),r=Kh(Ku(n,127.5),1),a=are(r,t.mobilenetv1),{boxPredictions:s,classPredictions:i}=dre(a.out,a.conv11,t.prediction_layer);return ure(s,i,t.output_layer)}))}async forward(e){return this.forwardInput(await Cte(e))}async locateFaces(e,t={}){let{maxResults:n,minConfidence:r}=new cre(t),a=await Cte(e),{boxes:s,scores:i}=this.forwardInput(a),o=s[0],l=i[0];for(let y=1;y<s.length;y++)s[y].dispose(),i[y].dispose();let u=Array.from(l.dataSync()),p=ire(o,u,n,.5,r),d=a.getReshapedInputDimensions(0),c=a.inputSize,h=c/d.width,f=c/d.height,m=o.arraySync(),g=p.map((e=>{let[t,n]=[Math.max(0,m[e][0]),Math.min(1,m[e][2])].map((e=>e*f)),[r,s]=[Math.max(0,m[e][1]),Math.min(1,m[e][3])].map((e=>e*h));return new Pee(u[e],new jee(r,t,s-r,n-t),{height:a.getInputHeight(0),width:a.getInputWidth(0)})}));return o.dispose(),l.dispose(),g}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeightMap(e){return Qne(e)}extractParams(e){return Zne(e)}};var fre=.4,mre=[new Dee(.738768,.874946),new Dee(2.42204,2.65704),new Dee(4.30971,7.04493),new Dee(10.246,4.59428),new Dee(12.6868,11.8741)],gre=[new Dee(1.603231,2.094468),new Dee(6.041143,7.080126),new Dee(2.882459,3.518061),new Dee(4.266906,5.178857),new Dee(9.041765,10.66308)],yre=[117.001,114.697,97.404],bre="tiny_yolov2_model",wre="tiny_yolov2_separable_conv_model",xre=e=>"number"==typeof e;function vre(e){if(!e)throw new Error(`invalid config: ${e}`);if("boolean"!=typeof e.withSeparableConvs)throw new Error(`config.withSeparableConvs has to be a boolean, have: ${e.withSeparableConvs}`);if(!xre(e.iouThreshold)||e.iouThreshold<0||e.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${e.iouThreshold}`);if(!Array.isArray(e.classes)||!e.classes.length||!e.classes.every((e=>"string"==typeof e)))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(e.classes)}`);if(!Array.isArray(e.anchors)||!e.anchors.length||!e.anchors.map((e=>e||{})).every((e=>xre(e.x)&&xre(e.y))))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(e.anchors)}`);if(e.meanRgb&&(!Array.isArray(e.meanRgb)||3!==e.meanRgb.length||!e.meanRgb.every(xre)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(e.meanRgb)}`)}function kre(e){return fl((()=>{let t=Yu(e,Bc(.10000000149011612));return Gu(Nm(Kh(e,t)),t)}))}function Ire(e,t){return fl((()=>{let n=Gf(e,[[0,0],[1,1],[1,1],[0,0]]);return n=Rd(n,t.conv.filters,[1,1],"valid"),n=Kh(n,t.bn.sub),n=Yu(n,t.bn.truediv),n=Gu(n,t.conv.bias),kre(n)}))}function Sre(e,t){return fl((()=>{let n=Gf(e,[[0,0],[1,1],[1,1],[0,0]]);return n=Hm(n,t.depthwise_filter,t.pointwise_filter,[1,1],"valid"),n=Gu(n,t.bias),kre(n)}))}function Nre(e,t){let n=Wte(e,t);function r(n,r){let a=Fg(e(n)),s=Fg(e(n));return t.push({paramPath:`${r}/sub`},{paramPath:`${r}/truediv`}),{sub:a,truediv:s}}function a(e,t,a){let s=n(e,t,3,`${a}/conv`),i=r(t,`${a}/bn`);return{conv:s,bn:i}}let s=Gte(e,t);return{extractConvParams:n,extractConvWithBatchNormParams:a,extractSeparableConvParams:s}}function Tre(e,t,n,r){let a,{extractWeights:s,getRemainingWeights:i}=qte(e),o=[],{extractConvParams:l,extractConvWithBatchNormParams:u,extractSeparableConvParams:p}=Nre(s,o);if(t.withSeparableConvs){let[e,s,i,o,u,d,c,h,f]=r,m=t.isFirstLayerConv2d?l(e,s,3,"conv0"):p(e,s,"conv0"),g=p(s,i,"conv1"),y=p(i,o,"conv2"),b=p(o,u,"conv3"),w=p(u,d,"conv4"),x=p(d,c,"conv5"),v=h?p(c,h,"conv6"):void 0,k=f?p(h,f,"conv7"):void 0,I=l(f||h||c,5*n,1,"conv8");a={conv0:m,conv1:g,conv2:y,conv3:b,conv4:w,conv5:x,conv6:v,conv7:k,conv8:I}}else{let[e,t,s,i,o,p,d,c,h]=r,f=u(e,t,"conv0"),m=u(t,s,"conv1"),g=u(s,i,"conv2"),y=u(i,o,"conv3"),b=u(o,p,"conv4"),w=u(p,d,"conv5"),x=u(d,c,"conv6"),v=u(c,h,"conv7"),k=l(h,5*n,1,"conv8");a={conv0:f,conv1:m,conv2:g,conv3:y,conv4:b,conv5:w,conv6:x,conv7:v,conv8:k}}if(0!==i().length)throw new Error(`weights remaing after extract: ${i().length}`);return{params:a,paramMappings:o}}function Cre(e,t){let n=jte(e,t);function r(e){let t=n(`${e}/sub`,1),r=n(`${e}/truediv`,1);return{sub:t,truediv:r}}function a(e){let t=n(`${e}/filters`,4),r=n(`${e}/bias`,1);return{filters:t,bias:r}}function s(e){let t=a(`${e}/conv`),n=r(`${e}/bn`);return{conv:t,bn:n}}let i=Hte(n);return{extractConvParams:a,extractConvWithBatchNormParams:s,extractSeparableConvParams:i}}function _re(e,t){let n,r=[],{extractConvParams:a,extractConvWithBatchNormParams:s,extractSeparableConvParams:i}=Cre(e,r);if(t.withSeparableConvs){let e=t.filterSizes&&t.filterSizes.length||9;n={conv0:t.isFirstLayerConv2d?a("conv0"):i("conv0"),conv1:i("conv1"),conv2:i("conv2"),conv3:i("conv3"),conv4:i("conv4"),conv5:i("conv5"),conv6:e>7?i("conv6"):void 0,conv7:e>8?i("conv7"):void 0,conv8:a("conv8")}}else n={conv0:s("conv0"),conv1:s("conv1"),conv2:s("conv2"),conv3:s("conv3"),conv4:s("conv4"),conv5:s("conv5"),conv6:s("conv6"),conv7:s("conv7"),conv8:a("conv8")};return Bte(e,r),{params:n,paramMappings:r}}var Ere=class{constructor({inputSize:e,scoreThreshold:t}={}){if(this._name="TinyYolov2Options",this._inputSize=e||416,this._scoreThreshold=t||.5,"number"!=typeof this._inputSize||this._inputSize%32!==0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if("number"!=typeof this._scoreThreshold||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}},Are=class extends Mte{constructor(e){super("TinyYolov2"),vre(e),this._config=e}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(e,t){let n=Ire(e,t.conv0);return n=hf(n,[2,2],[2,2],"same"),n=Ire(n,t.conv1),n=hf(n,[2,2],[2,2],"same"),n=Ire(n,t.conv2),n=hf(n,[2,2],[2,2],"same"),n=Ire(n,t.conv3),n=hf(n,[2,2],[2,2],"same"),n=Ire(n,t.conv4),n=hf(n,[2,2],[2,2],"same"),n=Ire(n,t.conv5),n=hf(n,[2,2],[1,1],"same"),n=Ire(n,t.conv6),n=Ire(n,t.conv7),zte(n,t.conv8,"valid",!1)}runMobilenet(e,t){let n=this.config.isFirstLayerConv2d?kre(zte(e,t.conv0,"valid",!1)):Sre(e,t.conv0);return n=hf(n,[2,2],[2,2],"same"),n=Sre(n,t.conv1),n=hf(n,[2,2],[2,2],"same"),n=Sre(n,t.conv2),n=hf(n,[2,2],[2,2],"same"),n=Sre(n,t.conv3),n=hf(n,[2,2],[2,2],"same"),n=Sre(n,t.conv4),n=hf(n,[2,2],[2,2],"same"),n=Sre(n,t.conv5),n=hf(n,[2,2],[1,1],"same"),n=t.conv6?Sre(n,t.conv6):n,n=t.conv7?Sre(n,t.conv7):n,zte(n,t.conv8,"valid",!1)}forwardInput(e,t){let{params:n}=this;if(!n)throw new Error("TinyYolov2 - load model before inference");return fl((()=>{let r=vo(e.toBatchTensor(t,!1),"float32");return r=this.config.meanRgb?Vee(r,this.config.meanRgb):r,r=r.div(255),this.config.withSeparableConvs?this.runMobilenet(r,n):this.runTinyYolov2(r,n)}))}async forward(e,t){return this.forwardInput(await Cte(e),t)}async detect(e,t={}){let{inputSize:n,scoreThreshold:r}=new Ere(t),a=await Cte(e),s=await this.forwardInput(a,n),i=fl((()=>jg(s)[0].expandDims())),o={width:a.getInputWidth(0),height:a.getInputHeight(0)},l=await this.extractBoxes(i,a.getReshapedInputDimensions(0),r);s.dispose(),i.dispose();let u=l.map((e=>e.box)),p=l.map((e=>e.score)),d=l.map((e=>e.classScore)),c=l.map((e=>this.config.classes[e.label]));return Wee(u.map((e=>e.rescale(n))),p,this.config.iouThreshold,!0).map((e=>new Lee(p[e],d[e],c[e],u[e],o)))}getDefaultModelName(){return""}extractParamsFromWeightMap(e){return _re(e,this.config)}extractParams(e){let t=this.config.filterSizes||Are.DEFAULT_FILTER_SIZES,n=t?t.length:void 0;if(7!==n&&8!==n&&9!==n)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${n} filterSizes in config`);return Tre(e,this.config,this.boxEncodingSize,t)}async extractBoxes(e,t,n){let{width:r,height:a}=t,s=Math.max(r,a),i=s/r,o=s/a,l=e.shape[1],u=this.config.anchors.length,[p,d,c]=fl((()=>{let t=e.reshape([l,l,u,this.boxEncodingSize]),n=t.slice([0,0,0,0],[l,l,u,4]),r=t.slice([0,0,0,4],[l,l,u,1]),a=this.withClassScores?ug(t.slice([0,0,0,5],[l,l,u,this.config.classes.length]),3):Bc(0);return[n,r,a]})),h=[],f=await d.array(),m=await p.array();for(let g=0;g<l;g++)for(let e=0;e<l;e++)for(let t=0;t<u;t++){let r=Gee(f[g][e][t][0]);if(!n||r>n){let n=(e+Gee(m[g][e][t][0]))/l*i,a=(g+Gee(m[g][e][t][1]))/l*o,s=Math.exp(m[g][e][t][2])*this.config.anchors[t].x/l*i,u=Math.exp(m[g][e][t][3])*this.config.anchors[t].y/l*o,p=n-s/2,d=a-u/2,f={row:g,col:e,anchor:t},{classScore:y,label:b}=this.withClassScores?await this.extractPredictedClass(c,f):{classScore:1,label:0};h.push({box:new Oee(p,d,p+s,d+u),score:r,classScore:r*y,label:b,...f})}}return p.dispose(),d.dispose(),c.dispose(),h}async extractPredictedClass(e,t){let{row:n,col:r,anchor:a}=t,s=await e.array();return Array(this.config.classes.length).fill(0).map(((e,t)=>s[n][r][a][t])).map(((e,t)=>({classScore:e,label:t}))).reduce(((e,t)=>e.classScore>t.classScore?e:t))}},$re=Are;$re.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var Fre=class extends $re{constructor(e=!0){let t={withSeparableConvs:e,iouThreshold:fre,classes:["face"],...e?{anchors:gre,meanRgb:yre}:{anchors:mre,withClassScores:!0}};super(t)}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map((e=>new Pee(e.score,e.relativeBox,{width:e.imageWidth,height:e.imageHeight})))}getDefaultModelName(){return this.withSeparableConvs?wre:bre}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}};var Rre=class extends Ere{constructor(){super(...arguments),this._name="TinyFaceDetectorOptions"}},Dre=class{async then(e){return e(await this.run())}async run(){throw new Error("ComposableTask - run is not implemented")}};async function Mre(e,t,n,r,a=(({alignedRect:e})=>e)){let s=e.map((e=>dne(e)?a(e):e.detection)),i=r||(t instanceof ks?await Ete(t,s):await _te(t,s)),o=await n(i);return i.forEach((e=>e instanceof ks&&e.dispose())),o}var Ore=.4,Lre=[new Dee(1.603231,2.094468),new Dee(6.041143,7.080126),new Dee(2.882459,3.518061),new Dee(4.266906,5.178857),new Dee(9.041765,10.66308)],Pre=[117.001,114.697,97.404],zre=class extends $re{constructor(){let e={withSeparableConvs:!0,iouThreshold:Ore,classes:["face"],anchors:Lre,meanRgb:Pre,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]};super(e)}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map((e=>new Pee(e.score,e.relativeBox,{width:e.imageWidth,height:e.imageHeight})))}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},Bre={ssdMobilenetv1:new hre,tinyFaceDetector:new zre,tinyYolov2:new Fre,faceLandmark68Net:new Ane,faceLandmark68TinyNet:new Dne,faceRecognitionNet:new jne,faceExpressionNet:new one,ageGenderNet:new _ne},Wre=class extends Dre{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},Vre=class extends Wre{async run(){let e=await this.parentTask,t=await Mre(e,this.input,(async e=>Promise.all(e.map((e=>Bre.faceExpressionNet.predictExpressions(e))))),this.extractedFaces);return e.map(((e,n)=>une(e,t[n])))}withAgeAndGender(){return new Hre(this,this.input)}},Ure=class extends Vre{withAgeAndGender(){return new jre(this,this.input)}withFaceDescriptors(){return new Kre(this,this.input)}},Gre=class extends Dre{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},Hre=class extends Gre{async run(){let e=await this.parentTask,t=await Mre(e,this.input,(async e=>Promise.all(e.map((e=>Bre.ageGenderNet.predictAgeAndGender(e))))),this.extractedFaces);return e.map(((e,n)=>{let{age:r,gender:a,genderProbability:s}=t[n];return Kne(Xne(e,a,s),r)}))}withFaceExpressions(){return new Vre(this,this.input)}},jre=class extends Hre{withFaceExpressions(){return new Ure(this,this.input)}withFaceDescriptors(){return new Kre(this,this.input)}},qre=class extends Dre{constructor(e,t){super(),this.parentTask=e,this.input=t}},Kre=class extends qre{async run(){let e=await this.parentTask;return(await Mre(e,this.input,(e=>Promise.all(e.map((e=>Bre.faceRecognitionNet.computeFaceDescriptor(e))))),null,(e=>e.landmarks.align(null,{useDlibAlignment:!0})))).map(((t,n)=>qne(e[n],t)))}withFaceExpressions(){return new Ure(this,this.input)}withAgeAndGender(){return new jre(this,this.input)}},Xre=class extends Dre{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.useTinyLandmarkNet=n}get landmarkNet(){return this.useTinyLandmarkNet?Bre.faceLandmark68TinyNet:Bre.faceLandmark68Net}},Yre=class extends Xre{async run(){let e=await this.parentTask,t=e.map((e=>e.detection)),n=this.input instanceof ks?await Ete(this.input,t):await _te(this.input,t),r=await Promise.all(n.map((e=>this.landmarkNet.detectLandmarks(e))));return n.forEach((e=>e instanceof ks&&e.dispose())),e.filter(((e,t)=>r[t])).map(((e,t)=>hne(e,r[t])))}withFaceExpressions(){return new Ure(this,this.input)}withAgeAndGender(){return new jre(this,this.input)}withFaceDescriptors(){return new Kre(this,this.input)}},Zre=class extends Dre{constructor(e,t=new cre){super(),this.input=e,this.options=t}},Jre=class extends Zre{async run(){let e,{input:t,options:n}=this;if(n instanceof Rre)e=Bre.tinyFaceDetector.locateFaces(t,n);else if(n instanceof cre)e=Bre.ssdMobilenetv1.locateFaces(t,n);else{if(!(n instanceof Ere))throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options");e=Bre.tinyYolov2.locateFaces(t,n)}return e}runAndExtendWithFaceDetections(){return new Promise(((e,t)=>{this.run().then((t=>e(t.map((e=>Qee({},e)))))).catch((e=>t(e)))}))}withFaceLandmarks(e=!1){return new Yre(this.runAndExtendWithFaceDetections(),this.input,e)}withFaceExpressions(){return new Vre(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new Hre(this.runAndExtendWithFaceDetections(),this.input)}};function Qre(e,t=new cre){return new Jre(e,t)}function eae(e,t){let{width:n,height:r}=new wee(t.width,t.height);if(n<=0||r<=0)throw new Error(`resizeResults - invalid dimensions: ${JSON.stringify({width:n,height:r})}`);if(Array.isArray(e))return e.map((e=>eae(e,{width:n,height:r})));if(dne(e)){let t=e.detection.forSize(n,r),a=e.unshiftedLandmarks.forSize(t.box.width,t.box.height);return hne(Qee(e,t),a)}return Jee(e)?Qee(e,e.detection.forSize(n,r)):e instanceof Yee||e instanceof Pee?e.forSize(n,r):e}var tae=n(2492),nae=n.n(tae),rae={name:"Webcam",data(){return{}},methods:{loadModels(){Promise.all([Bre.tinyFaceDetector.loadFromUri("../models"),Bre.faceLandmark68Net.loadFromUri("../models"),Bre.faceRecognitionNet.loadFromUri("../models"),Bre.faceExpressionNet.loadFromUri("../models")]).then(this.startVideo)},startVideo(){const e={audio:!0,video:{width:720,height:560}};navigator.mediaDevices.getUserMedia(e).then((async function(e){const t=document.getElementById("video");t.srcObject=e,t.onloadedmetadata=function(){t.play()};const r=new Audio(n(2452)),a=new Audio(n(4124)),s=new Audio(n(915)),i=new Audio(n(5958)),o=new Audio(n(3620));t.addEventListener("play",(()=>{const e=kte(t);document.body.append(e);const n={width:t.width,height:t.height};Dte(e,n),setInterval((async()=>{const l=await Qre(t,new Rre).withFaceLandmarks().withFaceExpressions(),u=eae(l,n);if(0!==u.length){const e=u[0].angle,t=u[0].expressions;if(t.surprised>.7){await o.play(),nae().fire({title:"YOU GOT RICK ROLLED",width:600,padding:"3em",timer:26e3,timerProgressBar:!0,color:"#716add",background:"#fff",backdrop:'\n                      rgba(0,0,123,0.4)\n                      url("/images/rickroll.gif")\n                      center\n                      repeat\n                    '})}else o.paused&&(e.roll>.3&&await r.play(),e.roll<-.3&&await a.play(),e.pitch>.3&&e.roll<.3&&await s.play(),e.pitch<-.2&&e.roll>-.2&&await i.play())}e.getContext("2d").clearRect(0,0,e.width,e.height),gee.drawDetections(e,u),gee.drawFaceLandmarks(e,u)}),450)}))}))}},mounted(){this.loadModels()}},aae=n(89);
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
/** @license See the LICENSE file. */const sae=(0,aae.Z)(rae,[["render",o]]);var iae=sae,oae={name:"App",components:{Webcam:iae}};const lae=(0,aae.Z)(oae,[["render",s]]);var uae=lae},4124:function(e,t,n){"use strict";e.exports=n.p+"media/Cymatics - Lofi Clap 3.23af2c3d.wav"},2452:function(e,t,n){"use strict";e.exports=n.p+"media/Cymatics - Lofi Kick 1 - C.37e93bc5.wav"},915:function(e,t,n){"use strict";e.exports=n.p+"media/Cymatics - Lofi Open Hihat 2.ec55a71e.wav"},5958:function(e,t,n){"use strict";e.exports=n.p+"media/Cymatics - Lofi Snare 1 - C.543aee23.wav"},3620:function(e,t,n){"use strict";e.exports=n.p+"media/rickroll.0afb9ffb.wav"}}]);
//# sourceMappingURL=272.714727e7.js.map