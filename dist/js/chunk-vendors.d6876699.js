(self["webpackChunkmusic_face_recognition"]=self["webpackChunkmusic_face_recognition"]||[]).push([[998],{9662:function(e,t,n){var r=n(614),a=n(6330),s=TypeError;e.exports=function(e){if(r(e))return e;throw s(a(e)+" is not a function")}},6077:function(e,t,n){var r=n(614),a=String,s=TypeError;e.exports=function(e){if("object"==typeof e||r(e))return e;throw s("Can't set "+a(e)+" as a prototype")}},1223:function(e,t,n){var r=n(5112),a=n(30),s=n(3070).f,i=r("unscopables"),o=Array.prototype;void 0==o[i]&&s(o,i,{configurable:!0,value:a(null)}),e.exports=function(e){o[i][e]=!0}},5787:function(e,t,n){var r=n(7976),a=TypeError;e.exports=function(e,t){if(r(t,e))return e;throw a("Incorrect invocation")}},9670:function(e,t,n){var r=n(111),a=String,s=TypeError;e.exports=function(e){if(r(e))return e;throw s(a(e)+" is not an object")}},4019:function(e){e.exports="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof DataView},260:function(e,t,n){"use strict";var r,a,s,i=n(4019),o=n(9781),l=n(7854),u=n(614),c=n(111),p=n(2597),d=n(648),h=n(6330),f=n(8880),m=n(8052),g=n(3070).f,y=n(7976),b=n(9518),w=n(7674),x=n(5112),v=n(9711),k=n(9909),I=k.enforce,S=k.get,N=l.Int8Array,T=N&&N.prototype,_=l.Uint8ClampedArray,C=_&&_.prototype,E=N&&b(N),A=T&&b(T),$=Object.prototype,F=l.TypeError,R=x("toStringTag"),D=v("TYPED_ARRAY_TAG"),M="TypedArrayConstructor",O=i&&!!w&&"Opera"!==d(l.opera),L=!1,P={Int8Array:1,Uint8Array:1,Uint8ClampedArray:1,Int16Array:2,Uint16Array:2,Int32Array:4,Uint32Array:4,Float32Array:4,Float64Array:8},z={BigInt64Array:8,BigUint64Array:8},B=function(e){if(!c(e))return!1;var t=d(e);return"DataView"===t||p(P,t)||p(z,t)},W=function(e){var t=b(e);if(c(t)){var n=S(t);return n&&p(n,M)?n[M]:W(t)}},V=function(e){if(!c(e))return!1;var t=d(e);return p(P,t)||p(z,t)},U=function(e){if(V(e))return e;throw F("Target is not a typed array")},G=function(e){if(u(e)&&(!w||y(E,e)))return e;throw F(h(e)+" is not a typed array constructor")},H=function(e,t,n,r){if(o){if(n)for(var a in P){var s=l[a];if(s&&p(s.prototype,e))try{delete s.prototype[e]}catch(i){try{s.prototype[e]=t}catch(u){}}}A[e]&&!n||m(A,e,n?t:O&&T[e]||t,r)}},j=function(e,t,n){var r,a;if(o){if(w){if(n)for(r in P)if(a=l[r],a&&p(a,e))try{delete a[e]}catch(s){}if(E[e]&&!n)return;try{return m(E,e,n?t:O&&E[e]||t)}catch(s){}}for(r in P)a=l[r],!a||a[e]&&!n||m(a,e,t)}};for(r in P)a=l[r],s=a&&a.prototype,s?I(s)[M]=a:O=!1;for(r in z)a=l[r],s=a&&a.prototype,s&&(I(s)[M]=a);if((!O||!u(E)||E===Function.prototype)&&(E=function(){throw F("Incorrect invocation")},O))for(r in P)l[r]&&w(l[r],E);if((!O||!A||A===$)&&(A=E.prototype,O))for(r in P)l[r]&&w(l[r].prototype,A);if(O&&b(C)!==A&&w(C,A),o&&!p(A,R))for(r in L=!0,g(A,R,{get:function(){return c(this)?this[D]:void 0}}),P)l[r]&&f(l[r],D,r);e.exports={NATIVE_ARRAY_BUFFER_VIEWS:O,TYPED_ARRAY_TAG:L&&D,aTypedArray:U,aTypedArrayConstructor:G,exportTypedArrayMethod:H,exportTypedArrayStaticMethod:j,getTypedArrayConstructor:W,isView:B,isTypedArray:V,TypedArray:E,TypedArrayPrototype:A}},1318:function(e,t,n){var r=n(5656),a=n(1400),s=n(6244),i=function(e){return function(t,n,i){var o,l=r(t),u=s(l),c=a(i,u);if(e&&n!=n){while(u>c)if(o=l[c++],o!=o)return!0}else for(;u>c;c++)if((e||c in l)&&l[c]===n)return e||c||0;return!e&&-1}};e.exports={includes:i(!0),indexOf:i(!1)}},9671:function(e,t,n){var r=n(9974),a=n(8361),s=n(7908),i=n(6244),o=function(e){var t=1==e;return function(n,o,l){var u,c,p=s(n),d=a(p),h=r(o,l),f=i(d);while(f-- >0)if(u=d[f],c=h(u,f,p),c)switch(e){case 0:return u;case 1:return f}return t?-1:void 0}};e.exports={findLast:o(0),findLastIndex:o(1)}},206:function(e,t,n){var r=n(1702);e.exports=r([].slice)},4326:function(e,t,n){var r=n(1702),a=r({}.toString),s=r("".slice);e.exports=function(e){return s(a(e),8,-1)}},648:function(e,t,n){var r=n(1694),a=n(614),s=n(4326),i=n(5112),o=i("toStringTag"),l=Object,u="Arguments"==s(function(){return arguments}()),c=function(e,t){try{return e[t]}catch(n){}};e.exports=r?s:function(e){var t,n,r;return void 0===e?"Undefined":null===e?"Null":"string"==typeof(n=c(t=l(e),o))?n:u?s(t):"Object"==(r=s(t))&&a(t.callee)?"Arguments":r}},7741:function(e,t,n){var r=n(1702),a=Error,s=r("".replace),i=function(e){return String(a(e).stack)}("zxcasd"),o=/\n\s*at [^:]*:[^\n]*/,l=o.test(i);e.exports=function(e,t){if(l&&"string"==typeof e&&!a.prepareStackTrace)while(t--)e=s(e,o,"");return e}},9920:function(e,t,n){var r=n(2597),a=n(3887),s=n(1236),i=n(3070);e.exports=function(e,t,n){for(var o=a(t),l=i.f,u=s.f,c=0;c<o.length;c++){var p=o[c];r(e,p)||n&&r(n,p)||l(e,p,u(t,p))}}},8544:function(e,t,n){var r=n(7293);e.exports=!r((function(){function e(){}return e.prototype.constructor=null,Object.getPrototypeOf(new e)!==e.prototype}))},8880:function(e,t,n){var r=n(9781),a=n(3070),s=n(9114);e.exports=r?function(e,t,n){return a.f(e,t,s(1,n))}:function(e,t,n){return e[t]=n,e}},9114:function(e){e.exports=function(e,t){return{enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:t}}},7045:function(e,t,n){var r=n(6339),a=n(3070);e.exports=function(e,t,n){return n.get&&r(n.get,t,{getter:!0}),n.set&&r(n.set,t,{setter:!0}),a.f(e,t,n)}},8052:function(e,t,n){var r=n(614),a=n(3070),s=n(6339),i=n(3072);e.exports=function(e,t,n,o){o||(o={});var l=o.enumerable,u=void 0!==o.name?o.name:t;if(r(n)&&s(n,u,o),o.global)l?e[t]=n:i(t,n);else{try{o.unsafe?e[t]&&(l=!0):delete e[t]}catch(c){}l?e[t]=n:a.f(e,t,{value:n,enumerable:!1,configurable:!o.nonConfigurable,writable:!o.nonWritable})}return e}},3072:function(e,t,n){var r=n(7854),a=Object.defineProperty;e.exports=function(e,t){try{a(r,e,{value:t,configurable:!0,writable:!0})}catch(n){r[e]=t}return t}},9781:function(e,t,n){var r=n(7293);e.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},317:function(e,t,n){var r=n(7854),a=n(111),s=r.document,i=a(s)&&a(s.createElement);e.exports=function(e){return i?s.createElement(e):{}}},3678:function(e){e.exports={IndexSizeError:{s:"INDEX_SIZE_ERR",c:1,m:1},DOMStringSizeError:{s:"DOMSTRING_SIZE_ERR",c:2,m:0},HierarchyRequestError:{s:"HIERARCHY_REQUEST_ERR",c:3,m:1},WrongDocumentError:{s:"WRONG_DOCUMENT_ERR",c:4,m:1},InvalidCharacterError:{s:"INVALID_CHARACTER_ERR",c:5,m:1},NoDataAllowedError:{s:"NO_DATA_ALLOWED_ERR",c:6,m:0},NoModificationAllowedError:{s:"NO_MODIFICATION_ALLOWED_ERR",c:7,m:1},NotFoundError:{s:"NOT_FOUND_ERR",c:8,m:1},NotSupportedError:{s:"NOT_SUPPORTED_ERR",c:9,m:1},InUseAttributeError:{s:"INUSE_ATTRIBUTE_ERR",c:10,m:1},InvalidStateError:{s:"INVALID_STATE_ERR",c:11,m:1},SyntaxError:{s:"SYNTAX_ERR",c:12,m:1},InvalidModificationError:{s:"INVALID_MODIFICATION_ERR",c:13,m:1},NamespaceError:{s:"NAMESPACE_ERR",c:14,m:1},InvalidAccessError:{s:"INVALID_ACCESS_ERR",c:15,m:1},ValidationError:{s:"VALIDATION_ERR",c:16,m:0},TypeMismatchError:{s:"TYPE_MISMATCH_ERR",c:17,m:1},SecurityError:{s:"SECURITY_ERR",c:18,m:1},NetworkError:{s:"NETWORK_ERR",c:19,m:1},AbortError:{s:"ABORT_ERR",c:20,m:1},URLMismatchError:{s:"URL_MISMATCH_ERR",c:21,m:1},QuotaExceededError:{s:"QUOTA_EXCEEDED_ERR",c:22,m:1},TimeoutError:{s:"TIMEOUT_ERR",c:23,m:1},InvalidNodeTypeError:{s:"INVALID_NODE_TYPE_ERR",c:24,m:1},DataCloneError:{s:"DATA_CLONE_ERR",c:25,m:1}}},6833:function(e,t,n){var r=n(8113);e.exports=/(?:ipad|iphone|ipod).*applewebkit/i.test(r)},5268:function(e,t,n){var r=n(4326),a=n(7854);e.exports="process"==r(a.process)},8113:function(e,t,n){var r=n(5005);e.exports=r("navigator","userAgent")||""},7392:function(e,t,n){var r,a,s=n(7854),i=n(8113),o=s.process,l=s.Deno,u=o&&o.versions||l&&l.version,c=u&&u.v8;c&&(r=c.split("."),a=r[0]>0&&r[0]<4?1:+(r[0]+r[1])),!a&&i&&(r=i.match(/Edge\/(\d+)/),(!r||r[1]>=74)&&(r=i.match(/Chrome\/(\d+)/),r&&(a=+r[1]))),e.exports=a},748:function(e){e.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},2914:function(e,t,n){var r=n(7293),a=n(9114);e.exports=!r((function(){var e=Error("a");return!("stack"in e)||(Object.defineProperty(e,"stack",a(1,7)),7!==e.stack)}))},2109:function(e,t,n){var r=n(7854),a=n(1236).f,s=n(8880),i=n(8052),o=n(3072),l=n(9920),u=n(4705);e.exports=function(e,t){var n,c,p,d,h,f,m=e.target,g=e.global,y=e.stat;if(c=g?r:y?r[m]||o(m,{}):(r[m]||{}).prototype,c)for(p in t){if(h=t[p],e.dontCallGetSet?(f=a(c,p),d=f&&f.value):d=c[p],n=u(g?p:m+(y?".":"#")+p,e.forced),!n&&void 0!==d){if(typeof h==typeof d)continue;l(h,d)}(e.sham||d&&d.sham)&&s(h,"sham",!0),i(c,p,h,e)}}},7293:function(e){e.exports=function(e){try{return!!e()}catch(t){return!0}}},2104:function(e,t,n){var r=n(4374),a=Function.prototype,s=a.apply,i=a.call;e.exports="object"==typeof Reflect&&Reflect.apply||(r?i.bind(s):function(){return i.apply(s,arguments)})},9974:function(e,t,n){var r=n(1702),a=n(9662),s=n(4374),i=r(r.bind);e.exports=function(e,t){return a(e),void 0===t?e:s?i(e,t):function(){return e.apply(t,arguments)}}},4374:function(e,t,n){var r=n(7293);e.exports=!r((function(){var e=function(){}.bind();return"function"!=typeof e||e.hasOwnProperty("prototype")}))},6916:function(e,t,n){var r=n(4374),a=Function.prototype.call;e.exports=r?a.bind(a):function(){return a.apply(a,arguments)}},6530:function(e,t,n){var r=n(9781),a=n(2597),s=Function.prototype,i=r&&Object.getOwnPropertyDescriptor,o=a(s,"name"),l=o&&"something"===function(){}.name,u=o&&(!r||r&&i(s,"name").configurable);e.exports={EXISTS:o,PROPER:l,CONFIGURABLE:u}},1702:function(e,t,n){var r=n(4374),a=Function.prototype,s=a.bind,i=a.call,o=r&&s.bind(i,i);e.exports=r?function(e){return e&&o(e)}:function(e){return e&&function(){return i.apply(e,arguments)}}},5005:function(e,t,n){var r=n(7854),a=n(614),s=function(e){return a(e)?e:void 0};e.exports=function(e,t){return arguments.length<2?s(r[e]):r[e]&&r[e][t]}},8173:function(e,t,n){var r=n(9662);e.exports=function(e,t){var n=e[t];return null==n?void 0:r(n)}},7854:function(e,t,n){var r=function(e){return e&&e.Math==Math&&e};e.exports=r("object"==typeof globalThis&&globalThis)||r("object"==typeof window&&window)||r("object"==typeof self&&self)||r("object"==typeof n.g&&n.g)||function(){return this}()||Function("return this")()},2597:function(e,t,n){var r=n(1702),a=n(7908),s=r({}.hasOwnProperty);e.exports=Object.hasOwn||function(e,t){return s(a(e),t)}},3501:function(e){e.exports={}},490:function(e,t,n){var r=n(5005);e.exports=r("document","documentElement")},4664:function(e,t,n){var r=n(9781),a=n(7293),s=n(317);e.exports=!r&&!a((function(){return 7!=Object.defineProperty(s("div"),"a",{get:function(){return 7}}).a}))},8361:function(e,t,n){var r=n(1702),a=n(7293),s=n(4326),i=Object,o=r("".split);e.exports=a((function(){return!i("z").propertyIsEnumerable(0)}))?function(e){return"String"==s(e)?o(e,""):i(e)}:i},9587:function(e,t,n){var r=n(614),a=n(111),s=n(7674);e.exports=function(e,t,n){var i,o;return s&&r(i=t.constructor)&&i!==n&&a(o=i.prototype)&&o!==n.prototype&&s(e,o),e}},2788:function(e,t,n){var r=n(1702),a=n(614),s=n(5465),i=r(Function.toString);a(s.inspectSource)||(s.inspectSource=function(e){return i(e)}),e.exports=s.inspectSource},8340:function(e,t,n){var r=n(111),a=n(8880);e.exports=function(e,t){r(t)&&"cause"in t&&a(e,"cause",t.cause)}},9909:function(e,t,n){var r,a,s,i=n(8536),o=n(7854),l=n(1702),u=n(111),c=n(8880),p=n(2597),d=n(5465),h=n(6200),f=n(3501),m="Object already initialized",g=o.TypeError,y=o.WeakMap,b=function(e){return s(e)?a(e):r(e,{})},w=function(e){return function(t){var n;if(!u(t)||(n=a(t)).type!==e)throw g("Incompatible receiver, "+e+" required");return n}};if(i||d.state){var x=d.state||(d.state=new y),v=l(x.get),k=l(x.has),I=l(x.set);r=function(e,t){if(k(x,e))throw new g(m);return t.facade=e,I(x,e,t),t},a=function(e){return v(x,e)||{}},s=function(e){return k(x,e)}}else{var S=h("state");f[S]=!0,r=function(e,t){if(p(e,S))throw new g(m);return t.facade=e,c(e,S,t),t},a=function(e){return p(e,S)?e[S]:{}},s=function(e){return p(e,S)}}e.exports={set:r,get:a,has:s,enforce:b,getterFor:w}},614:function(e){e.exports=function(e){return"function"==typeof e}},4705:function(e,t,n){var r=n(7293),a=n(614),s=/#|\.prototype\./,i=function(e,t){var n=l[o(e)];return n==c||n!=u&&(a(t)?r(t):!!t)},o=i.normalize=function(e){return String(e).replace(s,".").toLowerCase()},l=i.data={},u=i.NATIVE="N",c=i.POLYFILL="P";e.exports=i},111:function(e,t,n){var r=n(614);e.exports=function(e){return"object"==typeof e?null!==e:r(e)}},1913:function(e){e.exports=!1},2190:function(e,t,n){var r=n(5005),a=n(614),s=n(7976),i=n(3307),o=Object;e.exports=i?function(e){return"symbol"==typeof e}:function(e){var t=r("Symbol");return a(t)&&s(t.prototype,o(e))}},6244:function(e,t,n){var r=n(7466);e.exports=function(e){return r(e.length)}},6339:function(e,t,n){var r=n(7293),a=n(614),s=n(2597),i=n(9781),o=n(6530).CONFIGURABLE,l=n(2788),u=n(9909),c=u.enforce,p=u.get,d=Object.defineProperty,h=i&&!r((function(){return 8!==d((function(){}),"length",{value:8}).length})),f=String(String).split("String"),m=e.exports=function(e,t,n){"Symbol("===String(t).slice(0,7)&&(t="["+String(t).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),n&&n.getter&&(t="get "+t),n&&n.setter&&(t="set "+t),(!s(e,"name")||o&&e.name!==t)&&(i?d(e,"name",{value:t,configurable:!0}):e.name=t),h&&n&&s(n,"arity")&&e.length!==n.arity&&d(e,"length",{value:n.arity});try{n&&s(n,"constructor")&&n.constructor?i&&d(e,"prototype",{writable:!1}):e.prototype&&(e.prototype=void 0)}catch(a){}var r=c(e);return s(r,"source")||(r.source=f.join("string"==typeof t?t:"")),e};Function.prototype.toString=m((function(){return a(this)&&p(this).source||l(this)}),"toString")},4758:function(e){var t=Math.ceil,n=Math.floor;e.exports=Math.trunc||function(e){var r=+e;return(r>0?n:t)(r)}},133:function(e,t,n){var r=n(7392),a=n(7293);e.exports=!!Object.getOwnPropertySymbols&&!a((function(){var e=Symbol();return!String(e)||!(Object(e)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},8536:function(e,t,n){var r=n(7854),a=n(614),s=n(2788),i=r.WeakMap;e.exports=a(i)&&/native code/.test(s(i))},6277:function(e,t,n){var r=n(1340);e.exports=function(e,t){return void 0===e?arguments.length<2?"":t:r(e)}},30:function(e,t,n){var r,a=n(9670),s=n(6048),i=n(748),o=n(3501),l=n(490),u=n(317),c=n(6200),p=">",d="<",h="prototype",f="script",m=c("IE_PROTO"),g=function(){},y=function(e){return d+f+p+e+d+"/"+f+p},b=function(e){e.write(y("")),e.close();var t=e.parentWindow.Object;return e=null,t},w=function(){var e,t=u("iframe"),n="java"+f+":";return t.style.display="none",l.appendChild(t),t.src=String(n),e=t.contentWindow.document,e.open(),e.write(y("document.F=Object")),e.close(),e.F},x=function(){try{r=new ActiveXObject("htmlfile")}catch(t){}x="undefined"!=typeof document?document.domain&&r?b(r):w():b(r);var e=i.length;while(e--)delete x[h][i[e]];return x()};o[m]=!0,e.exports=Object.create||function(e,t){var n;return null!==e?(g[h]=a(e),n=new g,g[h]=null,n[m]=e):n=x(),void 0===t?n:s.f(n,t)}},6048:function(e,t,n){var r=n(9781),a=n(3353),s=n(3070),i=n(9670),o=n(5656),l=n(1956);t.f=r&&!a?Object.defineProperties:function(e,t){i(e);var n,r=o(t),a=l(t),u=a.length,c=0;while(u>c)s.f(e,n=a[c++],r[n]);return e}},3070:function(e,t,n){var r=n(9781),a=n(4664),s=n(3353),i=n(9670),o=n(4948),l=TypeError,u=Object.defineProperty,c=Object.getOwnPropertyDescriptor,p="enumerable",d="configurable",h="writable";t.f=r?s?function(e,t,n){if(i(e),t=o(t),i(n),"function"===typeof e&&"prototype"===t&&"value"in n&&h in n&&!n[h]){var r=c(e,t);r&&r[h]&&(e[t]=n.value,n={configurable:d in n?n[d]:r[d],enumerable:p in n?n[p]:r[p],writable:!1})}return u(e,t,n)}:u:function(e,t,n){if(i(e),t=o(t),i(n),a)try{return u(e,t,n)}catch(r){}if("get"in n||"set"in n)throw l("Accessors not supported");return"value"in n&&(e[t]=n.value),e}},1236:function(e,t,n){var r=n(9781),a=n(6916),s=n(5296),i=n(9114),o=n(5656),l=n(4948),u=n(2597),c=n(4664),p=Object.getOwnPropertyDescriptor;t.f=r?p:function(e,t){if(e=o(e),t=l(t),c)try{return p(e,t)}catch(n){}if(u(e,t))return i(!a(s.f,e,t),e[t])}},8006:function(e,t,n){var r=n(6324),a=n(748),s=a.concat("length","prototype");t.f=Object.getOwnPropertyNames||function(e){return r(e,s)}},5181:function(e,t){t.f=Object.getOwnPropertySymbols},9518:function(e,t,n){var r=n(2597),a=n(614),s=n(7908),i=n(6200),o=n(8544),l=i("IE_PROTO"),u=Object,c=u.prototype;e.exports=o?u.getPrototypeOf:function(e){var t=s(e);if(r(t,l))return t[l];var n=t.constructor;return a(n)&&t instanceof n?n.prototype:t instanceof u?c:null}},7976:function(e,t,n){var r=n(1702);e.exports=r({}.isPrototypeOf)},6324:function(e,t,n){var r=n(1702),a=n(2597),s=n(5656),i=n(1318).indexOf,o=n(3501),l=r([].push);e.exports=function(e,t){var n,r=s(e),u=0,c=[];for(n in r)!a(o,n)&&a(r,n)&&l(c,n);while(t.length>u)a(r,n=t[u++])&&(~i(c,n)||l(c,n));return c}},1956:function(e,t,n){var r=n(6324),a=n(748);e.exports=Object.keys||function(e){return r(e,a)}},5296:function(e,t){"use strict";var n={}.propertyIsEnumerable,r=Object.getOwnPropertyDescriptor,a=r&&!n.call({1:2},1);t.f=a?function(e){var t=r(this,e);return!!t&&t.enumerable}:n},7674:function(e,t,n){var r=n(1702),a=n(9670),s=n(6077);e.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var e,t=!1,n={};try{e=r(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set),e(n,[]),t=n instanceof Array}catch(i){}return function(n,r){return a(n),s(r),t?e(n,r):n.__proto__=r,n}}():void 0)},2140:function(e,t,n){var r=n(6916),a=n(614),s=n(111),i=TypeError;e.exports=function(e,t){var n,o;if("string"===t&&a(n=e.toString)&&!s(o=r(n,e)))return o;if(a(n=e.valueOf)&&!s(o=r(n,e)))return o;if("string"!==t&&a(n=e.toString)&&!s(o=r(n,e)))return o;throw i("Can't convert object to primitive value")}},3887:function(e,t,n){var r=n(5005),a=n(1702),s=n(8006),i=n(5181),o=n(9670),l=a([].concat);e.exports=r("Reflect","ownKeys")||function(e){var t=s.f(o(e)),n=i.f;return n?l(t,n(e)):t}},2626:function(e,t,n){var r=n(3070).f;e.exports=function(e,t,n){n in e||r(e,n,{configurable:!0,get:function(){return t[n]},set:function(e){t[n]=e}})}},7066:function(e,t,n){"use strict";var r=n(9670);e.exports=function(){var e=r(this),t="";return e.hasIndices&&(t+="d"),e.global&&(t+="g"),e.ignoreCase&&(t+="i"),e.multiline&&(t+="m"),e.dotAll&&(t+="s"),e.unicode&&(t+="u"),e.unicodeSets&&(t+="v"),e.sticky&&(t+="y"),t}},4488:function(e){var t=TypeError;e.exports=function(e){if(void 0==e)throw t("Can't call method on "+e);return e}},6200:function(e,t,n){var r=n(2309),a=n(9711),s=r("keys");e.exports=function(e){return s[e]||(s[e]=a(e))}},5465:function(e,t,n){var r=n(7854),a=n(3072),s="__core-js_shared__",i=r[s]||a(s,{});e.exports=i},2309:function(e,t,n){var r=n(1913),a=n(5465);(e.exports=function(e,t){return a[e]||(a[e]=void 0!==t?t:{})})("versions",[]).push({version:"3.23.3",mode:r?"pure":"global",copyright:"Â© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE",source:"https://github.com/zloirock/core-js"})},261:function(e,t,n){var r,a,s,i,o=n(7854),l=n(2104),u=n(9974),c=n(614),p=n(2597),d=n(7293),h=n(490),f=n(206),m=n(317),g=n(8053),y=n(6833),b=n(5268),w=o.setImmediate,x=o.clearImmediate,v=o.process,k=o.Dispatch,I=o.Function,S=o.MessageChannel,N=o.String,T=0,_={},C="onreadystatechange";try{r=o.location}catch(R){}var E=function(e){if(p(_,e)){var t=_[e];delete _[e],t()}},A=function(e){return function(){E(e)}},$=function(e){E(e.data)},F=function(e){o.postMessage(N(e),r.protocol+"//"+r.host)};w&&x||(w=function(e){g(arguments.length,1);var t=c(e)?e:I(e),n=f(arguments,1);return _[++T]=function(){l(t,void 0,n)},a(T),T},x=function(e){delete _[e]},b?a=function(e){v.nextTick(A(e))}:k&&k.now?a=function(e){k.now(A(e))}:S&&!y?(s=new S,i=s.port2,s.port1.onmessage=$,a=u(i.postMessage,i)):o.addEventListener&&c(o.postMessage)&&!o.importScripts&&r&&"file:"!==r.protocol&&!d(F)?(a=F,o.addEventListener("message",$,!1)):a=C in m("script")?function(e){h.appendChild(m("script"))[C]=function(){h.removeChild(this),E(e)}}:function(e){setTimeout(A(e),0)}),e.exports={set:w,clear:x}},1400:function(e,t,n){var r=n(9303),a=Math.max,s=Math.min;e.exports=function(e,t){var n=r(e);return n<0?a(n+t,0):s(n,t)}},5656:function(e,t,n){var r=n(8361),a=n(4488);e.exports=function(e){return r(a(e))}},9303:function(e,t,n){var r=n(4758);e.exports=function(e){var t=+e;return t!==t||0===t?0:r(t)}},7466:function(e,t,n){var r=n(9303),a=Math.min;e.exports=function(e){return e>0?a(r(e),9007199254740991):0}},7908:function(e,t,n){var r=n(4488),a=Object;e.exports=function(e){return a(r(e))}},4590:function(e,t,n){var r=n(3002),a=RangeError;e.exports=function(e,t){var n=r(e);if(n%t)throw a("Wrong offset");return n}},3002:function(e,t,n){var r=n(9303),a=RangeError;e.exports=function(e){var t=r(e);if(t<0)throw a("The argument can't be less than 0");return t}},7593:function(e,t,n){var r=n(6916),a=n(111),s=n(2190),i=n(8173),o=n(2140),l=n(5112),u=TypeError,c=l("toPrimitive");e.exports=function(e,t){if(!a(e)||s(e))return e;var n,l=i(e,c);if(l){if(void 0===t&&(t="default"),n=r(l,e,t),!a(n)||s(n))return n;throw u("Can't convert object to primitive value")}return void 0===t&&(t="number"),o(e,t)}},4948:function(e,t,n){var r=n(7593),a=n(2190);e.exports=function(e){var t=r(e,"string");return a(t)?t:t+""}},1694:function(e,t,n){var r=n(5112),a=r("toStringTag"),s={};s[a]="z",e.exports="[object z]"===String(s)},1340:function(e,t,n){var r=n(648),a=String;e.exports=function(e){if("Symbol"===r(e))throw TypeError("Cannot convert a Symbol value to a string");return a(e)}},6330:function(e){var t=String;e.exports=function(e){try{return t(e)}catch(n){return"Object"}}},9711:function(e,t,n){var r=n(1702),a=0,s=Math.random(),i=r(1..toString);e.exports=function(e){return"Symbol("+(void 0===e?"":e)+")_"+i(++a+s,36)}},3307:function(e,t,n){var r=n(133);e.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},3353:function(e,t,n){var r=n(9781),a=n(7293);e.exports=r&&a((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},8053:function(e){var t=TypeError;e.exports=function(e,n){if(e<n)throw t("Not enough arguments");return e}},5112:function(e,t,n){var r=n(7854),a=n(2309),s=n(2597),i=n(9711),o=n(133),l=n(3307),u=a("wks"),c=r.Symbol,p=c&&c["for"],d=l?c:c&&c.withoutSetter||i;e.exports=function(e){if(!s(u,e)||!o&&"string"!=typeof u[e]){var t="Symbol."+e;o&&s(c,e)?u[e]=c[e]:u[e]=l&&p?p(t):d(t)}return u[e]}},9191:function(e,t,n){"use strict";var r=n(5005),a=n(2597),s=n(8880),i=n(7976),o=n(7674),l=n(9920),u=n(2626),c=n(9587),p=n(6277),d=n(8340),h=n(7741),f=n(2914),m=n(9781),g=n(1913);e.exports=function(e,t,n,y){var b="stackTraceLimit",w=y?2:1,x=e.split("."),v=x[x.length-1],k=r.apply(null,x);if(k){var I=k.prototype;if(!g&&a(I,"cause")&&delete I.cause,!n)return k;var S=r("Error"),N=t((function(e,t){var n=p(y?t:e,void 0),r=y?new k(e):new k;return void 0!==n&&s(r,"message",n),f&&s(r,"stack",h(r.stack,2)),this&&i(I,this)&&c(r,this,N),arguments.length>w&&d(r,arguments[w]),r}));if(N.prototype=I,"Error"!==v?o?o(N,S):l(N,S,{name:!0}):m&&b in k&&(u(N,k,b),u(N,k,"prepareStackTrace")),l(N,k),!g)try{I.name!==v&&s(I,"name",v),I.constructor=N}catch(T){}return N}}},6699:function(e,t,n){"use strict";var r=n(2109),a=n(1318).includes,s=n(7293),i=n(1223),o=s((function(){return!Array(1).includes()}));r({target:"Array",proto:!0,forced:o},{includes:function(e){return a(this,e,arguments.length>1?arguments[1]:void 0)}}),i("includes")},1703:function(e,t,n){var r=n(2109),a=n(7854),s=n(2104),i=n(9191),o="WebAssembly",l=a[o],u=7!==Error("e",{cause:7}).cause,c=function(e,t){var n={};n[e]=i(e,t,u),r({global:!0,constructor:!0,arity:1,forced:u},n)},p=function(e,t){if(l&&l[e]){var n={};n[e]=i(o+"."+e,t,u),r({target:o,stat:!0,constructor:!0,arity:1,forced:u},n)}};c("Error",(function(e){return function(t){return s(e,this,arguments)}})),c("EvalError",(function(e){return function(t){return s(e,this,arguments)}})),c("RangeError",(function(e){return function(t){return s(e,this,arguments)}})),c("ReferenceError",(function(e){return function(t){return s(e,this,arguments)}})),c("SyntaxError",(function(e){return function(t){return s(e,this,arguments)}})),c("TypeError",(function(e){return function(t){return s(e,this,arguments)}})),c("URIError",(function(e){return function(t){return s(e,this,arguments)}})),p("CompileError",(function(e){return function(t){return s(e,this,arguments)}})),p("LinkError",(function(e){return function(t){return s(e,this,arguments)}})),p("RuntimeError",(function(e){return function(t){return s(e,this,arguments)}}))},2087:function(e,t,n){var r=n(7854),a=n(9781),s=n(7045),i=n(7066),o=n(7293),l=r.RegExp,u=l.prototype,c=a&&o((function(){var e=!0;try{l(".","d")}catch(c){e=!1}var t={},n="",r=e?"dgimsy":"gimsy",a=function(e,r){Object.defineProperty(t,e,{get:function(){return n+=r,!0}})},s={dotAll:"s",global:"g",ignoreCase:"i",multiline:"m",sticky:"y"};for(var i in e&&(s.hasIndices="d"),s)a(i,s[i]);var o=Object.getOwnPropertyDescriptor(u,"flags").get.call(t);return o!==r||n!==r}));c&&s(u,"flags",{configurable:!0,get:i})},8675:function(e,t,n){"use strict";var r=n(260),a=n(6244),s=n(9303),i=r.aTypedArray,o=r.exportTypedArrayMethod;o("at",(function(e){var t=i(this),n=a(t),r=s(e),o=r>=0?r:n+r;return o<0||o>=n?void 0:t[o]}))},2958:function(e,t,n){"use strict";var r=n(260),a=n(9671).findLastIndex,s=r.aTypedArray,i=r.exportTypedArrayMethod;i("findLastIndex",(function(e){return a(s(this),e,arguments.length>1?arguments[1]:void 0)}))},3408:function(e,t,n){"use strict";var r=n(260),a=n(9671).findLast,s=r.aTypedArray,i=r.exportTypedArrayMethod;i("findLast",(function(e){return a(s(this),e,arguments.length>1?arguments[1]:void 0)}))},3462:function(e,t,n){"use strict";var r=n(7854),a=n(6916),s=n(260),i=n(6244),o=n(4590),l=n(7908),u=n(7293),c=r.RangeError,p=r.Int8Array,d=p&&p.prototype,h=d&&d.set,f=s.aTypedArray,m=s.exportTypedArrayMethod,g=!u((function(){var e=new Uint8ClampedArray(2);return a(h,e,{length:1,0:3},1),3!==e[1]})),y=g&&s.NATIVE_ARRAY_BUFFER_VIEWS&&u((function(){var e=new p(2);return e.set(1),e.set("2",1),0!==e[0]||2!==e[1]}));m("set",(function(e){f(this);var t=o(arguments.length>1?arguments[1]:void 0,1),n=l(e);if(g)return a(h,this,n,t);var r=this.length,s=i(n),u=0;if(s+t>r)throw c("Wrong length");while(u<s)this[t+u]=n[u++]}),!g||y)},1118:function(e,t,n){n(2958)},7380:function(e,t,n){n(3408)},1091:function(e,t,n){var r=n(2109),a=n(7854),s=n(261).clear;r({global:!0,bind:!0,enumerable:!0,forced:a.clearImmediate!==s},{clearImmediate:s})},2801:function(e,t,n){"use strict";var r=n(2109),a=n(5005),s=n(9114),i=n(3070).f,o=n(2597),l=n(5787),u=n(9587),c=n(6277),p=n(3678),d=n(7741),h=n(1913),f="DOMException",m=a("Error"),g=a(f),y=function(){l(this,b);var e=arguments.length,t=c(e<1?void 0:arguments[0]),n=c(e<2?void 0:arguments[1],"Error"),r=new g(t,n),a=m(t);return a.name=f,i(r,"stack",s(1,d(a.stack,1))),u(r,this,y),r},b=y.prototype=g.prototype,w="stack"in m(f),x="stack"in new g(1,2),v=w&&!x;r({global:!0,constructor:!0,forced:h||v},{DOMException:v?y:g});var k=a(f),I=k.prototype;if(I.constructor!==k)for(var S in h||i(I,"constructor",s(1,k)),p)if(o(p,S)){var N=p[S],T=N.s;o(k,T)||i(k,T,s(6,N.c))}},4633:function(e,t,n){n(1091),n(2986)},2986:function(e,t,n){var r=n(2109),a=n(7854),s=n(261).set;r({global:!0,bind:!0,enumerable:!0,forced:a.setImmediate!==s},{setImmediate:s})},1999:function(e,t,n){"use strict";var r="/index.js",a="/";n.d(t,{JF:function(){return Ete},Jd:function(){return yte},Qr:function(){return Kre},_C:function(){return Xre},aK:function(){return Cre},ii:function(){return pee},qB:function(){return Mre}});n(1703),n(8675),n(3462),n(7380),n(1118),n(6699),n(2087),n(2801),n(4633);var s=Object.defineProperty,i=(e=>n(6741))(),o=(e,t)=>{for(var n in t)s(e,n,{get:t[n],enumerable:!0})},l={};o(l,{Abs:()=>nt,Acos:()=>rt,Acosh:()=>at,AdadeltaOptimizer:()=>ww,AdagradOptimizer:()=>xw,AdamOptimizer:()=>vw,AdamaxOptimizer:()=>kw,Add:()=>st,AddN:()=>it,All:()=>ot,Any:()=>lt,ArgMax:()=>ut,ArgMin:()=>ct,Asin:()=>pt,Asinh:()=>dt,Atan:()=>ht,Atan2:()=>mt,Atanh:()=>ft,AvgPool:()=>gt,AvgPool3D:()=>bt,AvgPool3DGrad:()=>wt,AvgPoolGrad:()=>yt,BackendWasm:()=>L9,BatchMatMul:()=>xt,BatchToSpaceND:()=>vt,Bincount:()=>kt,BroadcastArgs:()=>St,BroadcastTo:()=>It,Callback:()=>Y$,CallbackList:()=>nT,Cast:()=>Nt,Ceil:()=>Tt,ClipByValue:()=>_t,Complex:()=>Ct,ComplexAbs:()=>Et,Concat:()=>At,Conv2D:()=>$t,Conv2DBackpropFilter:()=>Ft,Conv2DBackpropInput:()=>Rt,Conv3D:()=>Dt,Conv3DBackpropFilterV2:()=>Mt,Conv3DBackpropInputV2:()=>Ot,Cos:()=>Lt,Cosh:()=>Pt,CropAndResize:()=>Wt,Cumprod:()=>zt,Cumsum:()=>Bt,CustomCallback:()=>sT,DataStorage:()=>q,DenseBincount:()=>Vt,DepthToSpace:()=>Ut,DepthwiseConv2dNative:()=>Gt,DepthwiseConv2dNativeBackpropFilter:()=>Ht,DepthwiseConv2dNativeBackpropInput:()=>jt,Diag:()=>qt,Dilation2D:()=>Kt,Dilation2DBackpropFilter:()=>Yt,Dilation2DBackpropInput:()=>Xt,ENV:()=>Je,EarlyStopping:()=>Q$,Einsum:()=>Zt,Elu:()=>Qt,EluGrad:()=>en,Environment:()=>He,Equal:()=>nn,Erf:()=>tn,Exp:()=>rn,ExpandDims:()=>an,Expm1:()=>sn,FFT:()=>on,Fill:()=>ln,FlipLeftRight:()=>un,Floor:()=>cn,FloorDiv:()=>pn,FromPixels:()=>oa,FusedBatchNorm:()=>dn,FusedConv2D:()=>ca,FusedDepthwiseConv2D:()=>pa,GPGPUContext:()=>$j,GatherNd:()=>fn,GatherV2:()=>hn,GraphModel:()=>cD,Greater:()=>mn,GreaterEqual:()=>gn,History:()=>aT,IFFT:()=>bn,Identity:()=>yn,Imag:()=>wn,InputSpec:()=>JS,IsFinite:()=>xn,IsInf:()=>vn,IsNan:()=>kn,KernelBackend:()=>K,LRN:()=>Dn,LRNGrad:()=>Mn,LayerVariable:()=>qS,LayersModel:()=>z_,LeakyRelu:()=>In,Less:()=>Sn,LessEqual:()=>Nn,LinSpace:()=>Tn,Log:()=>_n,Log1p:()=>Cn,LogSoftmax:()=>Fn,LogicalAnd:()=>En,LogicalNot:()=>An,LogicalOr:()=>$n,LowerBound:()=>Rn,MathBackendWebGL:()=>sK,Max:()=>On,MaxPool:()=>Pn,MaxPool3D:()=>Bn,MaxPool3DGrad:()=>Wn,MaxPoolGrad:()=>zn,MaxPoolWithArgmax:()=>Vn,Maximum:()=>Ln,Mean:()=>Un,Min:()=>Gn,Minimum:()=>Hn,MirrorPad:()=>jn,Mod:()=>qn,MomentumOptimizer:()=>Sw,Multinomial:()=>Kn,Multiply:()=>Xn,Neg:()=>Yn,NonMaxSuppressionV3:()=>Zn,NonMaxSuppressionV4:()=>Qn,NonMaxSuppressionV5:()=>er,NotEqual:()=>Jn,OP_SCOPE_SUFFIX:()=>ei,OneHot:()=>nr,OnesLike:()=>tr,Optimizer:()=>bw,OptimizerConstructors:()=>Tw,Pack:()=>rr,PadV2:()=>ar,Pool:()=>sr,Pow:()=>ir,Prelu:()=>or,Prod:()=>lr,RMSPropOptimizer:()=>Nw,RNN:()=>QC,Range:()=>ur,Rank:()=>xs,Real:()=>cr,RealDiv:()=>Jt,Reciprocal:()=>pr,Reduction:()=>Eb,Relu:()=>dr,Relu6:()=>br,Reshape:()=>hr,ResizeBilinear:()=>gr,ResizeBilinearGrad:()=>yr,ResizeNearestNeighbor:()=>fr,ResizeNearestNeighborGrad:()=>mr,Reverse:()=>wr,RotateWithOffset:()=>la,Round:()=>xr,Rsqrt:()=>vr,SGDOptimizer:()=>Iw,ScatterNd:()=>kr,SearchSorted:()=>Ir,Select:()=>Sr,Selu:()=>Nr,Sequential:()=>H_,Sigmoid:()=>Ar,Sign:()=>Er,Sin:()=>_r,Sinh:()=>Cr,Slice:()=>Tr,Softmax:()=>Or,Softplus:()=>$r,SpaceToBatchND:()=>Dr,SparseFillEmptyRows:()=>Lr,SparseReshape:()=>Pr,SparseSegmentMean:()=>zr,SparseSegmentSum:()=>Br,SparseToDense:()=>Wr,SplitV:()=>Mr,Sqrt:()=>Fr,Square:()=>Ur,SquaredDifference:()=>Vr,Step:()=>ia,StridedSlice:()=>Gr,StringNGrams:()=>Hr,StringSplit:()=>jr,StringToHashBucketFast:()=>qr,Sub:()=>Kr,Sum:()=>Rr,SymbolicTensor:()=>ZS,Tan:()=>Xr,Tanh:()=>Yr,Tensor:()=>ys,TensorBuffer:()=>ps,Tile:()=>Jr,TopK:()=>Zr,Transform:()=>Qr,Transpose:()=>ea,Unique:()=>ta,Unpack:()=>na,UnsortedSegmentSum:()=>ra,UpperBound:()=>aa,Variable:()=>ws,ZerosLike:()=>sa,_FusedMatMul:()=>ua,abs:()=>qu,acos:()=>Xu,acosh:()=>Ju,add:()=>zu,addN:()=>Qu,all:()=>tc,any:()=>rc,argMax:()=>sc,argMin:()=>oc,asin:()=>uc,asinh:()=>pc,atan:()=>hc,atan2:()=>mc,atanh:()=>yc,avgPool:()=>zc,avgPool3d:()=>Wc,backend:()=>xl,backend_util:()=>Aw,basicLSTMCell:()=>Jc,batchNorm:()=>np,batchNorm2d:()=>ap,batchNorm3d:()=>ip,batchNorm4d:()=>lp,batchToSpaceND:()=>Qc,bincount:()=>cp,booleanMaskAsync:()=>Kg,broadcastArgs:()=>dp,broadcastTo:()=>fp,broadcast_util:()=>Fl,browser:()=>Ll,buffer:()=>fo,callbacks:()=>rF,cast:()=>go,ceil:()=>gp,clipByValue:()=>bp,clone:()=>bo,complex:()=>ri,concat:()=>Uc,concat1d:()=>xp,concat2d:()=>kp,concat3d:()=>Sp,concat4d:()=>Tp,constraints:()=>wN,conv1d:()=>Ap,conv2d:()=>Cp,conv2dTranspose:()=>Dp,conv3d:()=>Op,conv3dTranspose:()=>Bp,copyRegisteredKernels:()=>Ia,cos:()=>Vp,cosh:()=>Gp,cosineWindow:()=>ly,cumprod:()=>jp,cumsum:()=>Kp,customGrad:()=>Oh,data:()=>mD,denseBincount:()=>Yp,deprecationWarn:()=>al,depthToSpace:()=>Zp,depthwiseConv2d:()=>ed,deregisterOp:()=>lF,device_util:()=>Us,diag:()=>nd,dilation2d:()=>ad,disableDeprecationWarnings:()=>rl,dispose:()=>cl,disposeVariables:()=>sl,div:()=>Uu,divNoNan:()=>dd,dot:()=>fd,dropout:()=>iy,einsum:()=>gd,elu:()=>bd,enableDebugMode:()=>nl,enableProdMode:()=>tl,enclosingPowerOfTwo:()=>oy,engine:()=>il,env:()=>Xe,equal:()=>id,erf:()=>xd,euclideanNorm:()=>jd,exp:()=>Kd,expandDims:()=>Yd,expm1:()=>Zd,eye:()=>nh,fft:()=>ig,fill:()=>rh,findBackend:()=>yl,findBackendFactory:()=>bl,floor:()=>sh,floorDiv:()=>Wu,forceHalfFloat:()=>lK,fused:()=>py,gather:()=>oh,gatherND:()=>ry,gather_util:()=>ql,getBackend:()=>ml,getGradient:()=>ya,getKernel:()=>ga,getKernelsForBackend:()=>ba,getThreadsCount:()=>Q9,gpgpu_util:()=>lj,grad:()=>$h,grads:()=>Fh,greater:()=>uh,greaterEqual:()=>ph,ifft:()=>lg,imag:()=>Il,image:()=>hw,inTopKAsync:()=>cy,initializers:()=>DN,input:()=>X_,io:()=>vo,irfft:()=>cg,isFinite:()=>hh,isInf:()=>mh,isNaN:()=>yh,keep:()=>pl,kernel_impls:()=>Fx,layers:()=>JN,leakyRelu:()=>wh,less:()=>vh,lessEqual:()=>Ih,linalg:()=>fw,linspace:()=>Sh,loadGraphModel:()=>pD,loadGraphModelSync:()=>dD,loadLayersModel:()=>K_,localResponseNormalization:()=>Th,log:()=>Ch,log1p:()=>Ah,logSigmoid:()=>Wh,logSoftmax:()=>Hh,logSumExp:()=>qh,logicalAnd:()=>Xh,logicalNot:()=>Jh,logicalOr:()=>Qh,logicalXor:()=>tf,losses:()=>mw,lowerBound:()=>sf,matMul:()=>Zo,math:()=>Yo,max:()=>Ad,maxPool:()=>lf,maxPool3d:()=>cf,maxPoolWithArgmax:()=>df,maximum:()=>ff,mean:()=>gf,memory:()=>ol,meshgrid:()=>wf,metrics:()=>E$,min:()=>Fd,minimum:()=>vf,mirrorPad:()=>If,mod:()=>Nf,model:()=>j_,models:()=>H$,moments:()=>_f,movingAverage:()=>Yg,mul:()=>Hu,multiRNNCell:()=>Ef,multinomial:()=>$f,neg:()=>Nl,nextFrame:()=>Ew,norm:()=>Gd,notEqual:()=>Rf,oneHot:()=>el,ones:()=>bf,onesLike:()=>Mf,op:()=>ti,outerProduct:()=>Lf,pad:()=>zf,pad1d:()=>Wf,pad2d:()=>Uf,pad3d:()=>Hf,pad4d:()=>qf,pool:()=>Qf,pow:()=>Dd,prelu:()=>tm,print:()=>wo,prod:()=>rm,profile:()=>ll,rand:()=>sm,randomGamma:()=>pm,randomNormal:()=>hm,randomUniform:()=>mm,range:()=>gm,ready:()=>fl,real:()=>_l,reciprocal:()=>bm,registerBackend:()=>wl,registerCallbackConstructor:()=>Y_,registerGradient:()=>xa,registerKernel:()=>wa,registerOp:()=>iF,regularizers:()=>j$,relu:()=>xm,relu6:()=>km,removeBackend:()=>gl,reshape:()=>Lc,reverse:()=>Sm,reverse1d:()=>Tm,reverse2d:()=>Cm,reverse3d:()=>Am,reverse4d:()=>Fm,rfft:()=>fg,round:()=>Dm,rsqrt:()=>Om,scalar:()=>Md,scatterND:()=>Zg,scatter_util:()=>Xl,searchSorted:()=>af,selu:()=>Pm,separableConv2d:()=>Bm,sequential:()=>q_,serialization:()=>xu,setBackend:()=>hl,setPlatform:()=>vl,setThreadsCount:()=>Z9,setWasmPath:()=>K9,setWasmPaths:()=>X9,setWebGLContext:()=>zU,setdiff1dAsync:()=>Vm,sigmoid:()=>Hc,sign:()=>Gm,signal:()=>dw,sin:()=>jm,sinh:()=>Km,slice:()=>qc,slice1d:()=>Ym,slice2d:()=>Zm,slice3d:()=>eg,slice4d:()=>ng,slice_util:()=>Ql,softmax:()=>ag,softplus:()=>zh,spaceToBatchND:()=>Xf,sparse:()=>gw,sparseToDense:()=>ty,spectral:()=>pw,split:()=>dg,sqrt:()=>Ld,square:()=>zd,squaredDifference:()=>gg,squeeze:()=>bg,stack:()=>xg,step:()=>kg,stridedSlice:()=>Sg,string:()=>yw,sub:()=>Uh,sum:()=>Wd,sumOutType:()=>Cs,tan:()=>Tg,tanh:()=>Xc,tensor:()=>si,tensor1d:()=>_g,tensor2d:()=>Cg,tensor3d:()=>Pl,tensor4d:()=>Eg,tensor5d:()=>Ag,tensor6d:()=>$g,tensor_util:()=>Ns,test_util:()=>Su,tidy:()=>ul,tile:()=>eh,time:()=>dl,topk:()=>Rg,train:()=>_w,transpose:()=>El,truncatedNormal:()=>Mg,unique:()=>Lg,unregisterGradient:()=>ka,unregisterKernel:()=>va,unsortedSegmentSum:()=>zg,unstack:()=>Wg,upcastType:()=>_s,upperBound:()=>Vg,util:()=>Na,valueAndGrad:()=>Rh,valueAndGrads:()=>Dh,variable:()=>Ug,variableGrads:()=>Mh,version:()=>cee,version_converter:()=>fD,version_core:()=>Lu,version_layers:()=>o_,version_wasm:()=>eee,version_webgl:()=>oK,webgl:()=>uK,webgl_util:()=>RU,where:()=>ld,whereAsync:()=>jg,zeros:()=>yf,zerosLike:()=>cd});var u=Object.create,c=Object.defineProperty,p=Object.getOwnPropertyDescriptor,d=Object.getOwnPropertyNames,h=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty,m=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),g=(e,t)=>{for(var n in t)c(e,n,{get:t[n],enumerable:!0})},y=(e,t,n,r)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let a of d(t))!f.call(e,a)&&a!==n&&c(e,a,{get:()=>t[a],enumerable:!(r=p(t,a))||r.enumerable});return e},b=(e,t,n)=>(n=null!=e?u(h(e)):{},y(!t&&e&&e.__esModule?n:c(n,"default",{value:e,enumerable:!0}),e)),w=m(((e,t)=>{t.exports=r;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(C){}function r(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function a(e){return!0===(e&&e.__isLong__)}r.prototype.__isLong__,Object.defineProperty(r.prototype,"__isLong__",{value:!0}),r.isLong=a;var s={},i={};function o(e,t){var n,r,a;return t?(e>>>=0,(a=0<=e&&e<256)&&(r=i[e],r)?r:(n=u(e,(0|e)<0?-1:0,!0),a&&(i[e]=n),n)):(e|=0,(a=-128<=e&&e<128)&&(r=s[e],r)?r:(n=u(e,e<0?-1:0,!1),a&&(s[e]=n),n))}function l(e,t){if(isNaN(e))return t?x:w;if(t){if(e<0)return x;if(e>=g)return N}else{if(e<=-y)return T;if(e+1>=y)return S}return e<0?l(-e,t).neg():u(e%m|0,e/m|0,t)}function u(e,t,n){return new r(e,t,n)}r.fromInt=o,r.fromNumber=l,r.fromBits=u;var c=Math.pow;function p(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return w;if("number"==typeof t?(n=t,t=!1):t=!!t,n=n||10,n<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return p(e.substring(1),t,n).neg();for(var a=l(c(n,8)),s=w,i=0;i<e.length;i+=8){var o=Math.min(8,e.length-i),u=parseInt(e.substring(i,i+o),n);if(o<8){var d=l(c(n,o));s=s.mul(d).add(l(u))}else s=s.mul(a),s=s.add(l(u))}return s.unsigned=t,s}function d(e,t){return"number"==typeof e?l(e,t):"string"==typeof e?p(e,t):u(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}r.fromString=p,r.fromValue=d;var h=65536,f=1<<24,m=h*h,g=m*m,y=g/2,b=o(f),w=o(0);r.ZERO=w;var x=o(0,!0);r.UZERO=x;var v=o(1);r.ONE=v;var k=o(1,!0);r.UONE=k;var I=o(-1);r.NEG_ONE=I;var S=u(-1,2147483647,!1);r.MAX_VALUE=S;var N=u(-1,-1,!0);r.MAX_UNSIGNED_VALUE=N;var T=u(0,-2147483648,!1);r.MIN_VALUE=T;var _=r.prototype;_.toInt=function(){return this.unsigned?this.low>>>0:this.low},_.toNumber=function(){return this.unsigned?(this.high>>>0)*m+(this.low>>>0):this.high*m+(this.low>>>0)},_.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(T)){var t=l(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var a=l(c(e,6),this.unsigned),s=this,i="";;){var o=s.div(a),u=s.sub(o.mul(a)).toInt()>>>0,p=u.toString(e);if(s=o,s.isZero())return p+i;for(;p.length<6;)p="0"+p;i=""+p+i}},_.getHighBits=function(){return this.high},_.getHighBitsUnsigned=function(){return this.high>>>0},_.getLowBits=function(){return this.low},_.getLowBitsUnsigned=function(){return this.low>>>0},_.getNumBitsAbs=function(){if(this.isNegative())return this.eq(T)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},_.isZero=function(){return 0===this.high&&0===this.low},_.eqz=_.isZero,_.isNegative=function(){return!this.unsigned&&this.high<0},_.isPositive=function(){return this.unsigned||this.high>=0},_.isOdd=function(){return 1===(1&this.low)},_.isEven=function(){return 0===(1&this.low)},_.equals=function(e){return a(e)||(e=d(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)},_.eq=_.equals,_.notEquals=function(e){return!this.eq(e)},_.neq=_.notEquals,_.ne=_.notEquals,_.lessThan=function(e){return this.comp(e)<0},_.lt=_.lessThan,_.lessThanOrEqual=function(e){return this.comp(e)<=0},_.lte=_.lessThanOrEqual,_.le=_.lessThanOrEqual,_.greaterThan=function(e){return this.comp(e)>0},_.gt=_.greaterThan,_.greaterThanOrEqual=function(e){return this.comp(e)>=0},_.gte=_.greaterThanOrEqual,_.ge=_.greaterThanOrEqual,_.compare=function(e){if(a(e)||(e=d(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},_.comp=_.compare,_.negate=function(){return!this.unsigned&&this.eq(T)?T:this.not().add(v)},_.neg=_.negate,_.add=function(e){a(e)||(e=d(e));var t=this.high>>>16,n=65535&this.high,r=this.low>>>16,s=65535&this.low,i=e.high>>>16,o=65535&e.high,l=e.low>>>16,c=65535&e.low,p=0,h=0,f=0,m=0;return m+=s+c,f+=m>>>16,m&=65535,f+=r+l,h+=f>>>16,f&=65535,h+=n+o,p+=h>>>16,h&=65535,p+=t+i,p&=65535,u(f<<16|m,p<<16|h,this.unsigned)},_.subtract=function(e){return a(e)||(e=d(e)),this.add(e.neg())},_.sub=_.subtract,_.multiply=function(e){if(this.isZero())return w;if(a(e)||(e=d(e)),n){var t=n.mul(this.low,this.high,e.low,e.high);return u(t,n.get_high(),this.unsigned)}if(e.isZero())return w;if(this.eq(T))return e.isOdd()?T:w;if(e.eq(T))return this.isOdd()?T:w;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(b)&&e.lt(b))return l(this.toNumber()*e.toNumber(),this.unsigned);var r=this.high>>>16,s=65535&this.high,i=this.low>>>16,o=65535&this.low,c=e.high>>>16,p=65535&e.high,h=e.low>>>16,f=65535&e.low,m=0,g=0,y=0,x=0;return x+=o*f,y+=x>>>16,x&=65535,y+=i*f,g+=y>>>16,y&=65535,y+=o*h,g+=y>>>16,y&=65535,g+=s*f,m+=g>>>16,g&=65535,g+=i*h,m+=g>>>16,g&=65535,g+=o*p,m+=g>>>16,g&=65535,m+=r*f+s*h+i*p+o*c,m&=65535,u(y<<16|x,m<<16|g,this.unsigned)},_.mul=_.multiply,_.divide=function(e){if(a(e)||(e=d(e)),e.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&-2147483648===this.high&&-1===e.low&&-1===e.high)return this;var t=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,e.low,e.high);return u(t,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?x:w;var r,s,i;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return x;if(e.gt(this.shru(1)))return k;i=x}else{if(this.eq(T)){if(e.eq(v)||e.eq(I))return T;if(e.eq(T))return v;var o=this.shr(1);return r=o.div(e).shl(1),r.eq(w)?e.isNegative()?v:I:(s=this.sub(e.mul(r)),i=r.add(s.div(e)),i)}if(e.eq(T))return this.unsigned?x:w;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();i=w}for(s=this;s.gte(e);){r=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var p=Math.ceil(Math.log(r)/Math.LN2),h=p<=48?1:c(2,p-48),f=l(r),m=f.mul(e);m.isNegative()||m.gt(s);)r-=h,f=l(r,this.unsigned),m=f.mul(e);f.isZero()&&(f=v),i=i.add(f),s=s.sub(m)}return i},_.div=_.divide,_.modulo=function(e){if(a(e)||(e=d(e)),n){var t=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,e.low,e.high);return u(t,n.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))},_.mod=_.modulo,_.rem=_.modulo,_.not=function(){return u(~this.low,~this.high,this.unsigned)},_.and=function(e){return a(e)||(e=d(e)),u(this.low&e.low,this.high&e.high,this.unsigned)},_.or=function(e){return a(e)||(e=d(e)),u(this.low|e.low,this.high|e.high,this.unsigned)},_.xor=function(e){return a(e)||(e=d(e)),u(this.low^e.low,this.high^e.high,this.unsigned)},_.shiftLeft=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?u(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):u(0,this.low<<e-32,this.unsigned)},_.shl=_.shiftLeft,_.shiftRight=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?u(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):u(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},_.shr=_.shiftRight,_.shiftRightUnsigned=function(e){if(a(e)&&(e=e.toInt()),e&=63,0===e)return this;var t=this.high;if(e<32){var n=this.low;return u(n>>>e|t<<32-e,t>>>e,this.unsigned)}return u(32===e?t:t>>>e-32,0,this.unsigned)},_.shru=_.shiftRightUnsigned,_.shr_u=_.shiftRightUnsigned,_.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},_.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},_.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},_.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},_.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},r.fromBytes=function(e,t,n){return n?r.fromBytesLE(e,t):r.fromBytesBE(e,t)},r.fromBytesLE=function(e,t){return new r(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},r.fromBytesBE=function(e,t){return new r(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}})),x=m((()=>{})),v=m((()=>{})),k=m(((e,t)=>{(function(e,t,n){function r(e){var t=this,n=i();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function a(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function s(e,t){var n=new r(e),s=t&&t.state,i=n.next;return i.int32=function(){return 4294967296*n.next()|0},i.double=function(){return i()+11102230246251565e-32*(2097152*i()|0)},i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}function i(){var e=4022871197,t=function(t){t=t.toString();for(var n=0;n<t.length;n++){e+=t.charCodeAt(n);var r=.02519603282416938*e;e=r>>>0,r-=e,r*=e,e=r>>>0,r-=e,e+=4294967296*r}return 2.3283064365386963e-10*(e>>>0)};return t}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.alea=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),I=m(((e,t)=>{(function(e,t,n){function r(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function s(e,t){var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xor128=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),S=m(((e,t)=>{(function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function s(e,t){var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xorwow=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),N=m(((e,t)=>{(function(e,t,n){function r(e){var t=this;function n(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}t.next=function(){var e,n,r=t.x,a=t.i;return e=r[a],e^=e>>>7,n=e^e<<24,e=r[a+1&7],n^=e^e>>>10,e=r[a+3&7],n^=e^e>>>3,e=r[a+4&7],n^=e^e<<7,e=r[a+7&7],e^=e<<13,n^=e^e<<9,r[a]=n,t.i=a+1&7,n},n(t,e)}function a(e,t){return t.x=e.x.slice(),t.i=e.i,t}function s(e,t){null==e&&(e=+new Date);var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},i.int32=n.next,i.quick=i,s&&(s.x&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xorshift7=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),T=m(((e,t)=>{(function(e,t,n){function r(e){var t=this;function n(e,t){var n,r,a,s,i,o=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),a=0,s=-32;s<l;++s)t&&(r^=t.charCodeAt((s+32)%t.length)),0===s&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,s>=0&&(i=i+1640531527|0,n=o[127&s]^=r+i,a=0==n?a+1:0);for(a>=128&&(o[127&(t&&t.length||0)]=-1),a=127,s=512;s>0;--s)r=o[a+34&127],n=o[a=a+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[a]=r^n;e.w=i,e.X=o,e.i=a}t.next=function(){var e,n,r=t.w,a=t.X,s=t.i;return t.w=r=r+1640531527|0,n=a[s+34&127],e=a[s=s+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=a[s]=n^e,t.i=s,n+(r^r>>>16)|0},n(t,e)}function a(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function s(e,t){null==e&&(e=+new Date);var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},i.int32=n.next,i.quick=i,s&&(s.X&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xor4096=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),_=m(((e,t)=>{(function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,a=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^a,a=a-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^a,t.a=a-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function s(e,t){var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.tychei=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),C=m((()=>{})),E=m(((e,t)=>{(function(e,r){var a,s=this,i=256,o=6,l=52,u="random",c=r.pow(i,o),p=r.pow(2,l),d=2*p,h=i-1;function f(t,n,a){var s=[];n=1==n?{entropy:!0}:n||{};var l=b(y(n.entropy?[t,x(e)]:null==t?w():t,3),s),h=new m(s),f=function(){for(var e=h.g(o),t=c,n=0;e<p;)e=(e+n)*i,t*=i,n=h.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return f.int32=function(){return 0|h.g(4)},f.quick=function(){return h.g(4)/4294967296},f.double=f,b(x(h.S),e),(n.pass||a||function(e,t,n,a){return a&&(a.S&&g(a,h),e.state=function(){return g(h,{})}),n?(r[u]=e,t):e})(f,l,"global"in n?n.global:this==r,n.state)}function m(e){var t,n=e.length,r=this,a=0,s=r.i=r.j=0,o=r.S=[];for(n||(e=[n++]);a<i;)o[a]=a++;for(a=0;a<i;a++)o[a]=o[s=h&s+e[a%n]+(t=o[a])],o[s]=t;(r.g=function(e){for(var t,n=0,a=r.i,s=r.j,o=r.S;e--;)t=o[a=h&a+1],n=n*i+o[h&(o[a]=o[s=h&s+t])+(o[s]=t)];return r.i=a,r.j=s,n})(i)}function g(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function y(e,t){var n,r=[],a=typeof e;if(t&&"object"==a)for(n in e)try{r.push(y(e[n],t-1))}catch(s){}return r.length?r:"string"==a?e:e+"\0"}function b(e,t){for(var n,r=e+"",a=0;a<r.length;)t[h&a]=h&(n^=19*t[h&a])+r.charCodeAt(a++);return x(t)}function w(){try{var t;return a&&(t=a.randomBytes)?t=t(i):(t=new Uint8Array(i),(s.crypto||s.msCrypto).getRandomValues(t)),x(t)}catch(o){var n=s.navigator,r=n&&n.plugins;return[+new Date,s,r,s.screen,x(e)]}}function x(e){return String.fromCharCode.apply(0,e)}if(r["seed"+u]=f,b(r.random(),e),"object"==typeof t&&t.exports){t.exports=f;try{a=C()}catch(v){}}else"function"==typeof define&&n.amdO&&define((function(){return f}))})([],Math)})),A=m(((e,t)=>{var n=k(),r=I(),a=S(),s=N(),i=T(),o=_(),l=E();l.alea=n,l.xor128=r,l.xorwow=a,l.xorshift7=s,l.xor4096=i,l.tychei=o,t.exports=l})),$=m(((e,t)=>{(function(e,t,n){function r(e){var t=this,n=i();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function a(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function s(e,t){var n=new r(e),s=t&&t.state,i=n.next;return i.int32=function(){return 4294967296*n.next()|0},i.double=function(){return i()+11102230246251565e-32*(2097152*i()|0)},i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}function i(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){e+=t.charCodeAt(n);var r=.02519603282416938*e;e=r>>>0,r-=e,r*=e,e=r>>>0,r-=e,e+=4294967296*r}return 2.3283064365386963e-10*(e>>>0)};return t}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.alea=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),F=m(((e,t)=>{(function(e,t,n){function r(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function s(e,t){var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xor128=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),R=m(((e,t)=>{(function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function s(e,t){var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xorwow=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),D=m(((e,t)=>{(function(e,t,n){function r(e){var t=this;function n(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}t.next=function(){var e,n,r=t.x,a=t.i;return e=r[a],e^=e>>>7,n=e^e<<24,e=r[a+1&7],n^=e^e>>>10,e=r[a+3&7],n^=e^e>>>3,e=r[a+4&7],n^=e^e<<7,e=r[a+7&7],e^=e<<13,n^=e^e<<9,r[a]=n,t.i=a+1&7,n},n(t,e)}function a(e,t){return t.x=e.x.slice(),t.i=e.i,t}function s(e,t){null==e&&(e=+new Date);var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},i.int32=n.next,i.quick=i,s&&(s.x&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xorshift7=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),M=m(((e,t)=>{(function(e,t,n){function r(e){var t=this;function n(e,t){var n,r,a,s,i,o=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),a=0,s=-32;s<l;++s)t&&(r^=t.charCodeAt((s+32)%t.length)),0===s&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,s>=0&&(i=i+1640531527|0,n=o[127&s]^=r+i,a=0==n?a+1:0);for(a>=128&&(o[127&(t&&t.length||0)]=-1),a=127,s=512;s>0;--s)r=o[a+34&127],n=o[a=a+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[a]=r^n;e.w=i,e.X=o,e.i=a}t.next=function(){var e,n,r=t.w,a=t.X,s=t.i;return t.w=r=r+1640531527|0,n=a[s+34&127],e=a[s=s+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=a[s]=n^e,t.i=s,n+(r^r>>>16)|0},n(t,e)}function a(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function s(e,t){null==e&&(e=+new Date);var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},i.int32=n.next,i.quick=i,s&&(s.X&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.xor4096=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),O=m(((e,t)=>{(function(e,t,n){function r(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,a=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^a,a=a-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^a,t.a=a-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function a(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function s(e,t){var n=new r(e),s=t&&t.state,i=function(){return(n.next()>>>0)/4294967296};return i.double=function(){do{var e=n.next()>>>11,t=(n.next()>>>0)/4294967296,r=(e+t)/(1<<21)}while(0===r);return r},i.int32=n.next,i.quick=i,s&&("object"==typeof s&&a(s,n),i.state=function(){return a(n,{})}),i}t&&t.exports?t.exports=s:n&&n.amd?n((function(){return s})):this.tychei=s})(0,"object"==typeof t&&t,"function"==typeof define&&define)})),L=m(((e,t)=>{(function(e,r,a){var s,i=256,o=6,l=52,u="random",c=a.pow(i,o),p=a.pow(2,l),d=2*p,h=i-1;function f(e,t,n){var s=[];t=1==t?{entropy:!0}:t||{};var l=b(y(t.entropy?[e,x(r)]:null==e?w():e,3),s),h=new m(s),f=function(){for(var e=h.g(o),t=c,n=0;e<p;)e=(e+n)*i,t*=i,n=h.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return f.int32=function(){return 0|h.g(4)},f.quick=function(){return h.g(4)/4294967296},f.double=f,b(x(h.S),r),(t.pass||n||function(e,t,n,r){return r&&(r.S&&g(r,h),e.state=function(){return g(h,{})}),n?(a[u]=e,t):e})(f,l,"global"in t?t.global:this==a,t.state)}function m(e){var t,n=e.length,r=this,a=0,s=r.i=r.j=0,o=r.S=[];for(n||(e=[n++]);a<i;)o[a]=a++;for(a=0;a<i;a++)o[a]=o[s=h&s+e[a%n]+(t=o[a])],o[s]=t;(r.g=function(e){for(var t,n=0,a=r.i,s=r.j,o=r.S;e--;)t=o[a=h&a+1],n=n*i+o[h&(o[a]=o[s=h&s+t])+(o[s]=t)];return r.i=a,r.j=s,n})(i)}function g(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function y(e,t){var n,r=[],a=typeof e;if(t&&"object"==a)for(n in e)try{r.push(y(e[n],t-1))}catch(s){}return r.length?r:"string"==a?e:e+"\0"}function b(e,t){for(var n,r=e+"",a=0;a<r.length;)t[h&a]=h&(n^=19*t[h&a])+r.charCodeAt(a++);return x(t)}function w(){try{var t;return s&&(t=s.randomBytes)?t=t(i):(t=new Uint8Array(i),(e.crypto||e.msCrypto).getRandomValues(t)),x(t)}catch(o){var n=e.navigator,a=n&&n.plugins;return[+new Date,e,a,e.screen,x(r)]}}function x(e){return String.fromCharCode.apply(0,e)}if(b(a.random(),r),"object"==typeof t&&t.exports){t.exports=f;try{s=C()}catch(v){}}else"function"==typeof define&&n.amdO?define((function(){return f})):a["seed"+u]=f})("undefined"!=typeof self?self:e,[],Math)})),P=m(((e,t)=>{var n=$(),r=F(),a=R(),s=D(),i=M(),o=O(),l=L();l.alea=n,l.xor128=r,l.xorwow=a,l.xorshift7=s,l.xor4096=i,l.tychei=o,t.exports=l})),z=m((()=>{})),B=m((()=>{})),W=m((()=>{})),V=m((()=>{})),U=m((()=>{})),G=m((()=>{})),H=m(((e,t)=>{var s=(()=>{var e="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0;return e=e||r,function(t){function r(){return O.buffer!=te&&le(O.buffer),ne}function s(){return O.buffer!=te&&le(O.buffer),re}function i(){return O.buffer!=te&&le(O.buffer),ae}function o(){return O.buffer!=te&&le(O.buffer),se}t=t||{};var l,u,c,p="undefined"!=typeof t?t:{};p.ready=new Promise((function(e,t){l=e,u=t})),"undefined"!=typeof process&&process.listeners&&(c={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var d,h,f,m,g,y,b=Object.assign({},p),w=[],x=(e,t)=>{throw t},v="object"==typeof window,k="function"==typeof importScripts,I="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,S=p.ENVIRONMENT_IS_PTHREAD||!1,N="";function T(e){return p.locateFile?p.locateFile(e,N):N+e}function _(e){e instanceof dn||$("exiting due to exception: "+e)}if(I){let e;N=k?W().dirname(N)+"/":a+"/",y=()=>{g||(m=B(),g=W())},d=function(e,t){return y(),e=g.normalize(e),m.readFileSync(e,t?void 0:"utf8")},f=e=>{var t=d(e,!0);return t.buffer||(t=new Uint8Array(t)),t},h=(e,t,n)=>{y(),e=g.normalize(e),m.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),w=process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof dn))throw e})),process.on("unhandledRejection",(function(e){throw e})),x=(e,t)=>{if(ge())throw process.exitCode=e,t;_(t),process.exit(e)},p.inspect=function(){return"[Emscripten Module object]"};try{e=V()}catch(yn){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),yn}n.g.Worker=e.Worker}else(v||k)&&(k?N=self.location.href:"undefined"!=typeof document&&document.currentScript&&(N=document.currentScript.src),"undefined"!=typeof e&&e&&(N=e),N=0!==N.indexOf("blob:")?N.substr(0,N.replace(/[?#].*/,"").lastIndexOf("/")+1):"",I||(d=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},k&&(f=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),h=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}),e=>document.title=e);I&&"undefined"==typeof performance&&(n.g.performance=U().performance);var C=console.log.bind(console),E=console.warn.bind(console);I&&(y(),C=e=>m.writeSync(1,e+"\n"),E=e=>m.writeSync(2,e+"\n"));var A=p.print||C,$=p.printErr||E;Object.assign(p,b),b=null,p.arguments&&(w=p.arguments),p.thisProgram&&p.thisProgram,p.quit&&(x=p.quit);function F(e){F.shown||(F.shown={}),F.shown[e]||(F.shown[e]=1,$(e))}var R,D=e=>{e};Atomics.load,Atomics.store,Atomics.compareExchange;p.wasmBinary&&(R=p.wasmBinary);var M=p.noExitRuntime||!0;"object"!=typeof WebAssembly&&Ee("no native wasm support detected");var O,L,P,z=!1;function H(e){var t=p["_"+e];return t}function j(e,t,n,r,a){var s={string:function(e){var t=0;if(null!=e&&0!==e){var n=1+(e.length<<2);t=cn(n),Q(e,t,n)}return t},array:function(e){var t=cn(e.length);return ie(e,t),t}};function i(e){return"string"===t?J(e):"boolean"===t?Boolean(e):e}var o=H(e),l=[],u=0;if(r)for(var c=0;c<r.length;c++){var p=s[n[c]];p?(0===u&&(u=ln()),l[c]=p(r[c])):l[c]=r[c]}var d=o.apply(null,l);function h(e){return 0!==u&&un(u),i(e)}return d=h(d),d}function q(e,t,n,r){n=n||[];var a=n.every((function(e){return"number"===e})),s="string"!==t;return s&&a&&!r?H(e):function(){return j(e,t,n,arguments,r)}}function K(e){var t=new TextDecoder(e);this.decode=e=>(e.buffer instanceof SharedArrayBuffer&&(e=new Uint8Array(e)),t.decode.call(t,e))}var X="undefined"!=typeof TextDecoder?new K("utf8"):void 0;function Y(e,t,n){for(var r=t+n,a=t;e[a]&&!(a>=r);)++a;if(a-t>16&&e.subarray&&X)return X.decode(e.subarray(t,a));for(var s="";t<a;){var i=e[t++];if(128&i){var o=63&e[t++];if(192!=(224&i)){var l=63&e[t++];if(i=224==(240&i)?(15&i)<<12|o<<6|l:(7&i)<<18|o<<12|l<<6|63&e[t++],i<65536)s+=String.fromCharCode(i);else{var u=i-65536;s+=String.fromCharCode(55296|u>>10,56320|1023&u)}}else s+=String.fromCharCode((31&i)<<6|o)}else s+=String.fromCharCode(i)}return s}function J(e,t){return e?Y(s(),e,t):""}function Z(e,t,n,r){if(!(r>0))return 0;for(var a=n,s=n+r-1,i=0;i<e.length;++i){var o=e.charCodeAt(i);if(o>=55296&&o<=57343){var l=e.charCodeAt(++i);o=65536+((1023&o)<<10)|1023&l}if(o<=127){if(n>=s)break;t[n++]=o}else if(o<=2047){if(n+1>=s)break;t[n++]=192|o>>6,t[n++]=128|63&o}else if(o<=65535){if(n+2>=s)break;t[n++]=224|o>>12,t[n++]=128|o>>6&63,t[n++]=128|63&o}else{if(n+3>=s)break;t[n++]=240|o>>18,t[n++]=128|o>>12&63,t[n++]=128|o>>6&63,t[n++]=128|63&o}}return t[n]=0,n-a}function Q(e,t,n){return Z(e,s(),t,n)}function ee(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);r>=55296&&r<=57343&&(r=65536+((1023&r)<<10)|1023&e.charCodeAt(++n)),r<=127?++t:t+=r<=2047?2:r<=65535?3:4}return t}var te,ne,re,ae,se;"undefined"!=typeof TextDecoder&&new K("utf-16le");function ie(e,t){r().set(e,t)}function oe(e,t){return e%t>0&&(e+=t-e%t),e}function le(e){te=e,p.HEAP8=ne=new Int8Array(e),p.HEAP16=new Int16Array(e),p.HEAP32=ae=new Int32Array(e),p.HEAPU8=re=new Uint8Array(e),p.HEAPU16=new Uint16Array(e),p.HEAPU32=new Uint32Array(e),p.HEAPF32=new Float32Array(e),p.HEAPF64=se=new Float64Array(e)}S&&(te=p.buffer);var ue=p.INITIAL_MEMORY||16777216;if(S)O=p.wasmMemory,te=p.buffer;else if(p.wasmMemory)O=p.wasmMemory;else if(O=new WebAssembly.Memory({initial:ue/65536,maximum:32768,shared:!0}),!(O.buffer instanceof SharedArrayBuffer))throw $("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),I&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");O&&(te=O.buffer),ue=te.byteLength,le(te);var ce,pe=[],de=[],he=[],fe=[],me=0;function ge(){return M||me>0}function ye(){if(p.preRun)for("function"==typeof p.preRun&&(p.preRun=[p.preRun]);p.preRun.length;)ve(p.preRun.shift());Pe(pe)}function be(){!0,!S&&Pe(de)}function we(){S||(He.terminateAllThreads(),!0)}function xe(){if(!S){if(p.postRun)for("function"==typeof p.postRun&&(p.postRun=[p.postRun]);p.postRun.length;)Ie(p.postRun.shift());Pe(fe)}}function ve(e){pe.unshift(e)}function ke(e){de.unshift(e)}function Ie(e){fe.unshift(e)}var Se=0,Ne=null,Te=null;function _e(e){Se++,p.monitorRunDependencies&&p.monitorRunDependencies(Se)}function Ce(e){if(Se--,p.monitorRunDependencies&&p.monitorRunDependencies(Se),0==Se&&(null!==Ne&&(clearInterval(Ne),Ne=null),Te)){var t=Te;Te=null,t()}}function Ee(e){S?postMessage({cmd:"onAbort",arg:e}):p.onAbort&&p.onAbort(e),e="Aborted("+e+")",$(e),z=!0,P=1,e+=". Build with -s ASSERTIONS=1 for more info.";var t=new WebAssembly.RuntimeError(e);throw u(t),t}p.preloadedImages={},p.preloadedAudios={};var Ae,$e="data:application/octet-stream;base64,";function Fe(e){return e.startsWith($e)}function Re(e){return e.startsWith("file://")}function De(e){try{if(e==Ae&&R)return new Uint8Array(R);if(f)return f(e);throw"both async and sync fetching of the wasm failed"}catch(yn){Ee(yn)}}function Me(){if(!R&&(v||k)){if("function"==typeof fetch&&!Re(Ae))return fetch(Ae,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+Ae+"'";return e.arrayBuffer()})).catch((function(){return De(Ae)}));if(h)return new Promise((function(e,t){h(Ae,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return De(Ae)}))}function Oe(){var e={env:Xt,wasi_snapshot_preview1:Xt};function t(e,t){var n=e.exports;if(p.asm=n,Ze(p.asm.emscripten_tls_init),ce=p.asm.__indirect_function_table,ke(p.asm.__wasm_call_ctors),L=t,!S){var r=He.unusedWorkers.length;He.unusedWorkers.forEach((function(e){He.loadWasmModuleToWorker(e,(function(){--r||Ce("wasm-instantiate")}))}))}}function n(e){t(e.instance,e.module)}function r(t){return Me().then((function(t){return WebAssembly.instantiate(t,e)})).then((function(e){return e})).then(t,(function(e){$("failed to asynchronously prepare wasm: "+e),Ee(e)}))}function a(){return R||"function"!=typeof WebAssembly.instantiateStreaming||Fe(Ae)||Re(Ae)||"function"!=typeof fetch?r(n):fetch(Ae,{credentials:"same-origin"}).then((function(t){var a=WebAssembly.instantiateStreaming(t,e);return a.then(n,(function(e){return $("wasm streaming compile failed: "+e),$("falling back to ArrayBuffer instantiation"),r(n)}))}))}if(S||_e("wasm-instantiate"),p.instantiateWasm)try{var s=p.instantiateWasm(e,t);return s}catch(i){return $("Module.instantiateWasm callback failed with error: "+i),!1}return a().catch(u),{}}Ae="tfjs-backend-wasm-threaded-simd.wasm",Fe(Ae)||(Ae=T(Ae));var Le={};function Pe(e){for(;e.length>0;){var t=e.shift();if("function"!=typeof t){var n=t.func;"number"==typeof n?void 0===t.arg?Ye(n)():Ye(n)(t.arg):n(void 0===t.arg?null:t.arg)}else t(p)}}function ze(e){var t=ln(),n=e();return un(t),n}function Be(e){i()[e>>2]=0;var t=He.pthreads[e];delete He.pthreads[e],t.worker.terminate(),sn(e),He.runningWorkers.splice(He.runningWorkers.indexOf(t.worker),1),t.worker.pthread=void 0}function We(e){var t=He.pthreads[e];t.worker.postMessage({cmd:"cancel"})}function Ve(e){var t=He.pthreads[e];if(t){i()[e>>2]=0;var n=t.worker;He.returnWorkerToPool(n)}}function Ue(e){fn(e)}function Ge(e){if(e instanceof dn||"unwind"==e)return P;x(1,e)}var He={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],init:function(){S?He.initWorker():He.initMainThread()},initMainThread:function(){for(var e=8,t=0;t<e;++t)He.allocateUnusedWorker()},initWorker:function(){M=!1},pthreads:{},setExitStatus:function(e){P=e},terminateAllThreads:function(){for(var e in He.pthreads){var t=He.pthreads[e];t&&t.worker&&He.returnWorkerToPool(t.worker)}for(var n=0;n<He.unusedWorkers.length;++n){var r=He.unusedWorkers[n];r.terminate()}He.unusedWorkers=[]},returnWorkerToPool:function(e){He.runWithoutMainThreadQueuedCalls((function(){delete He.pthreads[e.pthread.threadInfoStruct],He.unusedWorkers.push(e),He.runningWorkers.splice(He.runningWorkers.indexOf(e),1),sn(e.pthread.threadInfoStruct),e.pthread=void 0}))},runWithoutMainThreadQueuedCalls:function(e){i()[pn>>2]=0;try{e()}finally{i()[pn>>2]=1}},receiveObjectTransfer:function(e){},threadInit:function(){for(var e in He.tlsInitFunctions)He.tlsInitFunctions[e]()},loadWasmModuleToWorker:function(t,n){t.onmessage=e=>{var r=e.data,a=r.cmd;if(t.pthread&&(He.currentProxiedOperationCallerThread=t.pthread.threadInfoStruct),r.targetThread&&r.targetThread!=Qt()){var s=He.pthreads[r.targetThread];return s?s.worker.postMessage(r,r.transferList):$('Internal error! Worker sent a message "'+a+'" to target pthread '+r.targetThread+", but that thread no longer exists!"),void(He.currentProxiedOperationCallerThread=void 0)}"processQueuedMainThreadWork"===a?en():"spawnThread"===a?st(r):"cleanupThread"===a?Ve(r.thread):"killThread"===a?Be(r.thread):"cancelThread"===a?We(r.thread):"loaded"===a?(t.loaded=!0,n&&n(t),t.runPthread&&(t.runPthread(),delete t.runPthread)):"print"===a?A("Thread "+r.threadId+": "+r.text):"printErr"===a?$("Thread "+r.threadId+": "+r.text):"alert"===a?alert("Thread "+r.threadId+": "+r.text):"setimmediate"===r.target?t.postMessage(r):"onAbort"===a?p.onAbort&&p.onAbort(r.arg):$("worker sent an unknown command "+a),He.currentProxiedOperationCallerThread=void 0},t.onerror=e=>{var t="worker sent an error!";throw $(t+" "+e.filename+":"+e.lineno+": "+e.message),e},I&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){}))),t.postMessage({cmd:"load",urlOrBlob:p.mainScriptUrlOrBlob||e,wasmMemory:O,wasmModule:L})},allocateUnusedWorker:function(){var e=T("tfjs-backend-wasm-threaded-simd.worker.js");He.unusedWorkers.push(new Worker(e))},getNewWorker:function(){return 0==He.unusedWorkers.length&&(He.allocateUnusedWorker(),He.loadWasmModuleToWorker(He.unusedWorkers[0])),He.unusedWorkers.pop()}};function je(){var e=Qt(),t=i()[e+44>>2],n=i()[e+48>>2],r=t-n;on(t,r),un(t)}function qe(e){if(S)return ft(1,0,e);try{Ue(e)}catch(yn){Ge(yn)}}p.establishStackSpace=je;var Ke,Xe=[];function Ye(e){var t=Xe[e];return t||(e>=Xe.length&&(Xe.length=e+1),Xe[e]=t=ce.get(e)),t}function Je(e,t){return Ye(e)(t)}function Ze(e,t,n){He.tlsInitFunctions.push(e)}p.invokeEntryPoint=Je,Ke=I?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:S?()=>performance.now()-p.__performance_now_clock_drift:()=>performance.now();var Qe=!0;function et(e){return i()[Zt()>>2]=e,e}function tt(e,t){var n;if(0===e)n=Date.now();else{if(1!==e&&4!==e||!Qe)return et(28),-1;n=Ke()}return i()[t>>2]=n/1e3|0,i()[t+4>>2]=n%1e3*1e3*1e3|0,0}function nt(e,t){return tt(e,t)}function rt(e){tn(e,!k,1,!v),He.threadInit()}function at(e){S?postMessage({cmd:"cleanupThread",thread:e}):Ve(e)}function st(e){var t=He.getNewWorker();if(!t)return 6;He.runningWorkers.push(t);var n=He.pthreads[e.pthread_ptr]={worker:t,threadInfoStruct:e.pthread_ptr};t.pthread=n;var r={cmd:"run",start_routine:e.startRoutine,arg:e.arg,threadInfoStruct:e.pthread_ptr};return t.runPthread=()=>{r.time=performance.now(),t.postMessage(r,e.transferList)},t.loaded&&(t.runPthread(),delete t.runPthread),0}function it(e,t,n,r){if("undefined"==typeof SharedArrayBuffer)return $("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[],s=0;if(S&&(0===a.length||s))return nn(687865856,e,t,n,r);if(s)return s;var i={startRoutine:n,pthread_ptr:e,arg:r,transferList:a};return S?(i.cmd="spawnThread",postMessage(i,a),0):st(i)}function ot(){return 2097152}function lt(e,t){if(e==t)postMessage({cmd:"processQueuedMainThreadWork"});else if(S)postMessage({targetThread:e,cmd:"processThreadQueue"});else{var n=He.pthreads[e],r=n&&n.worker;if(!r)return;r.postMessage({cmd:"processThreadQueue"})}return 1}function ut(){Ee("")}function ct(){I||k||F("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function pt(){return 2147483648}function dt(e,t,n){s().copyWithin(e,t,t+n)}function ht(){return I?G().cpus().length:navigator.hardwareConcurrency}function ft(e,t){var n=arguments.length-2,r=arguments;return ze((function(){for(var a=n,s=cn(8*a),i=s>>3,l=0;l<n;l++){var u=r[2+l];o()[i+l]=u}return rn(e,a,s,t)}))}var mt=[];function gt(e,t,n){mt.length=t;for(var r=n>>3,a=0;a<t;a++)mt[a]=o()[r+a];var s=e<0,i=s?Le[-e-1]:Kt[e];return i.apply(null,mt)}function yt(e){try{return O.grow(e-te.byteLength+65535>>>16),le(O.buffer),1}catch(yn){}}function bt(e){var t=s().length;if(e>>>=0,e<=t)return!1;var n=pt();if(e>n)return!1;for(var r=1;r<=4;r*=2){var a=t*(1+.2/r);a=Math.min(a,e+100663296);var i=Math.min(n,oe(Math.max(e,a),65536)),o=yt(i);if(o)return!0}return!1}var wt={inEventHandler:0,removeAllEventListeners:function(){for(var e=wt.eventHandlers.length-1;e>=0;--e)wt._removeHandler(e);wt.eventHandlers=[],wt.deferredCalls=[]},registerRemoveEventListeners:function(){wt.removeEventListenersRegistered||(he.push(wt.removeAllEventListeners),wt.removeEventListenersRegistered=!0)},deferredCalls:[],deferCall:function(e,t,n){function r(e,t){if(e.length!=t.length)return!1;for(var n in e)if(e[n]!=t[n])return!1;return!0}for(var a in wt.deferredCalls){var s=wt.deferredCalls[a];if(s.targetFunction==e&&r(s.argsList,n))return}wt.deferredCalls.push({targetFunction:e,precedence:t,argsList:n}),wt.deferredCalls.sort((function(e,t){return e.precedence<t.precedence}))},removeDeferredCalls:function(e){for(var t=0;t<wt.deferredCalls.length;++t)wt.deferredCalls[t].targetFunction==e&&(wt.deferredCalls.splice(t,1),--t)},canPerformEventHandlerRequests:function(){return wt.inEventHandler&&wt.currentEventHandler.allowsDeferredCalls},runDeferredCalls:function(){if(wt.canPerformEventHandlerRequests())for(var e=0;e<wt.deferredCalls.length;++e){var t=wt.deferredCalls[e];wt.deferredCalls.splice(e,1),--e,t.targetFunction.apply(null,t.argsList)}},eventHandlers:[],removeAllHandlersOnTarget:function(e,t){for(var n=0;n<wt.eventHandlers.length;++n)wt.eventHandlers[n].target==e&&(!t||t==wt.eventHandlers[n].eventTypeString)&&wt._removeHandler(n--)},_removeHandler:function(e){var t=wt.eventHandlers[e];t.target.removeEventListener(t.eventTypeString,t.eventListenerFunc,t.useCapture),wt.eventHandlers.splice(e,1)},registerOrRemoveHandler:function(e){var t=function(t){++wt.inEventHandler,wt.currentEventHandler=e,wt.runDeferredCalls(),e.handlerFunc(t),wt.runDeferredCalls(),--wt.inEventHandler};if(e.callbackfunc)e.eventListenerFunc=t,e.target.addEventListener(e.eventTypeString,t,e.useCapture),wt.eventHandlers.push(e),wt.registerRemoveEventListeners();else for(var n=0;n<wt.eventHandlers.length;++n)wt.eventHandlers[n].target==e.target&&wt.eventHandlers[n].eventTypeString==e.eventTypeString&&wt._removeHandler(n--)},queueEventHandlerOnThread_iiii:function(e,t,n,r,a){ze((function(){var s=cn(12);i()[s>>2]=n,i()[s+4>>2]=r,i()[s+8>>2]=a,an(e,637534208,t,r,s)}))},getTargetThreadForEventCallback:function(e){switch(e){case 1:return 0;case 2:return He.currentProxiedOperationCallerThread;default:return e}},getNodeNameForTarget:function(e){return e?e==window?"#window":e==screen?"#screen":e&&e.nodeName?e.nodeName:"":""},fullscreenEnabled:function(){return document.fullscreenEnabled||document.webkitFullscreenEnabled}};function xt(e){var t=ee(e)+1,n=Yt(t);return Q(e,n,t),n}function vt(e,t,n,r){ze((function(){var a=cn(12),s=0;t&&(s=xt(t)),i()[a>>2]=s,i()[a+4>>2]=n,i()[a+8>>2]=r,an(e,657457152,0,s,a)}))}function kt(e,t,n,r){t=t?J(t):"",vt(e,t,n,r)}function It(e){return e>2?J(e):e}var St=[0,"undefined"!=typeof document?document:0,"undefined"!=typeof window?window:0];function Nt(e){e=It(e);var t=St[e]||("undefined"!=typeof document?document.querySelector(e):void 0);return t}function Tt(e){return Nt(e)}function _t(e,t,n){var r=Tt(e);if(!r)return-4;if(r.canvasSharedPtr&&(i()[r.canvasSharedPtr>>2]=t,i()[r.canvasSharedPtr+4>>2]=n),!r.offscreenCanvas&&r.controlTransferredOffscreen){if(r.canvasSharedPtr){var a=i()[r.canvasSharedPtr+8>>2];return kt(a,e,t,n),1}return-4}r.offscreenCanvas&&(r=r.offscreenCanvas);var s=!1;if(r.GLctxObject&&r.GLctxObject.GLctx){var o=r.GLctxObject.GLctx.getParameter(2978);s=0===o[0]&&0===o[1]&&o[2]===r.width&&o[3]===r.height}return r.width=t,r.height=n,s&&r.GLctxObject.GLctx.viewport(0,0,t,n),0}function Ct(e,t,n){return S?ft(2,1,e,t,n):_t(e,t,n)}function Et(e,t,n){var r=Tt(e);return r?_t(e,t,n):Ct(e,t,n)}function At(){throw"unwind"}function $t(e){var t=e.getExtension("ANGLE_instanced_arrays");if(t)return e.vertexAttribDivisor=function(e,n){t.vertexAttribDivisorANGLE(e,n)},e.drawArraysInstanced=function(e,n,r,a){t.drawArraysInstancedANGLE(e,n,r,a)},e.drawElementsInstanced=function(e,n,r,a,s){t.drawElementsInstancedANGLE(e,n,r,a,s)},1}function Ft(e){var t=e.getExtension("OES_vertex_array_object");if(t)return e.createVertexArray=function(){return t.createVertexArrayOES()},e.deleteVertexArray=function(e){t.deleteVertexArrayOES(e)},e.bindVertexArray=function(e){t.bindVertexArrayOES(e)},e.isVertexArray=function(e){return t.isVertexArrayOES(e)},1}function Rt(e){var t=e.getExtension("WEBGL_draw_buffers");if(t)return e.drawBuffers=function(e,n){t.drawBuffersWEBGL(e,n)},1}function Dt(e){return!!(e.multiDrawWebgl=e.getExtension("WEBGL_multi_draw"))}var Mt={counter:1,buffers:[],programs:[],framebuffers:[],renderbuffers:[],textures:[],shaders:[],vaos:[],contexts:{},offscreenCanvases:{},queries:[],stringCache:{},unpackAlignment:4,recordError:function(e){Mt.lastError||(Mt.lastError=e)},getNewId:function(e){for(var t=Mt.counter++,n=e.length;n<t;n++)e[n]=null;return t},getSource:function(e,t,n,r){for(var a="",s=0;s<t;++s){var o=r?i()[r+4*s>>2]:-1;a+=J(i()[n+4*s>>2],o<0?void 0:o)}return a},createContext:function(e,t){e.getContextSafariWebGL2Fixed||(e.getContextSafariWebGL2Fixed=e.getContext,e.getContext=function(t,n){var r=e.getContextSafariWebGL2Fixed(t,n);return"webgl"==t==r instanceof WebGLRenderingContext?r:null});var n=e.getContext("webgl",t);if(!n)return 0;var r=Mt.registerContext(n,t);return r},registerContext:function(e,t){var n=Yt(8);i()[n+4>>2]=Qt();var r={handle:n,attributes:t,version:t.majorVersion,GLctx:e};return e.canvas&&(e.canvas.GLctxObject=r),Mt.contexts[n]=r,("undefined"==typeof t.enableExtensionsByDefault||t.enableExtensionsByDefault)&&Mt.initExtensions(r),n},makeContextCurrent:function(e){return Mt.currentContext=Mt.contexts[e],p.ctx=Gt=Mt.currentContext&&Mt.currentContext.GLctx,!(e&&!Gt)},getContext:function(e){return Mt.contexts[e]},deleteContext:function(e){Mt.currentContext===Mt.contexts[e]&&(Mt.currentContext=null),"object"==typeof wt&&wt.removeAllHandlersOnTarget(Mt.contexts[e].GLctx.canvas),Mt.contexts[e]&&Mt.contexts[e].GLctx.canvas&&(Mt.contexts[e].GLctx.canvas.GLctxObject=void 0),Jt(Mt.contexts[e].handle),Mt.contexts[e]=null},initExtensions:function(e){if(e||(e=Mt.currentContext),!e.initExtensionsDone){e.initExtensionsDone=!0;var t=e.GLctx;$t(t),Ft(t),Rt(t),t.disjointTimerQueryExt=t.getExtension("EXT_disjoint_timer_query"),Dt(t);var n=t.getSupportedExtensions()||[];n.forEach((function(e){!e.includes("lose_context")&&!e.includes("debug")&&t.getExtension(e)}))}}},Ot=["default","low-power","high-performance"];function Lt(e,t){var n=t>>2,r=i()[n+6],a={alpha:!!i()[n+0],depth:!!i()[n+1],stencil:!!i()[n+2],antialias:!!i()[n+3],premultipliedAlpha:!!i()[n+4],preserveDrawingBuffer:!!i()[n+5],powerPreference:Ot[r],failIfMajorPerformanceCaveat:!!i()[n+7],majorVersion:i()[n+8],minorVersion:i()[n+9],enableExtensionsByDefault:i()[n+10],explicitSwapControl:i()[n+11],proxyContextToMainThread:i()[n+12],renderViaOffscreenBackBuffer:i()[n+13]},s=Tt(e);if(!s||a.explicitSwapControl)return 0;var o=Mt.createContext(s,a);return o}function Pt(e,t){return Lt(e,t)}var zt={mappings:{},buffers:[null,[],[]],printChar:function(e,t){var n=zt.buffers[e];0===t||10===t?((1===e?A:$)(Y(n,0)),n.length=0):n.push(t)},varargs:void 0,get:function(){zt.varargs+=4;var e=i()[zt.varargs-4>>2];return e},getStr:function(e){var t=J(e);return t},get64:function(e,t){return e}};function Bt(e){return S?ft(3,1,e):0}function Wt(e,t,n,r,a){if(S)return ft(4,1,e,t,n,r,a)}function Vt(e,t,n,r){if(S)return ft(5,1,e,t,n,r);for(var a=0,o=0;o<n;o++){var l=i()[t>>2],u=i()[t+4>>2];t+=8;for(var c=0;c<u;c++)zt.printChar(e,s()[l+c]);a+=u}return i()[r>>2]=a,0}function Ut(e){D(e)}He.init();var Gt,Ht,jt,qt,Kt=[null,qe,Ct,Bt,Wt,Vt],Xt={__clock_gettime:nt,__emscripten_init_main_thread_js:rt,__emscripten_thread_cleanup:at,__pthread_create_js:it,_emscripten_default_pthread_stack_size:ot,_emscripten_notify_thread_queue:lt,abort:ut,emscripten_check_blocking_allowed:ct,emscripten_get_heap_max:pt,emscripten_get_now:Ke,emscripten_memcpy_big:dt,emscripten_num_logical_cores:ht,emscripten_receive_on_main_thread_js:gt,emscripten_resize_heap:bt,emscripten_set_canvas_element_size:Et,emscripten_unwind_to_js_event_loop:At,emscripten_webgl_create_context:Pt,exit:Ue,fd_close:Bt,fd_seek:Wt,fd_write:Vt,memory:O||p.wasmMemory,setTempRet0:Ut},Yt=(Oe(),p.___wasm_call_ctors=function(){return(p.___wasm_call_ctors=p.asm.__wasm_call_ctors).apply(null,arguments)},p._init=function(){return(p._init=p.asm.init).apply(null,arguments)},p._init_with_threads_count=function(){return(p._init_with_threads_count=p.asm.init_with_threads_count).apply(null,arguments)},p._get_threads_count=function(){return(p._get_threads_count=p.asm.get_threads_count).apply(null,arguments)},p._register_tensor=function(){return(p._register_tensor=p.asm.register_tensor).apply(null,arguments)},p._dispose_data=function(){return(p._dispose_data=p.asm.dispose_data).apply(null,arguments)},p._dispose=function(){return(p._dispose=p.asm.dispose).apply(null,arguments)},p._Abs=function(){return(p._Abs=p.asm.Abs).apply(null,arguments)},p._Add=function(){return(p._Add=p.asm.Add).apply(null,arguments)},p._AddN=function(){return(p._AddN=p.asm.AddN).apply(null,arguments)},p._All=function(){return(p._All=p.asm.All).apply(null,arguments)},p._Any=function(){return(p._Any=p.asm.Any).apply(null,arguments)},p._ArgMax=function(){return(p._ArgMax=p.asm.ArgMax).apply(null,arguments)},p._AvgPool=function(){return(p._AvgPool=p.asm.AvgPool).apply(null,arguments)},p._BatchMatMul=function(){return(p._BatchMatMul=p.asm.BatchMatMul).apply(null,arguments)},p._Ceil=function(){return(p._Ceil=p.asm.Ceil).apply(null,arguments)},p._ClipByValue=function(){return(p._ClipByValue=p.asm.ClipByValue).apply(null,arguments)},p._Conv2D=function(){return(p._Conv2D=p.asm.Conv2D).apply(null,arguments)},p._Conv2DBackpropInput=function(){return(p._Conv2DBackpropInput=p.asm.Conv2DBackpropInput).apply(null,arguments)},p._Cos=function(){return(p._Cos=p.asm.Cos).apply(null,arguments)},p._Cosh=function(){return(p._Cosh=p.asm.Cosh).apply(null,arguments)},p._CropAndResize=function(){return(p._CropAndResize=p.asm.CropAndResize).apply(null,arguments)},p._Cumprod=function(){return(p._Cumprod=p.asm.Cumprod).apply(null,arguments)},p._Cumsum=function(){return(p._Cumsum=p.asm.Cumsum).apply(null,arguments)},p._DepthToSpace=function(){return(p._DepthToSpace=p.asm.DepthToSpace).apply(null,arguments)},p._DepthwiseConv2dNative=function(){return(p._DepthwiseConv2dNative=p.asm.DepthwiseConv2dNative).apply(null,arguments)},p._Elu=function(){return(p._Elu=p.asm.Elu).apply(null,arguments)},p._Equal=function(){return(p._Equal=p.asm.Equal).apply(null,arguments)},p._Exp=function(){return(p._Exp=p.asm.Exp).apply(null,arguments)},p._FlipLeftRight=function(){return(p._FlipLeftRight=p.asm.FlipLeftRight).apply(null,arguments)},p._Floor=function(){return(p._Floor=p.asm.Floor).apply(null,arguments)},p._FloorDiv=function(){return(p._FloorDiv=p.asm.FloorDiv).apply(null,arguments)},p._FusedBatchNorm=function(){return(p._FusedBatchNorm=p.asm.FusedBatchNorm).apply(null,arguments)},p._FusedConv2D=function(){return(p._FusedConv2D=p.asm.FusedConv2D).apply(null,arguments)},p._FusedDepthwiseConv2D=function(){return(p._FusedDepthwiseConv2D=p.asm.FusedDepthwiseConv2D).apply(null,arguments)},p._Gather=function(){return(p._Gather=p.asm.Gather).apply(null,arguments)},p._GatherNd=function(){return(p._GatherNd=p.asm.GatherNd).apply(null,arguments)},p._Greater=function(){return(p._Greater=p.asm.Greater).apply(null,arguments)},p._GreaterEqual=function(){return(p._GreaterEqual=p.asm.GreaterEqual).apply(null,arguments)},p._LeakyRelu=function(){return(p._LeakyRelu=p.asm.LeakyRelu).apply(null,arguments)},p._Less=function(){return(p._Less=p.asm.Less).apply(null,arguments)},p._LessEqual=function(){return(p._LessEqual=p.asm.LessEqual).apply(null,arguments)},p._Log=function(){return(p._Log=p.asm.Log).apply(null,arguments)},p._LogicalAnd=function(){return(p._LogicalAnd=p.asm.LogicalAnd).apply(null,arguments)},p._Max=function(){return(p._Max=p.asm.Max).apply(null,arguments)},p._MaxPool=function(){return(p._MaxPool=p.asm.MaxPool).apply(null,arguments)},p._Maximum=function(){return(p._Maximum=p.asm.Maximum).apply(null,arguments)},p._Mean=function(){return(p._Mean=p.asm.Mean).apply(null,arguments)},p._Min=function(){return(p._Min=p.asm.Min).apply(null,arguments)},p._Minimum=function(){return(p._Minimum=p.asm.Minimum).apply(null,arguments)},p._MirrorPad=function(){return(p._MirrorPad=p.asm.MirrorPad).apply(null,arguments)},p._Multiply=function(){return(p._Multiply=p.asm.Multiply).apply(null,arguments)},p._Neg=function(){return(p._Neg=p.asm.Neg).apply(null,arguments)},p._NonMaxSuppressionV3=function(){return(p._NonMaxSuppressionV3=p.asm.NonMaxSuppressionV3).apply(null,arguments)},p._NonMaxSuppressionV4=function(){return(p._NonMaxSuppressionV4=p.asm.NonMaxSuppressionV4).apply(null,arguments)},p._NonMaxSuppressionV5=function(){return(p._NonMaxSuppressionV5=p.asm.NonMaxSuppressionV5).apply(null,arguments)},p._NotEqual=function(){return(p._NotEqual=p.asm.NotEqual).apply(null,arguments)},p._OneHot=function(){return(p._OneHot=p.asm.OneHot).apply(null,arguments)},p._PadV2=function(){return(p._PadV2=p.asm.PadV2).apply(null,arguments)},p._Pow=function(){return(p._Pow=p.asm.Pow).apply(null,arguments)},p._Prelu=function(){return(p._Prelu=p.asm.Prelu).apply(null,arguments)},p._Prod=function(){return(p._Prod=p.asm.Prod).apply(null,arguments)},p._RealDiv=function(){return(p._RealDiv=p.asm.RealDiv).apply(null,arguments)},p._Relu=function(){return(p._Relu=p.asm.Relu).apply(null,arguments)},p._Relu6=function(){return(p._Relu6=p.asm.Relu6).apply(null,arguments)},p._ResizeBilinear=function(){return(p._ResizeBilinear=p.asm.ResizeBilinear).apply(null,arguments)},p._Reverse=function(){return(p._Reverse=p.asm.Reverse).apply(null,arguments)},p._RotateWithOffset=function(){return(p._RotateWithOffset=p.asm.RotateWithOffset).apply(null,arguments)},p._Round=function(){return(p._Round=p.asm.Round).apply(null,arguments)},p._Rsqrt=function(){return(p._Rsqrt=p.asm.Rsqrt).apply(null,arguments)},p._ScatterNd=function(){return(p._ScatterNd=p.asm.ScatterNd).apply(null,arguments)},p._SelectV2=function(){return(p._SelectV2=p.asm.SelectV2).apply(null,arguments)},p._Sigmoid=function(){return(p._Sigmoid=p.asm.Sigmoid).apply(null,arguments)},p._Sin=function(){return(p._Sin=p.asm.Sin).apply(null,arguments)},p._Softmax=function(){return(p._Softmax=p.asm.Softmax).apply(null,arguments)},p._SparseFillEmptyRows=function(){return(p._SparseFillEmptyRows=p.asm.SparseFillEmptyRows).apply(null,arguments)},p._SparseReshape=function(){return(p._SparseReshape=p.asm.SparseReshape).apply(null,arguments)},p._SparseSegmentReduction=function(){return(p._SparseSegmentReduction=p.asm.SparseSegmentReduction).apply(null,arguments)},p._Sqrt=function(){return(p._Sqrt=p.asm.Sqrt).apply(null,arguments)},p._Square=function(){return(p._Square=p.asm.Square).apply(null,arguments)},p._SquaredDifference=function(){return(p._SquaredDifference=p.asm.SquaredDifference).apply(null,arguments)},p._Step=function(){return(p._Step=p.asm.Step).apply(null,arguments)},p._StridedSlice=function(){return(p._StridedSlice=p.asm.StridedSlice).apply(null,arguments)},p._Sub=function(){return(p._Sub=p.asm.Sub).apply(null,arguments)},p._Sum=function(){return(p._Sum=p.asm.Sum).apply(null,arguments)},p._Tan=function(){return(p._Tan=p.asm.Tan).apply(null,arguments)},p._Tanh=function(){return(p._Tanh=p.asm.Tanh).apply(null,arguments)},p._Tile=function(){return(p._Tile=p.asm.Tile).apply(null,arguments)},p._TopK=function(){return(p._TopK=p.asm.TopK).apply(null,arguments)},p._Transform=function(){return(p._Transform=p.asm.Transform).apply(null,arguments)},p._Transpose=function(){return(p._Transpose=p.asm.Transpose).apply(null,arguments)},p.__FusedMatMul=function(){return(p.__FusedMatMul=p.asm._FusedMatMul).apply(null,arguments)},p._malloc=function(){return(Yt=p._malloc=p.asm.malloc).apply(null,arguments)}),Jt=p._free=function(){return(Jt=p._free=p.asm.free).apply(null,arguments)},Zt=(p._emscripten_tls_init=function(){return(p._emscripten_tls_init=p.asm.emscripten_tls_init).apply(null,arguments)},p.___errno_location=function(){return(Zt=p.___errno_location=p.asm.__errno_location).apply(null,arguments)}),Qt=p._pthread_self=function(){return(Qt=p._pthread_self=p.asm.pthread_self).apply(null,arguments)},en=p._emscripten_main_thread_process_queued_calls=function(){return(en=p._emscripten_main_thread_process_queued_calls=p.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},tn=(p.__emscripten_thread_crashed=function(){return(p.__emscripten_thread_crashed=p.asm._emscripten_thread_crashed).apply(null,arguments)},p.__emscripten_thread_init=function(){return(tn=p.__emscripten_thread_init=p.asm._emscripten_thread_init).apply(null,arguments)}),nn=(p._emscripten_current_thread_process_queued_calls=function(){return(p._emscripten_current_thread_process_queued_calls=p.asm.emscripten_current_thread_process_queued_calls).apply(null,arguments)},p._emscripten_main_browser_thread_id=function(){return(p._emscripten_main_browser_thread_id=p.asm.emscripten_main_browser_thread_id).apply(null,arguments)},p._emscripten_sync_run_in_main_thread_2=function(){return(p._emscripten_sync_run_in_main_thread_2=p.asm.emscripten_sync_run_in_main_thread_2).apply(null,arguments)},p._emscripten_sync_run_in_main_thread_4=function(){return(nn=p._emscripten_sync_run_in_main_thread_4=p.asm.emscripten_sync_run_in_main_thread_4).apply(null,arguments)}),rn=p._emscripten_run_in_main_runtime_thread_js=function(){return(rn=p._emscripten_run_in_main_runtime_thread_js=p.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)},an=p._emscripten_dispatch_to_thread_=function(){return(an=p._emscripten_dispatch_to_thread_=p.asm.emscripten_dispatch_to_thread_).apply(null,arguments)},sn=p.__emscripten_thread_free_data=function(){return(sn=p.__emscripten_thread_free_data=p.asm._emscripten_thread_free_data).apply(null,arguments)},on=(p.__emscripten_thread_exit=function(){return(p.__emscripten_thread_exit=p.asm._emscripten_thread_exit).apply(null,arguments)},p._memalign=function(){return(p._memalign=p.asm.memalign).apply(null,arguments)},p._emscripten_stack_set_limits=function(){return(on=p._emscripten_stack_set_limits=p.asm.emscripten_stack_set_limits).apply(null,arguments)}),ln=p.stackSave=function(){return(ln=p.stackSave=p.asm.stackSave).apply(null,arguments)},un=p.stackRestore=function(){return(un=p.stackRestore=p.asm.stackRestore).apply(null,arguments)},cn=p.stackAlloc=function(){return(cn=p.stackAlloc=p.asm.stackAlloc).apply(null,arguments)},pn=(p.dynCall_iijjiiii=function(){return(p.dynCall_iijjiiii=p.asm.dynCall_iijjiiii).apply(null,arguments)},p.dynCall_jiji=function(){return(p.dynCall_jiji=p.asm.dynCall_jiji).apply(null,arguments)},p.__emscripten_allow_main_runtime_queued_calls=21464);function dn(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function hn(e){if(e=e||w,!(Se>0)){if(S)return l(p),be(),void postMessage({cmd:"loaded"});ye(),Se>0||(p.setStatus?(p.setStatus("Running..."),setTimeout((function(){setTimeout((function(){p.setStatus("")}),1),t()}),1)):t())}function t(){Ht||(Ht=!0,p.calledRun=!0,!z&&(be(),l(p),p.onRuntimeInitialized&&p.onRuntimeInitialized(),xe()))}}function fn(e,t){if(P=e,!t&&S)throw qe(e),"unwind";ge()||we(),mn(e)}function mn(e){P=e,ge()||(He.terminateAllThreads(),p.onExit&&p.onExit(e),z=!0),x(e,new dn(e))}if(p.cwrap=q,p.keepRuntimeAlive=ge,p.PThread=He,p.PThread=He,p.wasmMemory=O,p.ExitStatus=dn,Te=function e(){Ht||hn(),Ht||(Te=e)},p.run=hn,p.preInit)for("function"==typeof p.preInit&&(p.preInit=[p.preInit]);p.preInit.length>0;)p.preInit.pop()();if(hn(),c&&(jt={uncaughtException:process.listeners("uncaughtException").filter((function(e){return!c.uncaughtException.indexOf(e)>-1})),unhandledRejection:process.listeners("unhandledRejection").filter((function(e){return!c.unhandledRejection.indexOf(e)>-1}))}),"undefined"!=typeof WasmBackendModule)qt=WasmBackendModule;else{if("undefined"==typeof t)throw new Error("Could not find wasm module in post.js");qt=t}if(jt){var gn=qt._dispose;qt._dispose=function(){gn(),jt.uncaughtException.forEach((function(e){process.removeListener("uncaughtException",e)})),jt.unhandledRejection.forEach((function(e){process.removeListener("unhandledRejection",e)}))}}return t.ready}})();"object"==typeof e&&"object"==typeof t?t.exports=s:"function"==typeof define&&n.amdO?define([],(function(){return s})):"object"==typeof e&&(e.WasmBackendModuleThreadedSimd=s)})),j=m(((e,t)=>{var s=(()=>{var e="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0;return e=e||r,function(t){t=t||{};var n,r,s,i="undefined"!=typeof t?t:{};i.ready=new Promise((function(e,t){n=e,r=t})),"undefined"!=typeof process&&process.listeners&&(s={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var o,l,u,c,p,d,h=Object.assign({},i),f=[],m="object"==typeof window,g="function"==typeof importScripts,y="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,b="";function w(e){return i.locateFile?i.locateFile(e,b):b+e}function x(e){e instanceof Oe||k("exiting due to exception: "+e)}y?(b=g?W().dirname(b)+"/":a+"/",d=()=>{p||(c=B(),p=W())},o=function(e,t){return d(),e=p.normalize(e),c.readFileSync(e,t?void 0:"utf8")},u=e=>{var t=o(e,!0);return t.buffer||(t=new Uint8Array(t)),t},l=(e,t,n)=>{d(),e=p.normalize(e),c.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),f=process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof Oe))throw e})),process.on("unhandledRejection",(function(e){throw e})),(e,t)=>{if(Y())throw process.exitCode=e,t;x(t),process.exit(e)},i.inspect=function(){return"[Emscripten Module object]"}):(m||g)&&(g?b=self.location.href:"undefined"!=typeof document&&document.currentScript&&(b=document.currentScript.src),e&&(b=e),b=0!==b.indexOf("blob:")?b.substr(0,b.replace(/[?#].*/,"").lastIndexOf("/")+1):"",o=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},g&&(u=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),l=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var v=i.print||console.log.bind(console),k=i.printErr||console.warn.bind(console);Object.assign(i,h),h=null,i.arguments&&(f=i.arguments),i.thisProgram&&i.thisProgram,i.quit&&i.quit;var I,S=e=>{e};i.wasmBinary&&(I=i.wasmBinary);var N=i.noExitRuntime||!0;"object"!=typeof WebAssembly&&le("no native wasm support detected");var T,_=!1;function C(e){var t=i["_"+e];return t}function E(e,t,n,r,a){var s={string:function(e){var t=0;if(null!=e&&0!==e){var n=1+(e.length<<2);t=Me(n),M(e,t,n)}return t},array:function(e){var t=Me(e.length);return V(e,t),t}};function i(e){return"string"===t?R(e):"boolean"===t?Boolean(e):e}var o=C(e),l=[],u=0;if(r)for(var c=0;c<r.length;c++){var p=s[n[c]];p?(0===u&&(u=Re()),l[c]=p(r[c])):l[c]=r[c]}var d=o.apply(null,l);function h(e){return 0!==u&&De(u),i(e)}return d=h(d),d}function A(e,t,n,r){n=n||[];var a=n.every((function(e){return"number"===e})),s="string"!==t;return s&&a&&!r?C(e):function(){return E(e,t,n,arguments,r)}}var $="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function F(e,t,n){for(var r=t+n,a=t;e[a]&&!(a>=r);)++a;if(a-t>16&&e.subarray&&$)return $.decode(e.subarray(t,a));for(var s="";t<a;){var i=e[t++];if(128&i){var o=63&e[t++];if(192!=(224&i)){var l=63&e[t++];if(i=224==(240&i)?(15&i)<<12|o<<6|l:(7&i)<<18|o<<12|l<<6|63&e[t++],i<65536)s+=String.fromCharCode(i);else{var u=i-65536;s+=String.fromCharCode(55296|u>>10,56320|1023&u)}}else s+=String.fromCharCode((31&i)<<6|o)}else s+=String.fromCharCode(i)}return s}function R(e,t){return e?F(P,e,t):""}function D(e,t,n,r){if(!(r>0))return 0;for(var a=n,s=n+r-1,i=0;i<e.length;++i){var o=e.charCodeAt(i);if(o>=55296&&o<=57343){var l=e.charCodeAt(++i);o=65536+((1023&o)<<10)|1023&l}if(o<=127){if(n>=s)break;t[n++]=o}else if(o<=2047){if(n+1>=s)break;t[n++]=192|o>>6,t[n++]=128|63&o}else if(o<=65535){if(n+2>=s)break;t[n++]=224|o>>12,t[n++]=128|o>>6&63,t[n++]=128|63&o}else{if(n+3>=s)break;t[n++]=240|o>>18,t[n++]=128|o>>12&63,t[n++]=128|o>>6&63,t[n++]=128|63&o}}return t[n]=0,n-a}function M(e,t,n){return D(e,P,t,n)}var O,L,P,z;"undefined"!=typeof TextDecoder&&new TextDecoder("utf-16le");function V(e,t){L.set(e,t)}function U(e,t){return e%t>0&&(e+=t-e%t),e}function G(e){O=e,i.HEAP8=L=new Int8Array(e),i.HEAP16=new Int16Array(e),i.HEAP32=z=new Int32Array(e),i.HEAPU8=P=new Uint8Array(e),i.HEAPU16=new Uint16Array(e),i.HEAPU32=new Uint32Array(e),i.HEAPF32=new Float32Array(e),i.HEAPF64=new Float64Array(e)}i.INITIAL_MEMORY;var H,j=[],q=[],K=[],X=0;function Y(){return N||X>0}function J(){if(i.preRun)for("function"==typeof i.preRun&&(i.preRun=[i.preRun]);i.preRun.length;)ee(i.preRun.shift());ge(j)}function Z(){!0,ge(q)}function Q(){if(i.postRun)for("function"==typeof i.postRun&&(i.postRun=[i.postRun]);i.postRun.length;)ne(i.postRun.shift());ge(K)}function ee(e){j.unshift(e)}function te(e){q.unshift(e)}function ne(e){K.unshift(e)}var re=0,ae=null,se=null;function ie(e){re++,i.monitorRunDependencies&&i.monitorRunDependencies(re)}function oe(e){if(re--,i.monitorRunDependencies&&i.monitorRunDependencies(re),0==re&&(null!==ae&&(clearInterval(ae),ae=null),se)){var t=se;se=null,t()}}function le(e){i.onAbort&&i.onAbort(e),e="Aborted("+e+")",k(e),_=!0,1,e+=". Build with -s ASSERTIONS=1 for more info.";var t=new WebAssembly.RuntimeError(e);throw r(t),t}i.preloadedImages={},i.preloadedAudios={};var ue,ce="data:application/octet-stream;base64,";function pe(e){return e.startsWith(ce)}function de(e){return e.startsWith("file://")}function he(e){try{if(e==ue&&I)return new Uint8Array(I);if(u)return u(e);throw"both async and sync fetching of the wasm failed"}catch(t){le(t)}}function fe(){if(!I&&(m||g)){if("function"==typeof fetch&&!de(ue))return fetch(ue,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+ue+"'";return e.arrayBuffer()})).catch((function(){return he(ue)}));if(l)return new Promise((function(e,t){l(ue,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return he(ue)}))}function me(){var e={env:Fe,wasi_snapshot_preview1:Fe};function t(e,t){var n=e.exports;i.asm=n,T=i.asm.memory,G(T.buffer),H=i.asm.__indirect_function_table,te(i.asm.__wasm_call_ctors),oe("wasm-instantiate")}function n(e){t(e.instance)}function a(t){return fe().then((function(t){return WebAssembly.instantiate(t,e)})).then((function(e){return e})).then(t,(function(e){k("failed to asynchronously prepare wasm: "+e),le(e)}))}function s(){return I||"function"!=typeof WebAssembly.instantiateStreaming||pe(ue)||de(ue)||"function"!=typeof fetch?a(n):fetch(ue,{credentials:"same-origin"}).then((function(t){var r=WebAssembly.instantiateStreaming(t,e);return r.then(n,(function(e){return k("wasm streaming compile failed: "+e),k("falling back to ArrayBuffer instantiation"),a(n)}))}))}if(ie("wasm-instantiate"),i.instantiateWasm)try{var o=i.instantiateWasm(e,t);return o}catch(l){return k("Module.instantiateWasm callback failed with error: "+l),!1}return s().catch(r),{}}function ge(e){for(;e.length>0;){var t=e.shift();if("function"!=typeof t){var n=t.func;"number"==typeof n?void 0===t.arg?be(n)():be(n)(t.arg):n(void 0===t.arg?null:t.arg)}else t(i)}}ue="tfjs-backend-wasm.wasm",pe(ue)||(ue=w(ue));var ye=[];function be(e){var t=ye[e];return t||(e>=ye.length&&(ye.length=e+1),ye[e]=t=H.get(e)),t}function we(){le("")}function xe(){return 2147483648}function ve(e,t,n){P.copyWithin(e,t,t+n)}function ke(e){try{return T.grow(e-O.byteLength+65535>>>16),G(T.buffer),1}catch(t){}}function Ie(e){var t=P.length;e>>>=0;var n=xe();if(e>n)return!1;for(var r=1;r<=4;r*=2){var a=t*(1+.2/r);a=Math.min(a,e+100663296);var s=Math.min(n,U(Math.max(e,a),65536)),i=ke(s);if(i)return!0}return!1}var Se={mappings:{},buffers:[null,[],[]],printChar:function(e,t){var n=Se.buffers[e];0===t||10===t?((1===e?v:k)(F(n,0)),n.length=0):n.push(t)},varargs:void 0,get:function(){Se.varargs+=4;var e=z[Se.varargs-4>>2];return e},getStr:function(e){var t=R(e);return t},get64:function(e,t){return e}};function Ne(e){return 0}function Te(e,t,n,r,a){}function _e(e,t,n,r){for(var a=0,s=0;s<n;s++){var i=z[t>>2],o=z[t+4>>2];t+=8;for(var l=0;l<o;l++)Se.printChar(e,P[i+l]);a+=o}return z[r>>2]=a,0}function Ce(e){S(e)}var Ee,Ae,$e,Fe={abort:we,emscripten_get_heap_max:xe,emscripten_memcpy_big:ve,emscripten_resize_heap:Ie,fd_close:Ne,fd_seek:Te,fd_write:_e,setTempRet0:Ce},Re=(me(),i.___wasm_call_ctors=function(){return(i.___wasm_call_ctors=i.asm.__wasm_call_ctors).apply(null,arguments)},i._init=function(){return(i._init=i.asm.init).apply(null,arguments)},i._init_with_threads_count=function(){return(i._init_with_threads_count=i.asm.init_with_threads_count).apply(null,arguments)},i._get_threads_count=function(){return(i._get_threads_count=i.asm.get_threads_count).apply(null,arguments)},i._register_tensor=function(){return(i._register_tensor=i.asm.register_tensor).apply(null,arguments)},i._dispose_data=function(){return(i._dispose_data=i.asm.dispose_data).apply(null,arguments)},i._dispose=function(){return(i._dispose=i.asm.dispose).apply(null,arguments)},i._Abs=function(){return(i._Abs=i.asm.Abs).apply(null,arguments)},i._Add=function(){return(i._Add=i.asm.Add).apply(null,arguments)},i._AddN=function(){return(i._AddN=i.asm.AddN).apply(null,arguments)},i._All=function(){return(i._All=i.asm.All).apply(null,arguments)},i._Any=function(){return(i._Any=i.asm.Any).apply(null,arguments)},i._ArgMax=function(){return(i._ArgMax=i.asm.ArgMax).apply(null,arguments)},i._AvgPool=function(){return(i._AvgPool=i.asm.AvgPool).apply(null,arguments)},i._BatchMatMul=function(){return(i._BatchMatMul=i.asm.BatchMatMul).apply(null,arguments)},i._Ceil=function(){return(i._Ceil=i.asm.Ceil).apply(null,arguments)},i._ClipByValue=function(){return(i._ClipByValue=i.asm.ClipByValue).apply(null,arguments)},i._Conv2D=function(){return(i._Conv2D=i.asm.Conv2D).apply(null,arguments)},i._Conv2DBackpropInput=function(){return(i._Conv2DBackpropInput=i.asm.Conv2DBackpropInput).apply(null,arguments)},i._Cos=function(){return(i._Cos=i.asm.Cos).apply(null,arguments)},i._Cosh=function(){return(i._Cosh=i.asm.Cosh).apply(null,arguments)},i._CropAndResize=function(){return(i._CropAndResize=i.asm.CropAndResize).apply(null,arguments)},i._Cumprod=function(){return(i._Cumprod=i.asm.Cumprod).apply(null,arguments)},i._Cumsum=function(){return(i._Cumsum=i.asm.Cumsum).apply(null,arguments)},i._DepthToSpace=function(){return(i._DepthToSpace=i.asm.DepthToSpace).apply(null,arguments)},i._DepthwiseConv2dNative=function(){return(i._DepthwiseConv2dNative=i.asm.DepthwiseConv2dNative).apply(null,arguments)},i._Elu=function(){return(i._Elu=i.asm.Elu).apply(null,arguments)},i._Equal=function(){return(i._Equal=i.asm.Equal).apply(null,arguments)},i._Exp=function(){return(i._Exp=i.asm.Exp).apply(null,arguments)},i._FlipLeftRight=function(){return(i._FlipLeftRight=i.asm.FlipLeftRight).apply(null,arguments)},i._Floor=function(){return(i._Floor=i.asm.Floor).apply(null,arguments)},i._FloorDiv=function(){return(i._FloorDiv=i.asm.FloorDiv).apply(null,arguments)},i._FusedBatchNorm=function(){return(i._FusedBatchNorm=i.asm.FusedBatchNorm).apply(null,arguments)},i._FusedConv2D=function(){return(i._FusedConv2D=i.asm.FusedConv2D).apply(null,arguments)},i._FusedDepthwiseConv2D=function(){return(i._FusedDepthwiseConv2D=i.asm.FusedDepthwiseConv2D).apply(null,arguments)},i._Gather=function(){return(i._Gather=i.asm.Gather).apply(null,arguments)},i._GatherNd=function(){return(i._GatherNd=i.asm.GatherNd).apply(null,arguments)},i._Greater=function(){return(i._Greater=i.asm.Greater).apply(null,arguments)},i._GreaterEqual=function(){return(i._GreaterEqual=i.asm.GreaterEqual).apply(null,arguments)},i._LeakyRelu=function(){return(i._LeakyRelu=i.asm.LeakyRelu).apply(null,arguments)},i._Less=function(){return(i._Less=i.asm.Less).apply(null,arguments)},i._LessEqual=function(){return(i._LessEqual=i.asm.LessEqual).apply(null,arguments)},i._Log=function(){return(i._Log=i.asm.Log).apply(null,arguments)},i._LogicalAnd=function(){return(i._LogicalAnd=i.asm.LogicalAnd).apply(null,arguments)},i._Max=function(){return(i._Max=i.asm.Max).apply(null,arguments)},i._MaxPool=function(){return(i._MaxPool=i.asm.MaxPool).apply(null,arguments)},i._Maximum=function(){return(i._Maximum=i.asm.Maximum).apply(null,arguments)},i._Mean=function(){return(i._Mean=i.asm.Mean).apply(null,arguments)},i._Min=function(){return(i._Min=i.asm.Min).apply(null,arguments)},i._Minimum=function(){return(i._Minimum=i.asm.Minimum).apply(null,arguments)},i._MirrorPad=function(){return(i._MirrorPad=i.asm.MirrorPad).apply(null,arguments)},i._Multiply=function(){return(i._Multiply=i.asm.Multiply).apply(null,arguments)},i._Neg=function(){return(i._Neg=i.asm.Neg).apply(null,arguments)},i._NonMaxSuppressionV3=function(){return(i._NonMaxSuppressionV3=i.asm.NonMaxSuppressionV3).apply(null,arguments)},i._NonMaxSuppressionV4=function(){return(i._NonMaxSuppressionV4=i.asm.NonMaxSuppressionV4).apply(null,arguments)},i._NonMaxSuppressionV5=function(){return(i._NonMaxSuppressionV5=i.asm.NonMaxSuppressionV5).apply(null,arguments)},i._NotEqual=function(){return(i._NotEqual=i.asm.NotEqual).apply(null,arguments)},i._OneHot=function(){return(i._OneHot=i.asm.OneHot).apply(null,arguments)},i._PadV2=function(){return(i._PadV2=i.asm.PadV2).apply(null,arguments)},i._Pow=function(){return(i._Pow=i.asm.Pow).apply(null,arguments)},i._Prelu=function(){return(i._Prelu=i.asm.Prelu).apply(null,arguments)},i._Prod=function(){return(i._Prod=i.asm.Prod).apply(null,arguments)},i._RealDiv=function(){return(i._RealDiv=i.asm.RealDiv).apply(null,arguments)},i._Relu=function(){return(i._Relu=i.asm.Relu).apply(null,arguments)},i._Relu6=function(){return(i._Relu6=i.asm.Relu6).apply(null,arguments)},i._ResizeBilinear=function(){return(i._ResizeBilinear=i.asm.ResizeBilinear).apply(null,arguments)},i._Reverse=function(){return(i._Reverse=i.asm.Reverse).apply(null,arguments)},i._RotateWithOffset=function(){return(i._RotateWithOffset=i.asm.RotateWithOffset).apply(null,arguments)},i._Round=function(){return(i._Round=i.asm.Round).apply(null,arguments)},i._Rsqrt=function(){return(i._Rsqrt=i.asm.Rsqrt).apply(null,arguments)},i._ScatterNd=function(){return(i._ScatterNd=i.asm.ScatterNd).apply(null,arguments)},i._SelectV2=function(){return(i._SelectV2=i.asm.SelectV2).apply(null,arguments)},i._Sigmoid=function(){return(i._Sigmoid=i.asm.Sigmoid).apply(null,arguments)},i._Sin=function(){return(i._Sin=i.asm.Sin).apply(null,arguments)},i._Softmax=function(){return(i._Softmax=i.asm.Softmax).apply(null,arguments)},i._SparseFillEmptyRows=function(){return(i._SparseFillEmptyRows=i.asm.SparseFillEmptyRows).apply(null,arguments)},i._SparseReshape=function(){return(i._SparseReshape=i.asm.SparseReshape).apply(null,arguments)},i._SparseSegmentReduction=function(){return(i._SparseSegmentReduction=i.asm.SparseSegmentReduction).apply(null,arguments)},i._Sqrt=function(){return(i._Sqrt=i.asm.Sqrt).apply(null,arguments)},i._Square=function(){return(i._Square=i.asm.Square).apply(null,arguments)},i._SquaredDifference=function(){return(i._SquaredDifference=i.asm.SquaredDifference).apply(null,arguments)},i._Step=function(){return(i._Step=i.asm.Step).apply(null,arguments)},i._StridedSlice=function(){return(i._StridedSlice=i.asm.StridedSlice).apply(null,arguments)},i._Sub=function(){return(i._Sub=i.asm.Sub).apply(null,arguments)},i._Sum=function(){return(i._Sum=i.asm.Sum).apply(null,arguments)},i._Tan=function(){return(i._Tan=i.asm.Tan).apply(null,arguments)},i._Tanh=function(){return(i._Tanh=i.asm.Tanh).apply(null,arguments)},i._Tile=function(){return(i._Tile=i.asm.Tile).apply(null,arguments)},i._TopK=function(){return(i._TopK=i.asm.TopK).apply(null,arguments)},i._Transform=function(){return(i._Transform=i.asm.Transform).apply(null,arguments)},i._Transpose=function(){return(i._Transpose=i.asm.Transpose).apply(null,arguments)},i.__FusedMatMul=function(){return(i.__FusedMatMul=i.asm._FusedMatMul).apply(null,arguments)},i._malloc=function(){return(i._malloc=i.asm.malloc).apply(null,arguments)},i._free=function(){return(i._free=i.asm.free).apply(null,arguments)},i.___errno_location=function(){return(i.___errno_location=i.asm.__errno_location).apply(null,arguments)},i._emscripten_main_thread_process_queued_calls=function(){return(i._emscripten_main_thread_process_queued_calls=i.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},i.stackSave=function(){return(Re=i.stackSave=i.asm.stackSave).apply(null,arguments)}),De=i.stackRestore=function(){return(De=i.stackRestore=i.asm.stackRestore).apply(null,arguments)},Me=i.stackAlloc=function(){return(Me=i.stackAlloc=i.asm.stackAlloc).apply(null,arguments)};i.dynCall_iijjiiii=function(){return(i.dynCall_iijjiiii=i.asm.dynCall_iijjiiii).apply(null,arguments)},i.dynCall_jiji=function(){return(i.dynCall_jiji=i.asm.dynCall_jiji).apply(null,arguments)};function Oe(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function Le(e){function t(){Ee||(Ee=!0,i.calledRun=!0,!_&&(Z(),n(i),i.onRuntimeInitialized&&i.onRuntimeInitialized(),Q()))}e=e||f,re>0||(J(),re>0)||(i.setStatus?(i.setStatus("Running..."),setTimeout((function(){setTimeout((function(){i.setStatus("")}),1),t()}),1)):t())}if(i.cwrap=A,se=function e(){Ee||Le(),Ee||(se=e)},i.run=Le,i.preInit)for("function"==typeof i.preInit&&(i.preInit=[i.preInit]);i.preInit.length>0;)i.preInit.pop()();if(Le(),s&&(Ae={uncaughtException:process.listeners("uncaughtException").filter((function(e){return!s.uncaughtException.indexOf(e)>-1})),unhandledRejection:process.listeners("unhandledRejection").filter((function(e){return!s.unhandledRejection.indexOf(e)>-1}))}),"undefined"!=typeof t)$e=t;else{if("undefined"==typeof WasmBackendModuleThreadedSimd)throw new Error("Could not find wasm module in post.js");$e=WasmBackendModuleThreadedSimd}if(Ae){var Pe=$e._dispose;$e._dispose=function(){Pe(),Ae.uncaughtException.forEach((function(e){process.removeListener("uncaughtException",e)})),Ae.unhandledRejection.forEach((function(e){process.removeListener("unhandledRejection",e)}))}}return t.ready}})();"object"==typeof e&&"object"==typeof t?t.exports=s:"function"==typeof define&&n.amdO?define([],(function(){return s})):"object"==typeof e&&(e.WasmBackendModule=s)})),q=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},K=class{refCount(e){return X("refCount")}incRef(e){return X("incRef")}timerAvailable(){return!0}time(e){return X("time")}read(e){return X("read")}readSync(e){return X("readSync")}readToGPU(e,t){return X("readToGPU")}numDataIds(){return X("numDataIds")}disposeData(e,t){return X("disposeData")}write(e,t,n){return X("write")}move(e,t,n,r,a){return X("move")}memory(){return X("memory")}floatPrecision(){return X("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return X("dispose")}};function X(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Y(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,ee(e,t,n)}function J(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,ee(e,n,r),ee(t,n,r)}function Z(e,t,n){return Math.max(e,Math.min(t,n))}function Q(e){return e%2===0?e:e+1}function ee(e,t,n){let r=e[t];e[t]=e[n],e[n]=r}function te(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function ne(e,t){let n=Math.random();return t*n+(1-n)*e}function re(e,t){let n=0;for(let r=0;r<e.length;r++){let a=Number(e[r])-Number(t[r]);n+=a*a}return n}function ae(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function se(e,t,n=""){ae(ce(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function ie(e){ae(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function oe(e,t=[],n=!1){if(null==t&&(t=[]),Array.isArray(e)||Ne(e)&&!n)for(let r=0;r<e.length;++r)oe(e[r],t,n);else t.push(e);return t}function le(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function ue(e){return 0===e.length}function ce(e,t){if(e===t)return!0;if(null==e||null==t||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function pe(e){return e%1===0}function de(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function he(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function fe(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return Y(t),t}function me(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function ge(e,t=(e=>0),n){return new Promise(((r,a)=>{let s=0,i=()=>{if(e())return void r();s++;let o=t(s);null!=n&&s>=n?a():setTimeout(i,o)};i()}))}function ye(e,t){let n=1,r=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)n*=e[s];else if(-1===e[s]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);r=s}else if(e[s]<0)throw Error(`Shapes can not be < 0. Found ${e[s]} at dim ${s}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let a=e.slice();return a[r]=t/n,a}function be(e,t){let n=t.length;return e=null==e?t.map(((e,t)=>t)):[].concat(e),ae(e.every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),ae(e.every((e=>pe(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function we(e,t){let n=[],r=[],a=null!=t&&Array.isArray(t)&&0===t.length,s=null==t||a?null:be(t,e).sort(),i=0;for(let o=0;o<e.length;++o){if(null!=s){if(s[i]===o&&1!==e[o])throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(null==s[i]||s[i]>o)&&1===e[o]&&(n.push(e[o]),r.push(o)),s[i]<=o&&i++}1!==e[o]&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function xe(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else{if("bool"!==e)throw new Error(`Unknown data type ${e}`);n=new Uint8Array(t)}return n}function ve(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function ke(e,t){for(let n=0;n<e.length;n++){let r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function Ie(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function Se(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function Ne(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}function Te(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function _e(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}function Ce(e){return"string"==typeof e||e instanceof String}function Ee(e){return"boolean"==typeof e}function Ae(e){return"number"==typeof e}function $e(e){return Array.isArray(e)?$e(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":Ae(e)?"float32":Ce(e)?"string":Ee(e)?"bool":"float32"}function Fe(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Re(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function De(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function Me(e,t,n,r=!1){let a=new Array;if(1===t.length){let s=t[0]*(r?2:1);for(let t=0;t<s;t++)a[t]=n[e+t]}else{let s=t[0],i=t.slice(1),o=i.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<s;t++)a[t]=Me(e+t*o,i,n,r)}return a}function Oe(e,t,n=!1){if(0===e.length)return t[0];let r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return Me(0,e,t,n)}function Le(e,t){let n=Pe(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function Pe(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function ze(e,t){let n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return Oe(e,new Float32Array(n));if("int32"===t)return Oe(e,new Int32Array(n));if("bool"===t)return Oe(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function Be(e){e.forEach((t=>{ae(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function We(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let a=0;a<e.length-1;++a)r+=n[a]*e[a];return r}function Ve(e,t,n){if(0===t)return[];if(1===t)return[e];let r=new Array(t);for(let a=0;a<r.length-1;++a)r[a]=Math.floor(e/n[a]),e-=r[a]*n[a];return r[r.length-1]=e,r}function Ue(e){return e&&e.then&&"function"==typeof e.then}var Ge="tfjsflags",He=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=je,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(Xe().getBool("IS_TEST")||Xe().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){let t=this.urlFlags[e];Xe().getBool("IS_TEST")||Xe().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(Ue(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"==typeof this.global||"undefined"==typeof this.global.location||"undefined"==typeof this.global.location.search)return;let e=this.getQueryParams(this.global.location.search);Ge in e&&e[Ge].split(",").forEach((e=>{let[t,n]=e.split(":");this.urlFlags[t]=Ke(t,n)}))}};function je(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,((e,...n)=>(qe(t,n[0],n[1]),n.join("=")))),t}function qe(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function Ke(e,t){if(t=t.toLowerCase(),"true"===t||"false"===t)return"true"===t;if(""+ +t===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}function Xe(){return Je}var Ye,Je=null;function Ze(e){Je=e}function Qe(){if(null==Ye){let e;if("undefined"!=typeof window)e=window;else if("undefined"!=typeof n.g)e=n.g;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}Ye=e}return Ye}function et(){let e=Qe();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}function tt(e,t){let n=et();if(n.has(e))return n.get(e);{let r=t();return n.set(e,r),n.get(e)}}var nt="Abs",rt="Acos",at="Acosh",st="Add",it="AddN",ot="All",lt="Any",ut="ArgMax",ct="ArgMin",pt="Asin",dt="Asinh",ht="Atan",ft="Atanh",mt="Atan2",gt="AvgPool",yt="AvgPoolGrad",bt="AvgPool3D",wt="AvgPool3DGrad",xt="BatchMatMul",vt="BatchToSpaceND",kt="Bincount",It="BroadcastTo",St="BroadcastArgs",Nt="Cast",Tt="Ceil",_t="ClipByValue",Ct="Complex",Et="ComplexAbs",At="Concat",$t="Conv2D",Ft="Conv2DBackpropFilter",Rt="Conv2DBackpropInput",Dt="Conv3D",Mt="Conv3DBackpropFilterV2",Ot="Conv3DBackpropInputV2",Lt="Cos",Pt="Cosh",zt="Cumprod",Bt="Cumsum",Wt="CropAndResize",Vt="DenseBincount",Ut="DepthToSpace",Gt="DepthwiseConv2dNative",Ht="DepthwiseConv2dNativeBackpropFilter",jt="DepthwiseConv2dNativeBackpropInput",qt="Diag",Kt="Dilation2D",Xt="Dilation2DBackpropInput",Yt="Dilation2DBackpropFilter",Jt="RealDiv",Zt="Einsum",Qt="Elu",en="EluGrad",tn="Erf",nn="Equal",rn="Exp",an="ExpandDims",sn="Expm1",on="FFT",ln="Fill",un="FlipLeftRight",cn="Floor",pn="FloorDiv",dn="FusedBatchNorm",hn="GatherV2",fn="GatherNd",mn="Greater",gn="GreaterEqual",yn="Identity",bn="IFFT",wn="Imag",xn="IsFinite",vn="IsInf",kn="IsNan",In="LeakyRelu",Sn="Less",Nn="LessEqual",Tn="LinSpace",_n="Log",Cn="Log1p",En="LogicalAnd",An="LogicalNot",$n="LogicalOr",Fn="LogSoftmax",Rn="LowerBound",Dn="LRN",Mn="LRNGrad",On="Max",Ln="Maximum",Pn="MaxPool",zn="MaxPoolGrad",Bn="MaxPool3D",Wn="MaxPool3DGrad",Vn="MaxPoolWithArgmax",Un="Mean",Gn="Min",Hn="Minimum",jn="MirrorPad",qn="Mod",Kn="Multinomial",Xn="Multiply",Yn="Neg",Jn="NotEqual",Zn="NonMaxSuppressionV3",Qn="NonMaxSuppressionV4",er="NonMaxSuppressionV5",tr="OnesLike",nr="OneHot",rr="Pack",ar="PadV2",sr="Pool",ir="Pow",or="Prelu",lr="Prod",ur="Range",cr="Real",pr="Reciprocal",dr="Relu",hr="Reshape",fr="ResizeNearestNeighbor",mr="ResizeNearestNeighborGrad",gr="ResizeBilinear",yr="ResizeBilinearGrad",br="Relu6",wr="Reverse",xr="Round",vr="Rsqrt",kr="ScatterNd",Ir="SearchSorted",Sr="Select",Nr="Selu",Tr="Slice",_r="Sin",Cr="Sinh",Er="Sign",Ar="Sigmoid",$r="Softplus",Fr="Sqrt",Rr="Sum",Dr="SpaceToBatchND",Mr="SplitV",Or="Softmax",Lr="SparseFillEmptyRows",Pr="SparseReshape",zr="SparseSegmentMean",Br="SparseSegmentSum",Wr="SparseToDense",Vr="SquaredDifference",Ur="Square",Gr="StridedSlice",Hr="StringNGrams",jr="StringSplit",qr="StringToHashBucketFast",Kr="Sub",Xr="Tan",Yr="Tanh",Jr="Tile",Zr="TopK",Qr="Transform",ea="Transpose",ta="Unique",na="Unpack",ra="UnsortedSegmentSum",aa="UpperBound",sa="ZerosLike",ia="Step",oa="FromPixels",la="RotateWithOffset",ua="_FusedMatMul",ca="FusedConv2D",pa="FusedDepthwiseConv2D";function da(...e){Xe().getBool("IS_TEST")||Xe().getBool("PROD")||console.warn(...e)}function ha(...e){Xe().getBool("IS_TEST")||Xe().getBool("PROD")||console.log(...e)}var fa=tt("kernelRegistry",(()=>new Map)),ma=tt("gradRegistry",(()=>new Map));function ga(e,t){let n=Sa(e,t);return fa.get(n)}function ya(e){return ma.get(e)}function ba(e){let t=fa.entries(),n=[];for(;;){let{done:r,value:a}=t.next();if(r)break;let[s,i]=a,[o]=s.split("_");o===e&&n.push(i)}return n}function wa(e){let{kernelName:t,backendName:n}=e,r=Sa(t,n);fa.has(r)&&da(`The kernel '${t}' for backend '${n}' is already registered`),fa.set(r,e)}function xa(e){let{kernelName:t}=e;ma.has(t)&&Xe().getBool("DEBUG")&&da(`Overriding the gradient for '${t}'`),ma.set(t,e)}function va(e,t){let n=Sa(e,t);if(!fa.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);fa.delete(n)}function ka(e){if(!ma.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);ma.delete(e)}function Ia(e,t){ba(e).forEach((e=>{let n=Object.assign({},e,{backendName:t});wa(n)}))}function Sa(e,t){return`${t}_${e}`}var Na={};g(Na,{arraysEqual:()=>ce,assert:()=>ae,assertNonNegativeIntegerDimensions:()=>Be,assertNonNull:()=>ie,assertShapesMatch:()=>se,bytesFromStringArray:()=>_e,bytesPerElement:()=>Te,checkConversionForErrors:()=>ke,clamp:()=>Z,computeStrides:()=>De,createScalarValue:()=>Ga,createShuffledIndices:()=>fe,decodeString:()=>Ya,distSquared:()=>re,encodeString:()=>Xa,fetch:()=>Ka,fingerPrint64:()=>Ua,flatten:()=>oe,getArrayFromDType:()=>ve,getTypedArrayFromDType:()=>xe,hasEncodingLoss:()=>Se,hexToLong:()=>Ca,indexToLoc:()=>Ve,inferDtype:()=>$e,inferFromImplicitShape:()=>ye,isBoolean:()=>Ee,isFunction:()=>Fe,isInt:()=>pe,isNumber:()=>Ae,isPromise:()=>Ue,isScalarShape:()=>ue,isString:()=>Ce,isTypedArray:()=>Ne,isValidDtype:()=>Ie,locToIndex:()=>We,makeOnesTypedArray:()=>Le,makeZerosNestedTypedArray:()=>ze,makeZerosTypedArray:()=>Pe,nearestDivisor:()=>Re,nearestLargerEven:()=>Q,now:()=>qa,parseAxisParam:()=>be,randUniform:()=>ne,repeatedTry:()=>ge,rightPad:()=>me,shuffle:()=>Y,shuffleCombo:()=>J,sizeFromShape:()=>le,sizeToSquarishShape:()=>he,squeezeShape:()=>we,sum:()=>te,swap:()=>ee,tanh:()=>de,toNestedArray:()=>Oe,toTypedArray:()=>ja});var Ta=b(w()),_a=Ta.default||Ta;function Ca(e){return _a.fromString(e,!0,16)}var Ea=Ca("c3a5c85c97cb3127"),Aa=Ca("b492b66fbe98f273"),$a=Ca("9ae16a3b2f90404f");function Fa(e){return e.xor(e.shru(47))}function Ra(e,t,n){let r=e.slice(t,t+n);return _a.fromBytes(Array.from(r),!0,!0)}function Da(e,t){return Ra(e,t,8)}function Ma(e,t){return Ra(e,t,4)}function Oa(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function La(e,t,n=Ca("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let a=t.xor(r).mul(n);return a=a.xor(a.shru(47)),a=a.mul(n),a}function Pa(e,t,n,r,a,s){a=a.add(e),s=Oa(s.add(a).add(r),21);let i=a;return a=a.add(t),a=a.add(n),s=s.add(Oa(a,44)),[a.add(r),s.add(i)]}function za(e,t,n,r){return Pa(Da(e,t),Da(e,t+8),Da(e,t+16),Da(e,t+24),n,r)}function Ba(e,t=e.length){if(t>=8){let n=$a.add(2*t),r=Da(e,0).add($a),a=Da(e,t-8),s=Oa(a,37).mul(n).add(r),i=Oa(r,25).add(a).mul(n);return La(s,i,n)}if(t>=4){let n=$a.add(2*t),r=Ma(e,0);return La(r.shl(3).add(t),Ma(e,t-4),n)}if(t>0){let n=e[0],r=e[t>>1],a=e[t-1],s=n+(r<<8),i=t+(a<<2);return Fa($a.mul(s).xor(Ea.mul(i))).mul($a)}return $a}function Wa(e,t=e.length){let n=$a.add(2*t),r=Da(e,0).mul(Aa),a=Da(e,8),s=Da(e,t-8).mul(n),i=Da(e,t-16).mul($a);return La(Oa(r.add(a),43).add(Oa(s,30)).add(i),r.add(Oa(a.add($a),18)).add(s),n)}function Va(e,t=e.length){let n=$a.add(2*t),r=Da(e,0).mul($a),a=Da(e,8),s=Da(e,t-8).mul(n),i=Da(e,t-16).mul($a),o=Oa(r.add(a),43).add(Oa(s,30)).add(i),l=La(o,r.add(Oa(a.add($a),18)).add(s),n),u=Da(e,16).mul(n),c=Da(e,24),p=o.add(Da(e,t-32)).mul(n),d=l.add(Da(e,t-24)).mul(n);return La(Oa(u.add(c),43).add(Oa(p,30)).add(d),u.add(Oa(c.add(r),18)).add(p),n)}function Ua(e,t=e.length){let n=_a.fromNumber(81,!0);if(t<=32)return t<=16?Ba(e,t):Wa(e,t);if(t<=64)return Va(e,t);let r=n,a=n.mul(Aa).add(113),s=Fa(a.mul($a).add(113)).mul($a),i=[_a.UZERO,_a.UZERO],o=[_a.UZERO,_a.UZERO];r=r.mul($a).add(Da(e,0));let l=0,u=64*(t-1>>6),c=u+(t-1&63)-63;do{r=Oa(r.add(a).add(i[0]).add(Da(e,l+8)),37).mul(Aa),a=Oa(a.add(i[1]).add(Da(e,l+48)),42).mul(Aa),r=r.xor(o[1]),a=a.add(i[0]).add(Da(e,l+40)),s=Oa(s.add(o[0]),33).mul(Aa),i=za(e,l,i[1].mul(Aa),r.add(o[0])),o=za(e,l+32,s.add(o[1]),a.add(Da(e,l+16))),[s,r]=[r,s],l+=64}while(l!==u);let p=Aa.add(s.and(255).shl(1));return l=c,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=Oa(r.add(a).add(i[0]).add(Da(e,l+8)),37).mul(p),a=Oa(a.add(i[1]).add(Da(e,l+48)),42).mul(p),r=r.xor(o[1].mul(9)),a=a.add(i[0].mul(9).add(Da(e,l+40))),s=Oa(s.add(o[0]),33).mul(p),i=za(e,l,i[1].mul(p),r.add(o[0])),o=za(e,l+32,s.add(o[1]),a.add(Da(e,l+16))),[s,r]=[r,s],La(La(i[0],o[0],p).add(Fa(a).mul(Ea)).add(s),La(i[1],o[1],p).add(r),p)}function Ga(e,t){return"string"===t?Xa(e):ja([e],t)}function Ha(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}function ja(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=oe(e)),Xe().getBool("DEBUG")&&ke(e,t),Ha(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){let t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function qa(){return Xe().platform.now()}function Ka(e,t){return Xe().platform.fetch(e,t)}function Xa(e,t="utf-8"){return t=t||"utf-8",Xe().platform.encode(e,t)}function Ya(e,t="utf-8"){return t=t||"utf-8",Xe().platform.decode(e,t)}var Ja=class{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new Qa)}profileKernel(e,t,n){let r,a,s=()=>{r=n()},i=qa();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(let e of r)e.dataSync();a=Promise.resolve({kernelMs:qa()-i})}if(Xe().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<r.length;o++){let t=r[o];t.data().then((n=>{Za(n,t.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then((e=>e.kernelMs)),extraInfo:a.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:r,inputs:a,extraInfo:s}=e;n.forEach((e=>{Promise.all([e.data(),r,s]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],a,n[2])}))}))}};function Za(e,t,n){if("float32"!==t)return!1;for(let r=0;r<e.length;r++){let t=e[r];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${n}'`),!0}return!1}var Qa=class{logKernelProfile(e,t,n,r,a,s){let i="number"==typeof r?me(`${r}ms`,9):r.error,o=me(e,25),l=t.rank,u=t.size,c=me(t.shape.toString(),14),p="";for(let d in a){let e=a[d];if(null!=e){let n=e.shape||t.shape,r=n.length;p+=`${d}: ${r}D ${r>0?n:""} `}}console.log(`%c${o}\t%c${i}\t%c${l}D ${c}\t%c${u}\t%c${p}\t%c${s}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function es(e,t,n){let r={},a={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){let n=e[l],s=n.inputs;for(let e in s){let i=s[e],o=!1;for(let e=0;e<t.length;e++)if(r[i.id]){n.outputs.forEach((e=>r[e.id]=!0)),o=!0,a[n.id]=!0;break}if(o)break}}let s={};s[n.id]=!0;let i={};for(let l=e.length-1;l>=0;l--){let t=e[l],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(s[t.outputs[e].id]){for(let e in n)s[n[e].id]=!0,i[t.id]=!0;break}}let o=[];for(let l=0;l<e.length;l++){let t=e[l];if(a[t.id]&&i[t.id]){let e={};for(let a in t.inputs){let n=t.inputs[a];r[n.id]&&(e[a]=n)}let n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,o.push(n)}}return o}function ts(e,t,n,r){for(let a=t.length-1;a>=0;a--){let s=t[a],i=[];if(s.outputs.forEach((t=>{let n=e[t.id];null!=n?i.push(n):i.push(null)})),null==s.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let o=s.gradient(i);for(let t in s.inputs){if(!(t in o))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);let a=n((()=>o[t]()));if("float32"!==a.dtype)throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${a.dtype}'`);let i=s.inputs[t];if(!ce(a.shape,i.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${t}' has shape '${a.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=a;else{let t=e[i.id];e[i.id]=r(t,a),t.dispose()}}}}var ns=20,rs=3,as=7;function ss(e,t,n,r){let a=De(t),s=is(e,t,n,a),i=t.length,o=us(e,t,n,a,s),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map((e=>"    "+e)).join("\n")),l.join("\n")}function is(e,t,n,r){let a=le(t),s=r[r.length-1],i=new Array(s).fill(0),o=t.length,l="complex64"===n?cs(e):e;if(o>1)for(let u=0;u<a/s;u++){let e=u*s;for(let t=0;t<s;t++)i[t]=Math.max(i[t],os(l[e+t],0,n).length)}return i}function os(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(as))} + ${parseFloat(e[1].toFixed(as))}j`:Ce(e)?`'${e}'`:"bool"===n?ls(e):parseFloat(e.toFixed(as)).toString(),me(r,t)}function ls(e){return 0===e?"false":"true"}function us(e,t,n,r,a,s=!0){let i="complex64"===n?2:1,o=t[0],l=t.length;if(0===l){if("complex64"===n){let t=cs(e);return[os(t[0],0,n)]}return"bool"===n?[ls(e[0])]:[e[0].toString()]}if(1===l){if(o>ns){let t=rs*i,r=Array.from(e.slice(0,t)),s=Array.from(e.slice((o-rs)*i,o*i));return"complex64"===n&&(r=cs(r),s=cs(s)),["["+r.map(((e,t)=>os(e,a[t],n))).join(", ")+", ..., "+s.map(((e,t)=>os(e,a[o-rs+t],n))).join(", ")+"]"]}let t="complex64"===n?cs(e):Array.from(e);return["["+t.map(((e,t)=>os(e,a[t],n))).join(", ")+"]"]}let u=t.slice(1),c=r.slice(1),p=r[0]*i,d=[];if(o>ns){for(let t=0;t<rs;t++){let r=t*p,s=r+p;d.push(...us(e.slice(r,s),u,n,c,a,!1))}d.push("...");for(let t=o-rs;t<o;t++){let r=t*p,s=r+p;d.push(...us(e.slice(r,s),u,n,c,a,t===o-1))}}else for(let m=0;m<o;m++){let t=m*p,r=t+p;d.push(...us(e.slice(t,r),u,n,c,a,m===o-1))}let h=2===l?",":"";d[0]="["+d[0]+h;for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+h;let f=",\n";for(let m=2;m<l;m++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(s?"":f),d}function cs(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var ps=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=le(e),null!=n){let e=n.length;ae(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||ve(t,this.size),this.strides=De(e)}set(e,...t){0===t.length&&(t=[0]),ae(t.length===this.rank,(()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`));let n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(let r of e){if(r<0||r>=this.shape[t]){let t=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(t)}t++}let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return ds().makeTensor(this.values,this.shape,this.dtype)}},ds=null,hs=null;function fs(e){ds=e}function ms(e){hs=e}function gs(e){e}var ys=class{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=le(e),this.strides=De(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return hs.buffer(this.shape,this.dtype,e)}bufferSync(){return hs.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return Oe(this.shape,e,"complex64"===this.dtype)}arraySync(){return Oe(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();let e=ds().read(this.dataId);if("string"===this.dtype){let n=await e;try{return n.map((e=>Ya(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),ds().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=ds().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>Ya(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await ds().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(ds().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return hs.print(this,e)}clone(){return this.throwIfDisposed(),hs.clone(this)}toString(e=!1){let t=this.dataSync();return ss(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),hs.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),ds().makeVariable(this,e,t,n)}};function bs(){return tt("Tensor",(()=>ys))}Object.defineProperty(ys,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),bs();var ws=class extends ys{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!ce(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);ds().disposeTensor(this),this.dataId=e.dataId,ds().incRef(this,null)}dispose(){ds().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(ws,Symbol.hasInstance,{value:e=>e instanceof ys&&null!=e.assign&&e.assign instanceof Function});var xs,vs,ks,Is,Ss,Ns={};g(Ns,{assertTypesMatch:()=>As,getTensorsInContainer:()=>Fs,isTensorInList:()=>$s,makeTypesMatch:()=>Es}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(xs||(xs={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(vs||(vs={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(ks||(ks={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(Is||(Is={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(Ss||(Ss={}));var Ts={float32:Is,int32:vs,bool:ks,complex64:Ss};function _s(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return Ts[e][t]}function Cs(e){return _s(e,"int32")}function Es(e,t){if(e.dtype===t.dtype)return[e,t];let n=_s(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function As(e,t){ae(e.dtype===t.dtype,(()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`))}function $s(e,t){return t.some((t=>t.id===e.id))}function Fs(e){let t=[];return Rs(e,t,new Set),t}function Rs(e,t,n){if(null==e)return;if(e instanceof ys)return void t.push(e);if(!Ds(e))return;let r=e;for(let a in r){let e=r[a];n.has(e)||(n.add(e),Rs(e,t,n))}}function Ds(e){return Array.isArray(e)||"object"==typeof e}function Ms(e){return null!=e.kernelName}var Os=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},Ls=class{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Os}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){let{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{let{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(da(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;let{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Ja(this.backendInstance),!0}setupRegisteredKernels(){ba(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){ba(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){let t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{let n=t.factory();if(!n||n instanceof K||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{let t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,da(`Initialization of backend ${e} failed`),da(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(n){return da(`Initialization of backend ${e} failed`),da(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t],{success:r,asyncInit:a}=this.initializeBackend(n);if(a||r)return{name:n,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){let n=this.state.tensorInfo.get(t),r=n.backend,a=this.readSync(t),s=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,a,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{let e=n();return t(),e}catch(r){throw t(),r}}nextTensorId(){return Ls.nextTensorId++}nextVariableId(){return Ls.nextVariableId++}clone(e){let t=Bs.runKernel(yn,{x:e}),n={x:e},r=e=>({x:()=>{let t="float32",n={x:e},r={dtype:t};return Bs.runKernel(Nt,n,r)}}),a=[];return this.addTapeNode(this.state.activeScope.name,n,[t],r,a,{}),t}runKernel(e,t,n){if(null==this.backendName&&this.backend,null==ga(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){let r=this.backend.numDataIds(),a=0;n.forEach((e=>{a+="complex64"===e.dtype?3:1}));let s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-a-s;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n,r=[],a=this.isTapeOn(),s=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;let o,l=Ms(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Ms(e)){let{kernelName:t,inputs:s,attrs:i}=e;null==this.backendName&&this.backend;let l=ga(t,this.backendName);ae(null!=l,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),n=()=>{let e=this.backend.numDataIds();o=l.kernelFunc({inputs:s,attrs:i,backend:this.backend});let n=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,n);let u=n.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(a){let e=this.getTensorsForGradient(t,s,u);r=this.saveTensorsForBackwardMode(e)}return u}}else{let{forwardFunc:t}=e,s=e=>{!a||(r=e.map((e=>this.keep(this.clone(e)))))};n=()=>{let e=this.backend.numDataIds();o=this.tidy((()=>t(this.backend,s)));let n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,e,n),n}}let u,{inputs:c,attrs:p}=e,d=Ms(e)?null:e.backwardsFunc;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(u=this.profiler.profileKernel(l,c,(()=>n())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(u),t=u.outputs):t=n()})),a&&this.addTapeNode(l,c,t,d,r,p),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map((e=>null!=c[e]?c[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:u.timeMs,extraInfo:u.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){return e.map((e=>this.keep(this.clone(e))))}getTensorsForGradient(e,t,n){let r=ya(e);if(null!=r){let e,a=r.inputsToSave||[],s=r.outputsToSave||[];r.saveAllInputs?(ae(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),e=Object.keys(t).map((e=>t[e]))):e=a.map((e=>t[e]));let i=n.filter(((e,t)=>s[t]));return e.concat(i)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let a=e;"string"===n&&Ce(e[0])&&(a=e.map((e=>Xa(e))));let s=r.write(a,t,n),i=new ys(t,n,s,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){let e=this.state.tensorInfo.get(s),t=_e(a);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){n=n||"float32";let a={dataId:e,shape:t,dtype:n};return this.makeTensorFromTensorInfo(a,r)}makeTensorFromTensorInfo(e,t){let{dataId:n,shape:r,dtype:a}=e,s=new ys(r,a,n,this.nextTensorId());return this.trackTensor(s,t),s}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));let a=new ws(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[a.name])throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*Te(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof ws||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){let t=e.size*Te(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;let t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,a,s){let i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:a},o=ya(e);null!=o&&(r=o.gradFunc),null!=r&&(i.gradient=e=>(e=e.map(((e,t)=>{if(null==e){let e=n[t],r=Pe(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],a,s))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){let t=Fs(e),n=new Set(t.map((e=>e.id)));for(let a=0;a<this.state.activeScope.track.length;a++){let e=this.state.activeScope.track[a];!e.kept&&!n.has(e.id)&&e.dispose()}let r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{!e.kept&&e.scopeId===r.id&&this.track(e)}))}gradients(e,t,n,r=!1){if(ae(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let a=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));ae(a instanceof ys,(()=>"The result y returned by f() must be a tensor."));let s=es(this.state.activeTape,t,a);if(!r&&0===s.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{let e={};e[a.id]=null==n?Ps(a.shape):n,ts(e,s,(e=>this.tidy(e)),Ws);let r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(let t of e.saved)t.dispose()})),this.state.activeTape=null),{value:a,grads:r}}))}customGrad(e){return ae(Fe(e),(()=>"The f passed in customGrad(f) must be a function.")),(...t)=>{ae(t.every((e=>e instanceof ys)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));let n,r={};t.forEach(((e,t)=>{r[t]=e}));let a=(r,a)=>(n=e(...t,a),ae(n.value instanceof ys,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),ae(Fe(n.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),n.value),s=(e,r)=>{let a=n.gradFunc(e,r),s=Array.isArray(a)?a:[a];ae(s.length===t.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),ae(s.every((e=>e instanceof ys)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));let i={};return s.forEach(((e,t)=>{i[t]=()=>e})),i};return this.runKernelFunc({forwardFunc:a,backwardsFunc:s,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){let t=qa(),n=await this.backend.time(e);return n.wallMs=qa()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Os;for(let e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};function Ps(e){let t=Le(le(e),"float32");return Bs.makeTensor(t,e,"float32")}function zs(){let e=Qe();if(null==e._tfengine){let t=new He(e);e._tfengine=new Ls(t)}return Ze(e._tfengine.ENV),fs((()=>e._tfengine)),e._tfengine}Ls.nextTensorId=0,Ls.nextVariableId=0;var Bs=zs();function Ws(e,t){let n={a:e,b:t};return Bs.runKernel(st,n)}var Vs,Us={};function Gs(){return"undefined"!=typeof navigator&&null!=navigator}function Hs(e){Vs=e}function js(e){if(void 0!==Vs)return Vs;if(e||Gs()){if(e||(e=navigator),"ReactNative"===e.product)return!0;let t=e.userAgent||e.vendor||("undefined"!=typeof window?window.opera:"");if(!t){let t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function qs(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}g(Us,{isBrowser:()=>qs,isMobile:()=>js,mockIsMobile:()=>Hs});var Ks=Xe();function Xs(e,t){let n=e;if(Ne(e))return"string"===t?[]:[e.length];if(!Array.isArray(e))return[];let r=[];for(;Array.isArray(n)||Ne(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&Xe().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Ys(e,r,[]),r}function Ys(e,t,n){if(n=n||[],!Array.isArray(e)&&!Ne(e))return void ae(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));ae(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),ae(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));let r=t.slice(1);for(let a=0;a<e.length;++a)Ys(e[a],r,n.concat(a))}function Js(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function Zs(e,t,n,r="numeric"){if(e instanceof ys)return Js(r,e.dtype,t,n),e;let a=$e(e);if("string"!==a&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),Js(r,a,t,n),null==e||!Ne(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){let r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}let s=Xs(e,a);!Ne(e)&&!Array.isArray(e)&&(e=[e]);let i="string"!==a?ja(e,a):oe(e,[],!0);return Bs.makeTensor(i,s,a)}function Qs(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,a)=>Zs(e,`${t}[${a}]`,n,r)))}Ks.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),Ks.registerFlag("IS_BROWSER",(()=>qs())),Ks.registerFlag("IS_NODE",(()=>"undefined"!=typeof process&&"undefined"!=typeof process.versions&&"undefined"!=typeof process.versions.node)),Ks.registerFlag("IS_CHROME",(()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),Ks.registerFlag("PROD",(()=>!1)),Ks.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>Ks.getBool("DEBUG"))),Ks.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),Ks.registerFlag("IS_TEST",(()=>!1)),Ks.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>!0)),Ks.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),Ks.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));var ei="__op";function ti(e){let t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=ei;let a=(...e)=>{Bs.startScope(n);try{let t=r(...e);return Ue(t)&&console.error("Cannot return a Promise inside of tidy."),Bs.endScope(t),t}catch(t){throw Bs.endScope(null),t}};return Object.defineProperty(a,"name",{value:n,configurable:!0}),a}function ni(e,t){let n=Zs(e,"real","complex"),r=Zs(t,"imag","complex");se(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);let a={real:n,imag:r};return Bs.runKernel(Ct,a)}var ri=ti({complex_:ni});function ai(e,t,n,r){if(null==r&&(r=$e(e)),"complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Ne(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Be(t);let e=le(t),r=le(n);ae(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let a=0;a<n.length;++a){let e=n[a],r=a!==n.length-1||e!==le(t.slice(a));ae(n[a]===t[a]||!r,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return!Ne(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e="string"!==r?ja(e,r):oe(e,[],!0),Bs.makeTensor(e,t,r)}function si(e,t,n){let r=Xs(e,n);return ai(e,t,r,n)}var ii={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},oi=4;async function li(e,t){let n=[],r=[],a=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let i=0;i<a.length;++i){let s=a[i],o=Array.isArray(e)?e[i].tensor:e[s];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${s}': ${o.dtype}`);let l={name:s,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){let e=new Promise((async e=>{let t=await o.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+oi*t.length,r=new Uint8Array(n),a=0;for(let s=0;s<t.length;s++){let e=t[s],n=new Uint8Array(new Uint32Array([e.length]).buffer);r.set(n,a),a+=oi,r.set(e,a),a+=e.length}e(r)}));r.push(e)}else r.push(o.data());null!=t&&(l.group=t),n.push(l)}let s=await Promise.all(r);return{data:ci(s),specs:n}}function ui(e,t){let n,r={},a=0;for(let s of t){let t,i=s.name,o=s.dtype,l=s.shape,u=le(l);if("quantization"in s){let r=s.quantization;if("uint8"===r.dtype||"uint16"===r.dtype){if(!("min"in r)||!("scale"in r))throw new Error(`Weight ${s.name} with quantization ${r.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==r.dtype)throw new Error(`Weight ${s.name} has unknown quantization dtype ${r.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==o)throw new Error(`Weight ${s.name} is quantized with ${r.dtype} which only supports weights of type float32 not ${o}.`)}let l=ii[r.dtype],c=e.slice(a,a+u*l),p="uint8"===r.dtype?new Uint8Array(c):new Uint16Array(c);if("float32"===o)if("uint8"===r.dtype||"uint16"===r.dtype){t=new Float32Array(p.length);for(let e=0;e<p.length;e++){let n=p[e];t[e]=n*r.scale+r.min}}else{if("float16"!==r.dtype)throw new Error(`Unsupported quantization type ${r.dtype} for weight type float32.`);void 0===n&&(n=Ii()),t=n(p)}else{if("int32"!==o)throw new Error(`Unsupported dtype in weight '${i}': ${o}`);if("uint8"!==r.dtype&&"uint16"!==r.dtype)throw new Error(`Unsupported quantization type ${r.dtype} for weight type int32.`);t=new Int32Array(p.length);for(let e=0;e<p.length;e++){let n=p[e];t[e]=Math.round(n*r.scale+r.min)}}a+=u*l}else if("string"===o){let n=le(s.shape);t=[];for(let r=0;r<n;r++){let n=new Uint32Array(e.slice(a,a+oi))[0];a+=oi;let r=new Uint8Array(e.slice(a,a+n));t.push(r),a+=n}}else{let n=ii[o],s=e.slice(a,a+u*n);if("float32"===o)t=new Float32Array(s);else if("int32"===o)t=new Int32Array(s);else if("bool"===o)t=new Uint8Array(s);else{if("complex64"!==o)throw new Error(`Unsupported dtype in weight '${i}': ${o}`);{t=new Float32Array(s);let e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let r=0;r<e.length;r++)e[r]=t[2*r],n[r]=t[2*r+1];let a=si(e,l,"float32"),o=si(n,l,"float32");r[i]=ri(a,o),a.dispose(),o.dispose()}}a+=u*n}"complex64"!==o&&(r[i]=si(t,l,o))}return r}function ci(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));let r=new Uint8Array(t),a=0;return n.forEach((e=>{r.set(new Uint8Array(e.buffer),a),a+=e.byteLength})),r.buffer}var pi="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function di(e){return pi?Buffer.byteLength(e):new Blob([e]).size}function hi(e){if(pi)return Buffer.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let r=0,a=t.length;r<a;r++)n+=String.fromCharCode(t[r]);return btoa(n)}function fi(e){if(pi){let t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}function mi(e){if(1===e.length)return e[0];let t=0;e.forEach((e=>{t+=e.byteLength}));let n=new Uint8Array(t),r=0;return e.forEach((e=>{n.set(new Uint8Array(e),r),r+=e.byteLength})),n.buffer}function gi(e){let t="/";for(e=e.trim();e.endsWith(t);)e=e.slice(0,e.length-1);let n=e.split(t);return n[n.length-1]}function yi(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}async function bi(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),null!=e.weightsManifest){let[r,a]=await t(e.weightsManifest);n.weightSpecs=r,n.weightData=a}return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),n}function wi(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:di(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:di(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:e.weightData.byteLength}}function xi(){let e=e=>{let t=e<<13,n=0;for(;0===(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function vi(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function ki(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function Ii(){let e=xi(),t=vi(),n=ki();return r=>{let a=new ArrayBuffer(4*r.length),s=new Uint32Array(a);for(let i=0;i<r.length;i++){let a=r[i],o=e[n[a>>10]+(1023&a)]+t[a>>10];s[i]=o}return new Float32Array(a)}}var Si=class{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Si.instance&&(Si.instance=new Si),Si.instance}static registerSaveRouter(e){Si.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Si.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Si.getHandlers(e,"save")}static getLoadHandlers(e,t){return Si.getHandlers(e,"load",t)}static getHandlers(e,t,n){let r=[];return("load"===t?Si.getInstance().loadRouters:Si.getInstance().saveRouters).forEach((t=>{let a=t(e,n);null!==a&&r.push(a)})),r}},Ni=e=>Si.registerSaveRouter(e),Ti=e=>Si.registerLoadRouter(e),_i=e=>Si.getSaveHandlers(e),Ci=(e,t)=>Si.getLoadHandlers(e,t),Ei="tensorflowjs",Ai=1,$i="models_store",Fi="model_info_store";function Ri(){if(!Xe().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Di(e){let t=e.result;t.createObjectStore($i,{keyPath:"modelPath"}),t.createObjectStore(Fi,{keyPath:"modelPath"})}var Mi=class{constructor(e){if(this.indexedDB=Ri(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{let r=this.indexedDB.open(Ei,Ai);r.onupgradeneeded=()=>Di(r),r.onsuccess=()=>{let a=r.result;if(null==t){let t=a.transaction($i,"readonly"),r=t.objectStore($i).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return a.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(a.close(),n(r.error)),t.oncomplete=()=>a.close()}else{let r,s=wi(t),i=a.transaction(Fi,"readwrite"),o=i.objectStore(Fi),l=o.put({modelPath:this.modelPath,modelArtifactsInfo:s});l.onsuccess=()=>{r=a.transaction($i,"readwrite");let l=r.objectStore($i).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:s});l.onsuccess=()=>e({modelArtifactsInfo:s}),l.onerror=e=>{o=i.objectStore(Fi);let t=o.delete(this.modelPath);t.onsuccess=()=>(a.close(),n(l.error)),t.onerror=e=>(a.close(),n(l.error))}},l.onerror=e=>(a.close(),n(l.error)),i.oncomplete=()=>{null==r?a.close():r.oncomplete=()=>a.close()}}},r.onerror=e=>n(r.error)}))}};Mi.URL_SCHEME="indexeddb://";var Oi=e=>Xe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Mi.URL_SCHEME)?Li(e.slice(Mi.URL_SCHEME.length)):null;function Li(e){return new Mi(e)}function Pi(e){return e.startsWith(Mi.URL_SCHEME)?e.slice(Mi.URL_SCHEME.length):e}Si.registerSaveRouter(Oi),Si.registerLoadRouter(Oi);var zi=class{constructor(){this.indexedDB=Ri()}async listModels(){return new Promise(((e,t)=>{let n=this.indexedDB.open(Ei,Ai);n.onupgradeneeded=()=>Di(n),n.onsuccess=()=>{let r=n.result,a=r.transaction(Fi,"readonly"),s=a.objectStore(Fi).getAll();s.onsuccess=()=>{let t={};for(let e of s.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},s.onerror=e=>(r.close(),t(s.error)),a.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){return e=Pi(e),new Promise(((t,n)=>{let r=this.indexedDB.open(Ei,Ai);r.onupgradeneeded=()=>Di(r),r.onsuccess=()=>{let a,s=r.result,i=s.transaction(Fi,"readwrite"),o=i.objectStore(Fi),l=o.get(e);l.onsuccess=()=>{if(null==l.result)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let r=o.delete(e),i=()=>{a=s.transaction($i,"readwrite");let r=a.objectStore($i).delete(e);r.onsuccess=()=>t(l.result.modelArtifactsInfo),r.onerror=e=>n(l.error)};r.onsuccess=i,r.onerror=e=>(i(),s.close(),n(l.error))}},l.onerror=e=>(s.close(),n(l.error)),i.oncomplete=()=>{null==a?s.close():a.oncomplete=()=>s.close()}},r.onerror=e=>n(r.error)}))}},Bi="/",Wi="tensorflowjs_models",Vi="info",Ui="model_topology",Gi="weight_specs",Hi="weight_data",ji="model_metadata";function qi(e){return{info:[Wi,e,Vi].join(Bi),topology:[Wi,e,Ui].join(Bi),weightSpecs:[Wi,e,Gi].join(Bi),weightData:[Wi,e,Hi].join(Bi),modelMetadata:[Wi,e,ji].join(Bi)}}function Ki(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function Xi(e){let t=e.split(Bi);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(Bi)}function Yi(e){return e.startsWith(Ji.URL_SCHEME)?e.slice(Ji.URL_SCHEME.length):e}var Ji=class{constructor(e){if(!Xe().getBool("IS_BROWSER")||"undefined"==typeof window||"undefined"==typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=qi(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),a=wi(e);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,hi(e.weightData));let t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:a}}catch(t){throw Ki(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;let a=this.LS.getItem(this.keys.modelMetadata);if(null!=a){let e=JSON.parse(a);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}let s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=fi(s),t}};Ji.URL_SCHEME="localstorage://";var Zi=e=>Xe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Ji.URL_SCHEME)?Qi(e.slice(Ji.URL_SCHEME.length)):null;function Qi(e){return new Ji(e)}Si.registerSaveRouter(Zi),Si.registerLoadRouter(Zi);var eo=class{constructor(){ae(Xe().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),ae("undefined"==typeof window||"undefined"!=typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){let e={},t=Wi+Bi,n=Bi+Vi;for(let r=0;r<this.LS.length;++r){let a=this.LS.key(r);if(a.startsWith(t)&&a.endsWith(n)){let t=Xi(a);e[t]=JSON.parse(this.LS.getItem(a))}}return e}async removeModel(e){e=Yi(e);let t=qi(e);if(null==this.LS.getItem(t.info))throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return Ki(t),n}},to="://",no=class{constructor(){this.managers={}}static getInstance(){return null==no.instance&&(no.instance=new no),no.instance}static registerManager(e,t){ae(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(to)&&(e=e.slice(0,e.indexOf(to))),ae(e.length>0,(()=>"scheme must not be an empty string."));let n=no.getInstance();ae(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){let t=this.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}};function ro(e){if(-1===e.indexOf(to))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${no.getSchemes().join(",")}`);return{scheme:e.split(to)[0],path:e.split(to)[1]}}async function ao(e,t,n=!1){ae(e!==t,(()=>`Old path and new path are the same: '${e}'`));let r=Si.getLoadHandlers(e);ae(r.length>0,(()=>`Copying failed because no load handler is found for source URL ${e}.`)),ae(r.length<2,(()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`));let a=r[0],s=Si.getSaveHandlers(t);ae(s.length>0,(()=>`Copying failed because no save handler is found for destination URL ${t}.`)),ae(s.length<2,(()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`));let i=s[0],o=ro(e).scheme,l=ro(e).path,u=o===ro(e).scheme,c=await a.load();n&&u&&await no.getManager(o).removeModel(l);let p=await i.save(c);return n&&!u&&await no.getManager(o).removeModel(l),p.modelArtifactsInfo}async function so(){let e=no.getSchemes(),t={};for(let n of e){let e=await no.getManager(n).listModels();for(let r in e){let a=n+to+r;t[a]=e[r]}}return t}async function io(e){let t=ro(e);return no.getManager(t.scheme).removeModel(t.path)}async function oo(e,t){return ao(e,t,!1)}async function lo(e,t){return ao(e,t,!0)}var uo=class{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}};if(Xe().get("IS_BROWSER")){Xe().setPlatform("browser",new uo);try{no.registerManager(Ji.URL_SCHEME,new eo)}catch(Yre){}try{no.registerManager(Mi.URL_SCHEME,new zi)}catch(Yre){}}var co,po={importFetch:()=>x()},ho=class{constructor(){this.util=v(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=Xe().global.fetch?Xe().global.fetch(e,t):(null==co&&(co=po.importFetch()),co(e,t))}now(){let e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}};function fo(e,t="float32",n){return t=t||"float32",Be(e),new ps(e,t,n)}function mo(e,t){let n=Zs(e,"x","cast");if(!Ie(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");let r={x:n},a={dtype:t};return Bs.runKernel(Nt,r,a)}Xe().get("IS_NODE")&&!Xe().get("IS_BROWSER")&&Xe().setPlatform("node",new ho);var go=ti({cast_:mo});function yo(e){let t={x:Zs(e,"x","clone","string_or_numeric")};return Bs.runKernel(yn,t)}var bo=ti({clone_:yo});function wo(e,t=!1){console.log(e.toString(t))}zs();var xo={buffer:fo,cast:go,clone:bo,print:wo};ms(xo);var vo={};g(vo,{browserFiles:()=>Ao,browserHTTPRequest:()=>Vo,concatenateArrayBuffers:()=>mi,copyModel:()=>oo,decodeWeights:()=>ui,encodeWeights:()=>li,fromMemory:()=>jo,fromMemorySync:()=>qo,getLoadHandlers:()=>Ci,getModelArtifactsForJSON:()=>bi,getModelArtifactsInfoForJSON:()=>wi,getSaveHandlers:()=>_i,http:()=>Wo,isHTTPScheme:()=>zo,listModels:()=>so,loadWeights:()=>Ro,moveModel:()=>lo,registerLoadRouter:()=>Ti,registerSaveRouter:()=>Ni,removeModel:()=>io,weightsLoaderFactory:()=>Do,withSaveHandler:()=>Ko,withSaveHandlerSync:()=>Xo});var ko="model",Io=".json",So=".weights.bin";function No(e){return new Promise((e=>setTimeout(e))).then(e)}var To=class{constructor(e){if(!Xe().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(To.URL_SCHEME)&&(e=e.slice(To.URL_SCHEME.length)),(null==e||0===e.length)&&(e=ko),this.modelJsonFileName=e+Io,this.weightDataFileName=e+So}async save(e){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");let t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let n=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],r=yi(e,n),a=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),s=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(s.download=this.modelJsonFileName,s.href=a,await No((()=>s.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){let e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=t,await No((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:wi(e)}}}};To.URL_SCHEME="downloads://";var _o=class{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise(((e,t)=>{let n=new FileReader;n.onload=n=>{let r=JSON.parse(n.target.result),a=r.modelTopology;if(null==a)return void t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==r.weightsManifest)return void t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void e({modelTopology:a});let s=bi(r,(e=>this.loadWeights(e)));e(s)},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)}))}loadWeights(e){let t=[],n=[];for(let s of e)t.push(...s.weights),n.push(...s.paths);let r=this.checkManifestAndWeightFiles(e),a=n.map((e=>this.loadWeightsFile(e,r[e])));return Promise.all(a).then((e=>[t,mi(e)]))}loadWeightsFile(e,t){return new Promise(((n,r)=>{let a=new FileReader;a.onload=e=>{let t=e.target.result;n(t)},a.onerror=t=>r(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(t)}))}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map((e=>gi(e.name))),r={};for(let a of e)a.paths.forEach((e=>{let a=gi(e);if(-1!==t.indexOf(a))throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),-1===n.indexOf(a))throw new Error(`Weight file with basename '${a}' is not provided.`);r[e]=this.weightsFiles[n.indexOf(a)]}));if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}},Co=e=>Xe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(To.URL_SCHEME)?Eo(e.slice(To.URL_SCHEME.length)):null;function Eo(e="model"){return new To(e)}function Ao(e){return new _o(e)}function $o(e,t,n,r){i(e),n=null==n?0:n,r=null==r?1:r,o(n,r);let a=0,s=s=>(s.then((s=>{let i=n+ ++a/e.length*(r-n);return t(i),s})),s);function i(e){ae(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}function o(e,t){ae(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),ae(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),ae(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}return Promise.all(e.map(s))}async function Fo(e,t){null==t&&(t={});let n=null==t.fetchFunc?Xe().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),a=0,s=.5,i=(null==t.onProgress?await Promise.all(r):await $o(r,t.onProgress,a,s)).map((e=>e.arrayBuffer())),o=.5,l=1;return null==t.onProgress?await Promise.all(i):await $o(i,t.onProgress,o,l)}async function Ro(e,t="",n,r){return Do((e=>Fo(e,{requestInit:r})))(e,t,n)}function Do(e){return async(t,n="",r)=>{let a=t.map((()=>!1)),s={},i=null!=r?r.map((()=>!1)):[],o=[];if(t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{let l="quantization"in e?e.quantization.dtype:e.dtype,u=ii[l]*le(e.shape),c=()=>{a[t]=!0,null==s[t]&&(s[t]=[]),s[t].push({manifestEntry:e,groupOffset:n,sizeBytes:u})};null!=r?r.forEach(((t,n)=>{t===e.name&&(c(),i[n]=!0)})):c(),o.push(e.name),n+=u}))})),!i.every((e=>e))){let e=r.filter(((e,t)=>!i[t]));throw new Error(`Could not find weights in manifest with names: ${e.join(", ")}. \nManifest JSON has weights with names: ${o.join(", ")}.`)}let l=a.reduce(((e,t,n)=>(t&&e.push(n),e)),[]),u=[];l.forEach((e=>{t[e].paths.forEach((e=>{let t=n+(n.endsWith("/")?"":"/")+e;u.push(t)}))}));let c=await e(u),p={},d=0;return l.forEach((e=>{let n=t[e].paths.length,r=0;for(let t=0;t<n;t++)r+=c[d+t].byteLength;let a=new ArrayBuffer(r),i=new Uint8Array(a),o=0;for(let t=0;t<n;t++){let e=new Uint8Array(c[d+t]);i.set(e,o),o+=e.byteLength}s[e].forEach((e=>{let t=a.slice(e.groupOffset,e.groupOffset+e.sizeBytes),n=ui(t,[e.manifestEntry]);for(let r in n)p[r]=n[r]})),d+=n})),p}}Si.registerSaveRouter(Co);var Mo="application/octet-stream",Oo="application/json",Lo=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(ae("function"==typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=Xe().platform.fetch,ae(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&ae(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=yi(e,n);t.body.append("model.json",new Blob([JSON.stringify(r)],{type:Oo}),"model.json"),null!=e.weightData&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:Mo}),"model.weights.bin");let a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:wi(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async load(){let e,t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);try{e=await t.json()}catch(a){let e=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}let n=e.modelTopology,r=e.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return bi(e,(e=>this.loadWeights(e)))}async loadWeights(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=Po(t),a=this.weightPathPrefix||n,s=[];for(let u of e)s.push(...u.weights);let i=[],o=[];for(let u of e)for(let e of u.paths)null!=this.weightUrlConverter?o.push(this.weightUrlConverter(e)):i.push(a+e+r);this.weightUrlConverter&&i.push(...await Promise.all(o));let l=await Fo(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[s,mi(l)]}};function Po(e){let t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),a=n>t?e.substring(n):"";return[r+"/",a]}function zo(e){return null!=e.match(Lo.URL_SCHEME_REGEX)}Lo.URL_SCHEME_REGEX=/^https?:\/\//;var Bo=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>zo(e))):zo(e),n)return Wo(e,t)}return null};function Wo(e,t){return new Lo(e,t)}function Vo(e,t){return Wo(e,t)}Si.registerSaveRouter(Bo),Si.registerLoadRouter(Bo);var Uo=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},Go=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},Ho=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function jo(e,t,n,r){let a=arguments;return new Ho(qo(...a))}function qo(e,t,n,r){return 1===arguments.length?null!=e.modelTopology||null!=e.weightSpecs?new Uo(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Uo({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Uo({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r}))}function Ko(e){return new Go(e)}function Xo(e){return new Go(e)}var Yo={};function Jo(e,t,n=!1,r=!1){let a=Zs(e,"a","matMul"),s=Zs(t,"b","matMul");[a,s]=Es(a,s);let i={a:a,b:s},o={transposeA:n,transposeB:r};return Bs.runKernel(xt,i,o)}g(Yo,{confusionMatrix:()=>$l});var Zo=ti({matMul_:Jo});function Qo(e,t,n=1,r=0){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let a={indices:Zs(e,"indices","oneHot","int32")},s={depth:t,onValue:n,offValue:r};return Bs.runKernel(nr,a,s)}var el=ti({oneHot_:Qo});function tl(){Xe().set("PROD",!0)}function nl(){Xe().set("DEBUG",!0)}function rl(){Xe().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function al(e){Xe().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function sl(){Bs.disposeVariables()}function il(){return Bs}function ol(){return Bs.memory()}function ll(e){return Bs.profile(e)}function ul(e,t){return Bs.tidy(e,t)}function cl(e){Fs(e).forEach((e=>e.dispose()))}function pl(e){return Bs.keep(e)}function dl(e){return Bs.time(e)}function hl(e){return Bs.setBackend(e)}function fl(){return Bs.ready()}function ml(){return Bs.backendName}function gl(e){Bs.removeBackend(e)}function yl(e){return Bs.findBackend(e)}function bl(e){return Bs.findBackendFactory(e)}function wl(e,t,n=1){return Bs.registerBackend(e,t,n)}function xl(){return Bs.backend}function vl(e,t){Xe().setPlatform(e,t)}function kl(e){let t={input:Zs(e,"input","imag")};return Bs.runKernel(wn,t)}gs(al);var Il=ti({imag_:kl});function Sl(e){let t={x:Zs(e,"x","neg")};return Bs.runKernel(Yn,t)}var Nl=ti({neg_:Sl});function Tl(e){let t={input:Zs(e,"input","real")};return Bs.runKernel(cr,t)}var _l=ti({real_:Tl});function Cl(e,t,n){let r=Zs(e,"x","transpose");if(null==t&&(t=r.shape.map(((e,t)=>t)).reverse()),ae(r.rank===t.length,(()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`)),t.forEach((e=>{ae(e>=0&&e<r.rank,(()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`))})),r.rank<=1)return r.clone();let a={x:r},s={perm:t};return"complex64"===r.dtype?ul((()=>{let e=_l(r),t=Il(r);return e=Bs.runKernel(ea,{x:e},s),t=Bs.runKernel(ea,{x:t},s),n&&(t=Nl(t)),ri(e,t)})):Bs.runKernel(ea,a,s)}var El=ti({transpose_:Cl});function Al(e,t,n){let r=Zs(e,"labels","confusionMatrix"),a=Zs(t,"predictions","confusionMatrix");ae(null==n||n>0&&Number.isInteger(n),(()=>`If provided, numClasses must be a positive integer, but got ${n}`)),ae(1===r.rank,(()=>`Expected the rank of labels to be 1, but got ${r.rank}`)),ae(1===a.rank,(()=>`Expected the rank of predictions to be 1, but got ${a.rank}`)),ae(r.shape[0]===a.shape[0],(()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${a.shape[0]}. Labels and predictions should have the same number of elements.`)),ae(n>0&&Number.isInteger(n),(()=>`numClasses is required to be a positive integer, but got ${n}`));let s=el(go(r,"int32"),n),i=el(go(a,"int32"),n),o=El(s),l=Zo(o,i);return go(l,"int32")}var $l=ti({confusionMatrix_:Al}),Fl={};function Rl(e,t){let n=e.length,r=[];for(let a=0;a<n;a++){let s=n-1-a,i=e[s]||1;(t[t.length-1-a]||1)>1&&1===i&&r.unshift(s)}return r}function Dl(e,t){let n=[];for(let r=0;r<t.length;r++){let a=e[e.length-r-1],s=t.length-r-1,i=t[s];(null==a||1===a&&i>1)&&n.unshift(s)}return n}function Ml(e,t){let n=[],r=Math.max(e.length,t.length);for(let a=0;a<r;a++){let r=e[e.length-a-1];null==r&&(r=1);let s=t[t.length-a-1];if(null==s&&(s=1),1===r)n.unshift(s);else if(1===s)n.unshift(r);else{if(r!==s){let n=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(n)}n.unshift(r)}}return n}g(Fl,{assertAndGetBroadcastShape:()=>Ml,getBroadcastDims:()=>Rl,getReductionAxes:()=>Dl});var Ol,Ll={};function Pl(e,t,n){if(ie(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");let r=Xs(e,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return ai(e,t,r,n)}function zl(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,a=!1,s=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)a=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)s=!0;else if(null!=e.getContext)i=!0;else{if(!("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);o=!0}if(a&&a&&e.readyState<2)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");if(null!=ga(oa,Bs.backendName)){let n={pixels:e},r={numChannels:t};return Bs.runKernel(oa,n,r)}let l,u,[c,p]=a?[e.videoWidth,e.videoHeight]:[e.width,e.height];if(i)l=e.getContext("2d").getImageData(0,0,c,p).data;else if(r||n)l=e.data;else if(s||a||o){if(null==Ol)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");Ol=new OffscreenCanvas(1,1).getContext("2d")}else Ol=document.createElement("canvas").getContext("2d");Ol.canvas.width=c,Ol.canvas.height=p,Ol.drawImage(e,0,0,c,p),l=Ol.getImageData(0,0,c,p).data}if(4===t)u=new Int32Array(l);else{let e=c*p;u=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)u[n*t+e]=l[4*n+e]}return Pl(u,[p,c,t],"int32")}function Bl(e){return null!=e&&e.data instanceof Uint8Array}function Wl(){return"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")}function Vl(e){return null!=e&&0!==e.width&&0!==e.height}function Ul(e){return Wl()&&!(e instanceof ImageBitmap)&&Vl(e)&&!Bl(e)}async function Gl(e,t=3){let n=null;if(Xe().getBool("WRAP_TO_IMAGEBITMAP")&&Ul(e)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(r){t=null}n=null!=t&&t.width===e.width&&t.height===e.height?t:e}else n=e;return zl(n,t)}async function Hl(e,t){let n=Zs(e,"img","toPixels");if(!(e instanceof ys)){let e=n;n=go(e,"int32"),e.dispose()}if(2!==n.rank&&3!==n.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);let[r,a]=n.shape.slice(0,2),s=2===n.rank?1:n.shape[2];if(s>4||2===s)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${s}`);if("float32"!==n.dtype&&"int32"!==n.dtype)throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`);let i=await n.data(),o="float32"===n.dtype?255:1,l=new Uint8ClampedArray(a*r*4);for(let u=0;u<r*a;++u){let e=[0,0,0,255];for(let r=0;r<s;r++){let t=i[u*s+r];if("float32"===n.dtype){if(t<0||t>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t}.`)}else if("int32"===n.dtype&&(t<0||t>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t}.`);1===s?(e[0]=t*o,e[1]=t*o,e[2]=t*o):e[r]=t*o}let t=4*u;l[t+0]=Math.round(e[0]),l[t+1]=Math.round(e[1]),l[t+2]=Math.round(e[2]),l[t+3]=Math.round(e[3])}if(null!=t){t.width=a,t.height=r;let e=t.getContext("2d"),n=new ImageData(l,a,r);e.putImageData(n,0,0)}return n!==e&&n.dispose(),l}g(Ll,{fromPixels:()=>jl,fromPixelsAsync:()=>Gl,toPixels:()=>Hl});var jl=ti({fromPixels_:zl}),ql={};function Kl(e,t){let n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===le(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let a=t.shape,s=a[a.length-1],i=1;for(let p=0;p<a.length-1;++p)i*=a[p];let o=e.shape,l=a.slice();l.pop();let u=1;for(let p=s;p<n;++p)u*=o[p],l.push(o[p]);let c=[...De(e.shape).map((e=>e/u)),1].slice(0,s);return[l,i,u,c]}g(ql,{prepareAndValidate:()=>Kl});var Xl={};function Yl(e,t,n){let r=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${a}.`;if(n.rank<a)throw new Error(s+` update.rank < ${a}. `);if(e.length<r+(n.rank-a))throw new Error(s+` Output shape length < ${r+(n.rank-a)}`);if(n.rank!==a+e.length-r)throw new Error(s+" update.rank != "+(a+e.length-r));for(let i=0;i<a;++i)if(n.shape[i]!==t.shape[i])throw new Error(s+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-a;++i)if(n.shape[i+a]!==e[i+r])throw new Error(s+` updates.shape[${i+a}] (${n.shape[i+a]}) != shape[${i+a}] (${e[i+a]})`)}function Jl(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}Yl(n,t,e)}function Zl(e,t,n){let r=t.shape.length,a=r>1?t.shape[r-1]:1,s=n.length,i=1;for(let p=a;p<s;++p)i*=n[p];let o=a<1?1:a,l=le(t.shape)/o,u=[...De(n.slice(0,a)),1],c=le(n);return{sliceRank:a,numUpdates:l,sliceSize:i,strides:u,outputSize:c}}g(Xl,{calculateShapes:()=>Zl,validateInput:()=>Jl,validateUpdateShape:()=>Yl});var Ql={};g(Ql,{assertParamsValid:()=>nu,computeFlatOffset:()=>mu,computeOutShape:()=>au,getNormalizedAxes:()=>lu,isSliceContinous:()=>fu,maskToAxes:()=>ru,parseSliceParams:()=>gu,sliceInfo:()=>yu,startForAxis:()=>du,startIndicesWithElidedDims:()=>uu,stopForAxis:()=>hu,stopIndicesWithElidedDims:()=>cu,stridesForAxis:()=>pu,stridesWithElidedDims:()=>su});var eu=-2,tu=-1;function nu(e,t,n){let r=e.shape.length;ae(r===t.length,(()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`)),ae(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let a=0;a<r;++a)ae(t[a]+n[a]<=e.shape[a],(()=>`Error in slice${r}D: begin[${a}] + size[${a}] (${t[a]+n[a]}) would overflow input.shape[${a}] (${e.shape[a]})`))}function ru(e){let t=[],n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function au(e,t,n){let r=[];for(let a=0;a<e.length;a++)r[a]=Math.ceil((t[a]-e[a])/n[a]);return r}function su(e,t,n,r){let a=[...e];for(let s=a.length;s<r.length;s++)a.push(1);for(let s=0;s<n;s++)0===s?a[t]=1:(a.splice(t,0,1),a.pop());return a}function iu(e,t,n){return n<=e?n:n-(t-1)}function ou(e,t){let n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function lu(e,t,n,r,a,s,i,o,l){let u=e.length,c=new Array(u),p=new Array(u),d=new Array(u);if(t.length&&n>0){let l=t[0],u=n+1;c=uu(i,l,u,r,e),p=cu(o,l,u,a,e),d=su(s,l,u,e)}else for(let h=0;h<u;h++)c[h]=du(i,r,s,e,h,l),p[h]=hu(o,a,s,e,h,l),d[h]=pu(s,h,l);return{begin:c,end:p,strides:d}}function uu(e,t,n,r,a){let s=[...a],i=ou(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=0;else{let a=iu(t,n,o),i=r[a];e&1<<a&&(i=0),s[o]=i}return s}function cu(e,t,n,r,a){let s=[...a],i=ou(n,t);for(let o=0;o<s.length;o++)if(i.indexOf(o)>-1)s[o]=Number.MAX_SAFE_INTEGER;else{let a=iu(t,n,o),i=r[a];e&1<<a&&(i=Number.MAX_SAFE_INTEGER),s[o]=i}for(let o=0;o<s.length;o++){let e=a[o];s[o]<0&&(s[o]+=e),s[o]=Z(0,s[o],a[o])}return s}function pu(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function du(e,t,n,r,a,s){let i=t[a],o=n[a]||1;(e&1<<a||s&1<<a||null==i)&&(i=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);let l=r[a];return i<0&&(i+=l),i=Z(0,i,l-1),i}function hu(e,t,n,r,a,s){let i=t[a],o=n[a]||1;(e&1<<a||s&1<<a||null==i)&&(i=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);let l=r[a];return i<0&&(i+=l),i=o>0?Z(0,i,l):Z(-1,i,l-1),i}function fu(e,t,n){let r=n.length;for(let a=0;a<n.length;a++)if(n[a]>1){r=a;break}for(let a=r+1;a<n.length;a++)if(t[a]>0||n[a]!==e[a])return!1;return!0}function mu(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function gu(e,t,n){let r,a,s=e.shape.length;return r="number"==typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach((e=>{ae(-1!==e,(()=>"slice() does not support negative begin indexing."))})),a=null==n?new Array(s).fill(-1):"number"==typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,a=a.map(((t,n)=>t>=0?t:(ae(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-r[n]))),[r,a]}function yu(e,t,n,r,a,s,i,o,l){let u;if(null==r?(u=new Array(t.length),u.fill(1)):u=r,null!=i&&0!==(i&i-1))throw new Error("Multiple ellipses in slice is not allowed.");let c=!1,p={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let b=0;b<p.dims;b++)c&&0!==(1<<b&o)&&p.numAddAxisAfterEllipsis++,1<<b&i&&(c=!0);c||(p.ellipsisMask|=1<<p.dims,p.dims++);let d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};bu(p,d);let h=!0,f=!0,m=!0,g=[],y=[];for(let b=0;b<e.length;++b){if(0===d.strides[b])throw Error(`strides[${b}] must be non-zero`);let t=!!(d.shrinkAxisMask&1<<b),n=e[b];if(-1===n){g.push(t?1:-1);continue}let r=[d.beginMask&1<<b,d.endMask&1<<b],a=[d.strides[b]>0?0:-1,d.strides[b]>0?n:n-1];if(t&&d.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===d.strides[b];let s=!!(d.beginMask&1<<b&&d.endMask&1<<b);if(d.beginValid&&d.endValid){if(t){let e=d.begin[b]<0?n+d.begin[b]:d.begin[b];if(d.begin[b]=e,d.end[b]=d.begin[b]+1,e<0||e>=n)throw Error(`slice index ${d.begin[b]} of dimension ${b} out of bounds.`)}else d.begin[b]=wu(d.begin[b],0,d.strides[b],n,r,a),d.end[b]=wu(d.end[b],1,d.strides[b],n,r,a);let e=1===d.strides[b]&&0===d.begin[b]&&d.end[b]===n;h=h&&e,f=f&&(0===b&&1===d.strides[b]||e)}else h=h&&1===d.strides[b]&&s,f=f&&(0===b&&1===d.strides[b]||s);let i,o=!1;if(d.beginValid&&d.endValid?(i=d.end[b]-d.begin[b],o=!0):t?(i=1,o=!0):s&&n>=0&&(i=d.strides[b]<0?-n:n,o=!0),o){let e;e=0===i||i<0!=d.strides[b]<0?0:Math.trunc(i/d.strides[b])+(i%d.strides[b]!==0?1:0),g.push(e)}else g.push(-1)}for(let b=0;b<d.finalShapeGatherIndices.length;++b){let e=d.finalShapeGatherIndices[b];e>=0?y.push(g[e]):e===eu&&y.push(1)}return{finalShapeSparse:y.filter(((e,t)=>d.finalShapeGatherIndices[t]!==eu)),finalShape:y,isIdentity:h,sliceDim0:f,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function bu(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){let a=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<a;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(eu),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(tu),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}function wu(e,t,n,r,a,s){if(a[t])return n>0?s[t]:s[t+1&1];{let t=e<0?r+e:e;return t<s[0]?s[0]:t>s[1]?s[1]:t}}var xu={};g(xu,{Serializable:()=>vu,SerializationMap:()=>ku,registerClass:()=>Iu});var vu=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},ku=class{constructor(){this.classNameMap={}}static getMap(){return null==ku.instance&&(ku.instance=new ku),ku.instance}static register(e){ku.getMap().classNameMap[e.className]=[e,e.fromConfig]}};function Iu(e){ae(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),ae("string"==typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),ae(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),ku.register(e)}var Su={};g(Su,{TEST_EPSILON_FLOAT16:()=>Tu,encodeStrings:()=>Ou,expectArrayBuffersEqual:()=>Mu,expectArraysClose:()=>_u,expectArraysEqual:()=>$u,expectNumbersClose:()=>Fu,expectPromiseToFail:()=>Au,expectValuesInRange:()=>Du,testEpsilon:()=>Cu});var Nu=.001,Tu=.1;function _u(e,t,n){return null==n&&(n=Cu()),Eu(e,t,((e,t)=>Ru(e,t,n)))}function Cu(){return 32===Bs.backend.floatPrecision()?Nu:Tu}function Eu(e,t,n){let r=!0;if((Ne(e)||Ne(t))&&(r=!1),Ne(e)&&Ne(t)&&(r=!0),r){let n=e.constructor.name,r=t.constructor.name;if(n!==r)throw new Error(`Arrays are of different type. Actual: ${n}. Expected: ${r}`)}if(Array.isArray(e)&&Array.isArray(t)){let n=Xs(e),r=Xs(t);if(!ce(n,r))throw new Error(`Arrays have different shapes. Actual: [${n}]. Expected: [${r}]`)}let a=Ne(e)?e:oe(e),s=Ne(t)?t:oe(t);if(a.length!==s.length)throw new Error(`Arrays have different lengths actual: ${a.length} vs expected: ${s.length}.\nActual:   ${a}.\nExpected: ${s}.`);for(let i=0;i<s.length;++i){let e=a[i],t=s[i];if(!n(e,t))throw new Error(`Arrays differ: actual[${i}] = ${e}, expected[${i}] = ${t}.\nActual:   ${a}.\nExpected: ${s}.`)}}function Au(e,t){e().then((()=>t.fail()),(()=>t()))}function $u(e,t){let n="string"==typeof t||"number"==typeof t||"boolean"==typeof t?[t]:t;return Ce(e)||Ce(e[0])||Ce(t)||Ce(t[0])?Eu(e,n,((e,t)=>e==t)):Eu(e,t,((e,t)=>Ru(e,t,0)))}function Fu(e,t,n){if(null==n&&(n=Cu()),!Ru(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`)}function Ru(e,t,n){return!isFinite(e)&&!isFinite(t)||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function Du(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function Mu(e,t){let n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let a=0;a<r.length;a++)if(n[a]!==r[a])throw new Error(`Expected ArrayBuffer value at ${a} to be ${r[a]} but got ${n[a]} instead`)}function Ou(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?Ou(n):e[t]=Xa(n)}return e}var Lu="3.18.0";function Pu(e,t){let n=Zs(e,"a","add"),r=Zs(t,"b","add");[n,r]=Es(n,r);let a={a:n,b:r};return Bs.runKernel(st,a)}var zu=ti({add_:Pu});function Bu(e,t){let n=Zs(e,"a","floorDiv"),r=Zs(t,"b","floorDiv");[n,r]=Es(n,r);let a={a:n,b:r};return Bs.runKernel(pn,a)}var Wu=ti({floorDiv_:Bu});function Vu(e,t){let n=Zs(e,"a","div"),r=Zs(t,"b","div");if([n,r]=Es(n,r),"int32"===n.dtype&&"int32"===r.dtype)return Wu(n,r);let a={a:n,b:r},s={};return Bs.runKernel(Jt,a,s)}var Uu=ti({div_:Vu});function Gu(e,t){let n=Zs(e,"a","mul"),r=Zs(t,"b","mul");[n,r]=Es(n,r);let a={a:n,b:r};return Bs.runKernel(Xn,a)}var Hu=ti({mul_:Gu});function ju(e){let t=Zs(e,"x","abs");if("complex64"===t.dtype){let e={x:t};return Bs.runKernel(Et,e)}{let e={x:t};return Bs.runKernel(nt,e)}}var qu=ti({abs_:ju});function Ku(e){let t={x:Zs(e,"x","acos")};return Bs.runKernel(rt,t)}var Xu=ti({acos_:Ku});function Yu(e){let t={x:Zs(e,"x","acosh")};return Bs.runKernel(at,t)}var Ju=ti({acosh_:Yu});function Zu(e){ae(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),ae(e.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`));let t=e.map(((e,t)=>Zs(e,`tensors${t}`,"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!ce(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));let r=t;return Bs.runKernel(it,r)}var Qu=ti({addN_:Zu});function ec(e,t=null,n=!1){let r={x:Zs(e,"x","all","bool")},a={axis:t,keepDims:n};return Bs.runKernel(ot,r,a)}var tc=ti({all_:ec});function nc(e,t=null,n=!1){let r={x:Zs(e,"x","any","bool")},a={axis:t,keepDims:n};return Bs.runKernel(lt,r,a)}var rc=ti({any_:nc});function ac(e,t=0){let n={x:Zs(e,"x","argMax")},r={axis:t};return Bs.runKernel(ut,n,r)}var sc=ti({argMax_:ac});function ic(e,t=0){let n={x:Zs(e,"x","argMin")},r={axis:t};return Bs.runKernel(ct,n,r)}var oc=ti({argMin_:ic});function lc(e){let t={x:Zs(e,"x","asin")};return Bs.runKernel(pt,t)}var uc=ti({asin_:lc});function cc(e){let t={x:Zs(e,"x","asinh")};return Bs.runKernel(dt,t)}var pc=ti({asinh_:cc});function dc(e){let t={x:Zs(e,"x","atan")};return Bs.runKernel(ht,t)}var hc=ti({atan_:dc});function fc(e,t){let n=Zs(e,"a","atan2"),r=Zs(t,"b","atan2");[n,r]=Es(n,r);let a={a:n,b:r};return Bs.runKernel(mt,a)}var mc=ti({atan2_:fc});function gc(e){let t={x:Zs(e,"x","atanh")};return Bs.runKernel(ft,t)}var yc=ti({atanh_:gc});function bc(e,t,n,r,a="NHWC",s){let i=e[3],o=[...t,i],l=Dc(a);return vc(e,o,n,s,r,null,null,l)}function wc(e,t,n,r,a,s,i="channelsLast"){let o,[l,u]=Tc(t);if("channelsLast"===i)o=[l,u,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);o=[l,u,e[1],e[1]]}return vc(e,o,n,r,a,s,!1,i)}function xc(e,t,n,r,a,s,i="NDHWC"){let o,l,[u,c,p]=_c(t);if("NDHWC"===i)l="channelsLast",o=[u,c,p,e[4],e[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);l="channelsFirst",o=[u,c,p,e[1],e[1]]}return kc(e,o,n,r,a,!1,l,s)}function vc(e,t,n,r,a,s,i=!1,o="channelsLast"){let[l,u,c,p]=[-1,-1,-1,-1];if("channelsLast"===o)[l,u,c,p]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,p,u,c]=e}let d,[h,f,,m]=t,[g,y]=Tc(n),[b,w]=Tc(r),x=Cc(h,b),v=Cc(f,w),{padInfo:k,outHeight:I,outWidth:S}=Ec(a,u,c,g,y,x,v,s,o),N=i?m*p:m;return"channelsFirst"===o?d=[l,N,I,S]:"channelsLast"===o&&(d=[l,I,S,N]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:p,outHeight:I,outWidth:S,outChannels:N,padInfo:k,strideHeight:g,strideWidth:y,filterHeight:h,filterWidth:f,effectiveFilterHeight:x,effectiveFilterWidth:v,dilationHeight:b,dilationWidth:w,inShape:e,outShape:d,filterShape:t}}function kc(e,t,n,r,a,s=!1,i="channelsLast",o){let[l,u,c,p,d]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,u,c,p,d]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,d,u,c,p]=e}let h,[f,m,g,,y]=t,[b,w,x]=_c(n),[v,k,I]=_c(r),S=Cc(f,v),N=Cc(m,k),T=Cc(g,I),{padInfo:_,outDepth:C,outHeight:E,outWidth:A}=Ac(a,u,c,p,b,w,x,S,N,T,o),$=s?y*d:y;return"channelsFirst"===i?h=[l,$,C,E,A]:"channelsLast"===i&&(h=[l,C,E,A,$]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:p,inChannels:d,outDepth:C,outHeight:E,outWidth:A,outChannels:$,padInfo:_,strideDepth:b,strideHeight:w,strideWidth:x,filterDepth:f,filterHeight:m,filterWidth:g,effectiveFilterDepth:S,effectiveFilterHeight:N,effectiveFilterWidth:T,dilationDepth:v,dilationHeight:k,dilationWidth:I,inShape:e,outShape:h,filterShape:t}}function Ic(e,t,n,r,a){null==r&&(r=Nc(e,t,n));let s=e[0],i=e[1],o=$c((s-t+2*r)/n+1,a),l=$c((i-t+2*r)/n+1,a);return[o,l]}function Sc(e,t,n,r,a,s){null==a&&(a=Nc(e,t,r));let i=e[0],o=e[1],l=e[2],u=$c((i-t+2*a)/r+1,s),c=$c((o-t+2*a)/r+1,s),p=$c((l-t+2*a)/r+1,s);return[u,c,p,n]}function Nc(e,t,n,r=1){let a=Cc(t,r);return Math.floor((e[0]*(n-1)-n+a)/2)}function Tc(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function _c(e){return"number"==typeof e?[e,e,e]:e}function Cc(e,t){return t<=1?e:e+(e-1)*(t-1)}function Ec(e,t,n,r,a,s,i,o,l){let u,c,p;if("number"==typeof e){u={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};let a=Ic([t,n],s,r,e,o);c=a[0],p=a[1]}else if("same"===e){c=Math.ceil(t/r),p=Math.ceil(n/a);let e=Math.max(0,(c-1)*r+s-t),o=Math.max(0,(p-1)*a+i-n),l=Math.floor(e/2),d=e-l,h=Math.floor(o/2),f=o-h;u={top:l,bottom:d,left:h,right:f,type:"SAME"}}else if("valid"===e)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-s+1)/r),p=Math.ceil((n-i+1)/a);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{let d="channelsLast"===l?e[1][0]:e[2][0],h="channelsLast"===l?e[1][1]:e[2][1],f="channelsLast"===l?e[2][0]:e[3][0],m="channelsLast"===l?e[2][1]:e[3][1];u={top:d,bottom:h,left:f,right:m,type:0===d&&0===h&&0===f&&0===m?"VALID":"EXPLICIT"},c=$c((t-s+d+h)/r+1,o),p=$c((n-i+f+m)/a+1,o)}}return{padInfo:u,outHeight:c,outWidth:p}}function Ac(e,t,n,r,a,s,i,o,l,u,c){let p,d,h,f;if("number"==typeof e){p={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};let s=Sc([t,n,r,1],o,1,a,e,c);d=s[0],h=s[1],f=s[2]}else if("same"===e){d=Math.ceil(t/a),h=Math.ceil(n/s),f=Math.ceil(r/i);let e=(d-1)*a+o-t,c=(h-1)*s+l-n,m=(f-1)*i+u-r,g=Math.floor(e/2),y=e-g,b=Math.floor(c/2),w=c-b,x=Math.floor(m/2),v=m-x;p={top:b,bottom:w,left:x,right:v,front:g,back:y,type:"SAME"}}else{if("valid"!==e)throw Error(`Unknown padding parameter: ${e}`);p={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((t-o+1)/a),h=Math.ceil((n-l+1)/s),f=Math.ceil((r-u+1)/i)}return{padInfo:p,outDepth:d,outHeight:h,outWidth:f}}function $c(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Fc(e){let[t,n,r]=Tc(e);return 1===t&&1===n&&1===r}function Rc(e,t){return Fc(e)||Fc(t)}function Dc(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function Mc(e,t,n){if(null!=n){if("string"==typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"==typeof t)ae(pe(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));else{if("object"!=typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach((t=>{t.forEach((t=>{ae(pe(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))}))}))}}}function Oc(e,t){let n={x:Zs(e,"x","reshape","string_or_numeric")},r={shape:t};return Bs.runKernel(hr,n,r)}var Lc=ti({reshape_:Oc});function Pc(e,t,n,r,a){let s=Zs(e,"x","avgPool","float32"),i=1;ae(Rc(n,i),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`));let o=s,l=!1;3===s.rank&&(l=!0,o=Lc(s,[1,s.shape[0],s.shape[1],s.shape[2]])),ae(4===o.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`)),Mc("avgPool",r,a);let u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:a},p=Bs.runKernel(gt,u,c);return p=go(p,s.dtype),l?Lc(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var zc=ti({avgPool_:Pc});function Bc(e,t,n,r,a,s="NDHWC"){let i=Zs(e,"x","avgPool3d","float32"),o=i,l=!1;4===i.rank&&(l=!0,o=Lc(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),ae(5===o.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`)),ae("NDHWC"===s,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),Mc("avgPool3d",r,a);let u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},p=Bs.runKernel(bt,u,c);return p=go(p,o.dtype),l?Lc(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var Wc=ti({avgPool3d_:Bc});function Vc(e,t=0){ae(e.length>=1,(()=>"Pass at least one tensor to concat"));let n=Qs(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return bo(n[0]);let r=n,a={axis:t};return Bs.runKernel(At,r,a)}var Uc=ti({concat_:Vc});function Gc(e){let t={x:Zs(e,"x","sigmoid","float32")};return Bs.runKernel(Ar,t)}var Hc=ti({sigmoid_:Gc});function jc(e,t,n){let r=Zs(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");let a={x:r},s={begin:t,size:n};return Bs.runKernel(Tr,a,s)}var qc=ti({slice_:jc});function Kc(e){let t={x:Zs(e,"x","tanh","float32")};return Bs.runKernel(Yr,t)}var Xc=ti({tanh_:Kc});function Yc(e,t,n,r,a,s){let i=Zs(e,"forgetBias","basicLSTMCell"),o=Zs(t,"lstmKernel","basicLSTMCell"),l=Zs(n,"lstmBias","basicLSTMCell"),u=Zs(r,"data","basicLSTMCell"),c=Zs(a,"c","basicLSTMCell"),p=Zs(s,"h","basicLSTMCell"),d=Uc([u,p],1),h=Zo(d,o),f=zu(h,l),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=qc(f,[0,0],y),w=qc(f,[0,g],y),x=qc(f,[0,2*g],y),v=qc(f,[0,3*g],y),k=zu(Hu(Hc(b),Xc(w)),Hu(c,Hc(zu(i,x)))),I=Hu(Xc(k),Hc(v));return[k,I]}var Jc=ti({basicLSTMCell_:Yc});function Zc(e,t,n){let r=Zs(e,"x","batchToSpaceND"),a=t.reduce(((e,t)=>e*t));ae(r.rank>=1+t.length,(()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`)),ae(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),ae(r.shape[0]%a===0,(()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${a}`));let s={x:r},i={blockShape:t,crops:n};return Bs.runKernel(vt,s,i)}var Qc=ti({batchToSpaceND_:Zc});function ep(e){let t;return t=0===e.rank||1===e.rank?Lc(e,[1,1,1,e.size]):2===e.rank?Lc(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?Lc(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}function tp(e,t,n,r,a,s){null==s&&(s=.001);let i,o,l=Zs(e,"x","batchNorm"),u=Zs(t,"mean","batchNorm"),c=Zs(n,"variance","batchNorm");null!=a&&(i=Zs(a,"scale","batchNorm")),null!=r&&(o=Zs(r,"offset","batchNorm")),ae(u.rank===c.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),ae(null==o||u.rank===o.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),ae(null==i||u.rank===i.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let p={x:ep(l),scale:i,offset:o,mean:u,variance:c},d={varianceEpsilon:s},h=Bs.runKernel(dn,p,d);return Lc(h,l.shape)}var np=ti({batchNorm_:tp});function rp(e,t,n,r,a,s){let i,o,l=Zs(e,"x","batchNorm"),u=Zs(t,"mean","batchNorm"),c=Zs(n,"variance","batchNorm");return null!=a&&(i=Zs(a,"scale","batchNorm")),null!=r&&(o=Zs(r,"offset","batchNorm")),ae(2===l.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${l.rank}.`)),ae(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${u.rank}.`)),ae(2===c.rank||1===c.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${c.rank}.`)),null!=i&&ae(2===i.rank||1===i.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${i.rank}.`)),null!=o&&ae(2===o.rank||1===o.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${o.rank}.`)),np(l,u,c,o,i,s)}var ap=ti({batchNorm2d_:rp});function sp(e,t,n,r,a,s){let i,o,l=Zs(e,"x","batchNorm"),u=Zs(t,"mean","batchNorm"),c=Zs(n,"variance","batchNorm");return null!=a&&(i=Zs(a,"scale","batchNorm")),null!=r&&(o=Zs(r,"offset","batchNorm")),ae(3===l.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${l.rank}.`)),ae(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${u.rank}.`)),ae(3===c.rank||1===c.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${c.rank}.`)),null!=i&&ae(3===i.rank||1===i.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${i.rank}.`)),null!=o&&ae(3===o.rank||1===o.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${o.rank}.`)),np(l,u,c,o,i,s)}var ip=ti({batchNorm3d_:sp});function op(e,t,n,r,a,s){let i,o,l=Zs(e,"x","batchNorm"),u=Zs(t,"mean","batchNorm"),c=Zs(n,"variance","batchNorm");return null!=a&&(i=Zs(a,"scale","batchNorm")),null!=r&&(o=Zs(r,"offset","batchNorm")),ae(4===l.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${l.rank}.`)),ae(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${u.rank}.`)),ae(4===c.rank||1===c.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${c.rank}.`)),null!=i&&ae(4===i.rank||1===i.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${i.rank}.`)),null!=o&&ae(4===o.rank||1===o.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${o.rank}.`)),np(l,u,c,o,i,s)}var lp=ti({batchNorm4d_:op});function up(e,t,n){let r=Zs(e,"x","bincount"),a=Zs(t,"weights","bincount");ae("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),ae(n>=0,(()=>`size must be non-negative, but got ${n}.`)),ae(a.size===r.size||0===a.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${a.shape}.`));let s={x:r,weights:a},i={size:n};return Bs.runKernel(kt,s,i)}var cp=ti({bincount_:up});function pp(e,t){let n=Zs(e,"s0","broadcastArgs","int32"),r=Zs(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let a={s0:n,s1:r};return Bs.runKernel(St,a)}var dp=ti({broadcastArgs_:pp});function hp(e,t){let n=Zs(e,"broadcastTo","x"),r=n.shape;if(t.some((e=>!(e>0)||e%1!==0)))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=Lc(n,e)}let a=n.shape,s=Array.from(t);for(let l=t.length-1;l>=0;l--)if(a[l]===t[l])s[l]=1;else if(1!==n.shape[l])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(0===s.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return bo(n);let i={x:n},o={reps:s};return Bs.runKernel(Jr,i,o)}var fp=ti({broadcastTo_:hp});function mp(e){let t={x:Zs(e,"x","ceil","float32")};return Bs.runKernel(Tt,t)}var gp=ti({ceil_:mp});function yp(e,t,n){let r=Zs(e,"x","clipByValue");ae(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`));let a={x:r},s={clipValueMin:t,clipValueMax:n};return Bs.runKernel(_t,a,s)}var bp=ti({clipByValue_:yp});function wp(e){return Uc(e,0)}var xp=ti({concat1d_:wp});function vp(e,t){return Uc(e,t)}var kp=ti({concat2d_:vp});function Ip(e,t){return Uc(e,t)}var Sp=ti({concat3d_:Ip});function Np(e,t){return Uc(e,t)}var Tp=ti({concat4d_:Np});function _p(e,t,n,r,a="NHWC",s=[1,1],i){let o=Zs(e,"x","conv2d","float32"),l=Zs(t,"filter","conv2d","float32"),u=o,c=!1;3===o.rank&&(c=!0,u=Lc(o,[1,o.shape[0],o.shape[1],o.shape[2]])),ae(4===u.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`)),ae(4===l.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`)),Mc("conv2d",r,i);let p="NHWC"===a?u.shape[3]:u.shape[1];ae(p===l.shape[2],(()=>`Error in conv2d: depth of input (${p}) must match input depth for filter ${l.shape[2]}.`)),ae(Rc(n,s),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`));let d={x:u,filter:l},h={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},f=Bs.runKernel($t,d,h);return c?Lc(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Cp=ti({conv2d_:_p});function Ep(e,t,n,r,a="NWC",s=1,i){let o=Zs(e,"x","conv1d"),l=Zs(t,"filter","conv1d"),u=o,c=!1;2===o.rank&&(c=!0,u=Lc(o,[1,o.shape[0],o.shape[1]])),ae(3===u.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`)),ae(3===l.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`)),Mc("conv1d",r,i),ae(u.shape[2]===l.shape[1],(()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`)),ae(Rc(n,s),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`)),ae("NWC"===a,(()=>`Error in conv1d: got dataFormat of ${a} but only NWC is currently supported.`));let p=Lc(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=Lc(u,[u.shape[0],1,u.shape[1],u.shape[2]]),h=Cp(d,p,[1,n],r,"NHWC",[1,s],i);return Lc(h,c?[h.shape[2],h.shape[3]]:[h.shape[0],h.shape[2],h.shape[3]])}var Ap=ti({conv1d_:Ep});function $p(e,t,n,r,a,s="NHWC",i){ae(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let o=e,l=t,u=!1;3===t.rank&&(u=!0,l=Lc(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),ae(4===o.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`)),ae(4===l.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`)),ae(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));let c="NHWC"===s?o[3]:o[1],p="NHWC"===s?l.shape[3]:l.shape[1];ae(c===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`)),ae(p===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${p}) must match output depth for filter ${n.shape[3]}.`)),Mc("conv2dDerInput",a,i);let d={dy:l,filter:n},h={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,inputShape:o},f=Bs.runKernel(Rt,d,h);return u?Lc(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Fp=ti({conv2DBackpropInput_:$p});function Rp(e,t,n,r,a,s){let i=Zs(e,"x","conv2dTranspose"),o=Zs(t,"filter","conv2dTranspose");return Fp(n,i,o,r,a,"NHWC",s)}var Dp=ti({conv2dTranspose_:Rp});function Mp(e,t,n,r,a="NDHWC",s=[1,1,1]){let i=Zs(e,"x","conv3d"),o=Zs(t,"filter","conv3d"),l=i,u=!1;4===i.rank&&(u=!0,l=Lc(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),ae(5===l.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`)),ae(5===o.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`)),ae(l.shape[4]===o.shape[3],(()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`)),ae(Rc(n,s),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),ae("NDHWC"===a,(()=>`Error in conv3d: got dataFormat of ${a} but only NDHWC is currently supported.`));let c={x:l,filter:o},p={strides:n,pad:r,dataFormat:a,dilations:s},d=Bs.runKernel(Dt,c,p);return u?Lc(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var Op=ti({conv3d_:Mp});function Lp(e,t,n,r,a){ae(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let s=e,i=t,o=!1;4===t.rank&&(o=!0,i=Lc(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);let l=s[4],u=i.shape[4];ae(5===s.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`)),ae(5===i.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`)),ae(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),ae(l===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`)),ae(u===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`));let c={dy:i,filter:n},p={pad:a,strides:r,inputShape:s},d=Bs.runKernel(Ot,c,p);return o?Lc(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var Pp=ti({conv3DBackpropInput_:Lp});function zp(e,t,n,r,a){let s=Zs(e,"x","conv3dTranspose"),i=Zs(t,"filter","conv3dTranspose");return Pp(n,s,i,r,a)}var Bp=ti({conv3dTranspose_:zp});function Wp(e){let t={x:Zs(e,"x","cos","float32")};return Bs.runKernel(Lt,t)}var Vp=ti({cos_:Wp});function Up(e){let t={x:Zs(e,"x","cosh","float32")};return Bs.runKernel(Pt,t)}var Gp=ti({cosh_:Up});function Hp(e,t=0,n=!1,r=!1){let a={x:Zs(e,"x","cumprod")},s={axis:t,exclusive:n,reverse:r};return Bs.runKernel(zt,a,s)}var jp=ti({cumprod_:Hp});function qp(e,t=0,n=!1,r=!1){let a={x:Zs(e,"x","cumsum")},s={axis:t,exclusive:n,reverse:r};return Bs.runKernel(Bt,a,s)}var Kp=ti({cumsum_:qp});function Xp(e,t,n,r=!1){let a=Zs(e,"x","denseBincount"),s=Zs(t,"weights","denseBincount");ae("int32"===a.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${a.dtype}`)),ae(a.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${a.rank}.`)),ae(n>=0,(()=>`size must be non-negative, but got ${n}.`)),ae(s.size===a.size||0===s.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${a.shape}, weights shape: ${s.shape}.`));let i={x:a,weights:s},o={size:n,binaryOutput:r};return Bs.runKernel(Vt,i,o)}var Yp=ti({denseBincount_:Xp});function Jp(e,t,n="NHWC"){let r=Zs(e,"x","depthToSpace","float32"),a="NHWC"===n?r.shape[1]:r.shape[2],s="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];ae(t>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`)),ae(a*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t}  for depthToSpace with input shape\n    ${r.shape}`)),ae(s*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t} for depthToSpace with input shape\n        ${r.shape}`)),ae(i%(t*t)===0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`));let o={x:r},l={blockSize:t,dataFormat:n};return Bs.runKernel(Ut,o,l)}var Zp=ti({depthToSpace_:Jp});function Qp(e,t,n,r,a="NHWC",s=[1,1],i){let o=Zs(e,"x","depthwiseConv2d","float32"),l=Zs(t,"filter","depthwiseConv2d","float32"),u=o,c=!1;3===o.rank&&(c=!0,u=Lc(o,[1,o.shape[0],o.shape[1],o.shape[2]])),ae(4===u.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`)),ae(4===l.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`)),ae(u.shape[3]===l.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`)),Mc("depthwiseConv2d",r,i);let p={x:u,filter:l},d={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i},h=Bs.runKernel(Gt,p,d);return c?Lc(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var ed=ti({depthwiseConv2d_:Qp});function td(e){let t={x:Zs(e,"x","diag")};return Bs.runKernel(qt,t)}var nd=ti({diag_:td});function rd(e,t,n,r,a=[1,1],s="NHWC"){let i=Zs(e,"x","dilation2d"),o=Zs(t,"filter","dilation2d");ae(3===i.rank||4===i.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`)),ae(3===o.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`)),ae("NHWC"===s,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`));let l=i,u=!1;3===i.rank&&(l=Lc(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0);let c={x:l,filter:o},p={strides:n,pad:r,dilations:a},d=Bs.runKernel(Kt,c,p);return u?Lc(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var ad=ti({dilation2d_:rd});function sd(e,t){let n=Zs(e,"a","equal","string_or_numeric"),r=Zs(t,"b","equal","string_or_numeric");[n,r]=Es(n,r),Ml(n.shape,r.shape);let a={a:n,b:r};return Bs.runKernel(nn,a)}var id=ti({equal_:sd});function od(e,t,n){let r=Zs(t,"a","where"),a=Zs(n,"b","where"),s=Zs(e,"condition","where","bool"),i=Ml(Ml(s.shape,r.shape),a.shape),o=fp(s,i),l=fp(r,i),u=fp(a,i),c={condition:o,t:l,e:u};return Bs.runKernel(Sr,c)}var ld=ti({where_:od});function ud(e){let t={x:Zs(e,"x","zerosLike")};return Bs.runKernel(sa,t)}var cd=ti({zerosLike_:ud});function pd(e,t){let n=Zs(e,"a","div"),r=Zs(t,"b","div");[n,r]=Es(n,r);let a=Uu(n,r),s=cd(a),i=id(r,s);return ld(i,s,a)}var dd=ti({divNoNan_:pd});function hd(e,t){let n=Zs(e,"t1","dot"),r=Zs(t,"t2","dot");ae((1===n.rank||2===n.rank)&&(1===r.rank||2===r.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`));let a=1===n.rank?n.size:n.shape[1],s=1===r.rank?r.size:r.shape[0];if(ae(a===s,(()=>`Error in dot: inner dimensions of inputs must match, but got ${a} and ${s}.`)),1===n.rank&&1===r.rank){let e=Lc(n,[1,-1]),t=Lc(r,[-1,1]),a=Zo(e,t);return Lc(a,[])}if(1===n.rank&&2===r.rank){let e=Lc(n,[1,-1]),t=Lc(r,[r.shape[0],r.shape[1]]),a=Zo(e,t);return Lc(a,[a.size])}if(2===n.rank&&1===r.rank){let e=Lc(r,[-1,1]),t=Zo(n,e);return Lc(t,[t.size])}{let e=Lc(r,[r.shape[0],r.shape[1]]);return Zo(n,e)}}var fd=ti({dot_:hd});function md(e,...t){let n=t.map(((e,t)=>Zs(e,`tensors${t}`,"einsum"))),r={equation:e};return Bs.runKernel(Zt,n,r)}var gd=ti({einsum_:md});function yd(e){let t={x:Zs(e,"x","elu","float32")};return Bs.runKernel(Qt,t)}var bd=ti({elu_:yd});function wd(e){let t=Zs(e,"x","erf");ae("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=go(t,"float32"));let n={x:t};return Bs.runKernel(tn,n)}var xd=ti({erf_:wd});function vd(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function kd(e,t,n){let r=e.length+t.length,a=[],s=0,i=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?a.push(e[s++]):a.push(t[i++]);return a}function Id(e,t){let n=[],r=e.length;for(let s=0;s<r;s++)-1===t.indexOf(s)&&n.push(e[s]);let a=t.map((t=>e[t]));return[n,a]}function Sd(e,t){let n=t.map((e=>1));return kd(e,n,t)}function Nd(e,t,n){ae(vd(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function Td(e,t){if(vd(e,t))return null;let n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function _d(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function Cd(e,t){let n=[];for(let r=t-e;r<t;++r)n.push(r);return n}function Ed(e,t=null,n=!1){let r={x:Zs(e,"x","max")},a={reductionIndices:t,keepDims:n};return Bs.runKernel(On,r,a)}var Ad=ti({max_:Ed});function $d(e,t=null,n=!1){let r={x:Zs(e,"x","min")},a={axis:t,keepDims:n};return Bs.runKernel(Gn,r,a)}var Fd=ti({min_:$d});function Rd(e,t){let n=Zs(e,"base","pow"),r=Zs(t,"exp","pow");[n,r]=Es(n,r);let a={a:n,b:r};return Bs.runKernel(ir,a)}var Dd=ti({pow_:Rd});function Md(e,t){if((Ne(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Ne(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return ai(e,[],[],t)}function Od(e){let t={x:Zs(e,"x","sqrt","float32")};return Bs.runKernel(Fr,t)}var Ld=ti({sqrt_:Od});function Pd(e){let t=Zs(e,"x","square"),n={};return Bs.runKernel("Square",{x:t},n)}var zd=ti({square_:Pd});function Bd(e,t=null,n=!1){let r=Zs(e,"x","sum");"bool"===r.dtype&&(r=go(r,"int32"));let a={x:r},s={axis:t,keepDims:n};return Bs.runKernel(Rr,a,s)}var Wd=ti({sum_:Bd});function Vd(e,t="euclidean",n=null,r=!1){e=Zs(e,"x","norm");let a=Ud(e,t,n),s=a.shape;if(r){let t=be(n,e.shape);s=Sd(a.shape,t)}return Lc(a,s)}function Ud(e,t,n=null){if(0===e.rank)return qu(e);if(1!==e.rank&&null===n)return Ud(Lc(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return Wd(qu(e),n);if(t===1/0)return Ad(qu(e),n);if(t===-1/0)return Fd(qu(e),n);if("euclidean"===t||2===t)return Ld(Wd(Dd(qu(e),Md(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return Ad(Wd(qu(e),n[0]),n[1]-1);if(t===1/0)return Ad(Wd(qu(e),n[1]),n[0]);if(t===-1/0)return Fd(Wd(qu(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return Ld(Wd(zd(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var Gd=ti({norm_:Vd});function Hd(e,t=null,n=!1){return Gd(e,"euclidean",t,n)}var jd=ti({euclideanNorm_:Hd});function qd(e){let t={x:Zs(e,"x","exp")};return Bs.runKernel(rn,t)}var Kd=ti({exp_:qd});function Xd(e,t=0){let n=Zs(e,"x","expandDims","string_or_numeric");ae(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));let r={input:n},a={dim:t};return Bs.runKernel(an,r,a)}var Yd=ti({expandDims_:Xd});function Jd(e){let t={x:Zs(e,"x","expm1")};return Bs.runKernel(sn,t)}var Zd=ti({expm1_:Jd});function Qd(e,t){let n=Zs(e,"x","tile","string_or_numeric");ae(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));let r={x:n},a={reps:t};return Bs.runKernel(Jr,r,a)}var eh=ti({tile_:Qd});function th(e,t,n,r="float32"){null==t&&(t=e);let a=fo([e,t],r),s=e<=t?e:t;for(let o=0;o<s;++o)a.set(1,o,o);let i=Lc(a.toTensor(),[e,t]);if(null==n)return i;if(1===n.length)return eh(Yd(i,0),[n[0],1,1]);if(2===n.length)return eh(Yd(Yd(i,0),0),[n[0],n[1],1,1]);if(3===n.length)return eh(Yd(Yd(Yd(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}var nh=ti({eye_:th});function rh(e,t,n){let r={shape:e,value:t,dtype:n};return Bs.runKernel(ln,{},r)}function ah(e){let t={x:Zs(e,"x","floor","float32")};return Bs.runKernel(cn,t)}var sh=ti({floor_:ah});function ih(e,t,n=0,r=0){let a=Zs(e,"x","gather"),s=Zs(t,"indices","gather","int32"),i={x:a,indices:s},o={axis:n,batchDims:r};return Bs.runKernel(hn,i,o)}var oh=ti({gather_:ih});function lh(e,t){let n=Zs(e,"a","greater","string_or_numeric"),r=Zs(t,"b","greater","string_or_numeric");[n,r]=Es(n,r),Ml(n.shape,r.shape);let a={a:n,b:r};return Bs.runKernel(mn,a)}var uh=ti({greater_:lh});function ch(e,t){let n=Zs(e,"a","greaterEqual","string_or_numeric"),r=Zs(t,"b","greaterEqual","string_or_numeric");[n,r]=Es(n,r),Ml(n.shape,r.shape);let a={a:n,b:r};return Bs.runKernel(gn,a)}var ph=ti({greaterEqual_:ch});function dh(e){let t={x:Zs(e,"x","isFinite")};return Bs.runKernel(xn,t)}var hh=ti({isFinite_:dh});function fh(e){let t={x:Zs(e,"x","isInf")};return Bs.runKernel(vn,t)}var mh=ti({isInf_:fh});function gh(e){let t={x:Zs(e,"x","isNaN")};return Bs.runKernel(kn,t)}var yh=ti({isNaN_:gh});function bh(e,t=.2){let n={x:Zs(e,"x","leakyRelu")},r={alpha:t};return Bs.runKernel(In,n,r)}var wh=ti({leakyRelu_:bh});function xh(e,t){let n=Zs(e,"a","less","string_or_numeric"),r=Zs(t,"b","less","string_or_numeric");[n,r]=Es(n,r),Ml(n.shape,r.shape);let a={a:n,b:r};return Bs.runKernel(Sn,a)}var vh=ti({less_:xh});function kh(e,t){let n=Zs(e,"a","lessEqual","string_or_numeric"),r=Zs(t,"b","lessEqual","string_or_numeric");[n,r]=Es(n,r),Ml(n.shape,r.shape);let a={a:n,b:r};return Bs.runKernel(Nn,a)}var Ih=ti({lessEqual_:kh});function Sh(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");let r={start:e,stop:t,num:n};return Bs.runKernel(Tn,{},r)}function Nh(e,t=5,n=1,r=1,a=.5){let s=Zs(e,"x","localResponseNormalization");ae(4===s.rank||3===s.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${s.rank}.`)),ae(pe(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let i=s,o=!1;3===s.rank&&(o=!0,i=Lc(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let l={x:i},u={depthRadius:t,bias:n,alpha:r,beta:a},c=Bs.runKernel(Dn,l,u);return o?Lc(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var Th=ti({localResponseNormalization_:Nh});function _h(e){let t={x:Zs(e,"x","log","float32")};return Bs.runKernel(_n,t)}var Ch=ti({log_:_h});function Eh(e){let t={x:Zs(e,"x","log1p")};return Bs.runKernel(Cn,t)}var Ah=ti({log1p_:Eh});function $h(e){return ae(Fe(e),(()=>"The f passed in grad(f) must be a function")),(t,n)=>{let r=Zs(t,"x","tf.grad","string_or_numeric"),a=null!=n?Zs(n,"dy","tf.grad"):null;return Bs.tidy((()=>{let{value:t,grads:n}=Bs.gradients((()=>e(r)),[r],a);return null!=a&&se(t.shape,a.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Lh(n),n[0]}))}}function Fh(e){return ae(Fe(e),(()=>"The f passed in grads(f) must be a function")),(t,n)=>{ae(Array.isArray(t),(()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"));let r=Qs(t,"args","tf.grads","string_or_numeric"),a=null!=n?Zs(n,"dy","tf.grads"):null;return Bs.tidy((()=>{let{value:t,grads:n}=Bs.gradients((()=>e(...r)),r,a);return null!=a&&se(t.shape,a.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Lh(n),n}))}}function Rh(e){return ae(Fe(e),(()=>"The f passed in valueAndGrad(f) must be a function")),(t,n)=>{ae(t instanceof ys,(()=>"The x passed in valueAndGrad(f)(x) must be a tensor")),ae(null==n||n instanceof ys,(()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"));let{grads:r,value:a}=Bs.gradients((()=>e(t)),[t],n);return Lh(r),{grad:r[0],value:a}}}function Dh(e){return ae(Fe(e),(()=>"The f passed in valueAndGrads(f) must be a function")),(t,n)=>{ae(Array.isArray(t)&&t.every((e=>e instanceof ys)),(()=>"The args passed in valueAndGrads(f)(args) must be array of tensors")),ae(null==n||n instanceof ys,(()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"));let r=Bs.gradients((()=>e(...t)),t,n);return null!=n&&se(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Lh(r.grads),r}}function Mh(e,t){ae(Fe(e),(()=>"The f passed in variableGrads(f) must be a function")),ae(null==t||Array.isArray(t)&&t.every((e=>e instanceof ws)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));let n=null!=t;if(!n){t=[];for(let e in Bs.registeredVariables)t.push(Bs.registeredVariables[e])}let r=n?t.filter((e=>!e.trainable)):null,a=t.length;t=t.filter((e=>e.trainable)),ae(t.length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${a} variables is trainable.`));let s=!0,{value:i,grads:o}=Bs.gradients(e,t,null,s);ae(o.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),ae(0===i.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`));let l={};return t.forEach(((e,t)=>{null!=o[t]&&(l[e.name]=o[t])})),null!=r&&r.forEach((e=>l[e.name]=null)),{value:i,grads:l}}function Oh(e){return Bs.customGrad(e)}function Lh(e){if(e.filter((e=>null==e)).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}function Ph(e){let t={x:Zs(e,"x","softplus")};return Bs.runKernel($r,t)}var zh=ti({softplus_:Ph});function Bh(e){let t=Zs(e,"x","logSigmoid");return Oh((e=>({value:Nl(zh(Nl(e))),gradFunc:t=>Hu(t,Hc(Nl(e)))})))(t)}var Wh=ti({logSigmoid_:Bh});function Vh(e,t){let n=Zs(e,"a","sub"),r=Zs(t,"b","sub");[n,r]=Es(n,r);let a={a:n,b:r};return Bs.runKernel(Kr,a)}var Uh=ti({sub_:Vh});function Gh(e,t=-1){let n=Zs(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return Oh(((e,n)=>{let r=Ad(e,t,!0),a=Uh(e,r),s=Uh(go(a,"float32"),Ch(Wd(Kd(a),t,!0)));return n([s]),{value:s,gradFunc:(e,n)=>{let[r]=n,a=!0,s=Kd(r);return Uh(e,Hu(Wd(e,t,a),s))}}}))(n)}var Hh=ti({logSoftmax_:Gh});function jh(e,t=null,n=!1){let r=Zs(e,"x","logSumExp"),a=be(t,r.shape),s=Ad(r,a,!0),i=Uh(r,s),o=Kd(i),l=Wd(o,a),u=Ch(l),c=zu(Lc(s,u.shape),u);if(n){let e=Sd(c.shape,a);return Lc(c,e)}return c}var qh=ti({logSumExp_:jh});function Kh(e,t){let n=Zs(e,"a","logicalAnd","bool"),r=Zs(t,"b","logicalAnd","bool");Ml(n.shape,r.shape);let a={a:n,b:r};return Bs.runKernel(En,a)}var Xh=ti({logicalAnd_:Kh});function Yh(e){let t={x:Zs(e,"x","logicalNot","bool")};return Bs.runKernel(An,t)}var Jh=ti({logicalNot_:Yh});function Zh(e,t){let n=Zs(e,"a","logicalOr","bool"),r=Zs(t,"b","logicalOr","bool");Ml(n.shape,r.shape);let a={a:n,b:r};return Bs.runKernel($n,a)}var Qh=ti({logicalOr_:Zh});function ef(e,t){let n=Zs(e,"a","logicalXor","bool"),r=Zs(t,"b","logicalXor","bool");return Ml(n.shape,r.shape),Xh(Qh(e,t),Jh(Xh(e,t)))}var tf=ti({logicalXor_:ef}),nf=2147483648;function rf(e,t,n="left"){let r=Zs(e,"sortedSequence","searchSorted"),a=Zs(t,"values","searchSorted"),s=r.shape[r.shape.length-1],i=a.shape[a.shape.length-1],o=Lc(r,[-1,s]),l=Lc(a,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(le(l.shape)>=nf)throw new Error(`values tensor size must less than ${nf}`);if(o.shape[1]>=nf)throw new Error(`trailing dim_size must less than ${nf} for int32 output type, was ${o.shape[1]}`);let u={sortedSequence:o,values:l},c={side:n};return Bs.runKernel(Ir,u,c)}var af=ti({searchSorted_:rf});function sf(e,t){return af(e,t,"left")}function of(e,t,n,r,a){let s=Zs(e,"x","maxPool"),i=1,o=s,l=!1;3===s.rank&&(l=!0,o=Lc(s,[1,s.shape[0],s.shape[1],s.shape[2]])),ae(4===o.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`)),ae(Rc(n,i),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`)),Mc("maxPool",r,a);let u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:a},p=Bs.runKernel(Pn,u,c);return l?Lc(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var lf=ti({maxPool_:of});function uf(e,t=[1,1,1],n,r,a,s="NDHWC"){let i=Zs(e,"x","maxPool3d"),o=i,l=!1;4===i.rank&&(l=!0,o=Lc(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),ae(5===o.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`)),ae("NDHWC"===s,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`)),Mc("maxPool3d",r,a);let u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:a,dataFormat:s},p=Bs.runKernel(Bn,u,c);return l?Lc(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var cf=ti({maxPool3d_:uf});function pf(e,t,n,r,a=!1){let s={x:Zs(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:a},o=Bs.runKernel(Vn,s,i);return{result:o[0],indexes:o[1]}}var df=ti({maxPoolWithArgmax_:pf});function hf(e,t){let n=Zs(e,"a","maximum"),r=Zs(t,"b","maximum");[n,r]=Es(n,r),"bool"===n.dtype&&(n=go(n,"int32"),r=go(r,"int32")),Ml(n.shape,r.shape);let a={a:n,b:r};return Bs.runKernel(Ln,a)}var ff=ti({maximum_:hf});function mf(e,t=null,n=!1){let r={x:Zs(e,"x","mean")},a={axis:t,keepDims:n};return Bs.runKernel(Un,r,a)}var gf=ti({mean_:mf});function yf(e,t="float32"){if("complex64"===t){let t=yf(e,"float32"),n=yf(e,"float32");return ri(t,n)}let n=Pe(le(e),t);return Bs.makeTensor(n,e,t)}function bf(e,t="float32"){if("complex64"===t){let t=bf(e,"float32"),n=yf(e,"float32");return ri(t,n)}let n=Le(le(e),t);return Bs.makeTensor(n,e,t)}function wf(e,t,{indexing:n="xy"}={}){if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===e)return[];let r=Zs(e,"x","meshgrid",e instanceof ys?e.dtype:"float32");if(void 0===t)return[r];let a=Zs(t,"y","meshgrid",t instanceof ys?t.dtype:"float32"),s=le(r.shape),i=le(a.shape);return"xy"===n?(r=Lc(r,[1,-1]),a=Lc(a,[-1,1]),[Zo(bf([i,1],r.dtype),r),Zo(a,bf([1,s],a.dtype))]):(r=Lc(r,[-1,1]),a=Lc(a,[1,-1]),[Zo(r,bf([1,i],r.dtype)),Zo(bf([s,1],a.dtype),a)])}function xf(e,t){let n=Zs(e,"a","minimum"),r=Zs(t,"b","minimum");[n,r]=Es(n,r),"bool"===n.dtype&&(n=go(n,"int32"),r=go(r,"int32")),Ml(n.shape,r.shape);let a={a:n,b:r};return Bs.runKernel(Hn,a)}var vf=ti({minimum_:xf});function kf(e,t,n){ae("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));let r=Zs(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");ae(t.length===r.rank,(()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`));let a="reflect"===n?1:0;for(let o=0;o<r.rank;o++)ae(2===t[o].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),ae(t[o][0]>=0&&t[o][0]<=r.shape[o]-a&&t[o][1]>=0&&t[o][1]<=r.shape[o]-a,(()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-a} or less than 0 for input of shape ${r.shape}`));let s={paddings:t,mode:n},i={x:r};return Bs.runKernel(jn,i,s)}var If=ti({mirrorPad_:kf});function Sf(e,t){let n=Zs(e,"a","mod"),r=Zs(t,"b","mod");[n,r]=Es(n,r);let a={a:n,b:r};return Bs.runKernel(qn,a)}var Nf=ti({mod_:Sf});function Tf(e,t=null,n=!1){e=Zs(e,"x","moments");let r=be(t,e.shape),a=gf(e,r,n),s=a.shape;n||(s=Sd(a.shape,r));let i=zd(Uh(go(e,"float32"),Lc(a,s))),o=gf(i,r,n);return{mean:a,variance:o}}var _f=ti({moments_:Tf});function Cf(e,t,n,r){let a=Zs(t,"data","multiRNNCell"),s=Qs(n,"c","multiRNNCell"),i=Qs(r,"h","multiRNNCell"),o=a,l=[];for(let p=0;p<e.length;p++){let t=e[p](o,s[p],i[p]);l.push(t[0]),l.push(t[1]),o=t[1]}let u=[],c=[];for(let p=0;p<l.length;p+=2)u.push(l[p]),c.push(l[p+1]);return[u,c]}var Ef=ti({multiRNNCell_:Cf});function Af(e,t,n,r=!1){let a=Zs(e,"logits","multinomial"),s=a.size,i=a.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();let o={logits:1===i?Lc(a,[1,-1]):a},l={numSamples:t,seed:n,normalized:r},u=Bs.runKernel(Kn,o,l);return 1===i?Lc(u,[u.size]):u}var $f=ti({multinomial_:Af});function Ff(e,t){let n=Zs(e,"a","notEqual","string_or_numeric"),r=Zs(t,"b","notEqual","string_or_numeric");[n,r]=Es(n,r),Ml(n.shape,r.shape);let a={a:n,b:r};return Bs.runKernel(Jn,a)}var Rf=ti({notEqual_:Ff});function Df(e){let t={x:Zs(e,"x","onesLike")};return Bs.runKernel(tr,t)}var Mf=ti({onesLike_:Df});function Of(e,t){let n=Zs(e,"v1","outerProduct"),r=Zs(t,"v2","outerProduct");ae(1===n.rank&&1===r.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`));let a=Lc(n,[-1,1]),s=Lc(r,[1,-1]);return Zo(a,s)}var Lf=ti({outerProduct_:Of});function Pf(e,t,n=0){let r=Zs(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let a={paddings:t,constantValue:n},s={x:r};return Bs.runKernel(ar,s,a)}var zf=ti({pad_:Pf});function Bf(e,t,n=0){return ae(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),zf(e,[t],n)}var Wf=ti({pad1d_:Bf});function Vf(e,t,n=0){return ae(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),zf(e,t,n)}var Uf=ti({pad2d_:Vf});function Gf(e,t,n=0){return ae(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),zf(e,t,n)}var Hf=ti({pad3d_:Gf});function jf(e,t,n=0){return ae(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),zf(e,t,n)}var qf=ti({pad4d_:jf});function Kf(e,t,n){let r=Zs(e,"x","spaceToBatchND");ae(r.rank>=1+t.length,(()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`)),ae(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),ae(r.shape.reduce(((e,r,a)=>a>0&&a<=t.length?e&&(r+n[a-1][0]+n[a-1][1])%t[a-1]===0:e),!0),(()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));let a={x:r},s={blockShape:t,paddings:n};return Bs.runKernel(Dr,a,s)}var Xf=ti({spaceToBatchND_:Kf});function Yf(e,t,n,r,a,s,i){null==a&&(a=[1,1]),null==s&&(s=1),0===r&&(r="valid");let o=Zs(e,"x","maxPool"),l=o,u=!1;3===o.rank&&(u=!0,l=Lc(o,[1,o.shape[0],o.shape[1],o.shape[2]])),ae(Rc(s,a),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${a}'`));let c,p=wc(l.shape,t,s,a,r),d=[p.dilationHeight,p.dilationWidth];c="same"===r?Zf([p.filterHeight,p.filterWidth],d):[[0,0],[0,0]];let h=1===d[0]&&1===d[1],[f,m]=Jf([p.inHeight,p.inWidth],d,c),g=h?r:"valid",y=h?l:Xf(l,d,f),b=("avg"===n?()=>zc(y,t,s,g,i):()=>lf(y,t,s,g,i))(),w=h?b:Qc(b,d,m);return u?Lc(w,[w.shape[1],w.shape[2],w.shape[3]]):w}function Jf(e,t,n){let r=n.map((e=>e[0])),a=n.map((e=>e[1])),s=e.concat(r,a),i=t.map(((e,t)=>(e-s[t]%e)%e)),o=a.map(((e,t)=>e+i[t])),l=t.map(((e,t)=>[r[t],o[t]])),u=t.map(((e,t)=>[0,i[t]]));return[l,u]}function Zf(e,t){let n=e.map(((e,n)=>e+(e-1)*(t[n]-1))).map((e=>e-1)),r=n.map((e=>Math.floor(e/2))),a=n.map(((e,t)=>e-r[t]));return n.map(((e,t)=>[r[t],a[t]]))}var Qf=ti({pool_:Yf});function em(e,t){let n=Zs(e,"x","prelu"),r=Zs(t,"alpha","prelu"),a={x:n,alpha:r};return Bs.runKernel(or,a)}var tm=ti({prelu_:em});function nm(e,t=null,n=!1){let r=Zs(e,"x","prod");"bool"===r.dtype&&(r=go(r,"int32"));let a={x:r},s={axis:t,keepDims:n};return Bs.runKernel(lr,a,s)}var rm=ti({prod_:nm});function am(e,t,n){let r=le(e),a=null;if(null==n||"float32"===n)a=new Float32Array(r);else if("int32"===n)a=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);a=new Uint8Array(r)}for(let s=0;s<r;s++)a[s]=t();return Bs.makeTensor(a,e,n)}var sm=ti({rand_:am}),im=b(A()),om=class{constructor(e,t,n,r,a){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);let s=a||Math.random();this.random=im.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){let e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,a,s;do{r=2*this.random()-1,a=2*this.random()-1,s=r*r+a*a}while(s>=1||0===s);let i=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*a*i,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},lm=class{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;let a=r||Math.random();this.randu=im.alea(a.toString()),this.randn=new om(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,a,s;for(;;){do{r=this.randn.nextValue(),s=1+this.c*r}while(s<=0);if(s*=s*s,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-s+Math.log(s)),a=this.randu(),a<t||Math.log(a)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}},um=class{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=im.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function cm(e,t,n=1,r="float32",a){if(null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);let s=new lm(t,n,r,a),i=fo(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var pm=ti({randomGamma_:cm});function dm(e,t=0,n=1,r,a){if(null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);let s=new om(t,n,r,!1,a),i=fo(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var hm=ti({randomNormal_:dm});function fm(e,t=0,n=1,r="float32",a){let s=fo(e,r),i=new um(t,n,null,a);for(let o=0;o<s.values.length;o++)s.values[o]=i.nextValue();return s.toTensor()}var mm=ti({randomUniform_:fm});function gm(e,t,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");let a={start:e,stop:t,step:n,dtype:r};return Bs.runKernel(ur,{},a)}function ym(e){let t={x:Zs(e,"x","reciprocal")};return Bs.runKernel(pr,t)}var bm=ti({reciprocal_:ym});function wm(e){let t={x:Zs(e,"x","relu")};return Bs.runKernel(dr,t)}var xm=ti({relu_:wm});function vm(e){let t={x:Zs(e,"x","relu6")};return Bs.runKernel(br,t)}var km=ti({relu6_:vm});function Im(e,t){let n={x:Zs(e,"x","reverse")},r={dims:t};return Bs.runKernel(wr,n,r)}var Sm=ti({reverse_:Im});function Nm(e){let t=Zs(e,"x","reverse");return ae(1===t.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`)),Sm(t,0)}var Tm=ti({reverse1d_:Nm});function _m(e,t){let n=Zs(e,"x","reverse");return ae(2===n.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`)),Sm(n,t)}var Cm=ti({reverse2d_:_m});function Em(e,t){let n=Zs(e,"x","reverse");return ae(3===n.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`)),Sm(n,t)}var Am=ti({reverse3d_:Em});function $m(e,t){let n=Zs(e,"x","reverse");return ae(4===n.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`)),Sm(n,t)}var Fm=ti({reverse4d_:$m});function Rm(e){let t={x:Zs(e,"x","round")};return Bs.runKernel(xr,t)}var Dm=ti({round_:Rm});function Mm(e){let t={x:Zs(e,"x","rsqrt","float32")};return Bs.runKernel(vr,t)}var Om=ti({rsqrt_:Mm});function Lm(e){let t={x:Zs(e,"x","selu")};return Bs.runKernel(Nr,t)}var Pm=ti({selu_:Lm});function zm(e,t,n,r,a,s=[1,1],i="NHWC"){let o=Zs(e,"x","separableConv2d"),l=Zs(t,"depthwiseFilter","separableConv2d"),u=Zs(n,"pointwiseFilter","separableConv2d"),c=o,p=!1;if(3===o.rank&&(p=!0,c=Lc(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");ae(4===c.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`)),ae(4===l.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`)),ae(4===u.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`)),ae(1===u.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`)),ae(1===u.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`));let d=l.shape[2],h=l.shape[3];ae(u.shape[2]===d*h,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*h}, but got ${u.shape[2]}.`));let f=ed(c,l,r,a,i,s),m=Cp(f,u,1,"valid",i);return p?Lc(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var Bm=ti({separableConv2d_:zm});async function Wm(e,t){let n=Zs(e,"x","setdiff1d"),r=Zs(t,"y","setdiff1d");ae(n.dtype===r.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`)),ae(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),ae(1===r.rank,(()=>`y should be 1D tensor, but got y (${r.shape}).`));let a=await n.data(),s=await r.data(),i=new Set(s),o=0;for(let c=0;c<a.length;c++)i.has(a[c])||o++;let l=new ps([o],n.dtype),u=new ps([o],"int32");for(let c=0,p=0;c<a.length;c++)i.has(a[c])||(l.values[p]=a[c],u.values[p]=c,p++);return[l.toTensor(),u.toTensor()]}var Vm=Wm;function Um(e){let t={x:Zs(e,"x","sign")};return Bs.runKernel(Er,t)}var Gm=ti({sign_:Um});function Hm(e){let t={x:Zs(e,"x","sin","float32")};return Bs.runKernel(_r,t)}var jm=ti({sin_:Hm});function qm(e){let t={x:Zs(e,"x","sinh")};return Bs.runKernel(Cr,t)}var Km=ti({sinh_:qm});function Xm(e,t,n){let r=Zs(e,"x","slice1d");return ae(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),qc(r,[t],[n])}var Ym=ti({slice1d_:Xm});function Jm(e,t,n){let r=Zs(e,"x","slice2d");return ae(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),qc(r,t,n)}var Zm=ti({slice2d_:Jm});function Qm(e,t,n){let r=Zs(e,"x","slice3d");return ae(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),qc(r,t,n)}var eg=ti({slice3d_:Qm});function tg(e,t,n){let r=Zs(e,"x","slice4d");return ae(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),qc(r,t,n)}var ng=ti({slice4d_:tg});function rg(e,t=-1){let n=Zs(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let r={logits:n},a={dim:t};return Bs.runKernel(Or,r,a)}var ag=ti({softmax_:rg});function sg(e){ae("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));let t={input:e};return Bs.runKernel(on,t)}var ig=ti({fft_:sg});function og(e){ae("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));let t={input:e};return Bs.runKernel(bn,t)}var lg=ti({ifft_:og});function ug(e){let t,n=e.shape[e.shape.length-1],r=e.size/n;if(n<=2){let a=Lc(e,[r,n]);t=lg(a)}else{let a=[r,2*(n-1)],s=Lc(_l(e),[r,n]),i=Lc(Il(e),[r,n]),o=Sm(qc(s,[0,1],[r,n-2]),1),l=Hu(Sm(qc(i,[0,1],[r,n-2]),1),Md(-1)),u=Uc([s,o],1),c=Uc([i,l],1),p=Lc(ri(u,c),[a[0],a[1]]);t=lg(p)}if(t=_l(t),3===e.rank&&0!==e.shape[0]){let n=t,r=e.shape[0];t=Lc(t,[r,t.shape[0]/r,t.shape[1]]),n.dispose()}return t}var cg=ti({irfft_:ug});function pg(e,t,n=0){let r={x:Zs(e,"x","split")},a={numOrSizeSplits:t,axis:n};return Bs.runKernel(Mr,r,a)}var dg=ti({split_:pg});function hg(e,t){ae("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n,r=e.shape[e.shape.length-1],a=e.size/r;if(null!=t&&t<r){let a=e.shape.map((e=>0)),s=e.shape.map((e=>e));s[e.shape.length-1]=t,n=qc(e,a,s),r=t}else if(null!=t&&t>r){let a=e.shape.map((e=>e));a[e.shape.length-1]=t-r,n=Uc([e,yf(a)],e.shape.length-1),r=t}else n=e;let s=cd(n),i=Lc(ri(n,s),[a,r]),o=ig(i),l=Math.floor(r/2)+1,u=_l(o),c=Il(o),p=dg(u,[l,r-l],u.shape.length-1),d=dg(c,[l,r-l],c.shape.length-1),h=n.shape.slice();return h[n.shape.length-1]=l,Lc(ri(p[0],d[0]),h)}var fg=ti({rfft_:hg});function mg(e,t){let n=Zs(e,"a","squaredDifference"),r=Zs(t,"b","squaredDifference");[n,r]=Es(n,r),Ml(n.shape,r.shape);let a={a:n,b:r},s={};return Bs.runKernel(Vr,a,s)}var gg=ti({squaredDifference_:mg});function yg(e,t){let n=Zs(e,"x","squeeze");return Lc(n,we(n.shape,t).newShape)}var bg=ti({squeeze_:yg});function wg(e,t=0){let n=Qs(e,"tensors","stack","string_or_numeric");ae(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&ae(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));let r=n,a={axis:t};return Bs.runKernel(rr,r,a)}var xg=ti({stack_:wg});function vg(e,t=0){let n={x:Zs(e,"x","step")},r={alpha:t};return Bs.runKernel(ia,n,r)}var kg=ti({step_:vg});function Ig(e,t,n,r,a=0,s=0,i=0,o=0,l=0){let u={x:Zs(e,"x","stridedSlice","string_or_numeric")},c={begin:t,end:n,strides:r,beginMask:a,endMask:s,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return Bs.runKernel(Gr,u,c)}var Sg=ti({stridedSlice_:Ig});function Ng(e){let t={x:Zs(e,"x","tan","float32")};return Bs.runKernel(Xr,t)}var Tg=ti({tan_:Ng});function _g(e,t){ie(e);let n=Xs(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return ai(e,null,n,t)}function Cg(e,t,n){if(ie(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");let r=Xs(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return ai(e,t,r,n)}function Eg(e,t,n){if(ie(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");let r=Xs(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return ai(e,t,r,n)}function Ag(e,t,n){if(ie(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");let r=Xs(e,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return ai(e,t,r,n)}function $g(e,t,n){if(ie(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");let r=Xs(e,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||r,ai(e,t,r,n)}function Fg(e,t=1,n=!0){let r=Zs(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");let a=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>a)throw new Error(`'k' passed to topk() must be <= the last dimension (${a}) but got ${t}`);let s={x:r},i={k:t,sorted:n},[o,l]=Bs.runKernel(Zr,s,i);return{values:o,indices:l}}var Rg=ti({topk_:Fg});function Dg(e,t=0,n=1,r,a){if(null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");let s=new om(t,n,r,!0,a),i=fo(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=s.nextValue();return i.toTensor()}var Mg=ti({truncatedNormal_:Dg});function Og(e,t=0){let n=Zs(e,"x","unique","string_or_numeric");ae(n.rank>0,(()=>"The input tensor must be at least 1D"));let r={x:n},a={axis:t},[s,i]=Bs.runKernel(ta,r,a);return{values:s,indices:i}}var Lg=ti({unique_:Og});function Pg(e,t,n){let r=Zs(e,"x","unsortedSegmentSum"),a=Zs(t,"segmentIds","unsortedSegmentSum","int32");ae(pe(n),(()=>"numSegments must be of dtype int"));let s={x:r,segmentIds:a},i={numSegments:n};return Bs.runKernel(ra,s,i)}var zg=ti({unsortedSegmentSum_:Pg});function Bg(e,t=0){let n=Zs(e,"x","unstack","string_or_numeric");ae(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));let r={value:n},a={axis:t};return Bs.runKernel(na,r,a)}var Wg=ti({unstack_:Bg});function Vg(e,t){return af(e,t,"right")}function Ug(e,t=!0,n,r){return Bs.makeVariable(e,t,n,r)}function Gg(e,t){let n=[];for(let s=0;s<t.length;s++)t[s]&&n.push(s);let r=fo(e,"int32"),a=fo([n.length,e.length],"int32");for(let s=0;s<n.length;s++){let t=r.indexToLoc(n[s]),i=s*e.length;a.values.set(t,i)}return a.toTensor()}async function Hg(e){let t=Zs(e,"condition","whereAsync","bool"),n=await t.data(),r=Gg(t.shape,n);return e!==t&&t.dispose(),r}var jg=Hg;async function qg(e,t,n){let r=Zs(e,"tensor","boolMask"),a=Zs(t,"mask","boolMask","bool"),s=null==n?0:n,i=a.rank,o=r.shape;ae(i>0,(()=>"mask cannot be scalar")),se(o.slice(s,s+i),a.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=s;m<s+i;m++)l*=o[m];let u=o.slice(0,s).concat([l],o.slice(s+i)),c=Lc(r,u),p=Lc(a,[-1]),d=await jg(p),h=bg(d,[1]),f=oh(c,h,s);return e!==r&&r.dispose(),t!==a&&a.dispose(),h.dispose(),c.dispose(),p.dispose(),d.dispose(),f}var Kg=qg;function Xg(e,t,n,r,a=!0){let s=Zs(e,"v","movingAverage"),i=Zs(t,"x","movingAverage"),o=Zs(n,"decay","movingAverage");As(s,i),ae(ce(s.shape,i.shape),(()=>"Shape mismatch in v and x"));let l=Md(1),u=Uh(l,o),c=Hu(Uh(i,s),u);if(a){ae(null!=r,(()=>"When using zeroDebias: true, step is required."));let e=Zs(r,"step","movingAverage");c=Uu(c,Uh(l,Dd(o,e)))}return zu(s,c)}var Yg=ti({movingAverage_:Xg});function Jg(e,t,n){let r=Zs(e,"indices","scatterND","int32"),a=Zs(t,"updates","scatterND");Jl(a,r,n);let s={indices:r,updates:a},i={shape:n};return Bs.runKernel(kr,s,i)}var Zg=ti({scatterND_:Jg});function Qg(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let a=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);let i=t.size;if(0!==t.rank&&(1!==t.rank||i!==a))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${a}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function ey(e,t,n,r=0){let a=Zs(e,"sparseIndices","sparseToDense","int32"),s=Zs(t,"sparseValues","sparseToDense","string_or_numeric"),i=Zs(r,"defaultValue","sparseToDense",s.dtype);Qg(a,s,n,i);let o={sparseIndices:a,sparseValues:s,defaultValue:i},l={outputShape:n};return Bs.runKernel(Wr,o,l)}var ty=ti({sparseToDense_:ey});function ny(e,t){let n=Zs(t,"indices","gatherND","int32"),r={params:Zs(e,"x","gatherND","string_or_numeric"),indices:n};return Bs.runKernel(fn,r)}var ry=ti({gatherND_:ny});function ay(e,t){if(null==t)return e.shape.slice();if(ce(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}function sy(e,t,n,r){let a=Zs(e,"x","dropout");if(ae("float32"===a.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${a.dtype} tensor instead.`)),ae(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return e instanceof ys?a.clone():a;let s=ay(a,n),i=1-t,o=Uu(sh(zu(mm(s,0,1,"float32",r),i)),i);return Hu(a,o)}var iy=ti({dropout_:sy});function oy(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function ly(e,t,n){let r=1-e%2,a=new Float32Array(e);for(let s=0;s<e;++s){let i=2*Math.PI*s/(e+r-1);a[s]=t-n*Math.cos(i)}return _g(a,"float32")}async function uy(e,t,n=1){let r=Zs(e,"predictions","inTopK"),a=Zs(t,"targets","inTopK");ae(r.rank>1,(()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`)),ae(r.rank-1===a.rank,(()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${a.rank}`)),se(r.shape.slice(0,r.shape.length-1),a.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=r.shape[r.shape.length-1];ae(n>0&&n<=s,(()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`));let i=await r.data(),o=await a.data(),[l,u]=[i.length/s,s],c=xe("bool",l);for(let p=0;p<l;p++){let e=p*u,t=i.subarray(e,e+u),r=[];for(let n=0;n<t.length;n++)r.push({value:t[n],index:n});r.sort(((e,t)=>t.value-e.value)),c[p]=0;for(let a=0;a<n;a++)if(r[a].index===o[p]){c[p]=1;break}}return e!==r&&r.dispose(),t!==a&&a.dispose(),si(c,a.shape,"bool")}var cy=uy,py={};function dy(e,t,n,r,a,s="NHWC",i){let o=e;3===e.rank&&(o=Lc(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=Lc(t,[1,t.shape[0],t.shape[1],t.shape[2]])),ae(4===o.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`)),ae(4===l.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`)),ae(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));let u="NHWC"===s?o.shape[3]:o.shape[1],c="NHWC"===s?l.shape[3]:l.shape[1];ae(u===n[2],(()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`)),ae(c===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`)),Mc("conv2dDerFilter",a,i);let p={x:o,dy:l},d={strides:r,pad:a,dataFormat:s,dimRoundingMode:i,filterShape:n};return Bs.runKernel(Ft,p,d)}g(py,{conv2d:()=>wy,depthwiseConv2d:()=>Ny,matMul:()=>_y});var hy=ti({conv2DBackpropFilter_:dy});function fy(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return Hu(e,kg(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function my(e,t){let n=t,r=Dl(e.shape,t.shape);return r.length>0&&(n=Wd(n,r)),Lc(n,e.shape)}function gy(e,t,n,r){if("linear"===t)return e;if("relu"===t)return xm(e);if("elu"===t)return bd(e);if("relu6"===t)return km(e);if("prelu"===t)return tm(e,n);if("leakyrelu"===t)return wh(e,r);if("sigmoid"===t)return Hc(e);throw new Error(`Unknown fused activation ${t}.`)}var yy=(e,t)=>!(e>0)||"linear"===t;function by({x:e,filter:t,strides:n,pad:r,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",!1===yy(Bs.state.gradientDepth,l)){ae("NHWC"===a,(()=>`Error in fused conv2d: got dataFormat of ${a} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let p=Cp(e,t,n,r,a,s,i);return null!=o&&(p=zu(p,o)),gy(p,l,u,c)}let p=Zs(e,"x","conv2d","float32"),d=Zs(t,"filter","conv2d","float32"),h=p,f=!1;3===p.rank&&(f=!0,h=Lc(p,[1,p.shape[0],p.shape[1],p.shape[2]])),ae(4===h.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${h.rank}.`)),ae(4===d.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`)),Mc("fused conv2d",r,i);let m="NHWC"===a?h.shape[3]:h.shape[1];ae(d.shape[2]===m,(()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${d.shape[2]}.`)),ae(Rc(n,s),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`));let g,y,b=vc(h.shape,d.shape,n,s,r,i);if(null!=o&&(g=Zs(o,"bias","fused conv2d"),[g]=Es(g,p),"NHWC"===a?Ml(b.outShape,g.shape):(ae(g.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${g.shape.length}.`)),ae(0===g.shape.length||g.shape[0]===b.outChannels||1===g.shape[0],(()=>`Error in fused conv2d: bias shape (${g.shape}) is not compatible with the number of output channels (${b.outChannels})`)))),null!=u){let e=u.shape;if(ae(e.length<=1||3===e.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`)),1===e.length)ae(1===e[0]||e[0]===b.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${b.outChannels}).`));else if(3===e.length)try{Ml(e,b.outShape)}catch(k){let t=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${b.outShape}).`;throw Error(t)}y=Zs(u,"prelu weights","fused conv2d")}let w=(e,t)=>{ae("NHWC"===a,(()=>`Error in gradient of fused conv2D: got dataFormat of ${a} but only NHWC is currently supported.`));let[i,o,u,c]=t,p=fy(e,u,l);ae(Fc(s),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`));let d=Fp(o.shape,p,i,n,r),h=hy(o,p,i.shape,n,r),f=[d,h];if(null!=c){let e=my(c,p);f.push(e)}return f},x={x:h,filter:d,bias:g,preluActivationWeights:y},v={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return null==o?Oh(((e,t,n)=>{let r=Bs.runKernel(ca,x,v);return n([t,e,r]),f&&(r=Lc(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:w}}))(h,d):Oh(((e,t,n,r)=>{let a=Bs.runKernel(ca,x,v);return r([t,e,a,n]),f&&(a=Lc(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:w}}))(h,d,g)}var wy=ti({fusedConv2d_:by});function xy(e,t,n,r,a,s=[1,1],i){let o=e;3===e.rank&&(o=Lc(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=Lc(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={x:o,dy:l},c={strides:r,pad:a,dimRoundingMode:i,dilations:s,filterShape:n};return Bs.runKernel(Ht,u,c)}var vy=ti({depthwiseConv2dNativeBackpropFilter_:xy});function ky(e,t,n,r,a,s=[1,1],i){let o=t,l=!1;3===t.rank&&(l=!0,o=Lc(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={dy:o,filter:n},c={strides:r,pad:a,dimRoundingMode:i,dilations:s,inputShape:e},p=Bs.runKernel(jt,u,c);return l?Lc(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var Iy=ti({depthwiseConv2dNativeBackpropInput_:ky});function Sy({x:e,filter:t,strides:n,pad:r,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===yy(Bs.state.gradientDepth,l)){let p=ed(e,t,n,r,a,s,i);return null!=o&&(p=zu(p,o)),gy(p,l,u,c)}let p=Zs(e,"x","depthwiseConv2d","float32"),d=Zs(t,"filter","depthwiseConv2d","float32"),h=p,f=!1;3===p.rank&&(f=!0,h=Lc(p,[1,p.shape[0],p.shape[1],p.shape[2]])),ae(4===h.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`)),ae(4===d.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`)),ae(h.shape[3]===d.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${h.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`)),null==s&&(s=[1,1]),ae(Rc(n,s),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`)),Mc("fused depthwiseConv2d",r,i);let m,g,y=vc(h.shape,d.shape,n,s,r,i,!0);null!=o&&(m=Zs(o,"bias","fused conv2d"),[m]=Es(m,p),Ml(y.outShape,m.shape)),null!=u&&(g=Zs(u,"prelu weights","fused depthwiseConv2d"));let b=(e,t)=>{ae(Fc(s),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`));let[a,o,u,c]=t,p=fy(e,u,l),d=Iy(o.shape,p,a,n,r,s,i),h=vy(o,p,a.shape,n,r,s,i);if(null!=c){let e=my(m,p);return[d,h,e]}return[d,h]},w={x:h,filter:d,bias:m,preluActivationWeights:g},x={strides:n,pad:r,dataFormat:a,dilations:s,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return null==o?Oh(((e,t,n)=>{let r=Bs.runKernel(pa,w,x);return n([t,e,r]),f&&(r=Lc(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:b}}))(h,d):Oh(((e,t,n,r)=>{let a=Bs.runKernel(pa,w,x);return r([t,e,a,n]),f&&(a=Lc(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:b}}))(h,d,m)}var Ny=ti({fusedDepthwiseConv2d_:Sy});function Ty({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:a,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:o}){if(!1===yy(Bs.state.gradientDepth,s)){let l=Zo(e,t,n,r);return null!=a&&(l=zu(l,a)),gy(l,s,i,o)}let l=Zs(e,"a","fused matMul"),u=Zs(t,"b","fused matMul");[l,u]=Es(l,u);let c=n?l.shape[l.rank-2]:l.shape[l.rank-1],p=r?u.shape[u.rank-1]:u.shape[u.rank-2],d=n?l.shape[l.rank-1]:l.shape[l.rank-2],h=r?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=le(f),y=le(m);ae(c===p,(()=>`Error in fused matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${r} must match.`));let b,w,x=Ml(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([d,h]),v=Lc(l,n?[g,c,d]:[g,d,c]),k=Lc(u,r?[y,h,p]:[y,p,h]);null!=a&&(b=Zs(a,"bias","fused matMul"),[b]=Es(b,l),Ml(x,b.shape)),null!=i&&(w=Zs(i,"prelu weights","fused matMul"));let I=(e,t)=>{let i,o,[l,u,c,p]=t,d=fy(Lc(e,c.shape),c,s);if(n||r?!n&&r?(i=Zo(d,u,!1,!1),o=Zo(d,l,!0,!1)):n&&!r?(i=Zo(u,d,!1,!0),o=Zo(l,d,!1,!1)):(i=Zo(u,d,!0,!0),o=Zo(d,l,!0,!0)):(i=Zo(d,u,!1,!0),o=Zo(l,d,!0,!1)),null!=a){let e=my(p,d);return[i,o,e]}return[i,o]},S={a:v,b:k,bias:b,preluActivationWeights:w},N={transposeA:n,transposeB:r,activation:s,leakyreluAlpha:o};return null==a?Oh(((e,t,n)=>{let r=Bs.runKernel(ua,S,N);return n([e,t,r]),{value:Lc(r,x),gradFunc:I}}))(v,k):Oh(((e,t,n,r)=>{let a=Bs.runKernel(ua,S,N);return r([e,t,a,n]),{value:Lc(a,x),gradFunc:I}}))(v,k,b)}var _y=ti({fusedMatMul_:Ty});function Cy(e){return ly(e,.54,.46)}var Ey=ti({hammingWindow_:Cy});function Ay(e){return ly(e,.5,.5)}var $y=ti({hannWindow_:Ay});function Fy(e,t,n,r=!1,a=0){let s=0,i=[];for(;s+t<=e.size;)i.push(qc(e,s,t)),s+=n;if(r)for(;s<e.size;){let r=s+t-e.size,o=Uc([qc(e,s,t-r),rh([r],a)]);i.push(o),s+=n}return 0===i.length?Cg([],[0,t]):Lc(Uc(i),[i.length,t])}var Ry=ti({frame_:Fy});function Dy(e,t,n,r,a=$y){null==r&&(r=oy(t));let s=Ry(e,t,n),i=Hu(s,a(t));return fg(i,r)}var My=ti({stft_:Dy});function Oy(e,t,n,r,a="bilinear",s=0){let i=Zs(e,"image","cropAndResize"),o=Zs(t,"boxes","cropAndResize","float32"),l=Zs(n,"boxInd","cropAndResize","int32"),u=o.shape[0];ae(4===i.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`)),ae(2===o.rank&&4===o.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`)),ae(1===l.rank&&l.shape[0]===u,(()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`)),ae(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),ae(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),ae("bilinear"===a||"nearest"===a,(()=>`method must be bilinear or nearest, but was ${a}`));let c={image:i,boxes:o,boxInd:l},p={method:a,extrapolationValue:s,cropSize:r};return Bs.runKernel(Wt,c,p)}var Ly=ti({cropAndResize_:Oy});function Py(e){let t=Zs(e,"image","flipLeftRight","float32");ae(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));let n={image:t};return Bs.runKernel(un,n,{})}var zy=ti({flipLeftRight_:Py});function By(e){let t=Zs(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];ae(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),ae(1===r,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`));let a=new Array(t.rank);return a.fill(1,0,n),a[n]=3,eh(t,a)}var Wy=ti({grayscaleToRGB_:By});function Vy(e,t,n=0,r=.5){let a=Zs(e,"image","rotateWithOffset","float32");ae(4===a.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`));let s={image:a},i={radians:t,fillValue:n,center:r};return Bs.runKernel(la,s,i)}var Uy=ti({rotateWithOffset_:Vy});function Gy(e,t,n,r,a,s){null==r&&(r=.5),null==a&&(a=Number.NEGATIVE_INFINITY),null==s&&(s=0);let i=e.shape[0];return n=Math.min(n,i),ae(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),ae(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),ae(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),ae(1===t.rank,(()=>"scores must be a 1D tensor")),ae(t.shape[0]===i,(()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`)),ae(0<=s&&s<=1,(()=>`softNmsSigma must be in [0, 1], but was '${s}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s}}function Hy(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY){let s=Zs(e,"boxes","nonMaxSuppression","float32"),i=Zs(t,"scores","nonMaxSuppression","float32"),o=Gy(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;let l={maxOutputSize:n,iouThreshold:r,scoreThreshold:a};return Bs.runKernel(Zn,{boxes:s,scores:i},l)}var jy=ti({nonMaxSuppression_:Hy});function qy(e,t,n){let r=Ky(e,t,n),a=r<0?-(r+1):r;e.splice(a,0,t)}function Ky(e,t,n){return Yy(e,t,n||Xy)}function Xy(e,t){return e>t?1:e<t?-1:0}function Yy(e,t,n){let r=0,a=e.length,s=0,i=!1;for(;r<a;){s=r+(a-r>>>1);let o=n(t,e[s]);o>0?r=s+1:(a=s,i=!o)}return i?r:-r-1}function Jy(e,t,n,r,a){return eb(e,t,n,r,a,0)}function Zy(e,t,n,r,a,s){return eb(e,t,n,r,a,0,!1,s,!0)}function Qy(e,t,n,r,a,s){return eb(e,t,n,r,a,s,!0)}function eb(e,t,n,r,a,s,i=!1,o=!1,l=!1){let u=[];for(let g=0;g<t.length;g++)t[g]>a&&u.push({score:t[g],boxIndex:g,suppressBeginIndex:0});u.sort(rb);let c=s>0?-.5/s:0,p=[],d=[];for(;p.length<n&&u.length>0;){let t=u.pop(),{score:n,boxIndex:s,suppressBeginIndex:i}=t;if(n<a)break;let o=!1;for(let l=p.length-1;l>=i;--l){let n=tb(e,s,p[l]);if(n>=r){o=!0;break}if(t.score=t.score*nb(r,c,n),t.score<=a)break}t.suppressBeginIndex=p.length,o||(t.score===n?(p.push(s),d.push(t.score)):t.score>a&&qy(u,t,rb))}let h=p.length,f=n-h;o&&f>0&&(p.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));let m={selectedIndices:p};return i&&(m.selectedScores=d),l&&(m.validOutputs=h),m}function tb(e,t,n){let r=e.subarray(4*t,4*t+4),a=e.subarray(4*n,4*n+4),s=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(a[0],a[2]),c=Math.min(a[1],a[3]),p=Math.max(a[0],a[2]),d=Math.max(a[1],a[3]),h=(o-s)*(l-i),f=(p-u)*(d-c);if(h<=0||f<=0)return 0;let m=Math.max(s,u),g=Math.max(i,c),y=Math.min(o,p),b=Math.min(l,d),w=Math.max(y-m,0)*Math.max(b-g,0);return w/(h+f-w)}function nb(e,t,n){let r=Math.exp(t*n*n);return n<=e?r:0}function rb(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function ab(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY){let s=Zs(e,"boxes","nonMaxSuppressionAsync"),i=Zs(t,"scores","nonMaxSuppressionAsync"),o=Gy(s,i,n,r,a);n=o.maxOutputSize,r=o.iouThreshold,a=o.scoreThreshold;let l=await Promise.all([s.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:p}=Jy(u,c,n,r,a);return s!==e&&s.dispose(),i!==t&&i.dispose(),_g(p,"int32")}var sb=ab;function ib(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=0){let i=Zs(e,"boxes","nonMaxSuppression"),o=Zs(t,"scores","nonMaxSuppression"),l=Gy(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;let u={boxes:i,scores:o},c={maxOutputSize:n,iouThreshold:r,scoreThreshold:a,softNmsSigma:s},p=Bs.runKernel(er,u,c);return{selectedIndices:p[0],selectedScores:p[1]}}var ob=ti({nonMaxSuppressionWithScore_:ib});async function lb(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=0){let i=Zs(e,"boxes","nonMaxSuppressionAsync"),o=Zs(t,"scores","nonMaxSuppressionAsync"),l=Gy(i,o,n,r,a,s);n=l.maxOutputSize,r=l.iouThreshold,a=l.scoreThreshold,s=l.softNmsSigma;let u=await Promise.all([i.data(),o.data()]),c=u[0],p=u[1],{selectedIndices:d,selectedScores:h}=Qy(c,p,n,r,a,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:_g(d,"int32"),selectedScores:_g(h)}}var ub=lb;function cb(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=!1){let i=Zs(e,"boxes","nonMaxSuppression"),o=Zs(t,"scores","nonMaxSuppression"),l=Gy(i,o,n,r,a,null),u=l.maxOutputSize,c=l.iouThreshold,p=l.scoreThreshold,d={boxes:i,scores:o},h={maxOutputSize:u,iouThreshold:c,scoreThreshold:p,padToMaxOutputSize:s},f=Bs.runKernel(Qn,d,h);return{selectedIndices:f[0],validOutputs:f[1]}}var pb=ti({nonMaxSuppressionPadded_:cb});async function db(e,t,n,r=.5,a=Number.NEGATIVE_INFINITY,s=!1){let i=Zs(e,"boxes","nonMaxSuppressionAsync"),o=Zs(t,"scores","nonMaxSuppressionAsync"),l=Gy(i,o,n,r,a,null),u=l.maxOutputSize,c=l.iouThreshold,p=l.scoreThreshold,[d,h]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=Zy(d,h,u,c,p,s);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:_g(f,"int32"),validOutputs:Md(m,"int32")}}var hb=db;function fb(e,t,n=!1,r=!1){let a=Zs(e,"images","resizeBilinear");ae(3===a.rank||4===a.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a.rank}.`)),ae(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),ae(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let s=a,i=!1;3===a.rank&&(i=!0,s=Lc(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let[]=t,o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},u=Bs.runKernel(gr,o,l);return i?Lc(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var mb=ti({resizeBilinear_:fb});function gb(e,t,n=!1,r=!1){let a=Zs(e,"images","resizeNearestNeighbor");ae(3===a.rank||4===a.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a.rank}.`)),ae(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),ae("float32"===a.dtype||"int32"===a.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),ae(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let s=a,i=!1;3===a.rank&&(i=!0,s=Lc(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let[]=t,o={images:s},l={alignCorners:n,halfPixelCenters:r,size:t},u=Bs.runKernel(fr,o,l);return i?Lc(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var yb=ti({resizeNearestNeighbor_:gb});function bb(e,t="binary",n=!1,r=.5){let a,s,i,o,l=Zs(e,"image","threshold"),u=.2989,c=.587,p=.114,d=l.shape[0]*l.shape[1],h=Hu(_g([r]),255);if(ae(3===l.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${l.rank}.`)),ae(3===l.shape[2]||1===l.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${l.shape[2]}.`)),ae("int32"===l.dtype||"float32"===l.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${l.dtype}.`)),ae("otsu"===t||"binary"===t,(()=>`Method must be binary or otsu, but was ${t}`)),3===l.shape[2]){[a,s,i]=dg(l,[1,1,1],-1);let e=Hu(a,u),t=Hu(s,c),n=Hu(i,p);o=zu(zu(e,t),n)}else o=e;if("otsu"===t){let e=cp(go(Dm(o),"int32"),si([]),256);h=wb(e,d)}let f=n?Ih(o,h):uh(o,h);return go(Hu(f,255),"int32")}function wb(e,t){let n,r,a,s,i,o,l=_g([-1]),u=_g([0]),c=_g([0]);for(let p=0;p<e.size-1;p++){n=qc(e,0,p+1),r=qc(e,p+1),i=Uu(Wd(n),t),o=Uu(Wd(r),t);let d=Wd(Hu(n,gm(0,n.size)));a=Uu(d,Wd(n));let h=rh(r.shape,n.size),f=zu(gm(0,r.size),h),m=Hu(r,f);s=Uu(Wd(m),Wd(r));let g=Uh(a,s),y=Uh(a,s),b=Hu(i,o);c=Hu(Hu(b,g),y);let w=uh(c,u);u=ld(w,c,u),l=ld(w,_g([p]),l)}return l}var xb=ti({threshold_:bb});function vb(e,t,n="nearest",r="constant",a=0,s){let i=Zs(e,"image","transform","float32"),o=Zs(t,"transforms","transform","float32");ae(4===i.rank,(()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`)),ae(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),ae(null==s||2===s.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`));let l={image:i,transforms:o},u={interpolation:n,fillMode:r,fillValue:a,outputShape:s};return Bs.runKernel(Qr,l,u)}var kb=ti({transform_:vb});function Ib(e,t,n){ae(t%1===0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),ae(n%1===0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`));let r=Zs(e,"a","bandPart");ae(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));let a=r.shape,[s,i]=r.shape.slice(-2);if(!(t<=s))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`);if(!(n<=i))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`);t<0&&(t=s),n<0&&(n=i);let o=Lc(gm(0,s,1,"int32"),[-1,1]),l=gm(0,i,1,"int32"),u=Uh(o,l),c=Xh(Ih(u,Md(+t,"int32")),ph(u,Md(-n,"int32"))),p=yf([s,i],r.dtype);return Lc(xg(Wg(Lc(r,[-1,s,i])).map((e=>ld(c,e,p)))),a)}var Sb=ti({bandPart_:Ib});function Nb(e){let t;if(Array.isArray(e)){t=!1,ae(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));let n=e[0].shape[0];for(let t=1;t<e.length;++t)ae(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=dg(e,e.shape[0],0).map((e=>bg(e,[0])));ae(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));let n=[],r=e;for(let a=0;a<e.length;++a)n.push(Bs.tidy((()=>{let e=r[a];if(a>0)for(let t=0;t<a;++t){let r=Hu(Wd(Hu(n[t],e)),n[t]);e=Uh(e,r)}return Uu(e,Gd(e,"euclidean"))})));return t?xg(n,0):n}var Tb=ti({gramSchmidt_:Nb});function _b(e,t=!1){if(ae(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return Cb(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=Wg(Lc(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),a=[],s=[];r.forEach((e=>{let[n,r]=Cb(e,t);a.push(n),s.push(r)}));let i=Lc(xg(a,0),e.shape),o=Lc(xg(s,0),e.shape);return[i,o]}}function Cb(e,t=!1){return Bs.tidy((()=>{ae(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));let n=e.shape[0],r=e.shape[1],a=nh(n),s=bo(e),i=Cg([[1]],[1,1]),o=bo(i),l=n>=r?r:n;for(let e=0;e<l;++e){let t=s,l=o,u=a;[o,s,a]=Bs.tidy((()=>{let t=qc(s,[e,e],[n-e,1]),l=Gd(t),u=qc(s,[e,e],[1,1]),c=ld(uh(u,0),Cg([[-1]]),Cg([[1]])),p=Uh(u,Hu(c,l)),d=Uu(t,p);o=1===d.shape[0]?bo(i):Uc([i,qc(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);let h=Nl(Uu(Zo(c,p),l)),f=qc(s,[e,0],[n-e,r]),m=Hu(h,o),g=El(o);if(0===e)s=Uh(f,Zo(m,Zo(g,f)));else{let t=Uh(f,Zo(m,Zo(g,f)));s=Uc([qc(s,[0,0],[e,r]),t],0)}let y=El(m),b=qc(a,[0,e],[n,a.shape[1]-e]);if(0===e)a=Uh(b,Zo(Zo(b,o),y));else{let t=Uh(b,Zo(Zo(b,o),y));a=Uc([qc(a,[0,0],[n,e]),t],1)}return[o,s,a]})),cl([t,l,u])}return!t&&n>r&&(a=qc(a,[0,0],[n,r]),s=qc(s,[0,0],[r,r])),[a,s]}))}var Eb,Ab=ti({qr_:_b});function $b(e,t,n=Eb.SUM_BY_NONZERO_WEIGHTS){let r=Zs(e,"losses","computeWeightedLoss"),a=null;null!=t&&(a=Zs(t,"weights","computeWeightedLoss"));let s=null==a?r:Hu(r,a);if(n===Eb.NONE)return s;if(n===Eb.SUM)return Wd(s);if(n===Eb.MEAN){if(null==a)return gf(s);{let e=r.size/a.size,t=Uu(Wd(s),Wd(a));return e>1?Uu(t,Md(e)):t}}if(n===Eb.SUM_BY_NONZERO_WEIGHTS){if(null==a)return Uu(Wd(s),Md(r.size));{let e=Hu(a,bf(r.shape)),t=go(Wd(Rf(e,Md(0))),"float32");return Uu(Wd(s),t)}}throw Error(`Unknown reduction: ${n}`)}(function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Eb||(Eb={}));var Fb=ti({computeWeightedLoss_:$b});function Rb(e,t,n,r=Eb.SUM_BY_NONZERO_WEIGHTS){let a=Zs(e,"labels","absoluteDifference"),s=Zs(t,"predictions","absoluteDifference"),i=null;null!=n&&(i=Zs(n,"weights","absoluteDifference")),se(a.shape,s.shape,"Error in absoluteDifference: ");let o=qu(Uh(a,s));return Fb(o,i,r)}var Db=ti({absoluteDifference_:Rb});function Mb(e,t,n,r,a=Eb.SUM_BY_NONZERO_WEIGHTS){let s=Zs(e,"labels","cosineDistance"),i=Zs(t,"predictions","cosineDistance"),o=null;null!=r&&(o=Zs(r,"weights","cosineDistance")),se(s.shape,i.shape,"Error in cosineDistance: ");let l=Md(1),u=Uh(l,Wd(Hu(s,i),n,!0));return Fb(u,o,a)}var Ob=ti({cosineDistance_:Mb});function Lb(e,t,n,r=Eb.SUM_BY_NONZERO_WEIGHTS){let a=Zs(e,"labels","hingeLoss"),s=Zs(t,"predictions","hingeLoss"),i=null;null!=n&&(i=Zs(n,"weights","hingeLoss")),se(a.shape,s.shape,"Error in hingeLoss: ");let o=Md(1);a=Uh(Hu(Md(2),a),o);let l=xm(Uh(o,Hu(a,s)));return Fb(l,i,r)}var Pb=ti({hingeLoss_:Lb});function zb(e,t,n,r=1,a=Eb.SUM_BY_NONZERO_WEIGHTS){let s=Zs(e,"labels","huberLoss"),i=Zs(t,"predictions","huberLoss"),o=null;null!=n&&(o=Zs(n,"weights","huberLoss")),se(s.shape,i.shape,"Error in huberLoss: ");let l=Md(r),u=qu(Uh(i,s)),c=vf(u,l),p=Uh(u,c),d=zu(Hu(Md(.5),zd(c)),Hu(l,p));return Fb(d,o,a)}var Bb=ti({huberLoss_:zb});function Wb(e,t,n,r=1e-7,a=Eb.SUM_BY_NONZERO_WEIGHTS){let s=Zs(e,"labels","logLoss"),i=Zs(t,"predictions","logLoss"),o=null;null!=n&&(o=Zs(n,"weights","logLoss")),se(s.shape,i.shape,"Error in logLoss: ");let l=Md(1),u=Md(r),c=Nl(Hu(s,Ch(zu(i,u)))),p=Hu(Uh(l,s),Ch(zu(Uh(l,i),u))),d=Uh(c,p);return Fb(d,o,a)}var Vb=ti({logLoss_:Wb});function Ub(e,t,n,r=Eb.SUM_BY_NONZERO_WEIGHTS){let a=Zs(e,"labels","meanSquaredError"),s=Zs(t,"predictions","meanSquaredError"),i=null;null!=n&&(i=Zs(n,"weights","meanSquaredError")),se(a.shape,s.shape,"Error in meanSquaredError: ");let o=gg(a,s);return Fb(o,i,r)}var Gb=ti({meanSquaredError_:Ub});function Hb(e,t){let n=Zs(e,"labels","sigmoidCrossEntropyWithLogits"),r=Zs(t,"logits","sigmoidCrossEntropyWithLogits");se(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let a=xm(r),s=Hu(r,n),i=Ah(Kd(Nl(qu(r))));return zu(Uh(a,s),i)}function jb(e,t,n,r=0,a=Eb.SUM_BY_NONZERO_WEIGHTS){let s=Zs(e,"multiClassLabels","sigmoidCrossEntropy"),i=Zs(t,"logits","sigmoidCrossEntropy"),o=null;if(null!=n&&(o=Zs(n,"weights","sigmoidCrossEntropy")),se(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){let e=Md(r),t=Md(1),n=Md(.5);s=zu(Hu(s,Uh(t,e)),Hu(n,e))}let l=Hb(s,i);return Fb(l,o,a)}var qb=ti({sigmoidCrossEntropy_:jb});function Kb(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return Oh(((e,t,r)=>{let a=qh(t,[n],!0),s=Uh(go(t,"float32"),a);r([e,s]);let i=Nl(Hu(s,e));return{value:Wd(i,[n]),gradFunc:(e,t)=>{let[r,a]=t,s=Sd(e.shape,[n]);return[Hu(Lc(e,s),Uh(go(r,"float32"),Kd(a))),Hu(Lc(e,s),Uh(Kd(a),go(r,"float32")))]}}}))(e,t)}function Xb(e,t,n,r=0,a=Eb.SUM_BY_NONZERO_WEIGHTS){let s=Zs(e,"onehotLabels","softmaxCrossEntropy"),i=Zs(t,"logits","softmaxCrossEntropy"),o=null;if(null!=n&&(o=Zs(n,"weights","softmaxCrossEntropy")),se(s.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){let e=Md(r),t=Md(1),n=Md(s.shape[1]);s=zu(Hu(s,Uh(t,e)),Uu(e,n))}let l=Kb(s,i);return Fb(l,o,a)}var Yb=ti({softmaxCrossEntropy_:Xb});function Jb(e,t,n,r){let a=Zs(e,"indices","sparseFillEmptyRows","int32"),s=Zs(t,"values","sparseFillEmptyRows"),i=Zs(n,"denseShape","sparseFillEmptyRows","int32"),o=Zs(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==a.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${a.shape}`);if(1!==s.rank)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(1!==i.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);let l={indices:a,values:s,denseShape:i,defaultValue:o},u=Bs.runKernel(Lr,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}var Zb=ti({sparseFillEmptyRows_:Jb});function Qb(e,t,n){let r=Zs(e,"inputIndices","sparseReshape","int32"),a=Zs(t,"inputShape","sparseReshape","int32"),s=Zs(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==a.rank)throw new Error(`Input shape should be Tensor1D but received shape ${a.shape}`);if(1!==s.rank)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:r,inputShape:a,newShape:s},o=Bs.runKernel(Pr,i);return{outputIndices:o[0],outputShape:o[1]}}var ew=ti({sparseReshape_:Qb});function tw(e,t,n){let r=Zs(e,"data","sparseSegmentMean"),a=Zs(t,"indices","sparseSegmentMean","int32"),s=Zs(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${a.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${s.shape}`);let i={data:r,indices:a,segmentIds:s};return Bs.runKernel(zr,i)}var nw=ti({sparseSegmentMean_:tw});function rw(e,t,n){let r=Zs(e,"data","sparseSegmentSum"),a=Zs(t,"indices","sparseSegmentSum","int32"),s=Zs(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${a.shape}`);if(1!==s.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${s.shape}`);let i={data:r,indices:a,segmentIds:s};return Bs.runKernel(Br,i)}var aw=ti({sparseSegmentSum_:rw});function sw(e,t,n,r,a,s,i,o){let l=Zs(e,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);let u=Zs(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");let c={separator:n,nGramWidths:r,leftPad:a,rightPad:s,padWidth:i,preserveShortSequences:o},p={data:l,dataSplits:u},d=Bs.runKernel(Hr,p,c);return{nGrams:d[0],nGramsSplits:d[1]}}var iw=ti({stringNGrams_:sw});function ow(e,t,n=!0){let r=Zs(e,"input","stringSplit","string"),a=Zs(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==a.rank)throw new Error(`Delimiter should be a scalar but received shape ${a.shape}`);let s={skipEmpty:n},i={input:r,delimiter:a},o=Bs.runKernel(jr,i,s);return{indices:o[0],values:o[1],shape:o[2]}}var lw=ti({stringSplit_:ow});function uw(e,t){let n=Zs(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let a={input:n};return Bs.runKernel(qr,a,r)}var cw=ti({stringToHashBucketFast_:uw}),pw={fft:ig,ifft:lg,rfft:fg,irfft:cg},dw={hammingWindow:Ey,hannWindow:$y,frame:Ry,stft:My},hw={flipLeftRight:zy,grayscaleToRGB:Wy,resizeNearestNeighbor:yb,resizeBilinear:mb,rotateWithOffset:Uy,cropAndResize:Ly,nonMaxSuppression:jy,nonMaxSuppressionAsync:sb,nonMaxSuppressionWithScore:ob,nonMaxSuppressionWithScoreAsync:ub,nonMaxSuppressionPadded:pb,nonMaxSuppressionPaddedAsync:hb,threshold:xb,transform:kb},fw={bandPart:Sb,gramSchmidt:Tb,qr:Ab},mw={absoluteDifference:Db,computeWeightedLoss:Fb,cosineDistance:Ob,hingeLoss:Pb,huberLoss:Bb,logLoss:Vb,meanSquaredError:Gb,sigmoidCrossEntropy:qb,softmaxCrossEntropy:Yb},gw={sparseFillEmptyRows:Zb,sparseReshape:ew,sparseSegmentMean:nw,sparseSegmentSum:aw},yw={stringNGrams:iw,stringSplit:lw,stringToHashBucketFast:cw},bw=class extends vu{minimize(e,t=!1,n){let{value:r,grads:a}=this.computeGradients(e,n);if(null!=n){let e=n.map((e=>({name:e.name,tensor:a[e.name]})));this.applyGradients(e)}else this.applyGradients(a);return cl(a),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return Mh(e,t)}dispose(){null!=this.iterations_&&cl(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:Md(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(bw,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});var ww=class extends bw{constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=Bs.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=Bs.registeredVariables[t],a=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:ul((()=>cd(r).variable(a)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:ul((()=>cd(r).variable(a)))});let s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;let i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;ul((()=>{let e=zu(Hu(i,this.rho),Hu(zd(s),1-this.rho)),t=Hu(Uu(Ld(zu(o,this.epsilon)),Ld(zu(i,this.epsilon))),s),n=zu(Hu(o,this.rho),Hu(zd(t),1-this.rho));i.assign(e),o.assign(n);let a=zu(Hu(t,-this.learningRate),r);r.assign(a)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(cl(this.accumulatedGrads.map((e=>e.variable))),cl(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}};ww.className="Adadelta",Iu(ww);var xw=class extends bw{constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=Bs.registeredVariables[t];null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:ul((()=>rh(r.shape,this.initialAccumulatorValue).variable(!1)))});let a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;let s=this.accumulatedGrads[n].variable;ul((()=>{let e=zu(s,zd(a));s.assign(e);let t=zu(Hu(Uu(a,Ld(zu(e,Bs.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&cl(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(t)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}};xw.className="Adagrad",Iu(xw);var vw=class extends bw{constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],ul((()=>{this.accBeta1=Md(t).variable(),this.accBeta2=Md(n).variable()})),null==r&&(this.epsilon=Bs.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);ul((()=>{let n=Uh(1,this.accBeta1),r=Uh(1,this.accBeta2);t.forEach(((t,a)=>{let s=Bs.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:ul((()=>cd(s).variable(i)))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:`${t}/v`,variable:ul((()=>cd(s).variable(i)))});let o=Array.isArray(e)?e[a].tensor:e[t];if(null==o)return;let l=this.accumulatedFirstMoment[a].variable,u=this.accumulatedSecondMoment[a].variable,c=zu(Hu(l,this.beta1),Hu(o,1-this.beta1)),p=zu(Hu(u,this.beta2),Hu(zd(o),1-this.beta2)),d=Uu(c,n),h=Uu(p,r);l.assign(c),u.assign(p);let f=zu(Hu(Uu(d,zu(Ld(h),this.epsilon)),-this.learningRate),s);s.assign(f)})),this.accBeta1.assign(Hu(this.accBeta1,this.beta1)),this.accBeta2.assign(Hu(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&cl(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&cl(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),ul((()=>{this.accBeta1.assign(Dd(this.beta1,this.iterations_+1)),this.accBeta2.assign(Dd(this.beta2,this.iterations_+1))}));let t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}};vw.className="Adam",Iu(vw);var kw=class extends bw{constructor(e,t,n,r=null,a=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],ul((()=>{this.iteration=Md(0).variable(),this.accBeta1=Md(t).variable()})),null==r&&(this.epsilon=Bs.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);ul((()=>{let n=Uh(1,this.accBeta1),r=Uu(-this.learningRate,zu(Hu(this.iteration,this.decay),1));t.forEach(((t,a)=>{let s=Bs.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:cd(s).variable(i)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:`${t}/v`,variable:cd(s).variable(i)});let o=Array.isArray(e)?e[a].tensor:e[t];if(null==o)return;let l=this.accumulatedFirstMoment[a].variable,u=this.accumulatedWeightedInfNorm[a].variable,c=zu(Hu(l,this.beta1),Hu(o,1-this.beta1)),p=Hu(u,this.beta2),d=qu(o),h=ff(p,d);l.assign(c),u.assign(h);let f=zu(Hu(Uu(r,n),Uu(c,zu(h,this.epsilon))),s);s.assign(f)})),this.iteration.assign(zu(this.iteration,1)),this.accBeta1.assign(Hu(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&cl(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&cl(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}};kw.className="Adamax",Iu(kw);var Iw=class extends bw{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;let a=Bs.registeredVariables[t];ul((()=>{let e=zu(Hu(this.c,r),a);a.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=pl(Md(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),0!==e.length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}};Iw.className="SGD",Iu(Iw);var Sw=class extends Iw{constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=Md(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=Bs.registeredVariables[t];null==this.accumulations[n]&&(this.accumulations[n]={originalName:`${t}/momentum`,variable:ul((()=>cd(r).variable(!1)))});let a=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];null!=s&&ul((()=>{let e,t=zu(Hu(this.m,a),s);e=this.useNesterov?zu(Hu(this.c,zu(s,Hu(t,this.m))),r):zu(Hu(this.c,t),r),a.assign(t),r.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&cl(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(t)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}};Sw.className="Momentum",Iu(Sw);var Nw=class extends bw{constructor(e,t=.9,n=0,r=null,a=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==r&&(this.epsilon=Bs.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{let r=Bs.registeredVariables[t],a=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:ul((()=>cd(r).variable(a)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:ul((()=>cd(r).variable(a)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:ul((()=>cd(r).variable(a)))});let s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;let i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;ul((()=>{let e=zu(Hu(i,this.decay),Hu(zd(s),1-this.decay));if(this.centered){let t=this.accumulatedMeanGrads[n].variable,a=zu(Hu(t,this.decay),Hu(s,1-this.decay)),l=Uu(Hu(s,this.learningRate),Ld(Uh(e,zu(zd(a),this.epsilon)))),u=zu(Hu(o,this.momentum),l);i.assign(e),t.assign(a),o.assign(u);let c=Uh(r,u);r.assign(c)}else{let e=zu(Hu(i,this.decay),Hu(zd(s),1-this.decay)),t=zu(Hu(o,this.momentum),Uu(Hu(s,this.learningRate),Ld(zu(e,this.epsilon))));i.assign(e),o.assign(t);let n=Uh(r,t);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&cl(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&cl(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&cl(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}};Nw.className="RMSProp",Iu(Nw);var Tw=class{static sgd(e){return new Iw(e)}static momentum(e,t,n=!1){return new Sw(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,a=!1){return new Nw(e,t,n,r,a)}static adam(e=.001,t=.9,n=.999,r=null){return new vw(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new ww(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,a=0){return new kw(e,t,n,r,a)}static adagrad(e,t=.1){return new xw(e,t)}},_w={sgd:Tw.sgd,momentum:Tw.momentum,adadelta:Tw.adadelta,adagrad:Tw.adagrad,rmsprop:Tw.rmsprop,adamax:Tw.adamax,adam:Tw.adam},Cw=(()=>"undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e())();function Ew(){return new Promise((e=>Cw((()=>e()))))}var Aw={};function $w(e,t){let n=e[0].length;e.forEach(((e,t)=>{ae(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),ae(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));let r=e[0];e.forEach(((e,a)=>{for(let s=0;s<n;s++)ae(s===t||e[s]===r[s],(()=>`Error in concat${n}D: Shape of tensors[${a}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`))}))}function Fw(e,t){let n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}g(Aw,{ERF_A1:()=>Gw,ERF_A2:()=>Hw,ERF_A3:()=>jw,ERF_A4:()=>qw,ERF_A5:()=>Kw,ERF_P:()=>Uw,PARALLELIZE_THRESHOLD:()=>Rw,SELU_SCALE:()=>Vw,SELU_SCALEALPHA:()=>Ww,applyActivation:()=>gy,assertAndGetBroadcastShape:()=>Ml,assertAxesAreInnerMostDims:()=>Nd,assertParamsConsistent:()=>$w,assignToTypedArray:()=>ex,axesAreInnerMostDims:()=>vd,calculateShapes:()=>Zl,checkEinsumDimSizes:()=>ux,checkPadOnDimRoundingMode:()=>Mc,combineLocations:()=>kd,complexWithEvenIndex:()=>Jw,complexWithOddIndex:()=>Zw,computeConv2DInfo:()=>vc,computeConv3DInfo:()=>kc,computeDefaultPad:()=>Nc,computeDilation2DInfo:()=>bc,computeOptimalWindowSize:()=>Dw,computeOutAndReduceShapes:()=>Id,computeOutShape:()=>Fw,computePool2DInfo:()=>wc,computePool3DInfo:()=>xc,convertConv2DDataFormat:()=>Dc,decodeEinsumEquation:()=>ox,eitherStridesOrDilationsAreOne:()=>Rc,expandShapeToKeepDim:()=>Sd,exponent:()=>nx,exponents:()=>tx,fromStringArrayToUint8:()=>$x,fromUint8ToStringArray:()=>Ax,getAxesPermutation:()=>Td,getBroadcastDims:()=>Rl,getComplexWithIndex:()=>Qw,getEinsumComputePath:()=>cx,getEinsumPermutation:()=>lx,getFusedBiasGradient:()=>my,getFusedDyActivation:()=>fy,getImageCenter:()=>Mw,getInnerMostAxes:()=>Cd,getPermuted:()=>Lw,getReductionAxes:()=>Dl,getReshaped:()=>Ow,getReshapedPermuted:()=>Pw,getSliceBeginCoords:()=>zw,getSliceSize:()=>Bw,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>fx,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>mx,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>gx,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>wx,getSparseReshapeInputOutputMismatchErrorMessage:()=>vx,getSparseReshapeInputOutputMultipleErrorMessage:()=>xx,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>yx,getSparseReshapeNegativeOutputDimErrorMessage:()=>bx,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>Nx,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>kx,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>Ix,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>Sx,getUndoAxesPermutation:()=>_d,isIdentityPermutation:()=>px,log:()=>ha,mergeRealAndImagArrays:()=>Xw,prepareAndValidate:()=>Kl,prepareSplitSize:()=>hx,segment_util:()=>Tx,shouldFuse:()=>yy,slice_util:()=>Ql,splitRealAndImagArrays:()=>Yw,tupleValuesAreOne:()=>Fc,upcastType:()=>_s,validateInput:()=>Jl,validateUpdateShape:()=>Yl,warn:()=>da});var Rw=30;function Dw(e){return e<=Rw?e:Re(e,Math.floor(Math.sqrt(e)))}function Mw(e,t,n){let r=n*("number"==typeof e?e:e[0]),a=t*("number"==typeof e?e:e[1]);return[r,a]}function Ow(e,t,n,r=!0){let a=[];if(r)a=a.concat(t.slice(0)),a.push(e[0]/n),a=a.concat(e.slice(1));else{a=a.concat(e[0]);let n=t.length;for(let r=0;r<n;++r)a=a.concat([e[r+1]/t[r],t[r]]);a=a.concat(e.slice(n+1))}return a}function Lw(e,t,n=!0){let r=[];if(n){r.push(t);for(let n=t+1;n<e;++n)n<=2*t?(r.push(n),r.push(n-(t+1))):r.push(n)}else{let n=[],a=[];for(let r=1;r<e;++r)r>=2*t+1||r%2===1?a.push(r):n.push(r);r.push(...n),r.push(0),r.push(...a)}return r}function Pw(e,t,n,r=!0){let a=[];r?a.push(e[0]/n):a.push(e[0]*n);for(let s=1;s<e.length;++s)s<=t.length?r?a.push(t[s-1]*e[s]):a.push(e[s]/t[s-1]):a.push(e[s]);return a}function zw(e,t){let n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function Bw(e,t,n){let r=e.slice(0,1);for(let a=0;a<n;++a)r.push(e[a+1]-t[a][0]-t[a][1]);return r}var Ww=1.7580993408473768,Vw=1.0507009873554805,Uw=.3275911,Gw=.254829592,Hw=-.284496736,jw=1.421413741,qw=-1.453152027,Kw=1.061405429;function Xw(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function Yw(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function Jw(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=0;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function Zw(e){let t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let a=2;a<e.length;a+=4)n[Math.floor(a/4)]=e[a],r[Math.floor(a/4)]=e[a+1];return{real:n,imag:r}}function Qw(e,t){let n=e[2*t],r=e[2*t+1];return{real:n,imag:r}}function ex(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function tx(e,t){let n=new Float32Array(e/2),r=new Float32Array(e/2);for(let a=0;a<Math.ceil(e/2);a++){let s=(t?2:-2)*Math.PI*(a/e);n[a]=Math.cos(s),r[a]=Math.sin(s)}return{real:n,imag:r}}function nx(e,t,n){let r=(n?2:-2)*Math.PI*(e/t),a=Math.cos(r),s=Math.sin(r);return{real:a,imag:s}}var rx="->",ax=/->/g,sx=",",ix="...";function ox(e,t){e=e.replace(/\s/g,"");let n=(e.length-e.replace(ax,"").length)/rx.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${rx}").`);let[r,a]=e.split(rx);ae(-1===r.indexOf(ix),(()=>`The ellipsis notation ("${ix}") is not supported yet.`));let s=r.split(sx),i=s.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let o=[];for(let d=0;d<a.length;++d){let e=a[d];if(!s.some((t=>-1!==t.indexOf(e))))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===o.indexOf(e)&&o.push(e)}for(let d=0;d<r.length;++d){let e=r[d];-1===o.indexOf(e)&&e!==sx&&o.push(e)}let l=new Array(s.length);for(let d=0;d<i;++d){if(new Set(s[d].split("")).size!==s[d].length)throw new Error(`Found duplicate axes in input component ${s[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let e=0;e<s[d].length;++e)l[d].push(o.indexOf(s[d][e]))}let u=o.length,c=a.length,p=[];for(let d=c;d<u;++d)p.push(d);return{allDims:o,summedDims:p,idDims:l}}function lx(e,t){let n=new Array(e);n.fill(-1);for(let a=0;a<t.length;++a)n[t[a]]=a;let r=[];for(let a=0;a<e;++a)-1===n[a]&&r.push(a);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function ux(e,t,n){let r=new Array(e);for(let a=0;a<n.length;++a){let e=n[a].shape;for(let n=0;n<t[a].length;++n)void 0===r[t[a][n]]?r[t[a][n]]=e[n]:ae(r[t[a][n]]===e[n],(()=>`Expected dimension ${r[t[a][n]]} at axis ${n} of input shaped ${JSON.stringify(e)}, but got dimension ${e[n]}`))}}function cx(e,t){let n=e,r=[],a=0;0===e.length&&n.push(-1),a=e.length+1;for(let i=0;i<a;++i)r.push([]);let s=[];for(let i=0;i<n.length;++i){let e=n[i],a=dx(t,e);for(let t of a)-1===s.indexOf(t)&&(r[i].push(t),s.push(t))}return{path:n,steps:r}}function px(e){return e.every(((e,t)=>e===t))}function dx(e,t){let n=[];for(let r=0;r<e.length;++r)(0===e[r].length||-1!==e[r].indexOf(t)||-1===t)&&n.push(r);return n}function hx(e,t,n=0){let r=[];if("number"==typeof t)ae(e.shape[n]%t===0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{let a=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);ae(a<=1,(()=>"There should be only one negative value in split array."));let s=t.indexOf(-1);if(-1!==s){let r=t.reduce(((e,t)=>t>0?e+t:e));t[s]=e.shape[n]-r}ae(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}function fx(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function mx(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function gx(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function yx(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function bx(e,t){return`size ${e} must be non-negative, not ${t}`}function wx(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function xx(e,t){let n=le(e),r=le(t);return`Input to reshape is a SparseTensor with ${n}\n  dense values, but the requested shape requires a multiple of ${r}. inputShape=${e} outputShape= ${t}`}function vx(e,t){let n=le(e),r=le(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${e} outputShape=${t}`}function kx(){return"segment ids must be >= 0"}function Ix(){return"segment ids are not increasing"}function Sx(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function Nx(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}var Tx={};function _x(e,t){let n,r=!1;for(e<=Rw?(n=e,r=!0):n=Re(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=Re(e,n+1);return n}function Cx(e,t,n){let r=[],a=e.length;for(let s=0;s<a;s++)s!==t?r.push(e[s]):r.push(n);return r}function Ex(e,t,n,r){let a=t.shape.length,s=e.shape.length;if(0!==r&&(r<-a||r>a))throw new Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${r}`);if(r<0&&(r+=a),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${s}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let p=0;p<r;++p)if(e.shape[p]!==t.shape[p])throw new Error(`x.shape[${p}]: ${e.shape[p]} should be equal to indices.shape[${p}]: ${t.shape[p]}.`);let i=e.shape[n],o=[],l=1,u=1,c=1;for(let p=0;p<r;++p)o.push(e.shape[p]),l*=e.shape[p];for(let p=r;p<n;p++)o.push(e.shape[p]),u*=e.shape[p];for(let p=r;p<a;p++)o.push(t.shape[p]);for(let p=n+1;p<s;p++)o.push(e.shape[p]),c*=e.shape[p];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:o}}function Ax(e){try{return e.map((e=>Ya(e)))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function $x(e){return e.map((e=>Xa(e)))}g(Tx,{collectGatherOpShapeInfo:()=>Ex,computeOutShape:()=>Cx,segOpComputeOptimalWindowSize:()=>_x});var Fx={};g(Fx,{nonMaxSuppressionV3Impl:()=>Jy,nonMaxSuppressionV4Impl:()=>Zy,nonMaxSuppressionV5Impl:()=>Qy,whereImpl:()=>Gg});var Rx={kernelName:nt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Hu(e,kg(go(n,"float32"),-1))}}},Dx={kernelName:rt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=zd(go(n,"float32")),r=Ld(Uh(Md(1),t));return Nl(Uu(e,r))}}}},Mx={kernelName:at,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=Ld(Uh(zd(go(n,"float32")),1));return Uu(e,t)}}}},Ox={kernelName:st,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Ml(n.shape,r.shape);return{a:()=>{let t=e,r=Dl(n.shape,a);return r.length>0&&(t=Wd(t,r)),Lc(t,n.shape)},b:()=>{let t=e,n=Dl(r.shape,a);return n.length>0&&(t=Wd(t,n)),Lc(t,r.shape)}}}},Lx={kernelName:it,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach(((t,r)=>{n[r]=()=>e.clone()})),n}},Px={kernelName:ut,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>cd(n)}}},zx={kernelName:ct,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>cd(n)}}},Bx={kernelName:pt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Uu(e,Ld(Uh(Md(1),zd(go(n,"float32")))))}}},Wx={kernelName:dt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=Ld(zu(Md(1),zd(go(n,"float32"))));return Uu(e,t)}}}},Vx={kernelName:mt,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Ml(n.shape,r.shape);return{a:()=>{let t=zu(zd(n),zd(r)),s=Hu(e,Uu(r,t)),i=Dl(n.shape,a);return i.length>0&&(s=Wd(s,i)),Lc(s,n.shape)},b:()=>{let t=zu(zd(n),zd(r)),s=Nl(Hu(e,Uu(n,t))),i=Dl(r.shape,a);return i.length>0&&(s=Wd(s,i)),Lc(s,r.shape)}}}},Ux={kernelName:ht,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Uu(e,zu(zd(go(n,"float32")),1))}}},Gx={kernelName:ft,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Uu(e,Uh(Md(1),zd(go(n,"float32"))))}}};function Hx(e,t,n,r,a,s){let i=Zs(e,"dy","avgPool3dGrad"),o=Zs(t,"input","avgPool3dGrad"),l=i,u=o,c=!1;4===o.rank&&(c=!0,l=Lc(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=Lc(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),ae(5===l.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`)),ae(5===u.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`)),Mc("avgPool3dGrad",a,s);let p={dy:l,input:u},d={filterSize:n,strides:r,pad:a,dimRoundingMode:s},h=Bs.runKernel(wt,p,d);return c?Lc(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var jx=ti({avgPool3dGrad_:Hx}),qx={kernelName:bt,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:s,pad:i,dimRoundingMode:o}=n;return{x:()=>jx(e,r,a,s,i,o)}}};function Kx(e,t,n,r,a){let s=Zs(e,"dy","avgPoolGrad"),i=Zs(t,"input","avgPoolGrad");ae(i.rank===s.rank,(()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`));let o=i,l=s,u=!1;3===i.rank&&(u=!0,o=Lc(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=Lc(s,[1,s.shape[0],s.shape[1],s.shape[2]])),ae(4===l.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`)),ae(4===o.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`));let c={dy:l,input:o},p={filterSize:n,strides:r,pad:a},d=Bs.runKernel(yt,c,p);return u?Lc(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var Xx=ti({avgPoolGrad_:Kx}),Yx={kernelName:gt,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:a,strides:s,pad:i}=n;return{x:()=>Xx(e,r,a,s,i)}}},Jx={kernelName:xt,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{let[r,a]=t,{transposeA:s,transposeB:i}=n;return s||i?!s&&i?{a:()=>Zo(e,a,!1,!1),b:()=>Zo(e,r,!0,!1)}:s&&!i?{a:()=>Zo(a,e,!1,!0),b:()=>Zo(r,e,!1,!1)}:{a:()=>Zo(a,e,!0,!0),b:()=>Zo(e,r,!0,!0)}:{a:()=>Zo(e,a,!1,!0),b:()=>Zo(r,e,!0,!1)}}},Zx={kernelName:vt,gradFunc:(e,t,n)=>{let{blockShape:r,crops:a}=n;return{x:()=>Xf(e,r,a)}}},Qx={kernelName:It,gradFunc:(e,t,n)=>{let r=n,a=r.inputShape,s=r.shape,i=Array.from(s);for(let l=a.length-1;l>=0;l--)if(a[l]===s[l])i[l]=1;else if(1!==a[l])throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${s}].`);let o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>Wd(e,o,!0)}}},ev={kernelName:Nt,gradFunc:e=>({x:()=>e.clone()})},tv={kernelName:Tt,gradFunc:e=>({x:()=>cd(e)})},nv={kernelName:_t,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{clipValueMin:a,clipValueMax:s}=n;return{x:()=>ld(Xh(ph(r,a),Ih(r,s)),e,cd(e))}}},rv={kernelName:Et,inputsToSave:["x"],gradFunc:Rx.gradFunc},av={kernelName:At,saveAllInputs:!0,gradFunc:(e,t,n)=>{let r=t.map((e=>e.shape)),{axis:a}=n,s=be(a,t[0].shape)[0],i=r.map((e=>e[s]));return dg(e,i,s).map((e=>()=>e))}},sv={kernelName:$t,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{dilations:s,strides:i,pad:o,dataFormat:l}=n;return ae(Fc(s),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`)),{x:()=>Fp(r.shape,e,a,i,o,l),filter:()=>hy(r,e,a.shape,i,o,l)}}},iv={kernelName:Rt,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,{strides:s,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>Cp(e,a,s,i,o,1,l),filter:()=>hy(e,r,a.shape,s,i,o,l)}}};function ov(e,t,n,r,a){let s=e;4===e.rank&&(s=Lc(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;4===i.rank&&(i=Lc(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),ae(5===s.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`)),ae(5===i.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`)),ae(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),ae(s.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${n[3]}.`)),ae(i.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`));let o={x:s,dy:i},l={strides:r,pad:a,filterShape:n};return Bs.runKernel(Mt,o,l)}var lv=ti({conv3DBackpropFilter_:ov}),uv={kernelName:Dt,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:s}=n;ae(Fc(r),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`));let[i,o]=t;return{x:()=>Pp(i.shape,e,o,a,s),filter:()=>lv(i,e,o.shape,a,s)}}},cv={kernelName:Lt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Hu(Nl(jm(go(n,"float32"))),e)}}},pv={kernelName:Pt,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Hu(Km(go(n,"float32")),e)}}},dv={kernelName:Bt,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a,exclusive:s,reverse:i}=n;return{x:()=>{let t=Td([a],r.rank),n=Kp(e,a,s,!i);return null!=t&&(n=El(n,t)),n}}}},hv={kernelName:Gt,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:a,pad:s,dimRoundingMode:i}=n,o=null==r?[1,1]:r;ae(Fc(o),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`));let[l,u]=t;return ae(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`)),ae(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`)),ae(l.shape[3]===u.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)),ae(Rc(a,o),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${a} and dilations '${o}'.`)),Mc("depthwiseConv2d",s,i),{x:()=>Iy(l.shape,e,u,a,s,o,i),filter:()=>vy(l,e,u.shape,a,s,o,i)}}},fv={kernelName:Kt,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,a]=t,s={x:r,filter:a,dy:e},i={x:r,filter:a,dy:e};return{x:()=>Bs.runKernel(Xt,s,n),filter:()=>Bs.runKernel(Yt,i,n)}}},mv={kernelName:Qt,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,r={dy:e,y:n};return{x:()=>Bs.runKernel(en,r)}}},gv={kernelName:tn,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=Hu(Kd(Nl(zd(n))),2/Math.sqrt(Math.PI));return{x:()=>Hu(e,r)}}},yv={kernelName:rn,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Hu(e,n)}}},bv={kernelName:an,inputsToSave:["input"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>Lc(e,n.shape)}}},wv={kernelName:sn,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Hu(e,Kd(n))}}},xv={kernelName:cn,gradFunc:e=>({x:()=>cd(e)})},vv={kernelName:pn,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Ml(n.shape,r.shape);return{a:()=>{let t=Uu(e,go(r,"float32")),s=Dl(n.shape,a);return s.length>0?Lc(Wd(t,s),n.shape):t},b:()=>{let t=Hu(e,go(n,"float32")),s=Dl(r.shape,a);s.length>0&&(t=Lc(Wd(t,s),r.shape));let i=zd(r);return Nl(Uu(t,go(i,"float32")))}}}},kv={kernelName:dn,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{let{varianceEpsilon:r}=n,[a,s,i,o]=t,l=null==o?Md(1):o,u=Dl(s.shape,a.shape),c=[];if(1===s.rank){for(let e=0;e<a.shape.length-1;++e)c.push(a.shape[e]);c.push(1)}let p=Uh(a,s),d=Hu(e,l),h=Om(zu(i,Md(r))),f=Hu(Hu(Hu(h,h),h),Md(-.5));return{x:()=>1===s.rank?Lc(Hu(Hu(e,eh(Lc(h,[1,1,1,s.shape[0]]),c)),l),a.shape):Lc(Hu(Hu(e,h),l),a.shape),mean:()=>{let e=Hu(Hu(h,Md(-1)),d);return 1===s.rank&&(e=Wd(e,u)),Lc(e,s.shape)},variance:()=>{let e=Hu(Hu(f,p),d);return 1===s.rank&&(e=Wd(e,u)),Lc(e,s.shape)},scale:()=>{let t=Hu(p,h),n=Hu(e,t);return 1===s.rank&&(n=Wd(n,u)),Lc(n,s.shape)},offset:()=>{let t=e;return 1===s.rank&&(t=Wd(t,u)),Lc(t,s.shape)}}}},Iv={kernelName:hn,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{let[r,a]=t,{axis:s}=n,i=be(s,r.shape)[0];return{x:()=>{let t=r.shape,n=a.size,o=t.slice(0,i),l=o.length,u=t.slice(s,t.length).slice(1),c=u.length,p=Sv(0,l),d=Sv(l+1,l+1+c),h=Nv([o,[n],u]),f=Lc(e,h),m=Lc(a,[n]),g=Nv([[l],p,d]),y=El(f,g),b=zg(y,m,r.shape[i]),w=_d(g);return b=El(b,w),b},indices:()=>a}}};function Sv(e,t){let n=[];for(let r=e;r<t;++r)n.push(r);return n}function Nv(e){let t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}var Tv={kernelName:gn,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>cd(n),b:()=>cd(r)}}},_v={kernelName:yn,gradFunc:e=>({x:()=>go(e,"float32")})},Cv={kernelName:xn,gradFunc:e=>({x:()=>cd(e)})},Ev={kernelName:vn,gradFunc:e=>({x:()=>cd(e)})},Av={kernelName:kn,gradFunc:e=>({x:()=>cd(e)})},$v={kernelName:In,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{alpha:a}=n,s=uh(r,0);return{x:()=>ld(s,e,Hu(e,a))}}},Fv={kernelName:Cn,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Uu(e,zu(n,1))}}},Rv={kernelName:_n,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Uu(e,go(n,"float32"))}}},Dv={kernelName:Fn,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n;return{logits:()=>{let t=Kd(r);return Uh(e,Hu(Wd(e,a,!0),t))}}}};function Mv(e,t,n,r=5,a=1,s=1,i=.5){let o={x:e,y:t,dy:n},l={depthRadius:r,bias:a,alpha:s,beta:i};return Bs.runKernel(Mn,o,l)}var Ov=ti({localResponseNormalizationBackprop_:Mv}),Lv={kernelName:Dn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{depthRadius:s,bias:i,alpha:o,beta:l}=n;return{x:()=>Ov(r,a,e,s,i,o,l)}}};function Pv(e,t,n,r){return t.rank<n.rank&&(t=Lc(t,Sd(t.shape,r))),e.rank<n.rank&&(e=Lc(e,Sd(e.shape,r))),{x:()=>Hu(e,go(id(n,t),e.dtype))}}var zv={kernelName:On,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{reductionIndices:a}=r,s=t[0],i=t[1],o=be(a,s.shape),l=Pv(e,i,s,o);return{x:()=>l.x()}}},Bv={kernelName:Ln,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>Hu(e,go(ph(n,r),"float32")),b:()=>Hu(e,go(vh(n,r),"float32"))}}};function Wv(e,t,n,r,a,s,i){let o=Zs(e,"dy","maxPool3dGrad"),l=Zs(t,"input","maxPool3dGrad"),u=Zs(n,"output","maxPool3dGrad"),c=o,p=l,d=u,h=!1;4===l.rank&&(h=!0,c=Lc(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),p=Lc(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=Lc(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),ae(5===c.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`)),ae(5===p.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`)),ae(5===d.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`)),Mc("maxPool3dGrad",s,i);let f={dy:c,input:p,output:d},m={filterSize:r,strides:a,pad:s,dimRoundingMode:i},g=Bs.runKernel(Wn,f,m);return h?Lc(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var Vv=ti({maxPool3dGrad_:Wv}),Uv={kernelName:Bn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>Vv(e,r,a,s,i,o,l)}}};function Gv(e,t,n,r,a,s,i){let o=Zs(e,"dy","maxPoolGrad"),l=Zs(t,"input","maxPoolGrad"),u=Zs(n,"output","maxPoolGrad");ae(l.rank===o.rank,(()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`)),ae(4===o.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`)),ae(4===l.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`)),Mc("maxPoolGrad",s,i);let c={dy:o,input:l,output:u},p={filterSize:r,strides:a,pad:s,dimRoundingMode:i};return Bs.runKernel(zn,c,p)}var Hv=ti({maxPoolGrad_:Gv}),jv={kernelName:Pn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,a]=t,{filterSize:s,strides:i,pad:o}=n;return{x:()=>Hv(e,r,a,s,i,o)}}},qv={kernelName:Un,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,s=be(a,r.shape),i=Id(r.shape,s)[1],o=le(i);return{x:()=>{let t=r.shape.slice();s.forEach((e=>{t[e]=1}));let n=Lc(e,t);return Uu(Hu(n,bf(r.shape,"float32")),o)}}}},Kv={kernelName:Gn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{axis:a}=r,[s,i]=t,o=be(a,s.shape),l=Pv(e,i,s,o);return{x:()=>l.x()}}},Xv={kernelName:Hn,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>Hu(e,go(Ih(n,r),"float32")),b:()=>Hu(e,go(uh(n,r),"float32"))}}},Yv={kernelName:jn,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,s=a.map((e=>e[0]));return{x:()=>qc(e,s,r.shape)}}},Jv={kernelName:qn,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Ml(n.shape,r.shape);return{a:()=>{let t=Dl(n.shape,a);return t.length>0?Lc(Wd(e,t),n.shape):e},b:()=>{let t=Hu(e,Nl(sh(Uu(n,r)))),s=Dl(r.shape,a);return s.length>0?Lc(Wd(t,s),r.shape):t}}}},Zv={kernelName:Xn,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Ml(n.shape,r.shape);return{a:()=>{let t=Hu(e,go(r,"float32")),s=Dl(n.shape,a);return s.length>0?Lc(Wd(t,s),n.shape):t},b:()=>{let t=Hu(e,go(n,"float32")),s=Dl(r.shape,a);return s.length>0?Lc(Wd(t,s),r.shape):t}}}},Qv={kernelName:Yn,gradFunc:e=>({x:()=>Nl(e)})},ek={kernelName:nr,inputsToSave:["indices"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>yf(n.shape,"float32")}}},tk={kernelName:tr,gradFunc:e=>({x:()=>cd(e)})},nk={kernelName:rr,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:r}=n;return Wg(e,r).map((e=>()=>e))}},rk={kernelName:ar,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:a}=n,s=a.map((e=>e[0]));return{x:()=>qc(e,s,r.shape)}}},ak={kernelName:ir,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,r,a]=t,s=n,i=r,o=Ml(s.shape,i.shape);return{a:()=>{let t=go(i,"float32"),n=Hu(e,Hu(t,Dd(s,Uh(t,Md(1))))),r=Dl(s.shape,o);return r.length>0&&(n=Wd(n,r)),Lc(n,s.shape)},b:()=>{let t=uh(s,0),n=ld(t,Ch(s),cd(s)),r=Hu(e,Hu(a,n)),l=Dl(i.shape,o);return l.length>0&&(r=Wd(r,l)),Lc(r,i.shape)}}}},sk={kernelName:or,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[n,r]=t,a=uh(n,0);return{x:()=>ld(a,e,Hu(e,r)),alpha:()=>{let t=ld(a,cd(e),Hu(e,n)),s=Dl(r.shape,e.shape);return s.length>0&&(t=Wd(t,s)),Lc(t,r.shape)}}}};function ik(e,t,n){let r=e.shape.slice();r[n]=1;let a=Lc(t,r),s=jp(e,n,!0,!1),i=jp(e,n,!0,!0),o=Hu(s,i);return Hu(a,o)}function ok(e,t,n){let r=e.shape.length,a=r-n.length,s=Aw.getAxesPermutation(n,r),i=e;null!=s&&(i=El(e,s));let o=i.shape.slice(),l=o.splice(r-n.length,n.length).reduce(((e,t)=>e*t),1);o.push(l);let u=i.reshape(o),c=ik(u,t,a);if(c=c.reshape(i.shape),null!=s){let e=Aw.getUndoAxesPermutation(s);c=El(c,e)}return c}var lk={kernelName:lr,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:a}=n,s=[];return s=null==a?r.shape.map(((e,t)=>t)):"number"==typeof a?[a]:a,{x:()=>ok(r,e,s)}}},uk={kernelName:Jt,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Ml(n.shape,r.shape);return{a:()=>{let t=Uu(e,go(r,"float32")),s=Dl(n.shape,a);return s.length>0?Lc(Wd(t,s),n.shape):t},b:()=>{let t=Hu(e,go(n,"float32")),s=Dl(r.shape,a);s.length>0&&(t=Lc(Wd(t,s),r.shape));let i=zd(r);return Nl(Uu(t,go(i,"float32")))}}}},ck={kernelName:pr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Uu(e,Nl(zd(n)))}}},pk={kernelName:br,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=Hu(Ih(n,6),kg(n));return{x:()=>Hu(e,go(r,"float32"))}}},dk={kernelName:dr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Hu(e,go(kg(n),"float32"))}}},hk={kernelName:hr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Lc(e,n.shape)}}},fk={kernelName:gr,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>Bs.runKernel(yr,a,n)}}},mk={kernelName:fr,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,a={dy:e,images:r};return{images:()=>Bs.runKernel(mr,a,n)}}},gk={kernelName:wr,gradFunc:(e,t,n)=>{let{dims:r}=n,a=be(r,e.shape);return{x:()=>Sm(e,a)}}},yk={kernelName:xr,gradFunc:e=>({x:()=>cd(e)})},bk={kernelName:vr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Nl(Uu(e,Hu(Dd(n,1.5),2)))}}},wk={kernelName:Sr,inputsToSave:["condition"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>go(cd(n),"float32"),t:()=>Hu(e,go(n,e.dtype)),e:()=>Hu(e,go(Jh(n),e.dtype))}}},xk={kernelName:Nr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let t=uh(n,Md(0)),r=Md(Ww),a=Md(Vw),s=Hu(e,a),i=Hu(Hu(e,r),Kd(go(n,"float32")));return ld(t,s,i)}}}},vk={kernelName:Ar,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Hu(e,Hu(n,Uh(Md(1),n)))}}},kk={kernelName:Er,gradFunc:e=>({x:()=>cd(e)})},Ik={kernelName:_r,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Hu(Vp(go(n,"float32")),e)}}},Sk={kernelName:Cr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Hu(Gp(go(n,"float32")),e)}}},Nk={kernelName:Tr,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{begin:a,size:s}=n,i=r.shape,[o,l]=gu(r,a,s),u=[];for(let c=0;c<e.rank;c++)u.push([o[c],i[c]-o[c]-l[c]]);return{x:()=>zf(e,u)}}},Tk={kernelName:Or,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{dim:a}=n,s=!0,i=Hu(e,r);return{logits:()=>Uh(i,Hu(Wd(i,[a],s),r))}}},_k={kernelName:$r,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Hu(e,Hc(n))}}},Ck={kernelName:Dr,gradFunc:(e,t,n)=>{let{blockShape:r,paddings:a}=n;return{x:()=>Qc(e,r,a)}}},Ek={kernelName:Mr,gradFunc:(e,t,n)=>{let{axis:r}=n;return{x:()=>Uc(e,r)}}},Ak={kernelName:Fr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Uu(e,Hu(Ld(go(n,"float32")),2))}}},$k={kernelName:Ur,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Hu(e,Hu(go(n,"float32"),2))}}},Fk={kernelName:Vr,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Md(2);return{a:()=>Hu(e,Hu(a,Uh(n,r))),b:()=>Hu(e,Hu(a,Uh(r,n)))}}},Rk={kernelName:ia,gradFunc:e=>({x:()=>cd(e)})},Dk={kernelName:Kr,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,a=Ml(n.shape,r.shape);return{a:()=>{let t=e,r=Dl(n.shape,a);return r.length>0&&(t=Wd(t,r)),Lc(t,n.shape)},b:()=>{let t=e,n=Dl(r.shape,a);return n.length>0&&(t=Wd(t,n)),Lc(Nl(t),r.shape)}}}},Mk={kernelName:Rr,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,a=r.shape.slice(),{axis:s}=n;be(s,r.shape).forEach((e=>{a[e]=1}));let i=Lc(e,a),o=Hu(i,bf(r.shape,"float32"));return{x:()=>o}}},Ok={kernelName:Xr,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Uu(e,zd(Vp(n)))}}},Lk={kernelName:Yr,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Hu(Uh(Md(1),zd(n)),e)}}},Pk={kernelName:Jr,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{reps:a}=n;return{x:()=>{let t=cd(r);if(1===r.rank)for(let n=0;n<a[0];++n)t=zu(t,qc(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)t=zu(t,qc(e,[n*r.shape[0],s*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let i=0;i<a[2];++i)t=zu(t,qc(e,[n*r.shape[0],s*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<a[0];++n)for(let s=0;s<a[1];++s)for(let i=0;i<a[2];++i)for(let o=0;o<a[3];++o)t=zu(t,qc(e,[n*r.shape[0],s*r.shape[1],i*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}},zk={kernelName:ea,gradFunc:(e,t,n)=>{let r=n,{perm:a}=r,s=_d(a);return{x:()=>El(e,s)}}},Bk={kernelName:na,gradFunc:(e,t,n)=>{let r=n,{axis:a}=r;return{value:()=>xg(e,a)}}},Wk={kernelName:ra,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Vk(e,n)}}};function Vk(e,t){let n=ff(t,cd(t)),r=oh(e,n),a=ph(t,Md(0,"int32")),s=r.rank-a.rank;for(let o=0;o<s;++o)a=Yd(a,o+1);a=Xh(a,bf(r.shape,"bool"));let i=cd(r);return ld(a,r,i)}var Uk={kernelName:sa,gradFunc:e=>({x:()=>cd(e)})},Gk=[Rx,Dx,Mx,Ox,Lx,Px,zx,Bx,Wx,Vx,Ux,Gx,qx,Yx,Jx,Zx,Qx,ev,tv,nv,rv,av,iv,sv,uv,cv,pv,dv,hv,fv,uk,mv,gv,yv,bv,wv,vv,xv,kv,Iv,Tv,_v,Cv,Ev,Av,$v,Fv,Rv,Dv,Lv,zv,zv,Bv,Uv,jv,qv,Kv,Xv,Yv,Jv,Zv,Qv,ek,tk,nk,rk,rk,ak,sk,lk,ck,pk,dk,hk,fk,mk,gk,yk,bk,wk,xk,vk,kk,Ik,Sk,Nk,Tk,_k,Ck,Ck,Ek,Ek,Ak,Fk,$k,Rk,Dk,Mk,Ok,Lk,Pk,zk,Bk,Wk,Uk];for(let Jre of Gk)xa(Jre);bs().prototype.abs=function(){return this.throwIfDisposed(),qu(this)},bs().prototype.acos=function(){return this.throwIfDisposed(),Xu(this)},bs().prototype.acosh=function(){return this.throwIfDisposed(),Ju(this)},bs().prototype.add=function(e){return this.throwIfDisposed(),zu(this,e)},bs().prototype.all=function(e,t){return this.throwIfDisposed(),tc(this,e,t)},bs().prototype.any=function(e,t){return this.throwIfDisposed(),rc(this,e,t)},bs().prototype.argMax=function(e){return this.throwIfDisposed(),sc(this,e)},bs().prototype.argMin=function(e){return this.throwIfDisposed(),oc(this,e)},bs().prototype.asScalar=function(){return this.throwIfDisposed(),ae(1===this.size,(()=>"The array must have only 1 element.")),Lc(this,[])},bs().prototype.asType=function(e){return this.throwIfDisposed(),go(this,e)},bs().prototype.as1D=function(){return this.throwIfDisposed(),Lc(this,[this.size])},bs().prototype.as2D=function(e,t){return this.throwIfDisposed(),Lc(this,[e,t])},bs().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),Lc(this,[e,t,n])},bs().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),Lc(this,[e,t,n,r])},bs().prototype.as5D=function(e,t,n,r,a){return this.throwIfDisposed(),Lc(this,[e,t,n,r,a])},bs().prototype.asin=function(){return this.throwIfDisposed(),uc(this)},bs().prototype.asinh=function(){return this.throwIfDisposed(),pc(this)},bs().prototype.atan=function(){return this.throwIfDisposed(),hc(this)},bs().prototype.atan2=function(e){return this.throwIfDisposed(),mc(this,e)},bs().prototype.atanh=function(){return this.throwIfDisposed(),yc(this)},bs().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),zc(this,e,t,n,r)},bs().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),Qc(this,e,t)},bs().prototype.batchNorm=function(e,t,n,r,a){return this.throwIfDisposed(),np(this,e,t,n,r,a)},bs().prototype.broadcastTo=function(e){return this.throwIfDisposed(),fp(this,e)},bs().prototype.cast=function(e){return this.throwIfDisposed(),go(this,e)},bs().prototype.ceil=function(){return this.throwIfDisposed(),gp(this)},bs().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),bp(this,e,t)},bs().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof ys&&(e=[e]),Uc([this,...e],t)},bs().prototype.conv1d=function(e,t,n,r,a,s){return this.throwIfDisposed(),Ap(this,e,t,n,r,a,s)},bs().prototype.conv2dTranspose=function(e,t,n,r,a){return this.throwIfDisposed(),Dp(this,e,t,n,r,a)},bs().prototype.conv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),Cp(this,e,t,n,r,a,s)},bs().prototype.cos=function(){return this.throwIfDisposed(),Vp(this)},bs().prototype.cosh=function(){return this.throwIfDisposed(),Gp(this)},bs().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),jp(this,e,t,n)},bs().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),Kp(this,e,t,n)},bs().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),Zp(this,e,t)},bs().prototype.depthwiseConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),ed(this,e,t,n,r,a,s)},bs().prototype.dilation2d=function(e,t,n,r,a){return this.throwIfDisposed(),ad(this,e,t,n,r,a)},bs().prototype.divNoNan=function(e){return this.throwIfDisposed(),dd(this,e)},bs().prototype.div=function(e){return this.throwIfDisposed(),Uu(this,e)},bs().prototype.dot=function(e){return this.throwIfDisposed(),fd(this,e)},bs().prototype.elu=function(){return this.throwIfDisposed(),bd(this)},bs().prototype.equal=function(e){return this.throwIfDisposed(),id(this,e)},bs().prototype.erf=function(){return this.throwIfDisposed(),xd(this)},bs().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),jd(this,e,t)},bs().prototype.exp=function(){return this.throwIfDisposed(),Kd(this)},bs().prototype.expandDims=function(e){return this.throwIfDisposed(),Yd(this,e)},bs().prototype.expm1=function(){return this.throwIfDisposed(),Zd(this)},bs().prototype.fft=function(){return this.throwIfDisposed(),ig(this)},bs().prototype.flatten=function(){return this.throwIfDisposed(),Lc(this,[this.size])},bs().prototype.floor=function(){return this.throwIfDisposed(),sh(this)},bs().prototype.floorDiv=function(e){return this.throwIfDisposed(),Wu(this,e)},bs().prototype.gather=function(e,t){return this.throwIfDisposed(),oh(this,e,t)},bs().prototype.greaterEqual=function(e){return this.throwIfDisposed(),ph(this,e)},bs().prototype.greater=function(e){return this.throwIfDisposed(),uh(this,e)},bs().prototype.ifft=function(){return this.throwIfDisposed(),lg(this)},bs().prototype.irfft=function(){return this.throwIfDisposed(),cg(this)},bs().prototype.isFinite=function(){return this.throwIfDisposed(),hh(this)},bs().prototype.isInf=function(){return this.throwIfDisposed(),mh(this)},bs().prototype.isNaN=function(){return this.throwIfDisposed(),yh(this)},bs().prototype.leakyRelu=function(e){return this.throwIfDisposed(),wh(this,e)},bs().prototype.lessEqual=function(e){return this.throwIfDisposed(),Ih(this,e)},bs().prototype.less=function(e){return this.throwIfDisposed(),vh(this,e)},bs().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),Th(this,e,t,n,r)},bs().prototype.logSigmoid=function(){return this.throwIfDisposed(),Wh(this)},bs().prototype.logSoftmax=function(e){return this.throwIfDisposed(),Hh(this,e)},bs().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),qh(this,e,t)},bs().prototype.log=function(){return this.throwIfDisposed(),Ch(this)},bs().prototype.log1p=function(){return this.throwIfDisposed(),Ah(this)},bs().prototype.logicalAnd=function(e){return this.throwIfDisposed(),Xh(this,e)},bs().prototype.logicalNot=function(){return this.throwIfDisposed(),Jh(this)},bs().prototype.logicalOr=function(e){return this.throwIfDisposed(),Qh(this,e)},bs().prototype.logicalXor=function(e){return this.throwIfDisposed(),tf(this,e)},bs().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),Zo(this,e,t,n)},bs().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),lf(this,e,t,n,r)},bs().prototype.max=function(e,t){return this.throwIfDisposed(),Ad(this,e,t)},bs().prototype.maximum=function(e){return this.throwIfDisposed(),ff(this,e)},bs().prototype.mean=function(e,t){return this.throwIfDisposed(),gf(this,e,t)},bs().prototype.min=function(e,t){return this.throwIfDisposed(),Fd(this,e,t)},bs().prototype.minimum=function(e){return this.throwIfDisposed(),vf(this,e)},bs().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),If(this,e,t)},bs().prototype.mod=function(e){return this.throwIfDisposed(),Nf(this,e)},bs().prototype.mul=function(e){return this.throwIfDisposed(),Hu(this,e)},bs().prototype.neg=function(){return this.throwIfDisposed(),Nl(this)},bs().prototype.norm=function(e,t,n){return this.throwIfDisposed(),Gd(this,e,t,n)},bs().prototype.notEqual=function(e){return this.throwIfDisposed(),Rf(this,e)},bs().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),el(this,e,t,n)},bs().prototype.onesLike=function(){return this.throwIfDisposed(),Mf(this)},bs().prototype.pad=function(e,t){return this.throwIfDisposed(),zf(this,e,t)},bs().prototype.pool=function(e,t,n,r,a,s){return this.throwIfDisposed(),Qf(this,e,t,n,r,a,s)},bs().prototype.pow=function(e){return this.throwIfDisposed(),Dd(this,e)},bs().prototype.prelu=function(e){return this.throwIfDisposed(),tm(this,e)},bs().prototype.prod=function(e,t){return this.throwIfDisposed(),rm(this,e,t)},bs().prototype.reciprocal=function(){return this.throwIfDisposed(),bm(this)},bs().prototype.relu=function(){return this.throwIfDisposed(),xm(this)},bs().prototype.relu6=function(){return this.throwIfDisposed(),km(this)},bs().prototype.reshapeAs=function(e){return this.throwIfDisposed(),Lc(this,e.shape)},bs().prototype.reshape=function(e){return this.throwIfDisposed(),Lc(this,e)},bs().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),mb(this,e,t,n)},bs().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),yb(this,e,t,n)},bs().prototype.reverse=function(e){return this.throwIfDisposed(),Sm(this,e)},bs().prototype.rfft=function(){return this.throwIfDisposed(),fg(this)},bs().prototype.round=function(){return this.throwIfDisposed(),Dm(this)},bs().prototype.rsqrt=function(){return this.throwIfDisposed(),Om(this)},bs().prototype.selu=function(){return this.throwIfDisposed(),Pm(this)},bs().prototype.separableConv2d=function(e,t,n,r,a,s){return this.throwIfDisposed(),Bm(this,e,t,n,r,a,s)},bs().prototype.sigmoid=function(){return this.throwIfDisposed(),Hc(this)},bs().prototype.sign=function(){return this.throwIfDisposed(),Gm(this)},bs().prototype.sin=function(){return this.throwIfDisposed(),jm(this)},bs().prototype.sinh=function(){return this.throwIfDisposed(),Km(this)},bs().prototype.slice=function(e,t){return this.throwIfDisposed(),qc(this,e,t)},bs().prototype.softmax=function(e){return this.throwIfDisposed(),ag(this,e)},bs().prototype.softplus=function(){return this.throwIfDisposed(),zh(this)},bs().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),Xf(this,e,t)},bs().prototype.split=function(e,t){return this.throwIfDisposed(),dg(this,e,t)},bs().prototype.sqrt=function(){return this.throwIfDisposed(),Ld(this)},bs().prototype.square=function(){return this.throwIfDisposed(),zd(this)},bs().prototype.squaredDifference=function(e){return this.throwIfDisposed(),gg(this,e)},bs().prototype.squeeze=function(e){return this.throwIfDisposed(),bg(this,e)},bs().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof ys?[this,e]:[this,...e];return xg(n,t)},bs().prototype.step=function(e){return this.throwIfDisposed(),kg(this,e)},bs().prototype.stridedSlice=function(e,t,n,r,a,s,i,o){return this.throwIfDisposed(),Sg(this,e,t,n,r,a,s,i,o)},bs().prototype.sub=function(e){return this.throwIfDisposed(),Uh(this,e)},bs().prototype.sum=function(e,t){return this.throwIfDisposed(),Wd(this,e,t)},bs().prototype.tan=function(){return this.throwIfDisposed(),Tg(this)},bs().prototype.tanh=function(){return this.throwIfDisposed(),Xc(this)},bs().prototype.tile=function(e){return this.throwIfDisposed(),eh(this,e)},bs().prototype.toBool=function(){return this.throwIfDisposed(),go(this,"bool")},bs().prototype.toFloat=function(){return this.throwIfDisposed(),go(this,"float32")},bs().prototype.toInt=function(){return this.throwIfDisposed(),go(this,"int32")},bs().prototype.topk=function(e,t){return this.throwIfDisposed(),Rg(this,e,t)},bs().prototype.transpose=function(e){return this.throwIfDisposed(),El(this,e)},bs().prototype.unique=function(e){return this.throwIfDisposed(),Lg(this,e)},bs().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),zg(this,e,t)},bs().prototype.unstack=function(e){return this.throwIfDisposed(),Wg(this,e)},bs().prototype.where=function(e,t){return this.throwIfDisposed(),ld(e,this,t)},bs().prototype.zerosLike=function(){return this.throwIfDisposed(),cd(this)};var Hk=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Hk.prototype)}},jk=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,jk.prototype)}},qk=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,qk.prototype)}},Kk=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Kk.prototype)}},Xk=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Xk.prototype)}},Yk=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}};function Jk(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{let n=new Array(t);return n.fill(e),n}}function Zk(e,t){if(!e)throw new Xk(t)}function Qk(e,t){let n=0;for(let r of e)r===t&&n++;return n}function eI(e){return 1===e.length?e[0]:e}function tI(e){return Array.isArray(e)?e:[e]}function nI(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function rI(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}var aI={};function sI(e){if(null==e)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function iI(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach((e=>iI(e)));else{let t=Object.keys(e);for(let n of t){let t=e[n];null!=t&&"object"==typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!=typeof t.value?iI(t):e[n]=t.value)}}}function oI(e,t={},n={},r="object",a=!1){if("string"==typeof e){let a,s=e;if(s in n)a=n[s];else if(s in aI)a=aI[s];else if(a=t[s],null==a)throw new qk(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}{let s=e;if(null==s.className||null==s.config)throw new qk(`${r}: Improper config format: ${JSON.stringify(s)}.\n'className' and 'config' must set.`);let i,o,l=s.className;if(l in n?[i,o]=n[l]:l in aI?[i,o]=aI.className:l in t&&([i,o]=t[l]),null==i)throw new qk(`Unknown ${r}: ${l}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=o){let e={};for(let n of Object.keys(aI))e[n]=aI[n];for(let a of Object.keys(n))e[a]=n[a];let t=s.config;t.customObjects=e;let r=Object.assign({},aI);for(let a of Object.keys(n))aI[a]=n[a];iI(s.config);let l=o(i,s.config,n,a);return aI=Object.assign({},r),l}{let e=Object.assign({},aI);for(let r of Object.keys(n))aI[r]=n[r];let t=new i(s.config);return aI=Object.assign({},e),t}}}function lI(e,t){return e<t?-1:e>t?1:0}function uI(e,t){return-1*lI(e,t)}function cI(e){if(null==e)return e;let t=[];for(let n of e)-1===t.indexOf(n)&&t.push(n);return t}function pI(e){if(null==e)throw new qk(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function dI(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new qk(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function hI(e,t,n=0,r=1/0){return Zk(n>=0),Zk(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every((e=>typeof e===t))}function fI(e,t){Array.isArray(e)?(Na.assert(e.length>0,(()=>`${t} is unexpectedly an empty array.`)),e.forEach(((e,n)=>fI(e,`element ${n+1} of ${t}`)))):Na.assert(Number.isInteger(e)&&e>0,(()=>`Expected ${t} to be a positive integer, but got ${mI(e)}.`))}function mI(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>mI(e))).join(",")+"]":"string"==typeof e?`"${e}"`:`${e}`}function gI(e,t,n){let r,a=null!=n?n():Na.now();return(...s)=>{let i=null!=n?n():Na.now();return i-a<t||(a=i,r=e(...s)),r}}function yI(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}var bI=0;function wI(){return bI++}var xI={};function vI(e=""){return e in xI||(xI[e]=0),xI[e]+=1,e+xI[e].toString()}var kI=["channelsFirst","channelsLast"],II=["nearest","bilinear"],SI=["valid","same","causal"],NI=["max","avg"],TI=["sum","mul","concat","ave"],_I=new Map;function CI(e){dI(kI,"DataFormat",e)}function EI(e){dI(II,"InterpolationFormat",e)}function AI(e){dI(SI,"PaddingMode",e)}function $I(e){dI(NI,"PoolMode",e)}var FI=[],RI="/";function DI(e,t){FI.push(e);try{let e=t();return FI.pop(),e}catch(n){throw FI.pop(),n}}function MI(){return 0===FI.length?"":FI.join(RI)+RI}function OI(e){if(!BI(e))throw new Error("Not a valid tensor name: '"+e+"'");return MI()+e}function LI(e){if(!BI(e))throw new Error("Not a valid tensor name: '"+e+"'");_I.has(e)||_I.set(e,0);let t=_I.get(e);if(_I.set(e,_I.get(e)+1),t>0){let n=`${e}_${t}`;return _I.set(n,1),n}return e}var PI,zI=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function BI(e){return!!e.match(zI)}function WI(e){return e===parseInt(e.toString(),10)}function VI(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let a=t;a<n;++a)r*=e[a];return r}function UI(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r<t&&(t=r)}return t}function GI(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r>t&&(t=r)}return t}function HI(e,t){if(t<e)throw new qk(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let r=e;r<t;++r)n.push(r);return n}function jI(){return null==PI&&(PI=xl().epsilon()),PI}function qI(){return"channelsLast"}function KI(e,t){return go(e,t)}function XI(e,t=-1){let n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),Lc(e,n)}function YI(e,t){return ul((()=>{if(2!==e.shape.length)throw new qk(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);let n=XI(e,1);return aS(n,[1,t,1])}))}function JI(e){let t=[VI(e.shape)];return Lc(e,t)}function ZI(e){if(e.rank<=1)throw new qk(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],VI(e.shape,1)];return Lc(e,t)}function QI(e,t,n){return ul((()=>{switch(e.rank){case 1:return Ym(e,t,n);case 2:return Zm(e,[t,0],[n,e.shape[1]]);case 3:return eg(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return ng(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return qc(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return qc(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new qk(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function eS(e,t,n){return ul((()=>{switch(e.rank){case 1:return Ym(e,t,n);case 2:return Zm(e,[0,t],[e.shape[0],n]);case 3:return eg(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return ng(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new qk(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function tS(e,t,n,r){return ul((()=>{switch(e.rank){case 1:return Ym(e,t,n);case 2:switch(r){case 1:return QI(e,t,n);case 2:return eS(e,t,n);default:throw new qk(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return QI(e,t,n);case 2:return eg(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return eS(e,t,n);default:throw new qk(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return QI(e,t,n);case 2:return ng(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return ng(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return eS(e,t,n);default:throw new qk(`The axis is not within the rank of the tensor ${r}`)}default:throw new qk(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function nS(e,t=-1){let n;return t<0&&(n=e[0].rank,t=0!==n?n:0),t===e[0].rank&&(t=-1),Uc(e,t)}function rS(e,t){switch(e.rank){case 1:return xp([e,t]);case 2:return kp([e,t],0);case 3:return Sp([e,t],0);case 4:return Tp([e,t],0);default:throw new qk(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function aS(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new qk(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return eh(e,t)}function sS(e,t=0,n=1,r,a){return hm(e,t,n,r,a)}function iS(e,t,n,r){if(e.rank<2||t.rank<2)throw new Kk(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){let n=e.shape.slice(-1)[0],r=t.shape.slice(-2)[0];if(n!==r)throw new Kk(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(2===e.rank&&2===t.rank)return py.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?uS(e.rank,r,qI()):null,activation:n});{let a=e.shape.slice(),s=a.pop();e=Lc(e,[-1,s]);let i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],c=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=Lc(El(t,c),[l,-1]);let p=[...a,...u],d=!1,h=!1;return Lc(py.matMul({a:e,b:t,transposeA:d,transposeB:h,bias:r?uS(e.rank,r,qI()):null,activation:n}),p)}}function oS(e,t,n){return ul((()=>(t=Array.isArray(t)?_g(t,"int32"):go(t,"int32"),oh(e,t,n))))}function lS(e){return Hu(e,e)}function uS(e,t,n){let r=t.shape;if(1!==t.rank&&t.rank!==e)throw new qk(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return 1===r.length?Lc(t,[1,r[0],1,1,1]):Lc(t,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?Lc(t,[1,1,1,1,r[0]]):Lc(t,[1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?Lc(t,[1,r[0],1,1]):Lc(t,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?Lc(t,[1,1,1,r[0]]):Lc(t,[1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?Lc(t,[1,r[0],1]):Lc(t,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?Lc(t,[1,1,r[0]]):Lc(t,[1].concat(r))}else if(e<3)return t;throw new qk(`Unsupported input rank by biasAdd: ${t.rank}`)}function cS(e,t,n){return ul((()=>(null==n&&(n=qI()),CI(n),zu(e,uS(e.rank,t,n)))))}function pS(e,t=1){if(1!==t)throw new Kk(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return bd(e)}function dS(e){return ul((()=>Uu(e,zu(qu(e),1))))}function hS(e,t,n,r){return ul((()=>iy(e,t,n,r)))}function fS(e){return ul((()=>{let t=zu(.5,Hu(.2,e));return bp(t,0,1)}))}function mS(e,t,n=!1){return n?e():t()}var gS=["fanIn","fanOut","fanAvg"],yS=["normal","uniform","truncatedNormal"];function bS(e){dI(gS,"FanMode",e)}function wS(e){dI(yS,"Distribution",e)}var xS=class extends xu.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},vS=class extends xS{apply(e,t){return yf(e,t)}};vS.className="Zeros",xu.registerClass(vS);var kS=class extends xS{apply(e,t){return bf(e,t)}};kS.className="Ones",xu.registerClass(kS);var IS=class extends xS{constructor(e){if(super(),"object"!=typeof e)throw new qk(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new qk(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return ul((()=>Hu(Md(this.value),bf(e,t))))}getConfig(){return{value:this.value}}};IS.className="Constant",xu.registerClass(IS);var SS=class extends xS{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return mm(e,this.minval,this.maxval,t)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};SS.className="RandomUniform",xu.registerClass(SS);var NS=class extends xS{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32","float32"!==t&&"int32"!==t)throw new Kk(`randomNormal does not support dType ${t}.`);return sS(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};NS.className="RandomNormal",xu.registerClass(NS);var TS=class extends xS{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32","float32"!==t&&"int32"!==t)throw new Kk(`truncatedNormal does not support dType ${t}.`);return Mg(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};TS.className="TruncatedNormal",xu.registerClass(TS);var _S=class extends xS{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return ul((()=>{if(2!==e.length||e[0]!==e[1])throw new qk("Identity matrix initializer can only be used for 2D square matrices.");return Hu(this.gain,nh(e[0]))}))}getConfig(){return{gain:this.gain}}};function CS(e,t="channelsLast"){let n,r;if(CI(t),2===e.length)n=e[0],r=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===t){let t=VI(e,2);n=e[1]*t,r=e[0]*t}else if("channelsLast"===t){let t=VI(e,0,e.length-2);n=e[e.length-2]*t,r=e[e.length-1]*t}}else{let t=VI(e);n=Math.sqrt(t),r=Math.sqrt(t)}return[n,r]}_S.className="Identity",xu.registerClass(_S);var ES=class extends xS{constructor(e){if(super(),e.scale<0)throw new qk(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,bS(this.mode),this.distribution=null==e.distribution?"normal":e.distribution,wS(this.distribution),this.seed=e.seed}apply(e,t){let n=CS(e),r=n[0],a=n[1],s=this.scale;if("fanIn"===this.mode?s/=Math.max(1,r):"fanOut"===this.mode?s/=Math.max(1,a):s/=Math.max(1,(r+a)/2),"normal"===this.distribution){let n=Math.sqrt(s);if(t=t||"float32","float32"!==t&&"int32"!==t)throw new Kk(`${this.getClassName()} does not support dType ${t}.`);return Mg(e,0,n,t,this.seed)}{let n=Math.sqrt(3*s);return mm(e,-n,n,t)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};ES.className="VarianceScaling",xu.registerClass(ES);var AS=class extends ES{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return ES.className}};AS.className="GlorotUniform",xu.registerClass(AS);var $S=class extends ES{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return ES.className}};$S.className="GlorotNormal",xu.registerClass($S);var FS=class extends ES{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return ES.className}};FS.className="HeNormal",xu.registerClass(FS);var RS=class extends ES{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return ES.className}};RS.className="HeUniform",xu.registerClass(RS);var DS=class extends ES{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return ES.className}};DS.className="LeCunNormal",xu.registerClass(DS);var MS=class extends ES{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return ES.className}};MS.className="LeCunNormal",xu.registerClass(MS);var OS=class extends xS{constructor(e){if(super(),this.DEFAULT_GAIN=1,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,null!=this.seed)throw new Kk("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,t){return ul((()=>{if(e.length<2)throw new Kk("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);let t=e[0]>e[1]?[e[1],e[0]]:e,n=sS(t,0,1,"float32"),r=fw.gramSchmidt(n);return e[0]>e[1]&&(r=El(r)),Hu(this.gain,r)}))}getConfig(){return{gain:this.gain,seed:this.seed}}};OS.className="Orthogonal",xu.registerClass(OS);var LS={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function PS(e,t={}){return oI(e,xu.SerializationMap.getMap().classNameMap,t,"initializer")}function zS(e){return sI(e)}function BS(e){if("string"==typeof e){let t=e in LS?LS[e]:e;if("GlorotNormal"===t)return new $S;if("GlorotUniform"===t)return new AS;if("HeNormal"===t)return new FS;if("HeUniform"===t)return new RS;if("LeCunNormal"===t)return new DS;if("LeCunUniform"===t)return new MS;{let e={};return e.className=t,e.config={},PS(e)}}return e instanceof xS?e:PS(e)}function WS(e){return Array.isArray(e)&&Array.isArray(e[0])}function VS(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function US(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new qk(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function GS(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new qk(`Expected exactly 1 Shape; got ${e.length}`)}return e}function HS(e){let t=0;for(let n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}var jS="Variable",qS=class{constructor(e,t="float32",n=jS,r=!0,a=null){this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=wI(),n=null==n?jS:n,this.originalName=OI(n),this.name=LI(this.originalName),this.trainable_=r,this.constraint=a,this.val=Ug(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),KS(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function KS(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function XS(e){return e.map((e=>e.read()))}function YS(e){e.forEach((e=>{e[0].write(e[1])}))}var JS=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},ZS=class{constructor(e,t,n,r,a,s,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=a,this.outputTensorIndex=i,this.id=wI(),null!=s&&(this.originalName=OI(s),this.name=LI(this.originalName)),this.rank=t.length}},QS=0,eN=class{constructor(e,t){this.callArgs=t,this.id=QS++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},tN=0,nN=class extends xu.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=tN++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let e=this.getClassName();t=nI(e)+"_"+vI(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new jk(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new qk(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return eI(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return eI(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Hk(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new Hk(`Layer ${this.name} is not connected, no input to return.`);return eI(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new Hk(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Hk(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return eI(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=tI(e),null==this.inputSpec||0===this.inputSpec.length)return;let t=tI(this.inputSpec);if(e.length!==t.length)throw new qk(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let n=0;n<e.length;n++){let r=e[n],a=t[n];if(null==a)continue;let s=r.rank;if(null!=a.ndim&&s!==a.ndim)throw new qk(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${s}`);if(null!=a.maxNDim&&s>a.maxNDim)throw new qk(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${s}`);if(null!=a.minNDim&&s<a.minNDim)throw new qk(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${s}.`);if(null!=a.dtype&&r.dtype!==a.dtype)throw new qk(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${r.dtype}.`);if(a.axes){let e=r.shape;for(let t in a.axes){let r=Number(t),s=a.axes[t],i=r>=0?e[r]:e[e.length+r];if(null!=s&&-1===[s,null].indexOf(i))throw new qk(`Input ${n} is incompatible with layer ${this.name}: expected axis ${r} of input shape to have value ${s} but got shape ${e}.`)}}if(null!=a.shape)for(let e=0;e<a.shape.length;++e){let t=a.shape[e],s=r.shape[e];if(null!=t&&null!=s&&t!==s)throw new qk(`Input ${n} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=tI(e),r=!0;for(let s of n)if(!(s instanceof ZS)){r=!1;break}let a=!0;for(let s of n)if(s instanceof ZS){a=!1;break}if(r===a)throw new qk("Arguments to apply() must be all SymbolicTensors or all Tensors");return DI(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);let t=[];for(let n of tI(e))t.push(n.shape);this.build(eI(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let r=this.call(e,t),a=tI(r),s=[];for(let e of a)-1!==n.indexOf(e)&&(e=e.clone()),s.push(e);if(r=eI(s),null!=this.activityRegularizer)throw new Kk("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{let n,r=rN(e),a=this.computeOutputShape(r),s=aN(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?r[0]:r),n=null!=a&&a.length>0&&Array.isArray(a[0])?a.map(((n,r)=>new ZS(s,n,this,tI(e),t,this.name,r))):new ZS(s,a,this,tI(e),t,this.name),this.addInboundNode(e,n,null,null,r,a,t),this._refCount++,null!=this.activityRegularizer)throw new Kk("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return n}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach(((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)})),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new Hk(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){let e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new Hk(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new jk(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return HS(this.weights)}build(e){this.built=!0}getWeights(e=!1){return XS(e?this.trainableWeights:this.weights)}setWeights(e){ul((()=>{let t=this.weights;if(t.length!==e.length)throw new qk(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;let n=[],r=XS(t);for(let a=0;a<r.length;++a){let s=r[a],i=t[a],o=e[a];if(!Na.arraysEqual(s.shape,o.shape))throw new qk(`Layer weight shape ${s.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}YS(n)}))}addWeight(e,t,n,r,a,s,i,o){if(-1!==this._addedWeightNames.indexOf(e))throw new qk(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=o?o():BS("zeros"));let l=r.apply(t,n),u=new qS(l,n,e,s,i);return l.dispose(),null!=a&&this.addLoss((()=>a.apply(u.read()))),null==s&&(s=!0),s?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=tI(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach((e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return t}addInboundNode(e,t,n,r,a,s,i=null){let o=tI(e);t=tI(t),n=tI(n),r=tI(r),a=VS(a),s=VS(s);let l=[],u=[],c=[];for(let p of o)l.push(p.sourceLayer),u.push(p.nodeIndex),c.push(p.tensorIndex);new eN({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:a,outputShapes:s},i);for(let p=0;p<t.length;p++)t[p].sourceLayer=this,t[p].nodeIndex=this.inboundNodes.length-1,t[p].tensorIndex=p}getConfig(){let e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function rN(e){e=tI(e);let t=[];for(let n of e)t.push(n.shape);return eI(t)}function aN(e){return"float32"}function sN(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{let e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{let t=[];for(let n=0;n<e.inboundLayers.length;n++){let r=e.inputTensors[n],a=e.inboundLayers[n],s=e.nodeIndices[n],i=sN(r,a,s);for(let e of i)-1===t.indexOf(e)&&t.push(e)}return t}}}var iN=class extends nN{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:vI("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new qk("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new qk("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new qk("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let r=new ZS(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new eN({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new qk(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};function oN(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new qk("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new iN({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}function lN(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return go(t,e.dtype)}catch(n){throw new qk(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}iN.className="InputLayer",xu.registerClass(iN);var uN=class{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof uN)for(let t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(let t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new qk(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=lN(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof ZS){if(null==this.id2Value[e.id])throw new qk(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{let t=this.name2Id[e];if(null==t)throw new qk(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof ZS){if(null==this.id2Value[e.id])throw new qk(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{let t=this.name2Id[e];if(null==t)throw new qk(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&cl(this.id2Mask)}},cN=new Yk,pN=new Yk;function dN(e){null!=cN&&cN.setMaxEntries(e),null!=pN&&pN.setMaxEntries(e)}function hN(e,t,n,r){let a=null!=n&&n.training,s=Array.isArray(e),i=s?e:[e],o=i.map((e=>e.name)),l=[],u=t.names();for(let f of o)-1!==u.indexOf(f)?l.push(t.getValue(f)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);let c,p=o.join(",")+"|"+t.names().sort().join(","),d=cN.get(p);if(null==d){let e=fN(i,t);d=e.sorted,c=e.recipientCounts,cN.put(p,d),pN.put(p,c)}c={},a||Object.assign(c,pN.get(p));let h=new uN(t);for(let f=0;f<d.length;++f){if(null!=r){let e=ol().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}let e=d[f],s=e.sourceLayer;if(s instanceof iN)continue;let i=[],u=[],p=[],m=!1;for(let n of e.inputs){let e=h.getValue(n),r=h.getMask(n);i.push(e),u.push(r),null!=r&&(m=!0),a||(c[n.name]--,0===c[n.name]&&!t.hasKey(n)&&-1===o.indexOf(n.name)&&!e.isDisposed&&!0!==n.sourceLayer.stateful&&p.push(e))}m&&(n=n||{},n.mask=u[0]);let g=tI(s.apply(i,n)),y=null;s.supportsMasking&&(y=s.computeMask(i,u));let b=yN(e),w=Array.isArray(b)?b:[b];for(let t=0;t<w.length;++t){h.hasKey(w[t])||h.add(w[t],g[t],Array.isArray(y)?y[0]:y);let e=o.indexOf(w[t].name);-1!==e&&(l[e]=g[t])}a||cl(p)}return h.disposeMasks(),s?l:l[0]}function fN(e,t){Na.assert(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],r={};if(1===e.length){let a=gN(e[0],t);n=a.sorted,r=a.recipientMap}else{let a=new Set;for(let s of e){let{sorted:e,recipientMap:i}=gN(s,t);for(let t of e)a.has(t.name)||(n.push(t),a.add(t.name));for(let t in i)null==r[t]&&(r[t]=new Set),i[t].forEach((e=>r[t].add(e)))}}return{sorted:n,recipientCounts:mN(r)}}function mN(e){let t={};for(let n in e)t[n]=e[n].size;return t}function gN(e,t){let n=new Set,r=[],a={};for(let o of t.names())n.add(o);let s=[],i=[];for(s.push(e);s.length>0;){let e=s[s.length-1];if(n.has(e.name)){s.pop();continue}let t=i[i.length-1]===s.length-1;if(0===e.inputs.length||t)s.pop(),r.push(e),n.add(e.name),t&&i.pop();else{i.push(s.length-1);for(let t of e.inputs)null==a[t.name]&&(a[t.name]=new Set),a[t.name].add(e.name),!n.has(t.name)&&s.push(t)}}return{sorted:r,recipientMap:a}}function yN(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(let r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}var bN=Xe();bN.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),dN);var wN={};function xN(e,t){return ul((()=>Ld(Wd(Hu(e,e),t,!0))))}g(wN,{maxNorm:()=>AN,minMaxNorm:()=>RN,nonNeg:()=>FN,unitNorm:()=>$N});var vN=class extends xu.Serializable{getConfig(){return{}}},kN=class extends vN{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return ul((()=>{let t=xN(e,this.axis),n=bp(t,0,this.maxValue);return Hu(e,Uu(n,zu(jI(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};kN.className="MaxNorm",xu.registerClass(kN);var IN=class extends vN{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return ul((()=>Uu(e,zu(jI(),xN(e,this.axis)))))}getConfig(){return{axis:this.axis}}};IN.className="UnitNorm",xu.registerClass(IN);var SN=class extends vN{apply(e){return xm(e)}};SN.className="NonNeg",xu.registerClass(SN);var NN=class extends vN{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return ul((()=>{let t=xN(e,this.axis),n=zu(Hu(this.rate,bp(t,this.minValue,this.maxValue)),Hu(1-this.rate,t));return Hu(e,Uu(n,zu(jI(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};NN.className="MinMaxNorm",xu.registerClass(NN);var TN={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function _N(e){return sI(e)}function CN(e,t={}){return oI(e,xu.SerializationMap.getMap().classNameMap,t,"constraint")}function EN(e){if(null==e)return null;if("string"==typeof e){let t={className:e in TN?TN[e]:e,config:{}};return CN(t)}return e instanceof vN?e:CN(e)}function AN(e){return new kN(e)}function $N(e){return new IN(e)}function FN(){return new SN}function RN(e){return new NN(e)}var DN={};function MN(){return new vS}function ON(){return new kS}function LN(e){return new IS(e)}function PN(e){return new SS(e)}function zN(e){return new NS(e)}function BN(e){return new TS(e)}function WN(e){return new _S(e)}function VN(e){return new ES(e)}function UN(e){return new AS(e)}function GN(e){return new $S(e)}function HN(e){return new FS(e)}function jN(e){return new RS(e)}function qN(e){return new DS(e)}function KN(e){return new MS(e)}function XN(e){return new OS(e)}g(DN,{constant:()=>LN,glorotNormal:()=>GN,glorotUniform:()=>UN,heNormal:()=>HN,heUniform:()=>jN,identity:()=>WN,leCunNormal:()=>qN,leCunUniform:()=>KN,ones:()=>ON,orthogonal:()=>XN,randomNormal:()=>zN,randomUniform:()=>PN,truncatedNormal:()=>BN,varianceScaling:()=>VN,zeros:()=>MN});var YN,JN={};async function ZN(e){if(null==e)return;let t=[],n=[],r=[];for(let a in e){let s=e[a];if("number"!=typeof s){let e=s;t.push(e.data()),n.push(a),r.push(e)}}if(t.length>0){let a=await Promise.all(t);for(let t=0;t<a.length;++t)e[n[t]]=a[t][0];cl(r)}}function QN(e){if(null!=e)for(let t in e){let n=e[t];"number"!=typeof n&&n.dispose()}}g(JN,{Layer:()=>nN,RNN:()=>QC,RNNCell:()=>eE,activation:()=>CA,add:()=>LA,alphaDropout:()=>_$,average:()=>PA,averagePooling1d:()=>qA,averagePooling2d:()=>YA,averagePooling3d:()=>QA,avgPool1d:()=>KA,avgPool2d:()=>JA,avgPool3d:()=>e$,avgPooling1d:()=>XA,avgPooling2d:()=>ZA,avgPooling3d:()=>t$,batchNormalization:()=>GA,bidirectional:()=>w$,concatenate:()=>zA,conv1d:()=>wA,conv2d:()=>xA,conv2dTranspose:()=>vA,conv3d:()=>kA,conv3dTranspose:()=>IA,convLstm2d:()=>m$,convLstm2dCell:()=>g$,cropping2D:()=>NA,dense:()=>EA,depthwiseConv2d:()=>_A,dot:()=>UA,dropout:()=>AA,elu:()=>hA,embedding:()=>OA,flatten:()=>FA,gaussianDropout:()=>T$,gaussianNoise:()=>N$,globalAveragePooling1d:()=>n$,globalAveragePooling2d:()=>r$,globalMaxPool1d:()=>v$,globalMaxPool2d:()=>k$,globalMaxPooling1d:()=>a$,globalMaxPooling2d:()=>s$,gru:()=>u$,gruCell:()=>c$,input:()=>X_,inputLayer:()=>dA,layerNormalization:()=>HA,leakyReLU:()=>mA,lstm:()=>p$,lstmCell:()=>d$,masking:()=>C$,maxPool1d:()=>I$,maxPool2d:()=>S$,maxPooling1d:()=>i$,maxPooling2d:()=>o$,maxPooling3d:()=>l$,maximum:()=>BA,minimum:()=>WA,multiply:()=>VA,permute:()=>MA,prelu:()=>gA,reLU:()=>fA,repeatVector:()=>RA,reshape:()=>DA,rnn:()=>y$,separableConv2d:()=>SA,simpleRNN:()=>h$,simpleRNNCell:()=>f$,softmax:()=>yA,spatialDropout1d:()=>$A,stackedRNNCells:()=>b$,thresholdedReLU:()=>bA,timeDistributed:()=>x$,upSampling2d:()=>TA,zeroPadding2d:()=>jA}),function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(YN||(YN={}));var eT=125,tT=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},nT=class{constructor(e,t=10){null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},rT=class extends tT{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});let n=null==t.size?0:t.size;this.seen+=n;for(let r in t){let e=t[r];if("number"==typeof e)this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+e*n;else{let t;r in this.totals?t=this.totals[r]:this.totals[r]=0;let a=ul((()=>zu(this.totals[r],Hu(e,n))));this.totals[r]=a,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(let n of this.params.metrics)null!=this.totals[n]&&("number"==typeof this.totals[n]?t[n]=this.totals[n]/this.seen:ul((()=>{let e=Hu(Uu(1,this.seen),this.totals[n]);t[n]=e,this.totals[n].dispose(),pl(t[n])})))}},aT=class extends tT{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(let n in t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let a in this.history){let r=this.history[a];for(let s=0;s<r.length;++s)if("number"!=typeof r[s]){let i=r[s];e.push(i.data()),t.push(a),n.push(s)}}let r=await Promise.all(e);for(let a=0;a<r.length;++a)this.history[t[a]][n[a]].dispose(),this.history[t[a]][n[a]]=r[a][0]}},sT=class extends tT{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Ew,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=eT),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Na.isNumber(this.yieldEvery)&&(this.maybeWait=gI(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let r=[];null!=this.yield&&(await ZN(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await ZN(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];null!=this.epochEnd&&(await ZN(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await ZN(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];null!=this.batchEnd&&(await ZN(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):Na.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await ZN(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await ZN(e),await this.trainEnd(e))}};function iT(e,t){return null==e&&(e={}),e instanceof tT?[e]:Array.isArray(e)&&e[0]instanceof tT?e:tI(e).map((e=>new sT(e,t)))}var oT=class{constructor(){}static registerCallbackConstructor(e,t){Na.assert(e>=0&&Number.isInteger(e),(()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`)),oT.checkForDuplicate(t),null==oT.constructors[e]&&(oT.constructors[e]=[]),oT.constructors[e].push(t)}static checkForDuplicate(e){for(let t in oT.constructors)oT.constructors[+t].forEach((t=>{if(t===e)throw new qk("Duplicate callback constructor.")}))}static clear(){oT.constructors={}}static createCallbacks(e){let t=[];for(let n in oT.constructors){let r=+n;e>=r&&t.push(...oT.constructors[r])}return t.map((e=>new e))}};function lT(e,t,n,r,a,s,i,o,l){let u=new aT,c=[new rT,...oT.createCallbacks(t)];null!=e&&c.push(...e),c.push(u);let p=new nT(c);return p.setParams({epochs:n,initialEpoch:r,samples:a,steps:s,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:p,history:u}}function uT(e,t={},n=!1){return oI(e,xu.SerializationMap.getMap().classNameMap,t,"layer",n)}function cT(e,t){return ul((()=>{"float32"!==e.dtype&&(e=go(e,"float32"));let n=Wd(lS(e),t,!0),r=rh(n.shape,jI()),a=Ld(ff(n,r));return Uu(e,a)}))}function pT(e,t){return ul((()=>gf(lS(Uh(t,e)),-1)))}function dT(e,t){return ul((()=>gf(qu(Uh(t,e)),-1)))}function hT(e,t){return ul((()=>{let n=Uh(e,t),r=bp(qu(e),jI(),Number.MAX_VALUE),a=qu(Uu(n,r));return Hu(100,gf(a,-1))}))}function fT(e,t){return ul((()=>{let n=bp(t,jI(),Number.MAX_VALUE),r=Ch(zu(1,n)),a=bp(e,jI(),Number.MAX_VALUE),s=Ch(zu(1,a));return gf(lS(Uh(r,s)),-1)}))}function mT(e,t){return ul((()=>{let n=ff(0,Uh(1,Hu(e,t)));return gf(lS(n),-1)}))}function gT(e,t){return ul((()=>{let n=ff(0,Uh(1,Hu(e,t)));return gf(n,-1)}))}function yT(e,t){return ul((()=>{let n=Wd(Hu(e,t),-1),r=Ad(Hu(Uh(1,e),t),-1);return ff(0,zu(1,Uh(r,n)))}))}function bT(e,t){return ul((()=>{let n=Math.log(2),r=Uh(t,e),a=Uh(zu(r,zh(Hu(-2,r))),n);return gf(a,-1)}))}function wT(e,t,n=!1){return ul((()=>{if(n)t=ag(t);else{let e=Wd(t,t.shape.length-1,!0);t=Uu(t,e)}return t=bp(t,jI(),1-jI()),Nl(Wd(Hu(go(e,"float32"),Ch(t)),t.shape.length-1))}))}function xT(e,t,n=!1){return ul((()=>{let r=go(sh(JI(e)),"int32");t=bp(t,jI(),1-jI());let a=t.shape,s=Lc(el(r,a[a.length-1]),a);return wT(s,t,n)}))}function vT(e,t){if(!Na.arraysEqual(e.shape,t.shape))throw new qk(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return ul((()=>{let n=xm(t),r=Nl(qu(t));return zu(Uh(n,Hu(t,e)),Ah(Kd(r)))}))}function kT(e,t){return ul((()=>{let n;return n=bp(t,jI(),1-jI()),n=Ch(Uu(n,Uh(1,n))),gf(vT(e,n),-1)}))}function IT(e,t){return ul((()=>{let n=bp(e,jI(),1),r=bp(t,jI(),1);return Wd(Hu(e,Ch(Uu(n,r))),-1)}))}function ST(e,t){return ul((()=>{let n=Ch(zu(jI(),t));return gf(Uh(t,Hu(e,n)),-1)}))}function NT(e,t){return ul((()=>{let n=cT(e,-1),r=cT(t,-1),a=Hu(n,r);return Nl(Wd(a,-1))}))}oT.constructors={};var TT={meanSquaredError:pT,meanAbsoluteError:dT,meanAbsolutePercentageError:hT,meanSquaredLogarithmicError:fT,squaredHinge:mT,hinge:gT,categoricalHinge:yT,logcosh:bT,categoricalCrossentropy:wT,sparseCategoricalCrossentropy:xT,binaryCrossentropy:kT,kullbackLeiblerDivergence:IT,poisson:ST,cosineProximity:NT};function _T(e){if("string"==typeof e){if(e in TT)return TT[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new qk(t)}return e}function CT(e,t){return ul((()=>{let n=Hu(.5,Mf(t)),r=KI(uh(t,n),e.dtype);return gf(id(e,r),-1)}))}function ET(e,t){return ul((()=>KI(id(sc(e,-1),sc(t,-1)),"float32")))}function AT(e,t){return ul((()=>go(Wd(Xh(id(e,1),id(t,1))),"float32")))}function $T(e,t){return ul((()=>go(Wd(Xh(id(e,1),id(t,0))),"float32")))}function FT(e,t){return ul((()=>go(Wd(Xh(id(e,0),id(t,1))),"float32")))}function RT(e,t){return ul((()=>{let n=AT(e,t),r=FT(e,t),a=zu(n,r);return go(ld(uh(a,0),Uu(n,a),0),"float32")}))}function DT(e,t){return ul((()=>{let n=AT(e,t),r=$T(e,t),a=zu(n,r);return go(ld(uh(a,0),Uu(n,a),0),"float32")}))}function MT(e,t){return kT(e,t)}function OT(e,t){return e.rank===t.rank&&(e=bg(e,[e.rank-1])),t=sc(t,-1),t.dtype!==e.dtype&&(t=go(t,e.dtype)),go(id(e,t),"float32")}var LT=pT,PT=pT,zT=dT,BT=dT,WT=hT,VT=hT,UT=wT,GT=NT,HT=xT,jT={binaryAccuracy:CT,categoricalAccuracy:ET,precision:RT,categoricalCrossentropy:UT,sparseCategoricalCrossentropy:HT,mse:LT,MSE:PT,mae:zT,MAE:BT,mape:WT,MAPE:VT,cosine:GT};function qT(e){if("string"==typeof e&&e in jT)return jT[e];if("string"!=typeof e&&null!=e)return e;throw new qk(`Unknown metric ${e}`)}function KT(e){if(Zk(null!==e,`Unknown LossOrMetricFn ${e}`),"string"==typeof e)return e;{let t;for(let n of Object.keys(TT))if(TT[n]===e){t=n;break}if(void 0!==t)return t;for(let n of Object.keys(jT))if(jT[n]===e){t=n;break}return void 0!==t?t:e.name}}function XT(e){let t={Adagrad:()=>_w.adagrad(.01),Adadelta:()=>_w.adadelta(1,.95,jI()),Adam:()=>_w.adam(.001,.9,.999,jI()),Adamax:()=>_w.adamax(.002,.9,.999,jI(),0),RMSProp:()=>_w.rmsprop(.001,.9,0,jI()),SGD:()=>_w.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new qk(`Unknown Optimizer ${e}`)}function YT(e,t,n=!1){if(null==e||"object"!=typeof e||Object.getPrototypeOf(e)!==Object.prototype||!JT(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let n=JSON.stringify(e);n.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function JT(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if("string"!=typeof n||!JT(e[n]))return!1;return!0}if(Array.isArray(e)){for(let t of e)if(!JT(t))return!1;return!0}return!1}{let t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function ZT(e,t,n,r=console.log){let a,s=e_(e),i=["Layer (type)","Input Shape","Output shape","Param #"];if(s?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!s){i.push("Receives inputs"),a=[];for(let t in e.nodesByDepth)a.push(...e.nodesByDepth[t])}r("_".repeat(t)),t_(i,n,r),r("=".repeat(t));let o=e.layers;for(let c=0;c<o.length;++c)s?n_(o[c],n,r):r_(o[c],n,a,r),r((c===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let l=QT(e),u=HS(e.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}function QT(e){let t;return t=null!=e.collectedTrainableWeights?HS(e.collectedTrainableWeights):HS(e.trainableWeights),t}function e_(e){let t=!0,n=[],r=[];for(let a in e.nodesByDepth)n.push(e.nodesByDepth[a]);for(let a of n){if(a.length>1||1===a.length&&a[0].inboundLayers.length>1){t=!1;break}r.push(...a)}if(t)for(let a of e.layers){let e=!1;for(let n of a.inboundNodes)if(-1!==r.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}function t_(e,t,n=console.log){let r="";for(let a=0;a<e.length;++a)a>0&&(r=r.slice(0,r.length-1)+" "),r+=e[a],r=r.slice(0,t[a]),r+=" ".repeat(t[a]-r.length);n(r)}function n_(e,t,n){let r,a;try{a=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(l){a="multiple"}try{r=JSON.stringify(e.outputShape)}catch(l){r="multiple"}let s=e.name,i=e.getClassName(),o=[`${s} (${i})`,a,r,e.countParams().toString()];t_(o,t,n)}function r_(e,t,n,r){let a,s;try{s=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(p){s="multiple"}try{a=JSON.stringify(e.outputShape)}catch(p){a="multiple"}let i=[];for(let d of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(d)))for(let e=0;e<d.inboundLayers.length;++e){let t=d.inboundLayers[e].name,n=d.nodeIndices[e],r=d.tensorIndices[e];i.push(`${t}[${n}][${r}]`)}let o=e.name,l=e.getClassName(),u=0===i.length?"":i[0],c=[`${o} (${l})`,s,a,e.countParams().toString(),u];t_(c,t,r);for(let d=1;d<i.length;++d)t_(["","","","",i[d]],t,r)}function a_(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function s_(e,t){if(null===e)return null;if("string"==typeof e)return rI(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let r=e[a];a_(t,a,r)?n.push(r):n.push(s_(r,t))}return n}{let t={};for(let n of Object.keys(e)){let r=e[n];if("name"===n&&"string"==typeof r)t[n]=r;else{let e=rI(n);t[e]=s_(r,e)}}return t}}function i_(e,t){if(null==e)return null;if("string"==typeof e)return nI(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){let n=[],r=e.length;for(let a=0;a<r;++a){let r=e[a];a_(t,a,r)?n.push(r):n.push(i_(r,t))}return n}{let t={};for(let n of Object.keys(e)){let r=e[n],a=nI(n);t[a]="name"!==n&&"className"!==n||"string"!=typeof r?i_(r,n):r}return t}}var o_="3.18.0",l_=class extends nN{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){let e=this.getClassName().toLowerCase();this.name=vI(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],cI(this.inputs).length!==this.inputs.length)throw new qk(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((e=>e.name))}`);cI(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((e=>e.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let y of this.outputs){let e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;this.outputLayers.push(e),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(n)}for(let y of this.inputs){let e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;Zk(0===t,"input layer has >1 nodes"),Zk(0===n,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(t),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){let t=this.inputLayers[y];if(!(t instanceof iN))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${y} (0-based) originates from layer type ${t.getClassName()}.`);this.inputNames.push(t.name),this.feedInputShapes.push(t.batchInputShape),this.feedInputNames.push(t.name)}for(let y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));let t={},n={},r={},a={},s={},i=[],o=(e,t,n,r,a,l)=>{(null==r||null==a||null==l)&&(r=e.sourceLayer,a=e.nodeIndex,l=e.tensorIndex);let u=r.inboundNodes[a];if(-1!==n.indexOf(u))throw new jk(`The tensor ${e.name} at layer "${r.name}" is part of a cycle.`);if(-1!==t.indexOf(u))return;this.containerNodes.add(l_.nodeKey(r,a)),r.id in s||(s[r.id]=Object.keys(s).length),-1===n.indexOf(u)&&n.push(u);let c=u.inboundLayers.length;for(let s=0;s<c;s++){let e=u.inputTensors[s],r=u.inboundLayers[s],a=u.nodeIndices[s],i=u.tensorIndices[s];o(e,t,n,r,a,i)}for(t.push(u);n.indexOf(u)>=0;)n.splice(n.indexOf(u),1);i.push(u)},l=[],u=[];for(let y of this.outputs)o(y,l,u);let c=i.slice().reverse();for(let y of c){n[y.id]=y,y.id in t||(t[y.id]=0);let e=t[y.id],s=null==r[y.outboundLayer.id]?0:r[y.outboundLayer.id];e=Math.max(e,s),r[y.outboundLayer.id]=e,a[y.outboundLayer.id]=y.outboundLayer,t[y.id]=e;for(let r=0;r<y.inboundLayers.length;r++){let a=y.inboundLayers[r],s=y.nodeIndices[r],i=a.inboundNodes[s],o=null==t[i.id]?0:t[i.id];t[i.id]=Math.max(e+1,o),n[i.id]=i}}let p={};for(let y in t){let e=t[y];e in p||(p[e]=[]),p[e].push(n[y])}let d={};for(let y in r){let e=r[y];e in d||(d[e]=[]),d[e].push(a[y])}let h=Object.keys(d).map((e=>parseInt(e,10))).sort(uI);this.layers=[];for(let y of h){let e=d[y];e.sort(((e,t)=>{let n=s[e.id],r=s[t.id];return n<r?-1:n>r?1:0}));for(let t of e)t instanceof l_&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=d,h=Object.keys(p).map((e=>parseInt(e,10))).sort(uI);let f=this.inputs.slice(),m=[];for(let y of h)for(let e of p[y]){let t=e.outboundLayer;if(null!=t){for(let n of e.inputTensors)if(-1===f.indexOf(n))throw new jk(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${t.name}". The following previous layers were accessed without issue: ${m}`);for(let t of e.outputTensors)f.push(t);m.push(t.name)}}this.nodesByDepth=p;let g=this.layers.map((e=>e.name));for(let y of g){let e=g.filter((e=>e===y)).length;if(1!==e)throw new jk(`The name "${y}" is used ${e} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new eN({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(let t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(let t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new qk("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(let t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){let n={},r=0;for(let s of this.layers)for(let e of s.weights){if(null!=n[e.originalName])throw new qk(`Duplicate weight name: ${e.originalName}`);n[e.originalName]=e,r++}let a=[];for(let s in e){let r=s;if(null==n[s]){let e=s.split("/");r=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[r])a.push([n[r],e[s]]);else if(t)throw new qk(`Provided weight data has no target variable: ${s}`);delete n[r]}if(t){let e=[];for(let t in n)e.push(t);if(e.length>0)throw new qk(`${e.length} of ${r} weights are not set: ${e}`)}YS(a)}updatedConfig(){let e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${o_}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){let n=i_(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return ul((()=>{e=tI(e);let n=new uN;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return hN(this.outputs,n,t)}))}computeMask(e,t){return ul((()=>{let n;return e=tI(e),n=null==t?Jk(null,e.length):tI(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){let t=VS(e);if(t.length!==this.inputLayers.length)throw new qk(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);let n={};for(let i=0;i<t.length;i++){let e=this.inputLayers[i],r=t[i],a=e.name+"_0_0";n[a]=r}let r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(uI);if(r.length>1)for(let i of r){let e=this.nodesByDepth[i];for(let t of e){let e=t.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(e.id))continue;let r=[];for(let o=0;o<t.inboundLayers.length;o++){let e=t.inboundLayers[o],a=t.nodeIndices[o],s=t.tensorIndices[o],i=`${e.name}_${a}_${s}`,l=n[i];r.push(l)}let a=e.computeOutputShape(eI(r)),s=VS(a),i=e.inboundNodes.indexOf(t);for(let t=0;t<s.length;t++){let r=`${e.name}_${i}_${t}`;n[r]=s[t]}}}let a=[],s=[];for(let i=0;i<this.outputLayers.length;i++){let e=this.outputLayers[i],t=this.outputLayersNodeIndices[i],n=this.outputLayersTensorIndices[i],r=`${e.name}_${t}_${n}`;s.push(r)}for(let i=0;i<s.length;i++){let e=s[i];Zk(e in n),a.push(n[e])}return eI(a)}runInternalGraph(e,t){null==t&&(t=Jk(null,e.length));let n={};for(let o=0;o<this.inputs.length;++o){let r=this.inputs[o],a=e[o],s=t[o];n[r.id]=[a,s]}let r=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(uI);for(let o of r){let e=this.nodesByDepth[o];for(let t of e){let e=t.outboundLayer,r=t.inputTensors,a=t.outputTensors,s=new Array;for(let t of r)t.id in n&&s.push(n[t.id]);if(s.length===r.length){let r,i,o,l,u={};if(null!=t.callArgs&&(u=t.callArgs),1===s.length){let[t,n]=s[0];null==u.mask&&(u.mask=n),o=tI(e.call(t,u)),l=tI(e.computeMask(t,n)),r=[t],i=[n]}else r=s.map((e=>e[0])),i=s.map((e=>e[1])),null==u.mask&&(u.mask=i),o=tI(e.call(r,u)),l=tI(e.computeMask(r,i));if(e.activityRegularizer)throw new Kk("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<a.length;++e){let t=a[e],r=o[e],s=l[e];n[t.id]=[r,s]}}}}let a=[],s=[],i=[];for(let o of this.outputs){Zk(o.id in n,`Could not compute output ${o.name} : ${o.id}`);let[e,t]=n[o.id];i.push(e.shape),a.push(e),s.push(t)}return[a,s,i]}buildNodeConversionMap(e){let t,n={};for(let r of this.layers){t=r instanceof l_?1:0;for(let e=0;e<r.inboundNodes.length;e++){let a=l_.nodeKey(r,e);this.containerNodes.has(a)&&(n[a]=t,t+=1)}}return n}getLayer(e,t){if(null!=t){if(this.layers.length<=t)throw new qk(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}if(null==e)throw new qk("Provide either a layer name or layer index");for(let n of this.layers)if(n.name===e)return n;throw new qk(`No such layer: ${e}`)}calculateLosses(){return ul((()=>{let e=[];for(let t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){let r=l_.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e}))}getConfig(){let e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(let i of this.layers){let e=i.getClassName(),r=i.getConfig(),a=[];for(let n=0;n<i.inboundNodes.length;n++){let e=i.inboundNodes[n],r=l_.nodeKey(i,n),o={};if(this.containerNodes.has(r)){if(e.callArgs)try{JSON.stringify(e.callArgs),o=e.callArgs}catch(s){console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${e.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),o={}}if(e.inboundLayers.length>0){let n=[];for(let r=0;r<e.inboundLayers.length;r++){let a=e.inboundLayers[r],s=e.nodeIndices[r],i=e.tensorIndices[r],l=l_.nodeKey(a,s),u=t[l];null==u&&(u=0),n.push([a.name,u,i,o])}a.push(n)}}}let o={};o.name=i.name,o.className=e,o.config=r,o.inboundNodes=a,n.push(o)}e.layers=n;let r=[];for(let i=0;i<this.inputLayers.length;i++){let e=this.inputLayers[i],n=this.inputLayersNodeIndices[i],a=l_.nodeKey(e,n);if(!this.containerNodes.has(a))continue;let s=t[a];null==s&&(s=0);let o=this.inputLayersTensorIndices[i];r.push([e.name,s,o])}e.inputLayers=r;let a=[];for(let i=0;i<this.outputLayers.length;i++){let e=this.outputLayers[i],n=this.outputLayersNodeIndices[i],r=l_.nodeKey(e,n);if(!this.containerNodes.has(r))continue;let s=t[r];null==s&&(s=0);let o=this.outputLayersTensorIndices[i];a.push([e.name,s,o])}return e.outputLayers=a,e}static fromConfig(e,t,n={},r=!1){let a={},s={};function i(e,t){e.name in s?s[e.name].push(t):s[e.name]=[t]}function o(e,t){let n,r=[];for(let s of t){let o=s[0],l=s[1],u=s[2];if(n=null==s[3]?{}:s[3],!(o in a))return void i(e,t);let c=a[o];if(c.inboundNodes.length<=l)return void i(e,t);let p=c.inboundNodes[l];r.push(p.outputTensors[u])}r.length>0&&e.apply(eI(r),n)}function l(e){let n=e.name,s=uT(e,null!=t.customObjects?t.customObjects:{});s.setFastWeightInitDuringBuild(r),a[n]=s,e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new qk(`Corrupted configuration, expected array for nodeData: ${e}`);i(s,e)}))}let u=t.name,c=t.layers;for(let m of c)l(m);for(;!pI(s);)for(let e of c){let t=a[e.name];if(t.name in s){let e=s[t.name];delete s[t.name];for(let n of e)o(t,n)}}let p=[],d=[],h=t.inputLayers;for(let m of h){let e=m[0],t=m[1],n=m[2];Zk(e in a);let r=a[e].inboundNodes[t].outputTensors;p.push(r[n])}let f=t.outputLayers;for(let m of f){let e=m[0],t=m[1],n=m[2];Zk(e in a);let r=a[e].inboundNodes[t].outputTensors;d.push(r[n])}return new e({inputs:p,outputs:d,name:u})}get stateful(){if(this._stateful)throw new qk("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let e of this.layers)if(e.stateful)return!0;return!1}resetStates(){ul((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}};function u_(e,t,n){let r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===r)return Array.isArray(e)&&1===e.length?e:"object"==typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){let n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function c_(e,t){return u_(e,t,"classWeight")}async function p_(e,t,n,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){let t=ul((()=>{if(1===e.shape.length)return bo(e);if(2===e.shape.length){if(e.shape[1]>1)return sc(e,1);if(1===e.shape[1])return Lc(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),r=Array.from(await t.data());cl(t);let a=[];return r.forEach((e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);a.push(n[e])})),_g(a,"float32")}return null}function d_(e,t){return Hu(e,t)}var h_=32;function f_(e,t){let n,r,a=t;n=a.xs,r=a.ys,Na.assert(null!=n&&null!=r,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`));let s=m_("input",e.inputNames,n),i=m_("output",e.outputNames,r),o=s[0].shape[0];Na.assert(s.length===e.inputs.length,(()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`)),Na.assert(i.length===e.outputs.length,(()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`));for(let l=0;l<s.length;l++)Na.assert(s[l].shape[0]===o,(()=>`Batch size mismatch: input ${e.inputNames[l]} has ${s[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));for(let l=0;l<i.length;l++)Na.assert(i[l].shape[0]===o,(()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));return{xs:s,ys:i}}function m_(e,t,n){if(n instanceof ys)return[n];if(Array.isArray(n))return Na.assert(n.length===t.length,(()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`)),n;{let r=[];for(let a of t){if(null==n[a])throw new qk(`The feature data generated by the dataset lacks the required ${e} key '${a}'.`);r.push(n[a])}return r}}function g_(e){if(3===e.length)throw new Kk("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}async function y_(e,t,n){let r=null!=n.batchesPerEpoch;if(Na.assert(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),Na.assert(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),Na.assert(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),Na.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),Na.assert(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let a,s,i=null!=n.validationData;if(i)if(w_(n.validationData))Na.assert(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{let e=g_(n.validationData);a=e.xs,s=e.ys}let o,l=e.makeTrainFunction(),u=e.getDedupedMetricsNames();o=i?u.slice().concat(u.map((e=>"val_"+e))):u.slice();let c=iT(n.callbacks,n.yieldEvery),p=null==n.verbose?1:n.verbose,{callbackList:d,history:h}=lT(c,p,n.epochs,null,null,b_(t,n),null,i,o);d.setModel(e),e.history=h,await d.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){let o={};await d.onEpochBegin(f);let c=0,p=0;for(r||(m=await t.iterator());!r||c<n.batchesPerEpoch;){let t=await m.next();if(r&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=t.value){let{xs:r,ys:a}=f_(e,t.value),s={};s.batch=p,s.size=r[0].shape[0],await d.onBatchBegin(p,s);let i=[];if(null!=n.classWeight){let t=c_(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)i.push(await p_(a[e],null,t[e]))}let o=r.concat(a).concat(i),h=l(o);cl(o);for(let e=0;e<u.length;++e){let t=u[e],n=h[e];s[t]=n,pl(n)}await d.onBatchEnd(p,s),QN(s),p++,c++}if(r?c>=n.batchesPerEpoch:t.done){if(i){let t;t=w_(n.validationData)?tI(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):tI(e.evaluate(a,s,{batchSize:null==n.validationBatchSize?h_:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)o[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await d.onEpochEnd(f,o),f++,e.stopTraining_)break}return await d.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function b_(e,t){let n=null;return null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function w_(e){return"function"==typeof e.iterator}function x_(e){return"function"==typeof e.next}async function v_(e,t,n){n=n||{};let r=null!=n.batches,a=e.testFunction,s=[];if(n.verbose>0)throw new Kk("Verbose mode is not implemented yet.");Na.assert(!r||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));let i=x_(t)?t:await t.iterator(),o=0,l=0;for(;!r||l<n.batches;){let t=await i.next();if(s=ul((()=>{if(t.value){let{xs:n,ys:r}=f_(e,t.value),i=n.concat(r),u=ul((()=>a(i)));if(cl(i),0===l)for(let e=0;e<u.length;++e)s.push(Md(0));let c=i[0].shape[0];for(let e=0;e<u.length;++e){let t=u[e],n=s[e];s[e]=ul((()=>zu(s[e],Hu(c,t)))),l>0&&cl(n)}cl(u),o+=c,++l}return s})),t.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<s.length;++u){let e=s[u];s[u]=Uu(s[u],o),cl(e)}return eI(s)}function k_(e){Na.assert(e>0&&Number.isInteger(e),(()=>`batchSize is required to be a positive integer, but got ${e}`))}function I_(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>QI(e,t,n-t))):QI(e,t,n-t)}function S_(e,t){return ul((()=>null==e?null:Array.isArray(e)?e.map((e=>S_(e,t))):oS(e,"int32"===t.dtype?t:go(t,"int32"))))}function N_(e,t){let n=[],r=0,a=null;for(;r<e;)a=r+t,a>=e&&(a=e),n.push([r,a]),r=a;return n}async function T_(e,t,n,r,a,s,i,o,l,u,c,p,d,h,f){null==a&&(a=32),null==s&&(s=1),null==c&&(c=!0),null==d&&(d=0);let m=!1;if(null!=l&&null!=u&&(m=!0),null!=f&&(m=!0,null==h))throw new qk("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let g,y=e.checkNumSamples(n,a,h,"steps_per_epoch");null!=y&&(g=HI(0,y)),null==i&&(i=1);let{callbackList:b,history:w}=lT(o,i,s,d,y,h,a,m,p);b.setModel(e),e.history=w,await b.onTrainBegin(),e.stopTraining_=!1;for(let x=d;x<s;++x){await b.onEpochBegin(x);let s={};if(null!=h)throw new Kk("stepsPerEpoch mode is not implemented yet.");{if("batch"===c)throw new Kk("batch shuffling is not implemneted yet");c&&Na.shuffle(g);let i=_g(g),o=N_(y,a);for(let c=0;c<o.length;++c){let p={};if(await b.onBatchBegin(c,p),ul((()=>{let d=o[c][0],h=o[c][1],f=QI(i,d,h-d);p.batch=c,p.size=h-d;let g=S_(n,f),y=t(g);for(let e=0;e<r.length;++e){let t=r[e],n=y[e];p[t]=n,pl(n)}if(c===o.length-1&&m){let t=e.testLoop(l,u,a);for(let e=0;e<r.length;++e){let n=r[e],a=t[e];pl(a),s["val_"+n]=a}}})),await b.onBatchEnd(c,p),QN(p),e.stopTraining_)break}i.dispose()}if(await b.onEpochEnd(x,s),e.stopTraining_)break}return await b.onTrainEnd(),await e.history.syncData(),e.history}async function __(e,t,n,r={}){if(e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let a,s,i,o,l,u,c,p,d;e.isTraining=!0;try{let h=null==r.batchSize?32:r.batchSize;k_(h);let f=!1,m=await e.standardizeUserData(t,n,r.sampleWeight,r.classWeight,f,h);a=m[0],s=m[1],d=m[2];let g,y=!1;if(null!=r.validationData&&r.validationData.length>0){if(y=!0,2!==r.validationData.length)throw 3===r.validationData.length?new Kk("validationData including sample weights is not supported yet."):new qk(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);l=r.validationData[0],u=r.validationData[1];let t=!0,n=await e.standardizeUserData(l,u,null,null,t,h);c=n[0],p=n[1],g=c.concat(p)}else if(null!=r.validationSplit&&r.validationSplit>0&&r.validationSplit<1){y=!0;let e=Math.floor(a[0].shape[0]*(1-r.validationSplit)),t=a[0].shape[0];c=I_(a,e,t),i=a,a=I_(a,0,e),p=I_(s,e,t),o=s,s=I_(s,0,e),g=c.concat(p)}else null!=r.validationSteps&&(y=!0);let b=a.concat(s).concat(d);e.checkTrainableWeightsConsistency();let w,x,v=e.makeTrainFunction(),k=e.getDedupedMetricsNames();y?(e.makeTestFunction(),w=e.testFunction,x=k.slice().concat(k.map((e=>"val_"+e)))):(w=null,g=[],x=k.slice());let I=iT(r.callbacks,r.yieldEvery);return await T_(e,v,b,k,h,r.epochs,r.verbose,I,w,g,r.shuffle,x,r.initialEpoch,null,null)}finally{e.isTraining=!1,E_(a,t),E_(s,n),E_(i,t),E_(o,n),E_(c,l),E_(p,u),null!=d&&cl(d)}}function C_(e){let t=[];e instanceof ys&&(e=[e]);for(let n=0;n<e.length;++n){let r=e[n];if(1===r.rank)t.push(XI(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function E_(e,t){if(null==e)return;let n=[];if(t instanceof ys)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(let a in t){let e=t[a];n.push(e.id)}let r=[];if(e instanceof ys)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&r.push(e)}));else if(null!=e)for(let a in e){let t=e[a];-1===n.indexOf(t.id)&&r.push(t)}r.forEach((e=>{e.isDisposed||e.dispose()}))}function A_(e){return e instanceof ys}function $_(e){return Array.isArray(e)}function F_(e){return!A_(e)&&!$_(e)}function R_(e,t,n,r=!0,a=""){if(null==t||0===t.length){if(null!=e){let t=!1;if($_(e)&&e.length>0)t=!0;else if(F_(e)){for(let n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new qk(`Error when checking model ${a} expected no data, but got ${e}`)}return[]}if(null==e)return t.map((e=>null));let s;if(F_(e)){s=[];for(let n of t){if(null==e[n])throw new qk(`No data provided for "${n}". Need data for each key in: ${t}`);s.push(e[n])}}else if($_(e)){if(e.length!==t.length)throw new qk(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);s=e}else{if(t.length>1)throw new qk(`The model ${a} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);s=[e]}if(s=C_(s),null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;let e=s[i];if(e.shape.length!==n[i].length)throw new qk(`Error when checking ${a}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${e.shape}`);for(let t=0;t<n[i].length;++t){if(0===t&&!r)continue;let s=e.shape[t],o=n[i][t];if(null!=o&&o>=0&&s!==o)throw new qk(`${a} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${a} received an input with ${e.shape[0]} examples, each with shape [${e.shape.slice(1,e.shape.length)}] (tensor shape [${e.shape}])`)}}return s}function D_(e,t,n){let r=cI(e.map((e=>e.shape[0])));r.sort();let a=cI(t.map((e=>e.shape[0])));if(a.sort(),r.length>1)throw new qk(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((e=>e.shape)))}`);if(a.length>1)throw new qk(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((e=>e.shape)))}`);if(r.length>0&&a.length>0&&!Na.arraysEqual(r,a))throw new qk(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${a[0]} target sample(s).`)}function M_(e,t,n){let r=[pT,kT,wT];for(let a=0;a<e.length;++a){let s=e[a],i=t[a],o=n[a];if(null!=i){if(i===wT&&1===s.shape[s.shape.length-1])throw new qk(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){let e=s.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){let r=e[n],a=t[n];if(null!=a&&r!==a)throw new qk(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function O_(e,t,n,r=!0,a=""){let s;if(Array.isArray(e)){if(e.length!==t.length)throw new qk(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);s=e}else{if(t.length>1)throw new qk(`The model expects ${t.length} ${a} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);s=[e]}if(null!=n)for(let i=0;i<t.length;++i){if(null==n[i])continue;let e=s[i];if(e.shape.length!==n[i].length)throw new qk(`Error when checking ${a}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(e.shape)}`);for(let s=0;s<n[i].length;++s){if(0===s&&!r)continue;let o=e.shape[s],l=n[i][s];if(null!=l&&l!==o)throw new qk(`Error when checking ${a}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(e.shape)}.`)}}}function L_(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"==typeof e||"function"==typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!=typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map((e=>n));{let e=[];for(let r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}var P_="layers-model",z_=class extends l_{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new qk("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");ZT(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=XT(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof bw))throw new qk("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new qk(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map((e=>_T(e)))}else{let n=_T(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(let t in e.loss)if(-1===this.outputNames.indexOf(t))throw new qk(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(let n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(_T(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){let e=this.internalOutputShapes[s],t=this.outputNames[s];this.feedOutputNames.push(t),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[s])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],DI("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;let t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));let r=L_(e.metrics,this.outputNames),a=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};DI("metric",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;let t=r[e];(t=>{let n,r,s,i="";for(let o of t){if("string"==typeof o&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(o)){let t,a=this.internalOutputShapes[e];1===a[a.length-1]||this.lossFunctions[e]===kT?-1!==["accuracy","acc"].indexOf(o)?r=CT:-1!==["crossentropy","ce"].indexOf(o)&&(r=MT):this.lossFunctions[e]===xT?-1!==["accuracy","acc"].indexOf(o)?r=OT:-1!==["crossentropy","ce"].indexOf(o)&&(r=HT):-1!==["accuracy","acc"].indexOf(o)?r=ET:-1!==["crossentropy","ce"].indexOf(o)&&(r=UT),-1!==["accuracy","acc"].indexOf(o)?t="acc":-1!==["crossentropy","ce"].indexOf(o)&&(t="ce"),s=r,n=i+t}else s=qT(o),n=i+KT(o);let t;DI(n,(()=>{t=s})),a(e,n,t)}})(t)}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){let r=null==n.batchSize?32:n.batchSize;k_(r);let a=!0,s=this.standardizeUserDataXY(e,t,a,r);try{let a=s[0].concat(s[1]);this.makeTestFunction();let i=this.testFunction,o=this.testLoop(i,a,r,n.verbose,n.steps);return eI(o)}finally{E_(s[0],e),E_(s[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),v_(this,e,t)}checkNumSamples(e,t,n,r="steps"){let a;if(null!=n){if(a=null,null!=t)throw new qk(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new qk(`Either the input data should have a defined shape, or ${r} shoud be specified.`);a=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return a}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new qk("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),r=n?t:[t],a=this.retrieveSymbolicTensors(r),s=new uN;if(e instanceof ys&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new qk(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)s.add(this.inputs[t],e[t])}else for(let o of this.inputs){let t=e[o.name];if(null==t)throw new qk(`No value is provided for the model's input ${o.name}`);s.add(o,t)}let i=hN(a,s);return n?i:i[0]}retrieveSymbolicTensors(e){let t=Jk(null,e.length),n=e.length;for(let r of this.layers){let a=Array.isArray(r.output)?r.output:[r.output],s=a.map((e=>e.name));for(let r=0;r<e.length;++r){let i=s.indexOf(e[r]);if(-1!==i&&(t[r]=a[i],n--),0===n)break}if(0===n)break}if(n>0){let n=[];throw t.forEach(((t,r)=>{null==t&&n.push(e[r])})),new qk(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e,t=32,n=!1){return ul((()=>{let r=this.checkNumSamples(e);if(n)throw new Kk("Verbose predictLoop() is not implemented yet.");let a=N_(r,t),s=this.outputs.map((e=>[]));for(let t=0;t<a.length;++t)ul((()=>{let n=a[t][0],r=a[t][1],s=I_(e,n,r),i=[];if(Array.isArray(s))for(let e=0;e<s.length;++e)i.push({key:this.inputs[e],value:s[e]});else i.push({key:this.inputs[0],value:s});let o=new uN(i);return hN(this.outputs,o)})).forEach(((e,t)=>s[t].push(e)));return eI(s.map((e=>Uc(e,0))))}))}predict(e,t={}){let n=C_(e);O_(n,this.inputNames,this.feedInputShapes,!1);try{let r=null==t.batchSize?32:t.batchSize;return k_(r),this.predictLoop(n,r)}finally{E_(n,e)}}predictOnBatch(e){O_(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(null==this.optimizer_)throw new jk("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let a=[];for(let s=0;s<this.feedOutputShapes.length;++s){let e=this.feedOutputShapes[s];this.feedLossFns[s]===xT?a.push(e.slice(0,e.length-1).concat([1])):a.push(e)}if(e=R_(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=R_(t,this.feedOutputNames,a,!1,"target"),D_(e,t,null),M_(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=r&&r>0&&e[0].shape[0]%r!==0)throw new qk(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,a=!0,s){let[i,o]=this.standardizeUserDataXY(e,t,a,s);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){let e=c_(r,this.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(await p_(o[t],null,e[t]))}return[i,o,l]}testLoop(e,t,n,r=0,a){return ul((()=>{let s=this.checkNumSamples(t,n,a,"steps"),i=[];if(r>0)throw new Kk("Verbose mode is not implemented yet.");if(null!=a)throw new Kk("steps mode in testLoop() is not implemented yet");{let r=N_(s,n),a=_g(HI(0,s));for(let n=0;n<r.length;++n){let s=r[n][0],o=r[n][1],l=QI(a,s,o-s),u=S_(t,l),c=e(u);if(0===n)for(let e=0;e<c.length;++e)i.push(Md(0));for(let e=0;e<c.length;++e){let t=c[e];i[e]=zu(i[e],Hu(o-s,t))}}for(let e=0;e<i.length;++e)i[e]=Uu(i[e],s)}return i}))}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let r=e[n],a=r;Qk(e,r)>1&&(a+=`_${Qk(e.slice(0,n),r)}`),t.push(a)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),s=[],i=()=>{let e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});let i,o=new uN(e),l=hN(this.outputs,o,{training:!0});for(let n=0;n<this.lossFunctions.length;++n){let e=this.lossFunctions[n](r[n],l[n]);null!=a[n]&&(e=d_(e,a[n]));let s=gf(e);t.push(s),i=0===n?e:zu(i,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{let t=this.metricsTensors[n][0],a=this.metricsTensors[n][1];e=gf(t(r[a],l[a]))}pl(e),s.push(e)}return i=gf(i),this.calculateLosses().forEach((e=>{i=zu(i,e)})),i},o=this.collectedTrainableWeights.map((e=>e.read())),l=!0;return[this.optimizer_.minimize(i,l,o)].concat(s)}}makeTestFunction(){this.testFunction=e=>ul((()=>{let t,n=[],r=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let e=0;e<this.inputs.length;++e)s.push({key:this.inputs[e],value:r[e]});let i=new uN(s),o=hN(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){let r=this.lossFunctions[e],s=gf(r(a[e],o[e]));t=0===e?s:zu(t,s),n.push(t)}for(let e=0;e<this.metricsTensors.length;++e){let t=this.metricsTensors[e][0],r=this.metricsTensors[e][1],s=gf(t(a[r],o[r]));n.push(s)}return n}))}async fit(e,t,n={}){return __(this,e,t,n)}async fitDataset(e,t){return y_(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),r=n[0],a=n[1],s=this.makeTrainFunction()(r.concat(a)),i=[];for(let o of s){let e=await o.data();i.push(e[0])}return cl(s),E_(n[0],e),E_(n[1],t),eI(i)}getNamedWeights(e){let t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,a=this.getWeights(n);for(let s=0;s<r.length;++s)n&&!r[s].trainable||t.push({name:r[s].originalName,tensor:a[s]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){let t=ol().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-ol().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=nI(this.loss);else if(Array.isArray(this.loss)){for(let e of this.loss)if("string"!=typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>nI(e)))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let r of t){if("string"!=typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=nI(n[r])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[nI(KT(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>nI(KT(e))));{let e={};for(let t in this.metrics)e[t]=nI(KT(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");let t,n,r=s_(e.optimizer_config),a=uT(r);if("string"==typeof e.loss)t=rI(e.loss);else if(Array.isArray(e.loss))t=e.loss.map((e=>rI(e)));else if(null!=e.loss){t={};for(let n in e.loss)t[n]=rI(e.loss[n])}if(Array.isArray(e.metrics))n=e.metrics.map((e=>rI(e)));else if(null!=e.metrics){n={};for(let t in e.metrics)n[t]=rI(e.metrics[t])}this.compile({loss:t,metrics:n,optimizer:a})}async save(e,t){if("string"==typeof e){let t=vo.getSaveHandlers(e);if(0===t.length)throw new qk(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new qk(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new qk("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await vo.encodeWeights(this.getNamedWeights(t)),r=!1,a=null,s={modelTopology:this.toJSON(a,r),format:P_,generatedBy:`TensorFlow.js tfjs-layers v${o_}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){s.trainingConfig=this.getTrainingConfig();let e="optimizer",{data:t,specs:r}=await vo.encodeWeights(await this.optimizer.getWeights(),e);n.specs.push(...r),n.data=vo.concatenateArrayBuffers([n.data,t])}return null!=this.userDefinedMetadata&&(YT(this.userDefinedMetadata,this.name,!0),s.userDefinedMetadata=this.userDefinedMetadata),s.weightData=n.data,s.weightSpecs=n.specs,e.save(s)}setUserDefinedMetadata(e){YT(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};z_.className="Model",xu.registerClass(z_);var B_=class extends z_{};async function W_(e,t){"modelTopology"in e||(e={modelTopology:e});let n=e.modelTopology;null!=n.model_config&&(n=n.model_config);let r=s_(n),a=uT(r,t);if(null!=e.weightsManifest){let t=await vo.loadWeights(e.weightsManifest,e.pathPrefix,a.weights.map((e=>e.originalName))),n={};for(let e of a.weights)n[e.originalName]=t[e.originalName];a.loadWeights(n),cl(t)}return a}async function V_(e,t){if(null==t&&(t={}),"string"==typeof e){let n=vo.getLoadHandlers(e,t);if(0===n.length)n.push(vo.browserHTTPRequest(e,t));else if(n.length>1)throw new qk(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return U_(e,void 0,t)}async function U_(e,t,n){if(null==n&&(n={}),null==e.load)throw new qk("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let r=await e.load(),a=r.modelTopology;null!=a.model_config&&(a=a.model_config);let s=null==n.strict||n.strict,i=null!=r.weightData&&null!=r.weightSpecs&&s,o=uT(s_(a),t,i),l=r.trainingConfig;if(null!=l&&o.loadTrainingConfig(l),null!=r.userDefinedMetadata&&o.setUserDefinedMetadata(r.userDefinedMetadata),null!=r.weightData){if(null==r.weightSpecs)throw new qk("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:e,optimizerWeights:t}=G_(r.weightData,r.weightSpecs);o.loadWeights(e,s),null!=o.optimizer&&t.length>0&&await o.optimizer.setWeights(t),cl(e),cl(t.map((e=>e.tensor)))}return o}function G_(e,t){let n=vo.decodeWeights(e,t),r={},a=[];return t.forEach((e=>{"optimizer"===e.group?a.push({name:e.name,tensor:n[e.name]}):r[e.name]=n[e.name]})),{modelWeights:r,optimizerWeights:a}}B_.className="Functional",xu.registerClass(B_);var H_=class extends z_{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:vI("sequential_"),null!=e.layers)for(let t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new qk(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){let t,n=e instanceof H_||e instanceof z_;if(n){if(t=e,1!==t.outputs.length)throw new qk("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==t.inputs.length)throw new qk("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new qk("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let t=oN({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(n)this.outputs=t.outputs,this.inputs=t.inputs;else{if(1!==e.inboundNodes.length)throw new qk(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new qk("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=sN(this.outputs[0])}this.inboundNodes=[],new eN({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Jk(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{let t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(GS(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new z_({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new jk("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new jk("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new jk("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new jk("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,n={},r=!1){let a,s={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new qk("Legacy serialization format not supported yet.");a=t}else Na.assert(null!=t.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),a=t.layers,delete t.layers,s=t;let i=new e(s);if(!(i instanceof H_))throw new Kk(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(let o of a){let e=uT(o,void 0,r);r&&e.setFastWeightInitDuringBuild(!0),i.add(e)}return i}set stopTraining(e){if(null==this.model)throw new qk("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new qk("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let e=[];for(let t of this.layers){let n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}};function j_(e){return new z_(e)}function q_(e){return new H_(e)}function K_(e,t){return null==t&&(t={}),V_(e,t)}function X_(e){return oN(e)}function Y_(e,t){oT.registerCallbackConstructor(e,t)}H_.className="Sequential",xu.registerClass(H_);var J_=class extends xu.Serializable{getConfig(){return{}}},Z_=class extends J_{apply(e,t=1){return pS(e,t)}};Z_.className="elu",xu.registerClass(Z_);var Q_=class extends J_{apply(e){return Pm(e)}};Q_.className="selu",xu.registerClass(Q_);var eC=class extends J_{apply(e){return xm(e)}};eC.className="relu",xu.registerClass(eC);var tC=class extends J_{apply(e){return ul((()=>vf(6,xm(e))))}};tC.className="relu6",xu.registerClass(tC);var nC=class extends J_{apply(e){return e}};nC.className="linear",xu.registerClass(nC);var rC=class extends J_{apply(e){return Hc(e)}};rC.className="sigmoid",xu.registerClass(rC);var aC=class extends J_{apply(e){return fS(e)}};aC.className="hardSigmoid",xu.registerClass(aC);var sC=class extends J_{apply(e){return zh(e)}};sC.className="softplus",xu.registerClass(sC);var iC=class extends J_{apply(e){return dS(e)}};iC.className="softsign",xu.registerClass(iC);var oC=class extends J_{apply(e){return Xc(e)}};oC.className="tanh",xu.registerClass(oC);var lC=class extends J_{apply(e,t=-1){return ag(e,t)}};lC.className="softmax",xu.registerClass(lC);var uC=class extends J_{apply(e,t=-1){return Hh(e,t)}};uC.className="logSoftmax",xu.registerClass(uC);var cC=class extends J_{apply(e,t=1){return ul((()=>Hu(Hc(Hu(e,t)),e)))}};cC.className="swish",xu.registerClass(cC);var pC=class extends J_{apply(e){return ul((()=>Hu(e,Xc(zh(e)))))}};function dC(e){return e.getClassName()}function hC(e,t={}){return oI(e,xu.SerializationMap.getMap().classNameMap,t,"activation")}function fC(e){if(null==e){let e={className:"linear",config:{}};return hC(e)}if("string"==typeof e){let t={};return t.className=e,t.config={},hC(t)}return e instanceof J_?e:hC(e)}function mC(e){if(null!=e&&"object"!=typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}pC.className="mish",xu.registerClass(pC);var gC=class extends xu.Serializable{},yC=class extends gC{constructor(e){super(),mC(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return ul((()=>{let t=yf([1]);return this.hasL1&&(t=zu(t,Wd(Hu(this.l1,qu(e))))),this.hasL2&&(t=zu(t,Wd(Hu(this.l2,lS(e))))),Lc(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};function bC(e){return mC(e),new yC({l1:null!=e?e.l1:null,l2:0})}function wC(e){return mC(e),new yC({l2:null!=e?e.l2:null,l1:0})}yC.className="L1L2",xu.registerClass(yC);var xC={l1l2:"L1L2"};function vC(e){return sI(e)}function kC(e,t={}){return oI(e,xu.SerializationMap.getMap().classNameMap,t,"regularizer")}function IC(e){if(null==e)return null;if("string"==typeof e){let t={className:e in xC?xC[e]:e,config:{}};return kC(t)}return e instanceof gC?e:kC(e)}var SC=class extends nN{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=US(e);let n=xm(e);return null!=this.maxValue&&(n=bp(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};SC.className="ReLU",xu.registerClass(SC);var NC=class extends nN{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=US(e);return wh(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};NC.className="LeakyReLU",xu.registerClass(NC);var TC=class extends nN{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=BS(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=IC(e.alphaRegularizer),this.alphaConstraint=EN(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new qk(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){e=GS(e);let t=e.slice(1);if(null!=this.sharedAxes)for(let r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(null!=this.sharedAxes)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new JS({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=US(e),tm(e,this.alpha.read())}getConfig(){let e={alphaInitializer:zS(this.alphaInitializer),alphaRegularizer:vC(this.alphaRegularizer),alphaConstraint:_N(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};TC.className="PReLU",xu.registerClass(TC);var _C=class extends nN{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new Kk(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=US(e);return bd(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};_C.className="ELU",xu.registerClass(_C);var CC=class extends nN{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){let n=US(e);return Hu(n,go(uh(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};CC.className="ThresholdedReLU",xu.registerClass(CC);var EC=class extends nN{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new lC).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){let n=US(e);return this.softmax(n,this.axis)}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};function AC(e,t,n){if("number"==typeof e)return Jk(e,t);if(e.length!==t)throw new qk(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){let a=e[r];if(!WI(a))throw new qk(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${a}`)}return e}function $C(e,t,n,r,a=1){if(null==e)return e;let s,i=t+(t-1)*(a-1);return s="same"===n?e:e-i+1,Math.floor((s+r-1)/r)}function FC(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+GI([n-t,0]);else{if("same"!==r)throw new qk(`Unsupport padding mode: ${r}.`);e*=t}return e}function RC(e,t){return ul((()=>(CI(t),"channelsFirst"===t?El(e,[0,2,3,1]):e)))}function DC(e,t){return ul((()=>(CI(t),"channelsFirst"===t?El(e,[0,2,3,4,1]):e)))}function MC(e,t,n,r=1,a="valid",s,i=1){return ul((()=>{if(null==s&&(s=qI()),CI(s),3!==e.shape.length)throw new qk(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new qk(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new qk(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===s&&(e=El(e,[0,2,1])),"causal"===a)throw new Kk("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=Ap(e,t,r,"same"===a?"same":"valid","NWC",i);return null!=n&&(o=cS(o,n)),o}))}function OC(e,t,n,r=[1,1],a="valid",s,i,o=null){return ul((()=>{if(null==s&&(s=qI()),CI(s),3!==e.rank&&4!==e.rank)throw new qk(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new qk(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=RC(e,s);if("causal"===a)throw new Kk("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=py.conv2d({x:l,filter:t,strides:r,pad:"same"===a?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===s&&(l=El(l,[0,3,1,2])),l}))}function LC(e,t,n,r=[1,1,1],a="valid",s,i){return ul((()=>{if(null==s&&(s=qI()),CI(s),4!==e.rank&&5!==e.rank)throw new qk(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new qk(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=DC(e,s);if("causal"===a)throw new Kk("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=Op(o,t,r,"same"===a?"same":"valid","NDHWC",i),null!=n&&(o=cS(o,n)),"channelsFirst"===s&&(o=El(o,[0,4,1,2,3])),o}))}EC.className="Softmax",xu.registerClass(EC);var PC=class extends nN{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",PC.verifyArgs(t),this.rank=e,fI(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new Kk(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=AC(t.kernelSize,e,"kernelSize"),this.strides=AC(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,AI(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,CI(this.dataFormat),this.activation=fC(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=BS(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=EN(t.biasConstraint),this.biasRegularizer=IC(t.biasRegularizer),this.activityRegularizer=IC(t.activityRegularizer),this.dilationRate=AC(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new qk(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new qk(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new qk(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(Zk("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!hI(e.kernelSize,"number",1,3))throw new qk(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){let e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:dC(this.activation),useBias:this.useBias,biasInitializer:zS(this.biasInitializer),biasRegularizer:vC(this.biasRegularizer),activityRegularizer:vC(this.activityRegularizer),biasConstraint:_N(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}},zC=class extends PC{constructor(e,t){super(e,t),this.kernel=null,zC.verifyArgs(t),this.filters=t.filters,fI(this.filters,"filters"),this.kernelInitializer=BS(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=EN(t.kernelConstraint),this.kernelRegularizer=IC(t.kernelRegularizer)}build(e){e=GS(e);let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new qk(`The channel dimension of the input should be defined. Found ${e[t]}`);let n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return ul((()=>{e=US(e);let t,n=null==this.bias?null:this.bias.read(),r=yI(this.activation.getClassName());if(null!=r&&2===this.rank)t=OC(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=MC(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=OC(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new Kk("convolutions greater than 3D are not implemented yet.");t=LC(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=GS(e);let t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let a=0;a<n.length;++a){let e=$C(n[a],this.kernelSize[a],this.padding,this.strides[a],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[a]);t.push(e)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){let e={filters:this.filters,kernelInitializer:zS(this.kernelInitializer),kernelRegularizer:vC(this.kernelRegularizer),kernelConstraint:_N(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new qk(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}},BC=class extends zC{constructor(e){super(2,e),BC.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!hI(e.kernelSize,"number",1,2))throw new qk(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}};BC.className="Conv2D",xu.registerClass(BC);var WC=class extends zC{constructor(e){super(3,e),WC.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new qk(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}};WC.className="Conv3D",xu.registerClass(WC);var VC=class extends BC{constructor(e){if(super(e),this.inputSpec=[new JS({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new qk(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=GS(e),4!==e.length)throw new qk("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new qk("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new JS({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return ul((()=>{let t=US(e);if(4!==t.shape.length)throw new qk(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);let n,r,a=t.shape,s=a[0];"channelsFirst"===this.dataFormat?(n=2,r=3):(n=1,r=2);let i=a[n],o=a[r],l=this.kernelSize[0],u=this.kernelSize[1],c=this.strides[0],p=this.strides[1],d=FC(i,c,l,this.padding),h=FC(o,p,u,this.padding),f=[s,d,h,this.filters];"channelsLast"!==this.dataFormat&&(t=El(t,[0,2,3,1]));let m=Dp(t,this.kernel.read(),f,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(m=El(m,[0,3,1,2])),null!=this.bias&&(m=cS(m,this.bias.read(),this.dataFormat)),null!=this.activation&&(m=this.activation.apply(m)),m}))}computeOutputShape(e){e=GS(e);let t,n,r,a=e.slice();"channelsFirst"===this.dataFormat?(t=1,n=2,r=3):(t=3,n=1,r=2);let s=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return a[t]=this.filters,a[n]=FC(a[n],o,s,this.padding),a[r]=FC(a[r],l,i,this.padding),a}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};VC.className="Conv2DTranspose",xu.registerClass(VC);var UC=class extends WC{constructor(e){if(super(e),this.inputSpec=[new JS({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new qk(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=GS(e),5!==e.length)throw new qk("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new qk("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new JS({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return ul((()=>{let t=US(e);if(5!==t.shape.length)throw new qk(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);let n,r,a,s=t.shape,i=s[0];"channelsFirst"===this.dataFormat?(a=2,n=3,r=4):(a=1,n=2,r=3);let o=s[a],l=s[n],u=s[r],c=this.kernelSize[0],p=this.kernelSize[1],d=this.kernelSize[2],h=this.strides[0],f=this.strides[1],m=this.strides[2],g=FC(o,h,c,this.padding),y=FC(l,f,p,this.padding),b=FC(u,m,d,this.padding),w=[i,g,y,b,this.filters];"channelsLast"!==this.dataFormat&&(t=El(t,[0,2,3,4,1]));let x=Bp(t,this.kernel.read(),w,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(x=El(x,[0,4,1,2,3])),null!==this.bias&&(x=cS(x,this.bias.read(),this.dataFormat)),null!==this.activation&&(x=this.activation.apply(x)),x}))}computeOutputShape(e){e=GS(e);let t,n,r,a,s=e.slice();"channelsFirst"===this.dataFormat?(t=1,n=2,r=3,a=4):(t=4,n=1,r=2,a=3);let i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],c=this.strides[1],p=this.strides[2];return s[t]=this.filters,s[n]=FC(s[n],u,i,this.padding),s[r]=FC(s[r],c,o,this.padding),s[a]=FC(s[a],p,l,this.padding),s}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};UC.className="Conv3DTranspose",xu.registerClass(UC);var GC=class extends zC{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new qk("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new qk("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new qk(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=BS(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=IC(t.depthwiseRegularizer),this.depthwiseConstraint=EN(t.depthwiseConstraint),this.pointwiseInitializer=BS(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=IC(t.pointwiseRegularizer),this.pointwiseConstraint=EN(t.pointwiseConstraint)}build(e){if(e=GS(e),e.length<this.rank+2)throw new qk(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new qk(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),a=[];for(let i=0;i<this.rank;++i)a.push(1);a.push(n*this.depthMultiplier,this.filters);let s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new JS({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return ul((()=>{let t;if(e=US(e),1===this.rank)throw new Kk("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=El(e,[0,2,3,1])),t=Bm(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=cS(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=El(t,[0,3,1,2])),t}))}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=zS(this.depthwiseInitializer),e.pointwiseInitializer=zS(this.pointwiseInitializer),e.depthwiseRegularizer=vC(this.depthwiseRegularizer),e.pointwiseRegularizer=vC(this.pointwiseRegularizer),e.depthwiseConstraint=_N(this.depthwiseConstraint),e.pointwiseConstraint=_N(this.pointwiseConstraint),e}};GC.className="SeparableConv";var HC=class extends GC{constructor(e){super(2,e)}};HC.className="SeparableConv2D",xu.registerClass(HC);var jC=class extends zC{constructor(e){super(1,e),jC.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){let e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!hI(e.kernelSize,"number",1,1))throw new qk(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}};jC.className="Conv1D",xu.registerClass(jC);var qC=class extends nN{constructor(e){super(e),"number"==typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return ul((()=>{if(e=US(e),"channelsLast"===this.dataFormat){let t=tS(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return tS(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{let t=tS(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return tS(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};qC.className="Cropping2D",xu.registerClass(qC);var KC=class extends nN{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,CI(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,EI(this.interpolation)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){let t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{let t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return ul((()=>{let t=US(e),n=t.shape;if("channelsFirst"===this.dataFormat){t=El(t,[0,2,3,1]);let e=this.size[0]*n[2],r=this.size[1]*n[3],a="nearest"===this.interpolation?hw.resizeNearestNeighbor(t,[e,r]):hw.resizeBilinear(t,[e,r]);return El(a,[0,3,1,2])}{let e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?hw.resizeNearestNeighbor(t,[e,r]):hw.resizeBilinear(t,[e,r])}}))}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};function XC(e,t,n=[1,1],r="valid",a,s){return ul((()=>{null==a&&(a=qI()),CI(a);let i=RC(e,a);if(4!==e.rank)throw new qk(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new qk(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=ed(i,t,n,"same"===r?"same":"valid","NHWC",s),"channelsFirst"===a&&(i=El(i,[0,3,1,2])),i}))}KC.className="UpSampling2D",xu.registerClass(KC);var YC=class extends PC{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=BS(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=EN(e.depthwiseConstraint),this.depthwiseRegularizer=IC(e.depthwiseRegularizer)}build(e){if(e=GS(e),e.length<4)throw new qk(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new qk(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ul((()=>{e=US(e);let t=XC(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=cS(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=GS(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=$C(t,this.kernelSize[0],this.padding,this.strides[0]),s=$C(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,a,s]:[e[0],a,s,r]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=zS(this.depthwiseInitializer),e.depthwiseRegularizer=vC(this.depthwiseRegularizer),e.depthwiseConstraint=_N(this.depthwiseRegularizer),e}};function JC(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new qk("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function a(e){return null==e||Array.isArray(e)?e:[e]}return t=a(t),n=a(n),{inputs:e,initialState:t,constants:n}}function ZC(e,t,n,r=!1,a,s,i=!1,o=!1){return ul((()=>{let l=t.shape.length;if(l<3)throw new qk(`Input should be at least 3D, but is ${l}D.`);let u=[1,0].concat(HI(2,l));if(t=El(t,u),null!=s)throw new Kk("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=a&&(a=go(go(a,"bool"),"float32"),a.rank===l-1&&(a=Yd(a,-1)),a=El(a,u)),r&&(t=Sm(t,0),null!=a&&(a=Sm(a,0)));let c,p,d,h=[],f=n,m=t.shape[0],g=Wg(t);null!=a&&(p=Wg(a));for(let t=0;t<m;++t){let n=g[t],r=ul((()=>e(n,f)));if(null==a)c=r[0],f=r[1];else{let e=ul((()=>{let e=p[t],n=Uh(Mf(e),e),a=zu(Hu(r[0],e),Hu(f[0],n)),s=f.map(((t,a)=>zu(Hu(r[1][a],e),Hu(t,n))));return{output:a,newStates:s}}));c=e.output,f=e.newStates}o&&h.push(c)}return o&&(d=xg(h,1)),[c,d,f]}))}YC.className="DepthwiseConv2D",xu.registerClass(YC);var QC=class extends nN{constructor(e){let t;if(super(e),null==e.cell)throw new qk("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new oE({cells:e.cell}):e.cell,null==t.stateSize)throw new qk("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new JS({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return HI(0,e).map((e=>null))}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){WS(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);let n,r=t[0];if(n=this.returnSequences?[e[0],e[1],r]:[e[0],r],this.returnState){let r=[];for(let n of t)r.push([e[0],n]);return[n].concat(r)}return n}computeMask(e,t){return ul((()=>{Array.isArray(t)&&(t=t[0]);let e=this.returnSequences?t:null;if(this.returnState){let t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new Kk("Constants support is not implemented in RNN yet.");WS(e)&&(e=e[0]);let t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new JS({shape:[t,null,...n]});let r,a=[e[0]].concat(e.slice(2));if(this.cell.build(a),r=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!Na.arraysEqual(this.stateSpec.map((e=>e.shape[e.shape.length-1])),r))throw new qk(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=r.map((e=>new JS({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e,t=!1){ul((()=>{if(!this.stateful)throw new Hk("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape[0];if(null==n)throw new qk("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>yf([n,e]))):this.states_=[yf([n,this.cell.stateSize])];else if(null==e)cl(this.states_),null!=this.keptStates&&(cl(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>yf([n,e]))):this.states_[0]=yf([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new qk(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):cl(this.states_);for(let t=0;t<this.states_.length;++t){let r=e[t],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,s=[n,a];if(!Na.arraysEqual(r.shape,s))throw new qk(`State ${t} is incompatible with layer ${this.name}: expected shape=${s}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map((e=>pl(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});let a=JC(e,n,r,this.numConstants);e=a.inputs,n=a.initialState,r=a.constants;let s=[],i=[];if(null!=n){t.initialState=n,s=s.concat(n),this.stateSpec=[];for(let e of n)this.stateSpec.push(new JS({shape:e.shape}));i=i.concat(this.stateSpec)}if(null!=r&&(t.constants=r,s=s.concat(r),this.numConstants=r.length),s[0]instanceof ZS){let n=[e].concat(s),r=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=r;let o=super.apply(n,t);return this.inputSpec=a,o}return super.apply(e,t)}call(e,t){return ul((()=>{let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;e=US(e),null==a&&(a=this.stateful?this.states_:this.getInitialState(e));let s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==s)throw new qk(`RNN Layer has ${s} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let i={training:r},o=ZC(((e,t)=>{let n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]}),e,a,this.goBackwards,n,null,this.unroll,this.returnSequences),l=o[0],u=o[1],c=o[2];this.stateful&&this.resetStates(c,r);let p=this.returnSequences?u:l;return this.returnState?[p].concat(c):p}))}getInitialState(e){return ul((()=>{let t=yf(e.shape);return t=Wd(t,[1,2]),t=XI(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?aS(t,[1,e]):t)):this.cell.stateSize>1?[aS(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){let e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);let n=this.cell.getConfig();return this.getClassName()===QC.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign({},n,e,t)}static fromConfig(e,t,n={}){let r=t.cell,a=uT(r,n);return new e(Object.assign(t,{cell:a}))}};QC.className="RNN",xu.registerClass(QC);var eE=class extends nN{},tE=class extends eE{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,fI(this.units,"units"),this.activation=fC(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=BS(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=BS(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=BS(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=IC(e.kernelRegularizer),this.recurrentRegularizer=IC(e.recurrentRegularizer),this.biasRegularizer=IC(e.biasRegularizer),this.kernelConstraint=EN(e.kernelConstraint),this.recurrentConstraint=EN(e.recurrentConstraint),this.biasConstraint=EN(e.biasConstraint),this.dropout=UI([1,GI([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=UI([1,GI([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=GS(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ul((()=>{if(2!==e.length)throw new qk(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let r=null!=t.training&&t.training;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=lE({ones:()=>Mf(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=lE({ones:()=>Mf(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let a,s=this.dropoutMask,i=this.recurrentDropoutMask;a=iS(null!=s?Hu(e,s):e,this.kernel.read()),null!=this.bias&&(a=cS(a,this.bias.read())),null!=i&&(n=Hu(n,i));let o=zu(a,iS(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]}))}getConfig(){let e=super.getConfig(),t={units:this.units,activation:dC(this.activation),useBias:this.useBias,kernelInitializer:zS(this.kernelInitializer),recurrentInitializer:zS(this.recurrentInitializer),biasInitializer:zS(this.biasInitializer),kernelRegularizer:vC(this.kernelRegularizer),recurrentRegularizer:vC(this.recurrentRegularizer),biasRegularizer:vC(this.biasRegularizer),activityRegularizer:vC(this.activityRegularizer),kernelConstraint:_N(this.kernelConstraint),recurrentConstraint:_N(this.recurrentConstraint),biasConstraint:_N(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},e,t)}};tE.className="SimpleRNNCell",xu.registerClass(tE);var nE=class extends QC{constructor(e){e.cell=new tE(e),super(e)}call(e,t){return ul((()=>{null!=this.cell.dropoutMask&&(cl(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(cl(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return new e(t)}};nE.className="SimpleRNN",xu.registerClass(nE);var rE=class extends eE{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new qk("GRUCell does not support reset_after parameter set to true.");this.units=e.units,fI(this.units,"units"),this.activation=fC(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=fC(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=BS(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=BS(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=BS(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=IC(e.kernelRegularizer),this.recurrentRegularizer=IC(e.recurrentRegularizer),this.biasRegularizer=IC(e.biasRegularizer),this.kernelConstraint=EN(e.kernelConstraint),this.recurrentConstraint=EN(e.recurrentConstraint),this.biasConstraint=EN(e.biasConstraint),this.dropout=UI([1,GI([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=UI([1,GI([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=GS(e);let t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ul((()=>{if(2!==e.length)throw new qk(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=null!=t.training&&t.training,r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=lE({ones:()=>Mf(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=lE({ones:()=>Mf(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let a,s,i,o=this.dropoutMask,l=this.recurrentDropoutMask;0<this.dropout&&this.dropout<1&&(e=Hu(e,o[0]));let u=iS(e,this.kernel.read());this.useBias&&(u=cS(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Hu(r,l[0]));let c=this.recurrentKernel.read(),[p,d]=dg(c,[2*this.units,this.units],c.rank-1),h=iS(r,p),[f,m,g]=dg(u,3,u.rank-1),[y,b]=dg(h,2,h.rank-1);a=this.recurrentActivation.apply(zu(f,y)),s=this.recurrentActivation.apply(zu(m,b));let w=iS(Hu(s,r),d);i=this.activation.apply(zu(g,w));let x=zu(Hu(a,r),Hu(zu(1,Nl(a)),i));return[x,x]}))}getConfig(){let e=super.getConfig(),t={units:this.units,activation:dC(this.activation),recurrentActivation:dC(this.recurrentActivation),useBias:this.useBias,kernelInitializer:zS(this.kernelInitializer),recurrentInitializer:zS(this.recurrentInitializer),biasInitializer:zS(this.biasInitializer),kernelRegularizer:vC(this.kernelRegularizer),recurrentRegularizer:vC(this.recurrentRegularizer),biasRegularizer:vC(this.biasRegularizer),activityRegularizer:vC(this.activityRegularizer),kernelConstraint:_N(this.kernelConstraint),recurrentConstraint:_N(this.recurrentConstraint),biasConstraint:_N(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},e,t)}};rE.className="GRUCell",xu.registerClass(rE);var aE=class extends QC{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new rE(e),super(e)}call(e,t){return ul((()=>{null!=this.cell.dropoutMask&&(cl(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(cl(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}};aE.className="GRU",xu.registerClass(aE);var sE=class extends eE{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,fI(this.units,"units"),this.activation=fC(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=fC(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=BS(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=BS(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=BS(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=IC(e.kernelRegularizer),this.recurrentRegularizer=IC(e.recurrentRegularizer),this.biasRegularizer=IC(e.biasRegularizer),this.kernelConstraint=EN(e.kernelConstraint),this.recurrentConstraint=EN(e.recurrentConstraint),this.biasConstraint=EN(e.biasConstraint),this.dropout=UI([1,GI([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=UI([1,GI([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=GS(e);let n,r=e[e.length-1];if(this.kernel=this.addWeight("kernel",[r,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){let e=this.biasInitializer,r=this.units;n=new(t=class extends xS{apply(t,n){let a=e.apply([r]),s=(new kS).apply([r]),i=e.apply([2*r]);return rS(rS(a,s),i)}},t.className="CustomInit",t)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return ul((()=>{let n=null!=t.training&&t.training;if(3!==e.length)throw new qk(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1],a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=lE({ones:()=>Mf(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=lE({ones:()=>Mf(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let s,i,o,l,u=this.dropoutMask,c=this.recurrentDropoutMask;0<this.dropout&&this.dropout<1&&(e=Hu(e,u[0]));let p=iS(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=Hu(r,c[0])),p=zu(p,iS(r,this.recurrentKernel.read())),this.useBias&&(p=cS(p,this.bias.read()));let[d,h,f,m]=dg(p,4,p.rank-1);s=this.recurrentActivation.apply(d),i=this.recurrentActivation.apply(h),o=zu(Hu(i,a),Hu(s,this.activation.apply(f))),l=this.recurrentActivation.apply(m);let g=Hu(l,this.activation.apply(o));return[g,g,o]}))}getConfig(){let e=super.getConfig(),t={units:this.units,activation:dC(this.activation),recurrentActivation:dC(this.recurrentActivation),useBias:this.useBias,kernelInitializer:zS(this.kernelInitializer),recurrentInitializer:zS(this.recurrentInitializer),biasInitializer:zS(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:vC(this.kernelRegularizer),recurrentRegularizer:vC(this.recurrentRegularizer),biasRegularizer:vC(this.biasRegularizer),activityRegularizer:vC(this.activityRegularizer),kernelConstraint:_N(this.kernelConstraint),recurrentConstraint:_N(this.recurrentConstraint),biasConstraint:_N(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},e,t)}};sE.className="LSTMCell",xu.registerClass(sE);var iE=class extends QC{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new sE(e),super(e)}call(e,t){return ul((()=>{null!=this.cell.dropoutMask&&(cl(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(cl(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}};iE.className="LSTM",xu.registerClass(iE);var oE=class extends eE{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return ul((()=>{let n=e.slice(1),r=[];for(let e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();let a,s=[];for(let i=0;i<this.cells.length;++i){let o=this.cells[i];n=r[i],a=0===i?[e[0]].concat(n):[a[0]].concat(n),a=o.call(a,t),s.push(a.slice(1))}n=[];for(let e of s.slice().reverse())n.push(...e);return[a[0]].concat(n)}))}build(e){let t;WS(e)&&(e=e[0]),this.cells.forEach(((n,r)=>{DI(`RNNCell_${r}`,(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){let e=super.getConfig(),t=e=>({className:e.getClassName(),config:e.getConfig()}),n={cells:this.cells.map(t)};return Object.assign({},e,n)}static fromConfig(e,t,n={}){let r=[];for(let a of t.cells)r.push(uT(a,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return XS(e)}setWeights(e){let t=[];for(let n of this.cells){let r=n.weights.length,a=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],a[e]])}YS(t)}};function lE(e){let{ones:t,rate:n,training:r=!1,count:a=1,dropoutFunc:s}=e,i=()=>null!=s?s(t(),n):hS(t(),n),o=()=>mS(i,t,r);return!a||a<=1?pl(o().clone()):Array(a).fill(void 0).map(o).map((e=>pl(e.clone())))}oE.className="StackedRNNCells",xu.registerClass(oE);var uE=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n},cE=class extends QC{constructor(e){if(e.unroll)throw new Kk("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Kk("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new JS({ndim:5})]}call(e,t){return ul((()=>{if(null!=this.cell.dropoutMask&&(cl(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(cl(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new qk("ConvRNN2D cell does not support constants");let n=null==t?null:t.mask,r=null==t?null:t.training,a=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:a})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return ul((()=>{let{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)],s=yf(a);return Array.isArray(t)?Array(t.length).fill(s):[s]}))}resetStates(e,t=!1){ul((()=>{if(!this.stateful)throw new Hk("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),a=[r[0],...r.slice(2)];if(null==n[0])throw new qk("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>yf(a))):this.states_=[yf(a)];else if(null==e)cl(this.states_),null!=this.keptStates&&(cl(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>yf(a))):this.states_[0]=yf(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new qk(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):cl(this.states_);for(let t=0;t<this.states_.length;++t){let n=e[t],r=a;if(!Na.arraysEqual(n.shape,r))throw new qk(`State ${t} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map((e=>pl(e.clone())))}))}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:r,padding:a,strides:s,dilationRate:i}=this.cell,o="channelsFirst"===t,l=e[o?3:2],u=e[o?4:3],c=$C(l,r[0],a,s[0],i[0]),p=$C(u,r[1],a,s[1],i[1]);return[...e.slice(0,2),...o?[n,c,p]:[c,p,n]]}};cE.className="ConvRNN2D";var pE=class extends sE{constructor(e){let{filters:t,kernelSize:n,strides:r,padding:a,dataFormat:s,dilationRate:i}=e;super(Object.assign({},e,{units:t})),this.filters=t,fI(this.filters,"filters"),this.kernelSize=AC(n,2,"kernelSize"),this.kernelSize.forEach((e=>fI(e,"kernelSize"))),this.strides=AC(r||1,2,"strides"),this.strides.forEach((e=>fI(e,"strides"))),this.padding=a||"valid",AI(this.padding),this.dataFormat=s||"channelsLast",CI(this.dataFormat),this.dilationRate=AC(i||1,2,"dilationRate"),this.dilationRate.forEach((e=>fI(e,"dilationRate")))}build(e){var t;e=GS(e);let n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new qk(`The channel dimension of the input should be defined. Found ${e[n]}`);let r=e[n],a=4,s=this.kernelSize.concat([r,this.filters*a]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let i=this.kernelSize.concat([this.filters,this.filters*a]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){let n=this.biasInitializer,r=this.filters;e=new(t=class extends xS{apply(e,t){let a=n.apply([r]),s=bf([r]),i=n.apply([2*r]);return nS([a,s,i])}},t.className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*a],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return ul((()=>{if(3!==e.length)throw new qk(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,r=e[0],a=e[1],s=e[2],i=4;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=lE({ones:()=>Mf(r),rate:this.dropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let o=this.dropoutMask,l=(e,t,n)=>t&&t[n]?Hu(t[n],e):e,u=l(r,o,0),c=l(r,o,1),p=l(r,o,2),d=l(r,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=lE({ones:()=>Mf(a),rate:this.recurrentDropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let h=this.recurrentDropoutMask,f=l(a,h,0),m=l(a,h,1),g=l(a,h,2),y=l(a,h,3),b=3,[w,x,v,k]=dg(this.kernel.read(),i,b),[I,S,N,T]=this.useBias?dg(this.bias.read(),i):[null,null,null,null];u=this.inputConv(u,w,I,this.padding),c=this.inputConv(c,x,S,this.padding),p=this.inputConv(p,v,N,this.padding),d=this.inputConv(d,k,T,this.padding);let[_,C,E,A]=dg(this.recurrentKernel.read(),i,b);f=this.recurrentConv(f,_),m=this.recurrentConv(m,C),g=this.recurrentConv(g,E),y=this.recurrentConv(y,A);let $=this.recurrentActivation.apply(zu(u,f)),F=this.recurrentActivation.apply(zu(c,m)),R=zu(Hu(F,s),Hu($,this.activation.apply(zu(p,g)))),D=Hu(this.recurrentActivation.apply(zu(d,y)),this.activation.apply(R));return[D,D,R]}))}getConfig(){let e=super.getConfig(),{units:t}=e,n=uE(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},n,r)}inputConv(e,t,n,r){let a=Cp(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?cS(a,n,this.dataFormat):a}recurrentConv(e,t){return Cp(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}};pE.className="ConvLSTM2DCell",xu.registerClass(pE);var dE=class extends cE{constructor(e){let t=new pE(e);super(Object.assign({},e,{cell:t}))}static fromConfig(e,t){return new e(t)}};dE.className="ConvLSTM2D",xu.registerClass(dE);var hE=class extends nN{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;let t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(null==this.noiseShape[r]?t[r]:this.noiseShape[r]);return n}call(e,t){return ul((()=>{this.invokeCallHook(e,t);let n=US(e);if(0<this.rate&&this.rate<1){let e=null!=t.training&&t.training,r=this.getNoiseShape(n);return mS((()=>hS(n,this.rate,r,this.seed)),(()=>n),e)}return e}))}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};hE.className="Dropout",xu.registerClass(hE);var fE=class extends hE{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};fE.className="SpatialDropout1D",xu.registerClass(fE);var mE=class extends nN{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,fI(this.units,"units"),this.activation=fC(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=BS(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=BS(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=EN(e.kernelConstraint),this.biasConstraint=EN(e.biasConstraint),this.kernelRegularizer=IC(e.kernelRegularizer),this.biasRegularizer=IC(e.biasRegularizer),this.activityRegularizer=IC(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=GS(e);let t=e[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=GS(e);let t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return ul((()=>{this.invokeCallHook(e,t);let n,r=US(e),a=yI(this.activation.getClassName());return null!=a?n=iS(r,this.kernel.read(),a,this.bias?this.bias.read():null):(n=iS(r,this.kernel.read()),null!=this.bias&&(n=cS(n,this.bias.read())),null!=this.activation&&(n=this.activation.apply(n))),n}))}getConfig(){let e={units:this.units,activation:dC(this.activation),useBias:this.useBias,kernelInitializer:zS(this.kernelInitializer),biasInitializer:zS(this.biasInitializer),kernelRegularizer:vC(this.kernelRegularizer),biasRegularizer:vC(this.biasRegularizer),activityRegularizer:vC(this.activityRegularizer),kernelConstraint:_N(this.kernelConstraint),biasConstraint:_N(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};mE.className="Dense",xu.registerClass(mE);var gE=class extends nN{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=GS(e);for(let t of e.slice(1))if(null==t)throw new qk(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],VI(e,1)]}call(e,t){return ul((()=>{this.invokeCallHook(e,t);let n=US(e);if("channelsFirst"===this.dataFormat&&n.rank>1){let e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=El(n,e)}return ZI(n)}))}getConfig(){let e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};gE.className="Flatten",xu.registerClass(gE);var yE=class extends nN{constructor(e){super(e),this.supportsMasking=!0,this.activation=fC(e.activation)}call(e,t){return ul((()=>{this.invokeCallHook(e,t);let n=US(e);return this.activation.apply(n)}))}getConfig(){let e={activation:dC(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};yE.className="Activation",xu.registerClass(yE);var bE=class extends nN{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return ul((()=>(e=US(e),YI(e,this.n))))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};bE.className="RepeatVector",xu.registerClass(bE);var wE=class extends nN{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",r=t.slice(),a=1,s=null;for(let o=0;o<r.length;++o){let e=r[o];if(this.isUnknown(e)){if(null!==s)throw new qk("Can only specifiy one unknown dimension.");s=o}else a*=e}let i=VI(e);if(null!==s){if(0===a||i%a!==0)throw new qk(n);r[s]=i/a}else if(i!==a)throw new qk(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return ul((()=>{this.invokeCallHook(e,t);let n=US(e),r=n.shape,a=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return Lc(n,a)}))}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};wE.className="Reshape",xu.registerClass(wE);var xE=class extends nN{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=HI(1,e.dims.length+1);if(!Na.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new JS({ndim:this.dims.length+1})]}computeOutputShape(e){e=GS(e);let t=e.slice();return this.dims.forEach(((n,r)=>{t[r+1]=e[n]})),t}call(e,t){return El(US(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};xE.className="Permute",xu.registerClass(xE);var vE=class extends nN{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=US(e),r=-1;return rc(Rf(n,this.maskValue),r)}call(e,t){return ul((()=>{this.invokeCallHook(e,t);let n=US(e),r=-1,a=!0,s=rc(Rf(n,this.maskValue),r,a);return Hu(n,go(s,n.dtype))}))}};vE.className="Masking",xu.registerClass(vE);var kE=class extends nN{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(tI(e.inputLength))}this.inputDim=e.inputDim,fI(this.inputDim,"inputDim"),this.outputDim=e.outputDim,fI(this.outputDim,"outputDim"),this.embeddingsInitializer=BS(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=IC(e.embeddingsRegularizer),this.activityRegularizer=IC(e.activityRegularizer),this.embeddingsConstraint=EN(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return ul((()=>this.maskZero?(e=US(e),Rf(e,cd(e))):null))}computeOutputShape(e){if(e=GS(e),null==this.inputLength)return[...e,this.outputDim];let t=tI(this.inputLength);if(t.length!==e.length-1)throw new qk(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){let a=t[r],s=e[r+1];if(null!=a&&null!=s&&a!==s)throw new qk(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==a&&(t[n]=s),n++}}return[e[0],...t,this.outputDim]}call(e,t){return ul((()=>{this.invokeCallHook(e,t);let n=US(e);"int32"!==n.dtype&&(n=KI(n,"int32"));let r=oS(this.embeddings.read(),Lc(n,[n.size]));return Lc(r,GS(this.computeOutputShape(n.shape)))}))}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:zS(this.embeddingsInitializer),embeddingsRegularizer:vC(this.embeddingsRegularizer),activityRegularizer:vC(this.activityRegularizer),embeddingsConstraint:_N(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};kE.className="Embedding",xu.registerClass(kE);var IE=class extends nN{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Kk}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;let n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){let a=e[e.length-t.length+r],s=t[r];if(null==a||null==s||a<0||s<0)n.push(null);else if(1===a)n.push(s);else if(1===s)n.push(a);else{if(a!==s)throw new qk("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(a)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[GS(e)]),e.length<2)throw new qk(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let a of e)null!=a&&null!==a[0]&&t.push(a[0]);if(t=cI(t),t.length>1)throw new qk(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let a=1;a<e.length;++a){let t=null==e[a]?null:e[a].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}let r=e.map((e=>e.length));-1===e.indexOf(null)&&1===cI(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return ul((()=>{if(this.reshapeRequired){let t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){let r=GI(n);for(let n of e){let e=n.rank;for(let t=0;t<r-e;++t)n=XI(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(let s of e){let e=s.rank;if(null==e){let e=s.shape,r=e[0],a=e.slice(1).concat([r]),i=Lc(s,[r].concat(VI(e.slice(1))));i=El(i,[1,0]),i=Lc(i,a),t.push(i),n=!0}else if(e>1){let r=HI(1,e).concat([0]);t.push(El(s,r)),n=!0}else t.push(s)}let r=this.mergeFunction(t),a=r.rank;if(n)if(null==a){let e=r.shape,t=e.length,n=e[t-1],a=[n].concat(e.slice(0,e.length-1));r=Lc(El(Lc(r,[-1,n]),[1,0]),a)}else if(a>1){let e=[a-1].concat(HI(0,a-1));r=El(r,e)}return r}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){let n=null==e[r]?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(let r of e)null!=r&&null!==r[0]&&n.push(r[0]);return n=cI(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return ul((()=>{if(null==t)return null;if(!Array.isArray(t))throw new qk("`mask` should be an Array");if(!Array.isArray(e))throw new qk("`inputs` should be an Array");if(t.length!==e.length)throw new qk(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every((e=>null==e)))return null;t=t.map((e=>null==e?e:Yd(e,0)));let n=t[0];for(let e=1;e<t.length-1;++e)n=Xh(n,t[e]);return n}))}},SE=class extends IE{constructor(e){super(e)}mergeFunction(e){return ul((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=zu(t,e[n]);return t}))}};SE.className="Add",xu.registerClass(SE);var NE=class extends IE{constructor(e){super(e)}mergeFunction(e){return ul((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Hu(t,e[n]);return t}))}};NE.className="Multiply",xu.registerClass(NE);var TE=class extends IE{constructor(e){super(e)}mergeFunction(e){return ul((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=zu(t,e[n]);return Hu(1/e.length,t)}))}};TE.className="Average",xu.registerClass(TE);var _E=class extends IE{constructor(e){super(e)}mergeFunction(e){return ul((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=ff(t,e[n]);return t}))}};_E.className="Maximum",xu.registerClass(_E);var CE=class extends IE{constructor(e){super(e)}mergeFunction(e){return ul((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=vf(t,e[n]);return t}))}};CE.className="Minimum",xu.registerClass(CE);var EE=class extends IE{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new qk("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(let r of e)if(null!=r){t=!1;break}if(t)return;let n=[];for(let r=0;r<e.length;++r){let t=e[r].slice();t.splice(this.axis,1);let a=!1;for(let e of n)if(Na.arraysEqual(e,t)){a=!0;break}a||n.push(t)}if(n.length>1)throw new qk("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return ul((()=>nS(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new qk("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(let a of t.slice(1)){if(null==n[r]||null==a[r]){n[r]=null;break}n[r]+=a[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new qk("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new qk("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new qk(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return ul((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;let r=[];for(let s=0;s<e.length;++s)null==t[s]?r.push(go(Mf(e[s]),"bool")):t[s].rank<e[s].rank?r.push(Yd(t[s],-1)):r.push(t[s]);let a=Uc(r,this.axis);return tc(a,-1,!1)}))}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};function AE(e,t){for(;e<0;)e+=t;return e}function $E(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new Kk("batchDot is not implemented for tensors of 4D or higher rank yet");if(Na.assert(e.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`)),Na.assert(e.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`)),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new Kk("batchDot is not implemented for complex64-type Tensors yet.");let r=e.shape.length,a=t.shape.length;null==n&&(n=[r-1,a-2]);let s=n;return ul((()=>{let n,i;if(r>a){n=r-a;let e=[];for(let t=0;t<n;++t)e.push(1);t=Lc(t,t.shape.concat(e))}else if(a>r){n=a-r;let t=[];for(let e=0;e<n;++e)t.push(1);e=Lc(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)i=s[0]===s[1]?Wd(Hu(e,t),s[0]):Wd(Hu(El(e,[1,0]),t),s[1]);else{let n=s[0]!==e.shape.length-1,r=s[1]===t.shape.length-1;i=Zo(e,t,n,r)}if(n>0){let e;e=r>a?r+a-3:r-1;let t=[];for(let r=e;r<e+n;++r)t.push(r);i=bg(i,t)}return 1===i.shape.length&&(i=Yd(i,1)),i}))}EE.className="Concatenate",xu.registerClass(EE);var FE=class extends IE{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){Na.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new Kk("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new qk(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(2!==e.length)throw new qk(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>AE(t,e[n].shape.length))):[AE(this.axes,n.shape.length),AE(this.axes,r.shape.length)],this.normalize&&(n=cT(n,t[0]),r=cT(r,t[1])),$E(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[AE(this.axes,e.length),AE(this.axes,t.length)],n}computeOutputShape(e){Na.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new Kk("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);let a=t.concat(n);return 1===a.length&&a.push(1),a}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};FE.className="Dot",xu.registerClass(FE);var RE=class extends nN{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return ul((()=>{this.invokeCallHook(e,t);let n=US(e);return mS((()=>zu(sS(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}};RE.className="GaussianNoise",xu.registerClass(RE);var DE=class extends nN{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return ul((()=>{this.invokeCallHook(e,t);let n=US(e);return this.rate>0&&this.rate<1?mS((()=>{let e=Math.sqrt(this.rate/(1-this.rate));return Hu(n,sS(n.shape,1,e))}),(()=>n),t.training||!1):n}))}};DE.className="GaussianDropout",xu.registerClass(DE);var ME=class extends nN{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||US(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return ul((()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return mS((()=>{let t=US(e),r=1.6732632423543772,a=1.0507009873554805,s=-r*a,i=ph(mm(n),this.rate);i=KI(i,"float32");let o=((1-this.rate)*(1+this.rate*s**2))**-.5,l=-o*s*this.rate,u=zu(Hu(t,i),Hu(zu(i,-1),s));return zu(Hu(u,o),l)}),(()=>US(e)),t.training||!1)}return e}))}};function OE(e,t,n,r,a,s=.001){let i;if(2===e.rank)i=ap(e,t,n,r,a,s);else if(3===e.rank)i=ip(e,t,n,r,a,s);else{if(4!==e.rank)throw new Kk(`batchNormalization is not implemented for array of rank ${e.rank} yet`);i=lp(e,t,n,r,a,s)}return i}function LE(e,t,n,r,a=.001){return ul((()=>{let s=_f(e,r),i=s.mean,o=s.variance;return[OE(e,i,o,n,t,a),i,o]}))}function PE(e,t,n,r,a=.001){return ul((()=>{let s=_f(e,r),i=s.mean,o=s.variance,l=[];for(let t of HI(0,e.rank))-1!==r.indexOf(t)?l.push(1):l.push(e.shape[t]);let u=Lc(i,l),c=Lc(o,l),p=null==t?null:Lc(t,l),d=null==n?null:Lc(n,l);return[OE(e,u,c,d,p,a),i,o]}))}function zE(e,t,n,r,a=.001){return Na.arraysEqual(r.slice().sort(),HI(0,e.rank-1))?LE(e,t,n,r,a):PE(e,t,n,r,a)}ME.className="AlphaDropout",xu.registerClass(ME);var BE=class extends nN{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=BS(e.betaInitializer||"zeros"),this.gammaInitializer=BS(e.gammaInitializer||"ones"),this.movingMeanInitializer=BS(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=BS(e.movingVarianceInitializer||"ones"),this.betaConstraint=EN(e.betaConstraint),this.gammaConstraint=EN(e.gammaConstraint),this.betaRegularizer=IC(e.betaRegularizer),this.gammaRegularizer=IC(e.gammaRegularizer)}build(e){e=GS(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new qk(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new JS({ndim:e.length,axes:{[t]:n}})];let r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return ul((()=>{let n=null!=t.training&&t.training,r=US(e),a=r.shape,s=a.length,i=HI(0,s),o=this.axis>=0?this.axis:this.axis+s;i.splice(o,1);let l=Jk(1,s);l[o]=a[o];let u=i.slice();u.sort();let c=!Na.arraysEqual(u,HI(0,s).slice(0,s-1)),p=()=>{if(c){let e=Lc(this.movingMean.read(),l),t=Lc(this.movingVariance.read(),l),n=this.center?Lc(this.beta.read(),l):null,a=this.scale?Lc(this.gamma.read(),l):null;return OE(r,e,t,n,a,this.epsilon)}return OE(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)};if(!n)return p();let[d,h,f]=zE(r,this.gamma.read(),this.beta.read(),i,this.epsilon),m=(e,t,n)=>{ul((()=>{let r=1-n,a=e.read(),s=Hu(Uh(a,t),r);e.write(Uh(a,s))}))};return m(this.movingMean,h,this.momentum),m(this.movingVariance,f,this.momentum),d}))}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:zS(this.betaInitializer),gammaInitializer:zS(this.gammaInitializer),movingMeanInitializer:zS(this.movingMeanInitializer),movingVarianceInitializer:zS(this.movingVarianceInitializer),betaRegularizer:vC(this.betaRegularizer),gammaRegularizer:vC(this.gammaRegularizer),betaConstraint:_N(this.betaConstraint),gammaConstraint:_N(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};BE.className="BatchNormalization",xu.registerClass(BE);var WE=class extends nN{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(let e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=BS(e.betaInitializer||"zeros"),this.gammaInitializer=BS(e.gammaInitializer||"ones"),this.betaRegularizer=IC(e.betaRegularizer),this.gammaRegularizer=IC(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=GS(e);let t=e.length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=t);for(let a of this.axis)if(a<0||a>=t)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==cI(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map((t=>e[t])),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){let n=US(e),r=n.shape,a=r.length;return ul((()=>{let{mean:e,variance:t}=_f(n,this.axis,!0),s=Jk(1,a);for(let n of this.axis)s[n]=r[n];let i=e=>null!=e&&e.shape.length!==a?Lc(e,s):e,o=this.scale?i(this.gamma.read()):null,l=this.center?i(this.beta.read()):null,u=[],c=[];for(let n=0;n<a;++n)-1!==this.axis.indexOf(n)?(u.push(r[n]),c.push(1)):(u.push(1),c.push(r[n]));return e=eh(e,u),t=eh(t,u),null!=o&&(o=eh(o,c)),null!=l&&(l=eh(l,c)),OE(n,e,t,l,o,this.epsilon)}))}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:zS(this.betaInitializer),gammaInitializer:zS(this.gammaInitializer),betaRegularizer:vC(this.betaRegularizer),gammaRegularizer:vC(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};function VE(e,t,n){return ul((()=>{if(4!==e.rank)throw new qk(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new qk("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==n&&(n=qI()),"channelsLast"!==n&&"channelsFirst"!==n)throw new qk(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return r="channelsFirst"===n?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],zf(e,r)}))}WE.className="LayerNormalization",xu.registerClass(WE);var UE=class extends nN{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?qI():e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new qk(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"==typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new qk(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new qk(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new JS({ndim:4})]}computeOutputShape(e){let t,n;return e=GS(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return ul((()=>VE(US(e),this.padding,this.dataFormat)))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};function GE(e,t,n,r,a,s){return ul((()=>{CI(a),$I(s),AI(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==a&&(a=qI()),null==s&&(s="max"),e=RC(e,a);let i,o="same"===r?"same":"valid";return i="max"===s?lf(e,t,n,o):zc(e,t,n,o),"channelsFirst"===a&&(i=El(i,[0,3,1,2])),i}))}function HE(e,t,n,r,a,s){return ul((()=>{CI(a),$I(s),AI(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==a&&(a=qI()),null==s&&(s="max"),e=DC(e,a);let i,o="same"===r?"same":"valid";return i="max"===s?cf(e,t,n,o):Wc(e,t,n,o),"channelsFirst"===a&&(i=El(i,[0,4,1,2,3])),i}))}UE.className="ZeroPadding2D",xu.registerClass(UE);var jE=class extends nN{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"==typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new qk(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(fI(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"==typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new qk(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}fI(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,AI(this.padding),this.inputSpec=[new JS({ndim:3})]}computeOutputShape(e){e=GS(e);let t=$C(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return ul((()=>{this.invokeCallHook(e,t),e=XI(US(e),2);let n=this.poolingFunction(US(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return bg(n,[2])}))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},qE=class extends jE{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return CI(a),AI(r),GE(e,t,n,r,a,"max")}};qE.className="MaxPooling1D",xu.registerClass(qE);var KE=class extends jE{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return CI(a),AI(r),GE(e,t,n,r,a,"avg")}};KE.className="AveragePooling1D",xu.registerClass(KE);var XE=class extends nN{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new qk(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];fI(this.poolSize,"poolSize"),fI(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,CI(this.dataFormat),AI(this.padding),this.inputSpec=[new JS({ndim:4})]}computeOutputShape(e){e=GS(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=$C(t,this.poolSize[0],this.padding,this.strides[0]),n=$C(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return ul((()=>(this.invokeCallHook(e,t),this.poolingFunction(US(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},YE=class extends XE{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return CI(a),AI(r),GE(e,t,n,r,a,"max")}};YE.className="MaxPooling2D",xu.registerClass(YE);var JE=class extends XE{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return CI(a),AI(r),GE(e,t,n,r,a,"avg")}};JE.className="AveragePooling2D",xu.registerClass(JE);var ZE=class extends nN{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new qk(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];fI(this.poolSize,"poolSize"),fI(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,CI(this.dataFormat),AI(this.padding),this.inputSpec=[new JS({ndim:5})]}computeOutputShape(e){e=GS(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=$C(t,this.poolSize[0],this.padding,this.strides[0]),n=$C(n,this.poolSize[1],this.padding,this.strides[1]),r=$C(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return ul((()=>(this.invokeCallHook(e,t),this.poolingFunction(US(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},QE=class extends ZE{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return CI(a),AI(r),HE(e,t,n,r,a,"max")}};QE.className="MaxPooling3D",xu.registerClass(QE);var eA=class extends ZE{constructor(e){super(e)}poolingFunction(e,t,n,r,a){return CI(a),AI(r),HE(e,t,n,r,a,"avg")}};eA.className="AveragePooling3D",xu.registerClass(eA);var tA=class extends nN{constructor(e){super(e),this.inputSpec=[new JS({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Kk}},nA=class extends tA{constructor(e){super(e||{})}call(e,t){return ul((()=>{let t=US(e);return gf(t,1)}))}};nA.className="GlobalAveragePooling1D",xu.registerClass(nA);var rA=class extends tA{constructor(e){super(e||{})}call(e,t){return ul((()=>{let t=US(e);return Ad(t,1)}))}};rA.className="GlobalMaxPooling1D",xu.registerClass(rA);var aA=class extends nN{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,CI(this.dataFormat),this.inputSpec=[new JS({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Kk}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},sA=class extends aA{call(e,t){return ul((()=>{let t=US(e);return"channelsLast"===this.dataFormat?gf(t,[1,2]):gf(t,[2,3])}))}};sA.className="GlobalAveragePooling2D",xu.registerClass(sA);var iA=class extends aA{call(e,t){return ul((()=>{let t=US(e);return"channelsLast"===this.dataFormat?Ad(t,[1,2]):Ad(t,[2,3])}))}};iA.className="GlobalMaxPooling2D",xu.registerClass(iA);var oA=class extends nN{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let r=t.layer,a=uT(r,n);delete t.layer;let s={layer:a};return Object.assign(s,t),new e(s)}},lA=class extends oA{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=GS(e),e.length<3)throw new qk(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=GS(e);let t=[e[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return ul((()=>(e=US(e),ZC(((e,n)=>[US(this.layer.call(e,t)),[]]),e,[],!1,null,null,!1,!0)[1])))}};function uA(e){dI(TI,"BidirectionalMergeMode",e)}lA.className="TimeDistributed",xu.registerClass(lA);var cA="concat",pA=class extends oA{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=uT(n),t.goBackwards=!0!==t.goBackwards;let r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=uT(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?cA:e.mergeMode,uA(this.mergeMode),e.weights)throw new Kk("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,r,a=this.forwardLayer.computeOutputShape(e);return Array.isArray(a)&&Array.isArray(a[0])||(a=[a]),this.returnState&&(r=a.slice(1)),t=a[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):eI(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});let a=JC(e,n,r,this.numConstants);if(e=a.inputs,n=a.initialState,r=a.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);let s=[],i=[];if(null!=n){let e=n.length;if(e%2>0)throw new qk("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,s.push(...n);let r=n.map((e=>new JS({shape:e.shape})));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),i.push(...r)}if(null!=r)throw new Kk("Support for constants in Bidirectional layers is not implemented yet.");let o=s[0]instanceof ZS;for(let l of s)if(l instanceof ZS!==o)throw new qk("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){let n=[e].concat(s),r=this.inputSpec.concat(i),a=this.inputSpec;this.inputSpec=r;let o=super.apply(n,t);return this.inputSpec=a,o}return super.apply(e,t)}call(e,t){return ul((()=>{let n,r,a,s,i=t.initialState;if(null==i)n=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{let a=i.slice(0,i.length/2),s=i.slice(i.length/2);n=this.forwardLayer.call(e,Object.assign(t,{initialState:a})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:s}))}return this.returnState&&(Array.isArray(n)&&(a=n.slice(1).concat(r.slice(1))),n=n[0],r=r[0]),this.returnSequences&&(r=Sm(r,1)),"concat"===this.mergeMode?s=nS([n,r]):"sum"===this.mergeMode?s=zu(n,r):"ave"===this.mergeMode?s=Hu(.5,zu(n,r)):"mul"===this.mergeMode?s=Hu(n,r):null==this.mergeMode&&(s=[n,r]),this.returnState?null==this.mergeMode?s.concat(a):[s].concat(a):s}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){DI(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),DI(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){let e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=uT(t.layer);if(delete t.layer,null!=t.numConstants)throw new Kk("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let r=t;return r.layer=n,new e(r)}};function dA(e){return new iN(e)}function hA(e){return new _C(e)}function fA(e){return new SC(e)}function mA(e){return new NC(e)}function gA(e){return new TC(e)}function yA(e){return new EC(e)}function bA(e){return new CC(e)}function wA(e){return new jC(e)}function xA(e){return new BC(e)}function vA(e){return new VC(e)}function kA(e){return new WC(e)}function IA(e){return new UC(e)}function SA(e){return new HC(e)}function NA(e){return new qC(e)}function TA(e){return new KC(e)}function _A(e){return new YC(e)}function CA(e){return new yE(e)}function EA(e){return new mE(e)}function AA(e){return new hE(e)}function $A(e){return new fE(e)}function FA(e){return new gE(e)}function RA(e){return new bE(e)}function DA(e){return new wE(e)}function MA(e){return new xE(e)}function OA(e){return new kE(e)}function LA(e){return new SE(e)}function PA(e){return new TE(e)}function zA(e){return new EE(e)}function BA(e){return new _E(e)}function WA(e){return new CE(e)}function VA(e){return new NE(e)}function UA(e){return new FE(e)}function GA(e){return new BE(e)}function HA(e){return new WE(e)}function jA(e){return new UE(e)}function qA(e){return new KE(e)}function KA(e){return qA(e)}function XA(e){return qA(e)}function YA(e){return new JE(e)}function JA(e){return YA(e)}function ZA(e){return YA(e)}function QA(e){return new eA(e)}function e$(e){return QA(e)}function t$(e){return QA(e)}function n$(e){return new nA(e)}function r$(e){return new sA(e)}function a$(e){return new rA(e)}function s$(e){return new iA(e)}function i$(e){return new qE(e)}function o$(e){return new YE(e)}function l$(e){return new QE(e)}function u$(e){return new aE(e)}function c$(e){return new rE(e)}function p$(e){return new iE(e)}function d$(e){return new sE(e)}function h$(e){return new nE(e)}function f$(e){return new tE(e)}function m$(e){return new dE(e)}function g$(e){return new pE(e)}function y$(e){return new QC(e)}function b$(e){return new oE(e)}function w$(e){return new pA(e)}function x$(e){return new lA(e)}pA.className="Bidirectional",xu.registerClass(pA);var v$=a$,k$=s$,I$=i$,S$=o$;function N$(e){return new RE(e)}function T$(e){return new DE(e)}function _$(e){return new ME(e)}function C$(e){return new vE(e)}var E$={};function A$(e,t){return CT(e,t)}function $$(e,t){return MT(e,t)}function F$(e,t){return OT(e,t)}function R$(e,t){return ET(e,t)}function D$(e,t){return UT(e,t)}function M$(e,t){return RT(e,t)}function O$(e,t){return DT(e,t)}function L$(e,t){return NT(e,t)}function P$(e,t){return dT(e,t)}function z$(e,t){return hT(e,t)}function B$(e,t){return hT(e,t)}function W$(e,t){return hT(e,t)}function V$(e,t){return pT(e,t)}function U$(e,t){return pT(e,t)}function G$(e,t){return pT(e,t)}g(E$,{MAPE:()=>B$,MSE:()=>U$,binaryAccuracy:()=>A$,binaryCrossentropy:()=>$$,categoricalAccuracy:()=>R$,categoricalCrossentropy:()=>D$,cosineProximity:()=>L$,mape:()=>W$,meanAbsoluteError:()=>P$,meanAbsolutePercentageError:()=>z$,meanSquaredError:()=>V$,mse:()=>G$,precision:()=>M$,recall:()=>O$,sparseCategoricalAccuracy:()=>F$});var H$={};g(H$,{modelFromJSON:()=>W_});var j$={};function q$(e){return new yC(e)}function K$(e){return bC(e)}function X$(e){return wC(e)}g(j$,{l1:()=>K$,l1l2:()=>q$,l2:()=>X$});var Y$=class extends tT{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof z_))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function J$(e,t){return e<t}function Z$(e,t){return e>t}var Q$=class extends Y${constructor(e){if(super(),null==e&&(e={}),e.restoreBestWeights)throw new Kk("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,-1===["auto","min","max"].indexOf(this.mode)&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),"min"===this.mode?this.monitorFunc=J$:"max"===this.mode||-1!==this.monitor.indexOf("acc")?this.monitorFunc=Z$:this.monitorFunc=J$,this.monitorFunc===J$&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,null!=this.baseline?this.best=this.baseline:this.best=this.monitorFunc===J$?1/0:-1/0}async onEpochEnd(e,t){await ZN(t);let n=this.getMonitorValue(t);null!=n&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){null==e&&(e={});let t=e[this.monitor];return null==t&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};function eF(e){return new Q$(e)}var tF,nF,rF={earlyStopping:eF},aF=Xe();aF.registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(tF||(tF={})),function(e){let t;(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(nF||(nF={}));var sF={};function iF(e,t){let n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};sF[e]=n}function oF(e){return sF[e]}function lF(e){delete sF[e]}function uF(e,t,n,r,a){let s=t.inputParams[e];if(s&&void 0!==s.inputIndexStart){let e=s.inputIndexStart,i=0===s.inputIndexEnd?void 0:void 0===s.inputIndexEnd?e+1:s.inputIndexEnd;if("tensor"===s.type)return cF(t.inputNames[s.inputIndexStart],n,r,a);if("tensors"===s.type)return t.inputNames.slice(e,i).map((e=>cF(e,n,r,a)));let o=cF(t.inputNames.slice(e)[0],n,r,a),l=o.dataSync();return"number"===s.type?l[0]:Na.toNestedArray(o.shape,l)}let i=t.attrParams[e];return i&&i.value}function cF(e,t,n,r){let[a,s]=fF(e);if(null!=r){let e=r.getHashTableHandleByName(a);if(null!=e)return e}let i=n.currentContextIds.find((e=>!!t[hF(a,e)]));return void 0!==i?t[hF(a,i)][s]:void 0}function pF(e,t,n){return t[hF(e,n.currentContextId)]}function dF(e,t){let[n,r,a]=fF(e);return[hF(n,t&&t.currentContextId),r,a]}function hF(e,t){return t?`${e}-${t}`:e}function fF(e){let t=e.split(":");if(1===t.length)return[e,0,void 0];let n=t[0],r=3===t.length?t[1]:void 0,a=Number(t[t.length-1]);return[n,a,r]}function mF(e,t,n){let r=uF("pad",e,t,n);if("explicit"===r){r=uF("explicitPaddings",e,t,n);let a=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)a[e][0]=r[2*e],a[e][1]=r[2*e+1];return a}return r}function gF(e){return e.kept?e:bo(e)}var yF={};g(yF,{json:()=>bF});var bF=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],wF={};g(wF,{json:()=>xF});var xF=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],vF={};g(vF,{json:()=>kF});var kF=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],IF={};g(IF,{json:()=>SF});var SF=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],NF={};g(NF,{json:()=>TF});var TF=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],_F={};g(_F,{json:()=>CF});var CF=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],EF={};g(EF,{json:()=>AF});var AF=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],$F={};g($F,{json:()=>FF});var FF=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],RF={};g(RF,{json:()=>DF});var DF=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],MF={};g(MF,{json:()=>OF});var OF=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],LF={};g(LF,{json:()=>PF});var PF=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],zF={};g(zF,{json:()=>BF});var BF=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],WF={};g(WF,{json:()=>VF});var VF=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],UF={};g(UF,{json:()=>GF});var GF=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],HF={};g(HF,{json:()=>jF});var jF=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],qF={};g(qF,{json:()=>KF});var KF=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],XF={};g(XF,{json:()=>YF});var YF=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],JF={};g(JF,{json:()=>ZF});var ZF=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],QF={};g(QF,{json:()=>eR});var eR=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],tR=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[yF,wF,vF,IF,NF,_F,EF,$F,RF,MF,LF,zF,WF,UF,HF,qF,XF,JF,QF],t=[].concat(...e.map((e=>e.json)));this.opMappers=t.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e,t={}){let n=e.node,r=[],a=[],s=[],i=n.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?r.push(e[t.name]):"Const"===t.op?a.push(e[t.name]):(null==t.input||0===t.input.length)&&s.push(e[t.name]),e)),{}),o=[],l=[],u={},c={};null!=t&&(u=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));let p=Object.keys(i);p.forEach((e=>{let t=i[e];t.inputNames.forEach(((e,n)=>{let[r,,a]=dF(e),s=i[r];if(null!=s.outputs){let e=s.outputs.indexOf(a);if(-1!==e){let a=`${r}:${e}`;t.inputNames[n]=a}}t.inputs.push(s),s.children.push(t)}))})),0===Object.keys(c).length?p.forEach((e=>{let t=i[e];0===t.children.length&&l.push(t)})):Object.keys(c).forEach((e=>{let[t]=dF(e),n=i[t];null!=n&&(n.signatureKey=c[e],l.push(n))})),Object.keys(u).length>0?Object.keys(u).forEach((e=>{let[t]=dF(e),n=i[t];n&&(n.signatureKey=u[e],o.push(n))})):o=r;let d={};null!=e.library&&null!=e.library.function&&(d=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));let h={nodes:i,inputs:o,outputs:l,weights:a,placeholders:r,signature:t,functions:d};return s.length>0&&(h.initNodes=s),h}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){let t=oF(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.slice(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((t,n)=>{let r,a=n.type;switch(n.type){case"string":r=aR(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=aR(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":r=fR(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=fR(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":r=iR(e.attr,n.tfName,n.defaultValue||0),void 0===r&&n.tfDeprecatedName&&(r=iR(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":r=hR(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=hR(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":r=sR(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=sR(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":r=gR(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=gR(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":r=dR(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=dR(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":r=mR(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=mR(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":r=uR(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=uR(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":r=cR(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=cR(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":r=lR(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=lR(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:r,type:a},t}),{})),n}mapFunction(e){let t=e.nodeDef,n=[],r=[],a={};null!=t&&(a=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&r.push(e[t.name]),e)),{}));let s=[],i=[];e.signature.inputArg.forEach((e=>{let[t]=dF(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:oR(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,s.push(n),a[t]=n})),Object.keys(a).forEach((e=>{let t=a[e];t.inputNames.forEach(((e,n)=>{let[r,,s]=dF(e),i=a[r];if(null!=i.outputs){let e=i.outputs.indexOf(s);if(-1!==e){let a=`${r}:${e}`;t.inputNames[n]=a}}t.inputs.push(i),i.children.push(t)}))}));let o=e.ret;e.signature.outputArg.forEach((e=>{let[t,n]=dF(o[e.name]),r=a[t];null!=r&&(r.defaultOutput=n,i.push(r))}));let l=this.mapArgsToSignature(e);return{nodes:a,inputs:s,outputs:i,weights:r,placeholders:n,signature:l}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}};function nR(e){let t=Xe().global;if("undefined"!=typeof t.atob)return t.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function rR(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):nR(e);return t?n:n.toLowerCase()}function aR(e,t,n,r=!1){let a=e[t];return null!=a?rR(a.s,r):n}function sR(e,t,n){let r=e[t];return r?r.b:n}function iR(e,t,n){let r=e[t]||{},a=null!=r.i?r.i:null!=r.f?r.f:n;return"number"==typeof a?a:parseInt(a,10)}function oR(e){switch("string"==typeof e&&(e=tF[e]),e){case tF.DT_FLOAT:case tF.DT_HALF:return"float32";case tF.DT_INT32:case tF.DT_INT64:case tF.DT_INT8:case tF.DT_UINT8:return"int32";case tF.DT_BOOL:return"bool";case tF.DT_DOUBLE:return"float32";case tF.DT_STRING:return"string";default:return null}}function lR(e,t,n){let r=e[t];return r&&r.func?r.func.name:n}function uR(e,t,n){let r=e[t];return r&&r.type?oR(r.type):n}function cR(e,t,n){let r=e[t];return r&&r.list&&r.list.type?r.list.type.map((e=>oR(e))):n}function pR(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"==typeof e.size?e.size:parseInt(e.size,10))):[]}function dR(e,t,n){let r=e[t];return r&&r.shape?pR(r.shape):n}function hR(e,t,n){let r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map((e=>"number"==typeof e?e:parseInt(e,10))):n}function fR(e,t,n,r=!1){let a=e[t];return a&&a.list&&a.list.s?a.list.s.map((e=>rR(e,r))):n}function mR(e,t,n){let r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map((e=>pR(e))):n}function gR(e,t,n){let r=e[t];return r&&r.list&&r.list.b?r.list.b:n}var yR=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return cF(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(null!=n.tensor)return cF(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return iR(this.node.rawAttrs,e,t);if(null!=n.s)return aR(this.node.rawAttrs,e,t);if(null!=n.b)return sR(this.node.rawAttrs,e,t);if(null!=n.shape)return dR(this.node.rawAttrs,e,t);if(null!=n.type)return uR(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return hR(this.node.rawAttrs,e,t);if(null!=n.list.s)return fR(this.node.rawAttrs,e,t);if(null!=n.list.shape)return mR(this.node.rawAttrs,e,t);if(null!=n.list.b)return gR(this.node.rawAttrs,e,t);if(null!=n.list.type)return cR(this.node.rawAttrs,e,t)}return t}},bR=(e,t,n)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[zu(uF("a",e,t,n),uF("b",e,t,n))];case"AddN":return[Qu(uF("tensors",e,t,n))];case"FloorMod":case"Mod":return[Nf(uF("a",e,t,n),uF("b",e,t,n))];case"Mul":return[Hu(uF("a",e,t,n),uF("b",e,t,n))];case"RealDiv":case"Div":return[Uu(uF("a",e,t,n),uF("b",e,t,n))];case"DivNoNan":return[dd(uF("a",e,t,n),uF("b",e,t,n))];case"FloorDiv":return[Wu(uF("a",e,t,n),uF("b",e,t,n))];case"Sub":return[Uh(uF("a",e,t,n),uF("b",e,t,n))];case"Minimum":return[vf(uF("a",e,t,n),uF("b",e,t,n))];case"Maximum":return[ff(uF("a",e,t,n),uF("b",e,t,n))];case"Pow":return[Dd(uF("a",e,t,n),uF("b",e,t,n))];case"SquaredDifference":return[gg(uF("a",e,t,n),uF("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},wR=(e,t,n)=>{switch(e.op){case"Abs":case"ComplexAbs":return[qu(uF("x",e,t,n))];case"Acos":return[Xu(uF("x",e,t,n))];case"Acosh":return[Ju(uF("x",e,t,n))];case"Asin":return[uc(uF("x",e,t,n))];case"Asinh":return[pc(uF("x",e,t,n))];case"Atan":return[hc(uF("x",e,t,n))];case"Atan2":return[mc(uF("x",e,t,n),uF("y",e,t,n))];case"Atanh":return[yc(uF("x",e,t,n))];case"Ceil":return[gp(uF("x",e,t,n))];case"Complex":return[ri(uF("real",e,t,n),uF("imag",e,t,n))];case"Cos":return[Vp(uF("x",e,t,n))];case"Cosh":return[Gp(uF("x",e,t,n))];case"Elu":return[bd(uF("x",e,t,n))];case"Erf":return[xd(uF("x",e,t,n))];case"Exp":return[Kd(uF("x",e,t,n))];case"Expm1":return[Zd(uF("x",e,t,n))];case"Floor":return[sh(uF("x",e,t,n))];case"Log":return[Ch(uF("x",e,t,n))];case"Log1p":return[Ah(uF("x",e,t,n))];case"Imag":return[Il(uF("x",e,t,n))];case"Neg":return[Nl(uF("x",e,t,n))];case"Reciprocal":return[bm(uF("x",e,t,n))];case"Real":return[_l(uF("x",e,t,n))];case"Relu":return[xm(uF("x",e,t,n))];case"Round":return[Dm(uF("x",e,t,n))];case"Selu":return[Pm(uF("x",e,t,n))];case"Sigmoid":return[Hc(uF("x",e,t,n))];case"Sin":return[jm(uF("x",e,t,n))];case"Sign":return[Gm(uF("x",e,t,n))];case"Sinh":return[Km(uF("x",e,t,n))];case"Softplus":return[zh(uF("x",e,t,n))];case"Sqrt":return[Ld(uF("x",e,t,n))];case"Square":return[zd(uF("x",e,t,n))];case"Tanh":return[Xc(uF("x",e,t,n))];case"Tan":return[Tg(uF("x",e,t,n))];case"ClipByValue":return[bp(uF("x",e,t,n),uF("clipValueMin",e,t,n),uF("clipValueMax",e,t,n))];case"Relu6":return[km(uF("x",e,t,n))];case"Rsqrt":return[Om(cF(e.inputNames[0],t,n))];case"Prod":return[rm(uF("x",e,t,n),uF("axes",e,t,n))];case"LeakyRelu":return[wh(uF("x",e,t,n),uF("alpha",e,t,n))];case"Prelu":return[tm(uF("x",e,t,n),uF("alpha",e,t,n))];case"IsNan":return[yh(cF(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function xR(e,t,n=""){if("number"!=typeof e&&"number"!=typeof t){Na.assert(e.length===t.length,(()=>n+` Shapes ${e} and ${t} must match`));for(let r=0;r<e.length;r++){let a=e[r],s=t[r];Na.assert(a<0||s<0||a===s,(()=>n+` Shapes ${e} and ${t} must match`))}}}function vR(e){return!("number"==typeof e||e.some((e=>e<0)))}function kR(e,t,n){let r=IR(e,n),a=!vR(r);if(a&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(a&&t.forEach((e=>{r=IR(e.shape,r)})),!vR(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function IR(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let r=0;r<e.length;++r){let a=e[r],s=t[r];if(a>=0&&s>=0&&a!==s)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=a>=0?a:s}return n}var SR=class{constructor(e,t,n,r,a,s,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=a,this.dynamicSize=s,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=Md(0),pl(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{(null==e||!e.has(t.tensor.id))&&t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=t.shape),xR(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,pl(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return si([],[0].concat(this.elementShape));let n=this.readMany(e);return xR(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),xg(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return si([],[0].concat(this.elementShape));let t=[];for(let r=0;r<this.size();r++)t.push(r);let n=this.readMany(t);return xR(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),Uc(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,Wg(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,r=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let a=0===n?0:t.size/n,s=[];ul((()=>{t=Lc(t,[1,n,a]);for(let n=0;n<e.length;++n){let i=0===n?0:r[n-1],o=[0,i,0],l=[1,e[n],a];s[n]=Lc(qc(t,o,l),this.elementShape)}return s}));let i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,s)}},NR=class{constructor(e,t,n,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);xR(t,e.shape,"TensorList shape mismatch: "),pl(e)})),this.idTensor=Md(0),this.maxNumElements=r,pl(this.idTensor)}get id(){return this.idTensor.id}copy(){return new NR([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{(null==e||!e.has(t.id))&&t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);xR(e,this.elementShape,"TensorList shape mismatch: ");let r=kR(this.elementShape,this.tensors,e);return ul((()=>{let e=this.tensors.map((e=>Lc(e,r)));return xg(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");let n=kR(this.elementShape,this.tensors,e),r=this.tensors.pop();return xR(r.shape,e,"TensorList shape mismatch: "),Lc(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(xR(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");pl(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);let t=new NR([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);xR(this.tensors[e].shape,t,"TensorList shape mismatch: ");let r=kR(this.elementShape,this.tensors,t);return Lc(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);xR(this.elementShape,t.shape,"TensorList shape mismatch: "),pl(t),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);xR(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());let r=kR(this.elementShape,this.tensors,n);return 0===e.length?si([],[0].concat(r)):ul((()=>{let t=e.map((e=>Lc(this.tensors[e],r)));return xg(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);xR(this.elementShape,t,"TensorList shape mismatch: ");let n=kR(this.elementShape,this.tensors,t);return 0===this.size()?si([],[0].concat(n)):ul((()=>{let e=this.tensors.map((e=>Lc(e,n)));return Uc(e,0)}))}};function TR(e,t,n){let r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);let a=e.shape.slice(1);xR(a,t,"TensorList shape mismatch: ");let s=Wg(e);return new NR(s,t,r)}function _R(e,t,n){return new NR([],e,t,n)}function CR(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let a=Math.max(...t);if(null!=r&&-1!==r&&a>=r)throw new Error(`Max index must be < array size (${a}  vs. ${r})`);let s=new NR([],n,e.dtype,r),i=Wg(e,0);return t.forEach(((e,t)=>{s.setItem(e,i[t])})),s}function ER(e,t,n){let r=0,a=t.map((e=>(r+=e,r)));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);let s=e.shape.slice(1),i=IR(s,n),o=0===r?0:e.size/r,l=ul((()=>{let n=[];e=Lc(e,[1,r,o]);for(let r=0;r<t.length;++r){let s=0===r?0:a[r-1],l=[0,s,0],u=[1,t[r],o];n[r]=Lc(qc(e,l,u),i)}return e.dispose(),n})),u=new NR([],n,e.dtype,t.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}var AR=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{let r=uF("thenBranch",e,t,n),a=uF("elseBranch",e,t,n),s=uF("cond",e,t,n),i=uF("args",e,t,n);return(await s.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[a].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{let r=uF("body",e,t,n),a=uF("cond",e,t,n),s=uF("args",e,t,n),i=await n.functionMap[a].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),o=s.map((e=>e.id)),l=await i[0].data();i.forEach((e=>{!e.kept&&-1===o.indexOf(e.id)&&e.dispose()}));let u=s;for(;l[0];){let e=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);let t=u.map((e=>e.id));e.forEach((e=>{!e.kept&&-1===o.indexOf(e.id)&&-1===t.indexOf(e.id)&&e.dispose()}));let s=await n.functionMap[a].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await s[0].data(),s.forEach((e=>{!e.kept&&-1===o.indexOf(e.id)&&-1===t.indexOf(e.id)&&e.dispose()}))}return u}case"LoopCond":{let r=uF("pred",e,t,n);return[gF(r)]}case"Switch":{let r=uF("pred",e,t,n),a=uF("data",e,t,n);return a.kept||(a=gF(a)),(await r.data())[0]?[void 0,a]:[a,void 0]}case"Merge":{let r=e.inputNames.find((e=>void 0!==cF(e,t,n)));if(r){let e=cF(r,t,n);return[gF(e)]}return}case"Enter":{let r=uF("frameName",e,t,n),a=uF("tensor",e,t,n);return n.enterFrame(r),[gF(a)]}case"Exit":{let r=uF("tensor",e,t,n);return n.exitFrame(),[gF(r)]}case"NextIteration":{let r=uF("tensor",e,t,n);return n.nextIteration(),[gF(r)]}case"TensorArrayV3":{let r=uF("size",e,t,n),a=uF("dtype",e,t,n),s=uF("elementShape",e,t,n),i=uF("dynamicSize",e,t,n),o=uF("clearAfterRead",e,t,n),l=uF("identicalElementShapes",e,t,n),u=uF("name",e,t,n),c=new SR(u,a,r,s,l,i,o);return n.addTensorArray(c),[c.idTensor,Md(1)]}case"TensorArrayWriteV3":{let r=uF("tensorArrayId",e,t,n),a=uF("index",e,t,n),s=uF("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(a,s),[i.idTensor]}case"TensorArrayReadV3":{let r=uF("tensorArrayId",e,t,n),a=uF("index",e,t,n);return[n.getTensorArray(r.id).read(a)]}case"TensorArrayGatherV3":{let r=uF("tensorArrayId",e,t,n),a=uF("indices",e,t,n),s=uF("dtype",e,t,n);return[n.getTensorArray(r.id).gather(a,s)]}case"TensorArrayScatterV3":{let r=uF("tensorArrayId",e,t,n),a=uF("indices",e,t,n),s=uF("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(a,s),[i.idTensor]}case"TensorArrayConcatV3":{let r=uF("tensorArrayId",e,t,n),a=n.getTensorArray(r.id),s=uF("dtype",e,t,n);return[a.concat(s)]}case"TensorArraySplitV3":{let r=uF("tensorArrayId",e,t,n),a=uF("tensor",e,t,n),s=uF("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(s,a),[i.idTensor]}case"TensorArraySizeV3":{let r=uF("tensorArrayId",e,t,n),a=n.getTensorArray(r.id);return[Md(a.size(),"int32")]}case"TensorArrayCloseV3":{let r=uF("tensorArrayId",e,t,n),a=n.getTensorArray(r.id);return a.clearAndClose(),[a.idTensor]}case"TensorListSetItem":{let r=uF("tensorListId",e,t,n),a=uF("index",e,t,n),s=uF("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(a,s),[i.idTensor]}case"TensorListGetItem":{let r=uF("tensorListId",e,t,n),a=uF("index",e,t,n),s=uF("elementShape",e,t,n),i=uF("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(a,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let r=uF("indices",e,t,n),a=uF("tensor",e,t,n),s=uF("elementShape",e,t,n),i=uF("numElements",e,t,n),o=CR(a,r,s,i);return n.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r,a=uF("elementShape",e,t,n),s=uF("elementDType",e,t,n);r="TensorListReserve"===e.op?"numElements":"maxNumElements";let i=uF(r,e,t,n),o=_R(a,s,i);return n.addTensorList(o),[o.idTensor]}case"TensorListGather":{let r=uF("tensorListId",e,t,n),a=uF("indices",e,t,n),s=uF("elementShape",e,t,n),i=uF("elementDType",e,t,n);return[n.getTensorList(r.id).gather(a,i,s)]}case"TensorListStack":{let r=uF("tensorListId",e,t,n),a=uF("elementShape",e,t,n),s=uF("elementDType",e,t,n),i=uF("numElements",e,t,n);return[n.getTensorList(r.id).stack(a,s,i)]}case"TensorListFromTensor":{let r=uF("tensor",e,t,n),a=uF("elementShape",e,t,n),s=uF("elementDType",e,t,n),i=TR(r,a,s);return n.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let r=uF("tensorListId",e,t,n),a=n.getTensorList(r.id),s=uF("dtype",e,t,n),i=uF("elementShape",e,t,n);return[a.concat(s,i)]}case"TensorListPushBack":{let r=uF("tensorListId",e,t,n),a=uF("tensor",e,t,n),s=n.getTensorList(r.id);return s.pushBack(a),[s.idTensor]}case"TensorListPopBack":{let r=uF("tensorListId",e,t,n),a=uF("elementShape",e,t,n),s=uF("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(a,s)]}case"TensorListSplit":{let r=uF("tensor",e,t,n),a=uF("elementShape",e,t,n),s=uF("lengths",e,t,n),i=ER(r,s,a);return n.addTensorList(i),[i.idTensor]}case"TensorListLength":{let r=uF("tensorListId",e,t,n),a=n.getTensorList(r.id);return[Md(a.size(),"int32")]}case"TensorListResize":{let r=uF("tensorListId",e,t,n),a=uF("size",e,t,n),s=n.getTensorList(r.id).resize(a);return n.addTensorList(s),[s.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function $R(e,t,n){let[r,a]=uF("fusedOps",e,t,n),s="biasadd"===r,i=!s,o="prelu"===a,l="fusedbatchnorm"===r,u=uF("numArgs",e,t,n);if(s){if(o&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&s&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let c=uF("strides",e,t,n),p=mF(e,t,n),d=uF("dataFormat",e,t,n).toUpperCase(),h=uF("dilations",e,t,n),[f,m]=uF("args",e,t,n);i&&(m=f,f=void 0);let g=uF("leakyreluAlpha",e,t,n);return{stride:c,pad:p,dataFormat:d,dilations:h,biasArg:f,preluArg:m,activationFunc:a,leakyreluAlpha:g}}var FR=(e,t,n)=>{switch(e.op){case"Conv1D":{let r=uF("stride",e,t,n),a=uF("pad",e,t,n),s=uF("dataFormat",e,t,n).toUpperCase(),i=uF("dilation",e,t,n);return[Ap(uF("x",e,t,n),uF("filter",e,t,n),r,a,s,i)]}case"Conv2D":{let r=uF("strides",e,t,n),a=mF(e,t,n),s=uF("dataFormat",e,t,n).toUpperCase(),i=uF("dilations",e,t,n);return[Cp(uF("x",e,t,n),uF("filter",e,t,n),[r[1],r[2]],a,s,[i[1],i[2]])]}case"_FusedConv2D":{let{stride:r,pad:a,dataFormat:s,dilations:i,biasArg:o,preluArg:l,activationFunc:u,leakyreluAlpha:c}=$R(e,t,n);return[py.conv2d({x:uF("x",e,t,n),filter:uF("filter",e,t,n),strides:[r[1],r[2]],pad:a,dataFormat:s,dilations:[i[1],i[2]],bias:o,activation:u,preluActivationWeights:l,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{let{stride:r,pad:a,dataFormat:s,dilations:i,biasArg:o,preluArg:l,activationFunc:u,leakyreluAlpha:c}=$R(e,t,n);return[py.depthwiseConv2d({x:uF("x",e,t,n),filter:uF("filter",e,t,n),strides:[r[1],r[2]],pad:a,dataFormat:s,dilations:[i[1],i[2]],bias:o,activation:u,preluActivationWeights:l,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let r=uF("outputShape",e,t,n),a=uF("strides",e,t,n),s=mF(e,t,n);return[Dp(uF("x",e,t,n),uF("filter",e,t,n),r,[a[1],a[2]],s)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let r=uF("strides",e,t,n),a=mF(e,t,n),s=uF("dilations",e,t,n),i=uF("dataFormat",e,t,n).toUpperCase();return[ed(uF("input",e,t,n),uF("filter",e,t,n),[r[1],r[2]],a,i,[s[1],s[2]])]}case"Conv3D":{let r=uF("strides",e,t,n),a=uF("pad",e,t,n),s=uF("dataFormat",e,t,n).toUpperCase(),i=uF("dilations",e,t,n);return[Op(uF("x",e,t,n),uF("filter",e,t,n),[r[1],r[2],r[3]],a,s,[i[1],i[2],i[3]])]}case"AvgPool":{let r=uF("strides",e,t,n),a=uF("pad",e,t,n),s=uF("kernelSize",e,t,n);return[zc(uF("x",e,t,n),[s[1],s[2]],[r[1],r[2]],a)]}case"MaxPool":{let r=uF("strides",e,t,n),a=uF("pad",e,t,n),s=uF("kernelSize",e,t,n);return[lf(uF("x",e,t,n),[s[1],s[2]],[r[1],r[2]],a)]}case"MaxPoolWithArgmax":{let r=uF("strides",e,t,n),a=uF("pad",e,t,n),s=uF("kernelSize",e,t,n),i=uF("includeBatchInIndex",e,t,n),{result:o,indexes:l}=df(uF("x",e,t,n),[s[1],s[2]],[r[1],r[2]],a,i);return[o,l]}case"AvgPool3D":{let r=uF("strides",e,t,n),a=uF("pad",e,t,n),s=uF("kernelSize",e,t,n);return[Wc(uF("x",e,t,n),[s[1],s[2],s[3]],[r[1],r[2],r[3]],a)]}case"MaxPool3D":{let r=uF("strides",e,t,n),a=uF("pad",e,t,n),s=uF("kernelSize",e,t,n);return[cf(uF("x",e,t,n),[s[1],s[2],s[3]],[r[1],r[2],r[3]],a)]}case"Dilation2D":{let r=uF("strides",e,t,n),a=uF("pad",e,t,n),s=uF("dilations",e,t,n),i=r[1],o=r[2],l=s[1],u=s[2];return[ad(uF("x",e,t,n),uF("filter",e,t,n),[i,o],a,[l,u],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},RR=(e,t,n)=>{switch(e.op){case"Fill":{let r=uF("shape",e,t,n),a=uF("dtype",e,t,n),s=uF("value",e,t,n);return[rh(r,s,a)]}case"LinSpace":{let r=uF("start",e,t,n),a=uF("stop",e,t,n),s=uF("num",e,t,n);return[Sh(r,a,s)]}case"Multinomial":{let r=uF("logits",e,t,n),a=uF("numSamples",e,t,n),s=uF("seed",e,t,n);return[$f(r,a,s)]}case"OneHot":{let r=uF("indices",e,t,n),a=uF("depth",e,t,n),s=uF("onValue",e,t,n),i=uF("offValue",e,t,n);return[el(r,a,s,i)]}case"Ones":return[bf(uF("shape",e,t,n),uF("dtype",e,t,n))];case"OnesLike":return[Mf(uF("x",e,t,n))];case"RandomUniform":return[mm(uF("shape",e,t,n),uF("minval",e,t,n),uF("maxval",e,t,n),uF("dtype",e,t,n))];case"Range":{let r=uF("start",e,t,n),a=uF("stop",e,t,n),s=uF("step",e,t,n);return[gm(r,a,s,uF("dtype",e,t,n))]}case"TruncatedNormal":{let r=uF("shape",e,t,n),a=uF("mean",e,t,n),s=uF("stdDev",e,t,n),i=uF("seed",e,t,n);return[Mg(r,a,s,uF("dtype",e,t,n),i)]}case"Zeros":return[yf(uF("shape",e,t,n),uF("dtype",e,t,n))];case"ZerosLike":return[cd(uF("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function DR(e,t,n){let r=uF("boxes",e,t,n),a=uF("scores",e,t,n),s=uF("maxOutputSize",e,t,n),i=uF("iouThreshold",e,t,n),o=uF("scoreThreshold",e,t,n),l=uF("softNmsSigma",e,t,n);return{boxes:r,scores:a,maxOutputSize:s,iouThreshold:i,scoreThreshold:o,softNmsSigma:l}}var MR=async(e,t,n)=>{switch(e.op){case"NonMaxSuppressionV5":{let{boxes:r,scores:a,maxOutputSize:s,iouThreshold:i,scoreThreshold:o,softNmsSigma:l}=DR(e,t,n),u=await hw.nonMaxSuppressionWithScoreAsync(r,a,s,i,o,l);return[u.selectedIndices,u.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:r,scores:a,maxOutputSize:s,iouThreshold:i,scoreThreshold:o}=DR(e,t,n),l=uF("padToMaxOutputSize",e,t,n),u=await hw.nonMaxSuppressionPaddedAsync(r,a,s,i,o,l);return[u.selectedIndices,u.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:r,scores:a,maxOutputSize:s,iouThreshold:i,scoreThreshold:o}=DR(e,t,n);return[await hw.nonMaxSuppressionAsync(r,a,s,i,o)]}case"Where":{let r=go(uF("condition",e,t,n),"bool"),a=[await jg(r)];return r.dispose(),a}case"ListDiff":return Vm(uF("x",e,t,n),uF("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}},OR=(e,t,n)=>{switch(e.op){case"LowerBound":{let r=uF("sortedSequence",e,t,n),a=uF("values",e,t,n);return[sf(r,a)]}case"TopKV2":{let r=uF("x",e,t,n),a=uF("k",e,t,n),s=uF("sorted",e,t,n),i=Rg(r,a,s);return[i.values,i.indices]}case"UpperBound":{let r=uF("sortedSequence",e,t,n),a=uF("values",e,t,n);return[Vg(r,a)]}case"Unique":{let r=uF("x",e,t,n),a=Lg(r);return[a.values,a.indices]}case"UniqueV2":{let r=uF("x",e,t,n),a=uF("axis",e,t,n),s=Lg(r,a);return[s.values,s.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},LR=(e,t,n)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let r=uF("default",e,t,n);return[cF(e.name,t,n)||r];case"Placeholder":return[cF(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let r=uF("x",e,t,n);return[gF(r)]}case"IdentityN":return uF("x",e,t,n).map((e=>gF(e)));case"Snapshot":let a=uF("x",e,t,n);return[gF(a)];case"Shape":return[_g(uF("x",e,t,n).shape,"int32")];case"ShapeN":return uF("x",e,t,n).map((e=>_g(e.shape)));case"Size":return[Md(uF("x",e,t,n).size,"int32")];case"Rank":return[Md(uF("x",e,t,n).rank,"int32")];case"NoOp":return[Md(1)];case"Print":let s=uF("x",e,t,n),i=uF("data",e,t,n),o=uF("message",e,t,n),l=uF("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(let e=0;e<i.length;e++)console.log(Array.prototype.slice.call(i[e].dataSync()).slice(0,l));return[s];default:throw TypeError(`Node type ${e.op} is not implemented`)}},PR=class{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=Md(0),this.tensorMap=new Map,pl(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Md(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),ul((()=>{let e=Wg(t),r=n.length,a=e.length;Na.assert(r===a,(()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${a} elements.`));for(let t=0;t<r;t++){let r=n[t],a=e[t];pl(a),this.tensorMap.set(r,a)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return ul((()=>{let e=[];for(let r=0;r<n.length;r++){let a=n[r],s=this.findWithDefault(a,t);e.push(s)}return xg(e)}))}findWithDefault(e,t){let n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}},zR=async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{let a=uF("keyDType",e,t,n),s=uF("valueDType",e,t,n),i=new PR(a,s);return r.addHashTable(e.name,i),[i.handle]}case"LookupTableImport":case"LookupTableImportV2":{let a=uF("tableHandle",e,t,n,r),s=uF("keys",e,t,n),i=uF("values",e,t,n);return[await r.getHashTableById(a.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let a=uF("tableHandle",e,t,n,r),s=uF("keys",e,t,n),i=uF("defaultValue",e,t,n);return[await r.getHashTableById(a.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let a=uF("tableHandle",e,t,n,r);return[r.getHashTableById(a.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},BR=(e,t,n)=>{switch(e.op){case"ResizeBilinear":{let r=uF("images",e,t,n),a=uF("size",e,t,n),s=uF("alignCorners",e,t,n),i=uF("halfPixelCenters",e,t,n);return[hw.resizeBilinear(r,[a[0],a[1]],s,i)]}case"ResizeNearestNeighbor":{let r=uF("images",e,t,n),a=uF("size",e,t,n),s=uF("alignCorners",e,t,n),i=uF("halfPixelCenters",e,t,n);return[hw.resizeNearestNeighbor(r,[a[0],a[1]],s,i)]}case"CropAndResize":{let r=uF("image",e,t,n),a=uF("boxes",e,t,n),s=uF("boxInd",e,t,n),i=uF("cropSize",e,t,n),o=uF("method",e,t,n),l=uF("extrapolationValue",e,t,n);return[hw.cropAndResize(r,a,s,i,o,l)]}case"ImageProjectiveTransformV3":{let r=uF("images",e,t,n),a=uF("transforms",e,t,n),s=uF("outputShape",e,t,n),i=uF("fillValue",e,t,n),o=uF("interpolation",e,t,n),l=uF("fillMode",e,t,n);return[hw.transform(r,a,o.toLowerCase(),l.toLowerCase(),i,s)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},WR=(e,t,n)=>{switch(e.op){case"Equal":return[id(uF("a",e,t,n),uF("b",e,t,n))];case"NotEqual":return[Rf(uF("a",e,t,n),uF("b",e,t,n))];case"Greater":return[uh(uF("a",e,t,n),uF("b",e,t,n))];case"GreaterEqual":return[ph(uF("a",e,t,n),uF("b",e,t,n))];case"Less":return[vh(uF("a",e,t,n),uF("b",e,t,n))];case"LessEqual":return[Ih(uF("a",e,t,n),uF("b",e,t,n))];case"LogicalAnd":return[Xh(uF("a",e,t,n),uF("b",e,t,n))];case"LogicalNot":return[Jh(uF("a",e,t,n))];case"LogicalOr":return[Qh(uF("a",e,t,n),uF("b",e,t,n))];case"Select":case"SelectV2":return[ld(uF("condition",e,t,n),uF("a",e,t,n),uF("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},VR=(e,t,n)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[Zo(uF("a",e,t,n),uF("b",e,t,n),uF("transposeA",e,t,n),uF("transposeB",e,t,n))];case"Einsum":return[gd(uF("equation",e,t,n),...uF("tensors",e,t,n))];case"Transpose":return[El(uF("x",e,t,n),uF("perm",e,t,n))];case"_FusedMatMul":let[r,a]=uF("fusedOps",e,t,n),s="biasadd"===r,i="prelu"===a,o=uF("numArgs",e,t,n),l=uF("leakyreluAlpha",e,t,n);if(s){if(i&&2!==o)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&1!==o)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[u,c]=uF("args",e,t,n);return[py.matMul({a:uF("a",e,t,n),b:uF("b",e,t,n),transposeA:uF("transposeA",e,t,n),transposeB:uF("transposeB",e,t,n),bias:u,activation:a,preluActivationWeights:c,leakyreluAlpha:l})];default:throw TypeError(`Node type ${e.op} is not implemented`)}},UR=(e,t,n)=>{switch(e.op){case"EuclideanNorm":return[jd(uF("x",e,t,n),uF("axis",e,t,n),uF("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[np(uF("x",e,t,n),uF("mean",e,t,n),uF("variance",e,t,n),uF("offset",e,t,n),uF("scale",e,t,n),uF("epsilon",e,t,n))];case"FusedBatchNormV3":return[np(uF("x",e,t,n),uF("mean",e,t,n),uF("variance",e,t,n),uF("offset",e,t,n),uF("scale",e,t,n),uF("epsilon",e,t,n))];case"LRN":return[Th(uF("x",e,t,n),uF("radius",e,t,n),uF("bias",e,t,n),uF("alpha",e,t,n),uF("beta",e,t,n))];case"Softmax":return[ag(uF("x",e,t,n))];case"LogSoftmax":return[Hh(uF("x",e,t,n))];case"SparseToDense":return[ty(uF("sparseIndices",e,t,n),uF("outputShape",e,t,n),uF("sparseValues",e,t,n),uF("defaultValue",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},GR=(e,t,n)=>{switch(e.op){case"Max":{let r=uF("axis",e,t,n),a=uF("keepDims",e,t,n);return[Ad(uF("x",e,t,n),r,a)]}case"Mean":{let r=uF("axis",e,t,n),a=uF("keepDims",e,t,n);return[gf(uF("x",e,t,n),r,a)]}case"Min":{let r=uF("axis",e,t,n),a=uF("keepDims",e,t,n);return[Fd(uF("x",e,t,n),r,a)]}case"Sum":{let r=uF("axis",e,t,n),a=uF("keepDims",e,t,n);return[Wd(uF("x",e,t,n),r,a)]}case"All":{let r=uF("axis",e,t,n),a=uF("keepDims",e,t,n);return[tc(uF("x",e,t,n),r,a)]}case"Any":{let r=uF("axis",e,t,n),a=uF("keepDims",e,t,n);return[rc(uF("x",e,t,n),r,a)]}case"ArgMax":{let r=uF("axis",e,t,n);return[sc(uF("x",e,t,n),r)]}case"ArgMin":{let r=uF("axis",e,t,n);return[oc(uF("x",e,t,n),r)]}case"Prod":{let r=uF("axis",e,t,n),a=uF("keepDims",e,t,n);return[rm(uF("x",e,t,n),r,a)]}case"Cumprod":{let r=uF("axis",e,t,n),a=uF("exclusive",e,t,n),s=uF("reverse",e,t,n);return[jp(uF("x",e,t,n),r,a,s)]}case"Cumsum":{let r=uF("axis",e,t,n),a=uF("exclusive",e,t,n),s=uF("reverse",e,t,n);return[Kp(uF("x",e,t,n),r,a,s)]}case"Bincount":let r=uF("x",e,t,n),a=uF("weights",e,t,n),s=uF("size",e,t,n);return[cp(r,a,s)];case"DenseBincount":{let r=uF("x",e,t,n),a=uF("weights",e,t,n),s=uF("size",e,t,n),i=uF("binaryOutput",e,t,n);return[Yp(r,a,s,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},HR=(e,t,n)=>{switch(e.op){case"ConcatV2":case"Concat":{let r=uF("n",e,t,n),a=uF("axis",e,t,n),s=uF("tensors",e,t,n);return s=s.slice(0,r),[Uc(s,a)]}case"Gather":{let r=uF("x",e,t,n),a=uF("indices",e,t,n);return[oh(r,go(a,"int32"),0)]}case"GatherV2":{let r=uF("axis",e,t,n),a=uF("batchDims",e,t,n),s=uF("x",e,t,n),i=uF("indices",e,t,n);return[oh(s,go(i,"int32"),r,a)]}case"Reverse":{let r=uF("dims",e,t,n),a=[];for(let e=0;e<r.length;e++)r[e]&&a.push(e);let s=uF("x",e,t,n);return[Sm(s,a)]}case"ReverseV2":{let r=uF("axis",e,t,n),a=uF("x",e,t,n);return[Sm(a,r)]}case"Slice":{let r=uF("begin",e,t,n),a=uF("size",e,t,n);return[qc(uF("x",e,t,n),r,a)]}case"StridedSlice":{let r=uF("begin",e,t,n),a=uF("end",e,t,n),s=uF("strides",e,t,n),i=uF("beginMask",e,t,n),o=uF("endMask",e,t,n),l=uF("ellipsisMask",e,t,n),u=uF("newAxisMask",e,t,n),c=uF("shrinkAxisMask",e,t,n),p=uF("x",e,t,n);return[Sg(p,r,a,s,i,o,l,u,c)]}case"Pack":return ul((()=>{let r=uF("axis",e,t,n),a=uF("tensors",e,t,n),s=a[0].shape,i=bg(a[0]).shape,o=a.map((e=>{let t=Na.arraysEqual(e.shape,s);if(!t&&!Na.arraysEqual(bg(e).shape,i))throw new Error("the input tensors shape does not match");return t?e:Lc(e,s)}));return[xg(o,r)]}));case"Unpack":{let r=uF("axis",e,t,n),a=uF("tensor",e,t,n);return Wg(a,r)}case"Tile":{let r=uF("reps",e,t,n);return[eh(uF("x",e,t,n),r)]}case"Split":case"SplitV":{let r=uF("axis",e,t,n),a=uF("numOrSizeSplits",e,t,n),s=uF("x",e,t,n);return dg(s,a,r)}case"ScatterNd":{let r=uF("indices",e,t,n),a=uF("values",e,t,n),s=uF("shape",e,t,n);return[Zg(r,a,s)]}case"GatherNd":{let r=uF("x",e,t,n),a=uF("indices",e,t,n);return[ry(r,a)]}case"SparseToDense":{let r=uF("sparseIndices",e,t,n),a=uF("outputShape",e,t,n),s=uF("sparseValues",e,t,n),i=uF("defaultValue",e,t,n);return[ty(r,s,a,s.dtype===i.dtype?i:go(i,s.dtype))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},jR=(e,t,n)=>{switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:r,outputValues:a,emptyRowIndicator:s,reverseIndexMap:i}=gw.sparseFillEmptyRows(uF("indices",e,t,n),uF("values",e,t,n),uF("denseShape",e,t,n),uF("defaultValue",e,t,n));return[r,a,s,i]}case"SparseReshape":{let{outputIndices:r,outputShape:a}=gw.sparseReshape(uF("inputIndices",e,t,n),uF("inputShape",e,t,n),uF("newShape",e,t,n));return[r,a]}case"SparseSegmentMean":return[gw.sparseSegmentMean(uF("data",e,t,n),uF("indices",e,t,n),uF("segmentIds",e,t,n))];case"SparseSegmentSum":return[gw.sparseSegmentSum(uF("data",e,t,n),uF("indices",e,t,n),uF("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},qR=(e,t,n)=>{switch(e.op){case"FFT":return[ig(uF("x",e,t,n))];case"IFFT":return[lg(uF("x",e,t,n))];case"RFFT":return[fg(uF("x",e,t,n))];case"IRFFT":return[cg(uF("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},KR=(e,t,n)=>{switch(e.op){case"StringNGrams":{let{nGrams:r,nGramsSplits:a}=yw.stringNGrams(uF("data",e,t,n),uF("dataSplits",e,t,n),uF("separator",e,t,n),uF("nGramWidths",e,t,n),uF("leftPad",e,t,n),uF("rightPad",e,t,n),uF("padWidth",e,t,n),uF("preserveShortSequences",e,t,n));return[r,a]}case"StringSplit":{let{indices:r,values:a,shape:s}=yw.stringSplit(uF("input",e,t,n),uF("delimiter",e,t,n),uF("skipEmpty",e,t,n));return[r,a,s]}case"StringToHashBucketFast":return[yw.stringToHashBucketFast(uF("input",e,t,n),uF("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},XR=(e,t,n)=>{switch(e.op){case"Cast":return[go(uF("x",e,t,n),uF("dtype",e,t,n))];case"ExpandDims":{let r=uF("axis",e,t,n);return[Yd(uF("x",e,t,n),r)]}case"Squeeze":{let r=uF("axis",e,t,n);return[bg(uF("x",e,t,n),r)]}case"Reshape":return[Lc(uF("x",e,t,n),uF("shape",e,t,n))];case"MirrorPad":return[If(uF("x",e,t,n),uF("padding",e,t,n),uF("mode",e,t,n))];case"PadV2":case"Pad":return[zf(uF("x",e,t,n),uF("padding",e,t,n),uF("constantValue",e,t,n))];case"SpaceToBatchND":{let r=uF("blockShape",e,t,n),a=uF("paddings",e,t,n);return[Xf(uF("x",e,t,n),r,a)]}case"BatchToSpaceND":{let r=uF("blockShape",e,t,n),a=uF("crops",e,t,n);return[Qc(uF("x",e,t,n),r,a)]}case"DepthToSpace":{let r=uF("blockSize",e,t,n),a=uF("dataFormat",e,t,n).toUpperCase();return[Zp(uF("x",e,t,n),r,a)]}case"BroadcastTo":return[fp(uF("x",e,t,n),uF("shape",e,t,n))];case"BroadcastArgs":return[dp(uF("s0",e,t,n),uF("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function YR(e,t,n,r){let a=((e,t,n)=>{switch(e.category){case"arithmetic":return ul((()=>bR(e,t,n)));case"basic_math":return ul((()=>wR(e,t,n)));case"control":return AR(e,t,n);case"convolution":return ul((()=>FR(e,t,n)));case"creation":return ul((()=>RR(e,t,n)));case"dynamic":return MR(e,t,n);case"evaluation":return ul((()=>OR(e,t,n)));case"image":return ul((()=>BR(e,t,n)));case"graph":return ul((()=>LR(e,t,n)));case"logical":return ul((()=>WR(e,t,n)));case"matrices":return ul((()=>VR(e,t,n)));case"normalization":return ul((()=>UR(e,t,n)));case"reduction":return ul((()=>GR(e,t,n)));case"slice_join":return ul((()=>HR(e,t,n)));case"sparse":return ul((()=>jR(e,t,n)));case"spectral":return ul((()=>qR(e,t,n)));case"string":return ul((()=>KR(e,t,n)));case"transformation":return ul((()=>XR(e,t,n)));case"hash_table":return zR(e,t,n,r);case"custom":let a=oF(e.op);if(a&&a.customExecutor)return a.customExecutor(new yR(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return Na.isPromise(a)?a.then((e=>[].concat(e))):[].concat(a)}var JR=class{constructor(e={},t={},n={},r={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function ZR(e,t,n,r){let a=new Set,s=[],i=null,o=null,l=new Set,u=Object.keys(e).map((e=>fF(e)[0])),c=[];null!=r&&(c=r.map((e=>fF(e.name)[0])));let p=[...t];for(;p.length>0;){let e=p.pop();if((rD(e)||aD(e)||sD(e))&&null==i&&(i=e,o=i.children.map((e=>e.name)).filter((e=>a.has(e)))),a.add(e.name),null==n[e.name]&&-1===u.indexOf(e.name)&&-1===c.indexOf(e.name)){if(0===e.inputs.length){s.push(e.name);continue}e.inputs.forEach((e=>{l.has(e.name)||(l.add(e.name),p.push(e))}))}}return{inputs:e,outputs:t,usedNodes:a,missingInputs:s,dynamicNode:i,syncInputs:o}}function QR(e,t,n){let{usedNodes:r,inputs:a}=n,s=[],i=Object.keys(a).map((e=>fF(e)[0])).map((t=>e.nodes[t])),o=e.initNodes;i.forEach((e=>{r.has(e.name)&&s.push(e)})),e.weights.forEach((e=>{r.has(e.name)&&s.push(e)})),null!=o&&o.forEach((e=>{r.has(e.name)&&s.push(e)}));let l=new Set,u=[];for(;s.length>0;){let e=s.pop();l.add(e.name),t[e.name]||u.push(e),e.children.forEach((e=>{!l.has(e.name)&&r.has(e.name)&&e.inputs.every((e=>l.has(e.name)))&&s.push(e)}))}return u}var eD=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],tD=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],nD=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function rD(e){return eD.indexOf(e.op)>=0}function aD(e){return tD.indexOf(e.op)>=0}function sD(e){return nD.indexOf(e.op)>=0}var iD=class{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new iD(e.functions[t],this)}))}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){let t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{let t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}getCompilationKey(e,t){let n=e.map((e=>e.name)).sort(),r=t.map((e=>e.name)).sort();return n.join(this.SEPERATOR)+"--"+r.join(this.SEPERATOR)}compile(e,t){let n=ZR(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:a,syncInputs:s}=n;if(null!=a)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${s}]`);if(r.length>0){let n=t.map((e=>e.name)),a=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${a}]. Missing the following inputs: [${r}]`)}return QR(this.graph,this.weightMap,n)}execute(e,t){e=this.mapInputs(e);let n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);let r=n.map((e=>this.graph.nodes[fF(e)[0]])),a=t.map((e=>fF(e)[0])),s=a.map((e=>this.graph.nodes[e]));this.resetIntermediateTensors(),0===s.length&&(s=this._outputs);let i=this.getCompilationKey(r,s),o=this.compiledMap.get(i);null==o&&(o=this.compile(e,s),this.compiledMap.set(i,o));let l={},u={};return ul((()=>{let n=new JR(this.weightMap,l,u,this.functionExecutorMap),r=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{let[n,a]=fF(t),s=[];s[a]=e[t],r[n]=s}));let s=this.getFrozenTensorIds(r),i={};for(let e=0;e<o.length;e++){let t=o[e];if(!r[t.name]){let e=YR(t,r,n,this._resourceManager);if(Na.isPromise(e))throw new Error(`The execution of the op '${t.op}' returned a promise. Please use model.executeAsync() instead.`);r[t.name]=e,this.checkTensorForDisposal(t.name,t,r,n,s,a,i)}}return null==this.parent&&n.dispose(s),t.map((e=>cF(e,r,n)))}))}getFrozenTensorIds(e){let t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,r,a,s,i){"control"===t.category||-1!==s.indexOf(e)||(n[e].forEach((e=>{null!=e&&(i[e.id]=(i[e.id]||0)+t.children.length)})),t.inputs.forEach((e=>{if("control"!==e.category){let s=pF(e.name,n,r);null!=s&&s.forEach((e=>{if(e&&!e.kept&&!a.has(e.id)){let n=i[e.id];if(1===n){if(this.keepTensorForDebug){let[n,a]=dF(t.name,r);this.intermediateTensors[n]||(this.intermediateTensors[n]=[]),this.intermediateTensors[n][a]=e}else e.dispose();delete i[e.id]}else null!=n&&i[e.id]--}}))}})))}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){!this.intermediateTensors||(Object.keys(this.intermediateTensors).forEach((e=>this.intermediateTensors[e].forEach((e=>e.dispose())))),this.disposeTensorsMap())}disposeTensorsMap(){!this.tensorsMap||Object.keys(this.tensorsMap).forEach((e=>{this.tensorsMap[e].forEach((e=>{e&&!e.kept&&!e.isDisposed&&!this.keepIds.has(e.id)&&e.dispose()}))}))}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(let e in this.intermediateTensors)this.intermediateTensors[e].forEach((e=>e.dispose())),delete this.intermediateTensors[e]}async _executeAsync(e,t,n=!1,r={},a={}){n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepTensorForDebug=Xe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(u){console.warn(u.message)}this.resetIntermediateTensors();let s=new JR(this.weightMap,r,a,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(e,s,t,n);let i=t.map((e=>cF(e,this.tensorsMap,s))),o=i.map((e=>e.id)),l=Object.keys(e).map((t=>e[t].id));return this.keepIds=new Set([...o,...l,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),null==this.parent&&s.dispose(this.keepIds),i}async executeFunctionAsync(e,t,n){let r=e.reduce(((e,t,n)=>(e[this.inputs[n].name]=t,e)),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){let a=Object.keys(e),s=a.map((e=>this.graph.nodes[fF(e)[0]])),i=n.map((e=>fF(e)[0])),o=i.map((e=>this.graph.nodes[e]));0===o.length&&(o=this._outputs);let{usedNodes:l,missingInputs:u,dynamicNode:c,syncInputs:p}=ZR(e,o,this.weightMap,this._initNodes),d=[...s,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),h=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{let[n,r]=fF(t),a=[];a[r]=e[t],h[n]=a}));let f={},m=this.getFrozenTensorIds(h),g={};for(;d.length>0;){let e=this.processStack(s,d,t,h,g,m,i,f,l);await Promise.all(e)}null==c&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let y=o.filter((e=>!rD(e)&&!cF(e.name,h,t))).map((e=>e.name));if(y.length>0){let e="";throw null!=c&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${y}] from the provided inputs [${a}]. Consider providing the following inputs: [${u}]. ${e}`)}return h}processStack(e,t,n,r,a,s,i,o,l){let u=[];for(;t.length>0;){let e=t.pop();n.currentContext=e.contexts;let c="";if("Enter"===e.node.op&&uF("isConstant",e.node,r,n)&&([c]=dF(e.node.name,n)),null==r[e.node.name]){let p=YR(e.node,r,n,this._resourceManager);c||([c]=dF(e.node.name,n));let d=n.currentContext;Na.isPromise(p)?u.push(p.then((u=>(r[c]=u,n.currentContext=d,this.checkTensorForDisposal(c,e.node,r,n,s,i,o),this.processChildNodes(e.node,t,n,r,a,l),u)))):(r[c]=p,this.checkTensorForDisposal(c,e.node,r,n,s,i,o),this.processChildNodes(e.node,t,n,r,a,l))}else this.processChildNodes(e.node,t,n,r,a,l)}return u}processChildNodes(e,t,n,r,a,s){e.children.forEach((e=>{let[i]=dF(e.name,n);a[i]||!s.has(e.name)||("Merge"===e.op?e.inputNames.some((e=>!!cF(e,r,n)))&&(a[i]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!cF(e,r,n)))&&(a[i]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{let n=e[t],[r]=fF(t),a=this.graph.nodes[r];if(a.attrParams.shape&&a.attrParams.shape.value){let e=a.attrParams.shape.value,t=e.length===n.shape.length&&n.shape.every(((t,n)=>-1===e[n]||e[n]===t));Na.assert(t,(()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`))}a.attrParams.dtype&&a.attrParams.dtype.value&&Na.assert(n.dtype===a.attrParams.dtype.value,(()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${n.dtype}`))}))}mapInputs(e){let t={};for(let n in e)if(null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[n]){let r=this._signature.inputs[n];t[r.name]=e[n]}else t[n]=e[n];return t}checkInputs(e){let t=Object.keys(e).filter((e=>{let[t]=fF(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map((e=>null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[e]?this._signature.outputs[e].name:e),{})}checkOutputs(e){e.forEach((e=>{let[t]=fF(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)}))}},oD=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}},lD="?tfjs-format=file",uD="model.json",cD=class{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",null==t&&(this.loadOptions={}),this.resourceManager=new oD}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){let e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=vo.browserHTTPRequest(e,this.loadOptions);else{let t=vo.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(vo.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return Na.isPromise(e)?e.then((e=>this.loadSync(e))):this.loadSync(e)}loadSync(e){this.artifacts=e;let t,n=this.artifacts.modelTopology;t=null!=this.artifacts.userDefinedMetadata&&null!=this.artifacts.userDefinedMetadata.signature?this.artifacts.userDefinedMetadata.signature:this.artifacts.signature,this.signature=t,this.version=`${n.versions.producer}.${n.versions.minConsumer}`;let r=vo.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new iD(tR.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){let t=tR.Instance.transformGraph(e.modelInitializer);this.initializer=new iD(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if("string"==typeof e){let t=vo.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof ys)&&!Array.isArray(e))return e;if(e=Array.isArray(e)?e:[e],e.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce(((t,n,r)=>(t[n]=e[r],t)),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>(t[n]=[e[n]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}};async function pD(e,t={}){if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof e&&(e=hD(e));let n=new cD(e,t);return await n.load(),n}function dD(e){if(null==e)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide a url or an IOHandler that loads the model");if(!e.load)throw new Error(`modelUrl IO Handler ${e} has no load function`);let t=new cD(e);return t.load(),t}function hD(e){return e.endsWith("/")||(e+="/"),`${e}${uD}${lD}`}var fD="3.18.0",mD={};g(mD,{CSVDataset:()=>dM,Dataset:()=>QD,FileDataSource:()=>TM,TextLineDataset:()=>sM,URLDataSource:()=>_M,array:()=>tM,csv:()=>CM,func:()=>EM,generator:()=>AM,microphone:()=>FM,version_data:()=>RM,webcam:()=>$M,zip:()=>nM});var gD=b(P()),yD=b(P());function bD(e,t){return wD(e,t)}function wD(e,t,n=new Map,r=new Set){if(null==e)return null;if("function"==typeof Blob&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);let a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(a.recurse){if(SD(e)){let a=Array.isArray(e)?[]:{};r.add(e);for(let s in e){let i=e[s],o=wD(i,t,n,r);a[s]=o}return r.delete(e),e.__proto__&&(a.__proto__=e.__proto__),a}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,a.value),a.value}function xD(e,t=kD){return vD(e,t)}function vD(e,t,n=new Set){let r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");let a=t(e);if(a.recurse&&null!==a.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(a.recurse){if(SD(r)){let a=Array.isArray(r)?[]:{};n.add(r);for(let s in r){let r=e.map((e=>e[s])),i=vD(r,t,n);a[s]=i}return n.delete(r),a}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return a.value}function kD(e){return null===e?null:SD(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function ID(e,t){let n=new Map;wD(e,t,n);for(let r of Array.from(n.keys())){let e=n.get(r);if(Na.isPromise(e)){let t=await e;n.set(r,t)}}return wD(e,t,n)}function SD(e){let t=!1;if(Xe().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=z();t=e instanceof n}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"==typeof e&&!(e instanceof ys)&&!(e instanceof Promise)&&!t)}function ND(e){return null==e||TD(e)||Array.isArray(e)||"object"==typeof e&&e instanceof ys||Na.isTypedArray(e)}function TD(e){return null===e||"object"!=typeof e&&"function"!=typeof e}function _D(e){return bD(e,CD)}function CD(e){return e instanceof ys?{value:e.clone(),recurse:!1}:SD(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var ED=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},AD=class extends ED{constructor(){super(AD.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){let e=2*this.capacity,t=new Array(e),n=this.length();for(let r=0;r<n;r++)t[r]=this.get(this.wrap(this.begin+r));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}};function $D(e){return new LD(e)}function FD(e){return new PD(e)}function RD(e,t){return new XD(e,t)}function DD(e,t=MD.FAIL){return new YD(e,t)}AD.INITIAL_CAPACITY=32;var MD,OD=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new HD(this,e)}filter(e){return new UD(this,e)}map(e){return new GD(this,e)}mapAsync(e){return new jD(this,e)}serialMapAsync(e){return new jD(this,e).serial()}flatmap(e){return new KD(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e,t=!0){return new VD(this,e,t)}columnMajorBatch(e,t=!0,n=kD){return this.rowMajorBatch(e,t).map((e=>xD(e,n)))}concatenate(e,t){return new XD($D([this,e]),t)}take(e){return e<0||null==e?this:new WD(this,e)}skip(e){return e<0||null==e?this:new BD(this,e)}prefetch(e){return new JD(this,e)}shuffle(e,t){return new ZD(this,e,t)}serial(){return new zD(this)}},LD=class extends OD{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:_D(e),done:!1}}},PD=class extends OD{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(Yre){throw Yre.message=`Error thrown while iterating through a dataset: ${Yre.message}`,Yre}}},zD=class extends OD{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}},BD=class extends OD{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;cl(e.value)}return this.upstream.next()}},WD=class extends OD{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},VD=class extends OD{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},UD=class extends OD{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;cl(e.value)}}},GD=class extends OD{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Ns.getTensorsInContainer(e.value),n=this.transform(e.value),r=Ns.getTensorsInContainer(n);for(let a of t)Ns.isTensorInList(a,r)||a.dispose();return{value:n,done:!1}}},HD=class extends OD{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(Yre){if(!this.handler(Yre))return{value:null,done:!0}}}},jD=class extends OD{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Ns.getTensorsInContainer(e.value),n=await this.transform(e.value),r=Ns.getTensorsInContainer(n);for(let a of t)Ns.isTensorInList(a,r)||a.dispose();return{value:n,done:!1}}},qD=class extends OD{constructor(){super(),this.outputQueue=new AD,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},KD=class extends qD{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=Ns.getTensorsInContainer(e.value),n=this.transform(e.value),r=Ns.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let a of t)Ns.isTensorInList(a,r)||a.dispose();return!0}},XD=class extends OD{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){let e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}};(function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"})(MD||(MD={}));var YD=class extends OD{constructor(e,t=MD.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;function r(e){return e instanceof OD?{value:e.next().then((e=>(t++,e.done&&n++,e.value))),recurse:!1}:{value:null,recurse:!0}}let a=await ID(this.iterators,r);if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case MD.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case MD.SHORTEST:return{value:null,done:!0};case MD.LONGEST:default:}return this.count++,{value:a,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},JD=class extends OD{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new ED(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},ZD=class extends JD{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=yD.alea(n||Na.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}},QD=class{constructor(){this.size=null}batch(e,t=!0){let n,r=this;return Na.assert(e>0,(()=>`batchSize needs to be positive, but it is\n      ${e}`)),n=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),eM((async()=>(await r.iterator()).columnMajorBatch(e,t,rM)),n)}concatenate(e){let t,n=this;return t=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,eM((async()=>(await n.iterator()).concatenate(await e.iterator())),t)}filter(e){let t,n=this;return t=this.size===1/0?1/0:null,eM((async()=>(await n.iterator()).filter((t=>ul((()=>e(t)))))),t)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return eM((async()=>(await t.iterator()).map((t=>ul((()=>e(t)))))),this.size)}mapAsync(e){let t=this;return eM((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return eM((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){let t,n=this;return t=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,eM((async()=>{let t=FD((async()=>({value:await n.iterator(),done:!1})));return RD(t.take(e))}),t)}skip(e){let t,n=this;return t=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,eM((async()=>(await n.iterator()).skip(e)),t)}shuffle(e,t,n=!0){if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let r=this,a=gD.alea(t||Na.now().toString());return eM((async()=>{let t=a.int32();return n&&(t+=a.int32()),(await r.iterator()).shuffle(e,t.toString())}),this.size)}take(e){let t,n=this;return t=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,eM((async()=>(await n.iterator()).take(e)),t)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};function eM(e,t=null){return new class extends QD{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function tM(e){return eM((async()=>$D(e)),e.length)}function nM(e){if(!SD(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=null==t?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=null==t?e[n].size:Math.min(t,e[n].size);return eM((async()=>{let t=await ID(e,(e=>{if(e instanceof QD)return{value:e.iterator(),recurse:!1};if(SD(e))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")}));return DD(t,MD.SHORTEST)}),t)}function rM(e){if(null===e)return null;let t=e[0];return ND(t)?{value:aM(e),recurse:!1}:{value:null,recurse:!0}}function aM(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof ys?xg(e):si(e)}QD.MAX_BUFFER_SIZE=1e4;var sM=class extends QD{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split("\n").map((e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e)))}},iM='"',oM=Symbol("out"),lM=Symbol("field"),uM=Symbol("quote"),cM=Symbol("quoteafterquote"),pM=Symbol("quoteinquote"),dM=class extends QD{constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new sM(e),t||(t={}),this.hasHeader=!1!==t.hasHeader,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(Na.assert(null==t.delimiter,(()=>"Delimiter should not be provided when delimWhitespace is true.")),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&Na.assert(e.length===this.fullColumnNames.length,(()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+").")),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce(((e,t)=>(e[t]=e[t]+1||1,e)),{}),n=Object.keys(t).filter((e=>t[e]>1));if(Na.assert(0===n.length,(()=>"Duplicate column names found: "+n.toString())),this.columnConfigs)for(let r of Object.keys(this.columnConfigs))if(-1===this.fullColumnNames.indexOf(r))throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").");this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");let t=e.value;return this.parseRow(t,!1)}return null}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map((e=>this.makeDataElement(e)))}makeDataElement(e){let t=this.parseRow(e),n={},r={};for(let a=0;a<this.fullColumnNames.length;a++){let s=this.fullColumnNames[a],i=this.columnConfigs?this.columnConfigs[s]:null;if(!this.configuredColumnsOnly||i){let o=t[a],l=null;if(""===o)if(i&&void 0!==i.default)l=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${s} is empty in this line: ${e}`);l=void 0}else{let e=Number(o);if(isNaN(e))l=i&&"bool"===i.dtype?this.getBoolean(o):o;else if(i&&i.dtype)switch(i.dtype){case"float32":l=e;break;case"int32":l=Math.floor(e);break;case"bool":l=this.getBoolean(o);break;default:l=e}else l=e}i&&i.isLabel?r[s]=l:n[s]=l}}return 0===Object.keys(r).length?n:{xs:n,ys:r}}getBoolean(e){return"1"===e||"true"===e.toLowerCase()?1:0}parseRow(e,t=!0){let n=[],r=0,a=e.length,s=oM;for(let i=0;i<a;i++)switch(s){case oM:switch(e.charAt(i)){case iM:r=i+1,s=uM;break;case this.delimiter:if(r=i+1," "===this.delimiter&&this.delimWhitespace)break;n.push(""),s=oM;break;default:s=lM,r=i;break}break;case lM:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(r,i)),s=oM,r=i+1;break;default:}break;case uM:switch(e.charAt(i)){case iM:s=cM;break;default:}break;case cM:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(r,i-1)),s=oM,r=i+1;break;case iM:s=uM;break;default:s=pM;break}break;case pM:switch(e.charAt(i)){case iM:s=uM;break;default:}break;default:}if(s===cM?n.push(e.substring(r,a-1)):n.push(e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},hM=class extends OD{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;let t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=!1!==e.includeSpectrogram,this.includeWaveform=!0===e.includeWaveform,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!Xe().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let t=new hM(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:null==this.audioTrackConstraints||this.audioTrackConstraints,video:!1})}catch(n){throw new Error(`Error thrown while initializing video stream: ${n.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,this.sampleRateHz){if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`)}else this.sampleRateHz=this.audioContext.sampleRate;let t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t,n=await this.getAudioData();if(this.includeSpectrogram){let t=this.flattenQueue(n.freqDataQueue);e=this.getTensorFromAudioDataArray(t,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let e=this.flattenQueue(n.timeDataQueue);t=this.getTensorFromAudioDataArray(e,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let e=[],t=[],n=0;return new Promise((r=>{let a=setInterval((()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(a),r({freqDataQueue:e,timeDataQueue:t}))}),this.fftSize/this.sampleRateHz*1e3)}))}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){let t=e[0].length,n=new Float32Array(e.length*t);return e.forEach(((e,r)=>n.set(e,r*t))),n}getTensorFromAudioDataArray(e,t){let n=new Float32Array(Na.sizeFromShape(t));return n.set(e,n.length-e.length),si(n,t)}},fM=class extends OD{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=_g([0],"int32"),this.webcamConfig.centerCrop){let e=1*this.webcamConfig.resizeWidth/this.webcamVideoElement.width,t=1*this.webcamConfig.resizeHeight/this.webcamVideoElement.height,n=(1-e)/2,r=(1-t)/2,a=n+e,s=t+r;this.cropBox=Cg([r,n,s,a],[1,4])}else this.cropBox=Cg([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(!Xe().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}let n=new fM(e,t);return await n.start(),n}async start(){this.webcamConfig.facingMode&&Na.assert("user"===this.webcamConfig.facingMode||"environment"===this.webcamConfig.facingMode,(()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`));try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(Yre){throw Yre.message=`Error thrown while initializing video stream: ${Yre.message}`,Yre}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(Yre){console.log(Yre),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise((e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}}))}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=Ll.fromPixels(this.webcamVideoElement)}catch(t){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(t)}`)}if(!this.resize)return{value:e,done:!1};try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(t){throw new Error(`Error thrown cropping the video: ${t.message}`)}finally{e.dispose()}}needToResize(){return!(!this.webcamConfig.resizeWidth||!this.webcamConfig.resizeHeight||this.webcamVideoElement.width===this.webcamConfig.resizeWidth&&this.webcamVideoElement.height===this.webcamConfig.resizeHeight)}cropAndResizeFrame(e){return ul((()=>{let t,n=Yd(go(e,"float32"),0);t=hw.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let r=t.shape;return Lc(t,r.slice(1))}))}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach((e=>e.stop()));try{this.webcamVideoElement.srcObject=null}catch(Yre){console.log(Yre),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},mM=class{},gM=class extends OD{split(e){return new yM(this,e)}},yM=class extends gM{constructor(e,t){super(),this.upstream=e,this.impl=new bM(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},bM=class extends qD{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return""!==this.carryover&&(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}},wM=class extends OD{decodeUTF8(){return new xM(this)}},xM=class extends gM{constructor(e){super(),this.upstream=e,this.impl=new vM(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},vM=class extends qD{constructor(e){if(super(),this.upstream=e,Xe().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:e}=z();this.decoder=new e("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e,t,n=await this.upstream.next();return!n.done&&(e=n.value,t=Xe().get("IS_BROWSER")?this.decoder.decode(e,{stream:!0}):this.decoder.write(Buffer.from(e.buffer)),this.outputQueue.push(t),!0)}},kM=class extends wM{constructor(e,t={}){super(),this.file=e,this.options=t,Na.assert(e instanceof Uint8Array||!!Xe().get("IS_BROWSER")&&(e instanceof File||e instanceof Blob),(()=>"FileChunkIterator only supports File, Blob and Uint8Array right now.")),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1048576}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise(((e,t)=>{let n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{let r=new FileReader;r.onload=n=>{let a=r.result;if(a instanceof ArrayBuffer&&(a=new Uint8Array(a)),!(a instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(a)},r.onabort=e=>t(new Error("Aborted")),r.onerror=e=>t(new Error(e.type));let a=this.file.slice(this.offset,n);r.readAsArrayBuffer(a)}this.offset=n})),done:!1}}};async function IM(e,t={},n){let r,a;"string"==typeof e?r=e:(r=e.url,a=SM(e));let s=await(n||Na.fetch)(r,a);if(s.ok){let e=new Uint8Array(await s.arrayBuffer());return new kM(e,t)}throw new Error(s.statusText)}var SM=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function NM(e){return"string"==typeof e&&"file://"===e.slice(0,7)}var TM=class extends mM{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(NM(this.input)&&Xe().get("IS_NODE")){let e=B();this.input=e.readFileSync(this.input.slice(7))}return new kM(this.input,this.options)}},_M=class extends mM{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return NM(this.url)?new TM(this.url,this.fileOptions).iterator():IM(this.url,this.fileOptions)}};function CM(e,t={}){return new dM(new _M(e),t)}function EM(e){let t=FD(e);return eM((async()=>t))}function AM(e){return eM((async()=>{let t=await e();return FD((()=>t.next()))}))}async function $M(e,t){return fM.create(e,t)}async function FM(e){return hM.create(e)}var RM="3.18.0";function DM(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Na.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}var MM=Fx.whereImpl,OM=class extends K{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new q(this,il())}nextDataId(){return OM.nextDataId++}write(e,t,n){this.firstUse&&(this.firstUse=!1,Xe().get("IS_NODE")&&Aw.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));let r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&Na.isString(n[0])){let a=n.map((e=>Na.encodeString(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){let t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){let t=this.data.get(e);t.refCount--}}move(e,t,n,r,a){this.data.set(e,{values:t,dtype:r,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){let{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){let e=this.readSync(n.real.dataId),t=this.readSync(n.imag.dataId);return Aw.mergeRealAndImagArrays(e,t)}return this.data.get(e).values}bufferSync(e){let t=this.readSync(e.dataId);if("string"===e.dtype)try{let n=t.map((e=>Na.decodeString(e)));return fo(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return fo(e.shape,e.dtype,t)}makeOutput(e,t,n){return il().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){let t=Na.now();return e(),{kernelMs:Na.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){DM([e],"where");let t=this.readSync(e.dataId);return MM(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};OM.nextDataId=0;var LM={};function PM(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}g(LM,{addImpl:()=>QM,bincountImpl:()=>rO,bincountReduceImpl:()=>aO,ceilImpl:()=>lO,concatImpl:()=>pO,equalImpl:()=>dO,expImpl:()=>mO,expm1Impl:()=>bO,floorImpl:()=>vO,gatherNdImpl:()=>SO,gatherV2Impl:()=>NO,greaterEqualImpl:()=>EO,greaterImpl:()=>TO,lessEqualImpl:()=>MO,lessImpl:()=>FO,linSpaceImpl:()=>PO,logImpl:()=>zO,maxImpl:()=>VO,maximumImpl:()=>UO,minimumImpl:()=>jO,multiplyImpl:()=>XO,negImpl:()=>QO,notEqualImpl:()=>nL,prodImpl:()=>lL,rangeImpl:()=>pL,rsqrtImpl:()=>dL,scatterImpl:()=>mL,sigmoidImpl:()=>gL,simpleAbsImpl:()=>PM,sliceImpl:()=>wL,sparseFillEmptyRowsImpl:()=>kL,sparseReshapeImpl:()=>IL,sparseSegmentReductionImpl:()=>SL,sqrtImpl:()=>NL,squaredDifferenceImpl:()=>CL,stridedSliceImpl:()=>$L,stringNGramsImpl:()=>RL,stringSplitImpl:()=>ML,stringToHashBucketFastImpl:()=>OL,subImpl:()=>LL,tileImpl:()=>WL,topKImpl:()=>GL,transposeImpl:()=>sL,uniqueImpl:()=>HL});var zM=e=>{let{x:t}=e.inputs,n=e.backend;DM(t,"abs");let r=new Float32Array(Na.sizeFromShape(t.shape)),a=n.data.get(t.dataId).values;return r=PM(a),n.makeOutput(r,t.shape,t.dtype)},BM={kernelName:nt,backendName:"cpu",kernelFunc:zM};function WM(e){return(t,n,r,a,s)=>{let i=Aw.assertAndGetBroadcastShape(t,n),o=i.length,l=Na.computeStrides(i),u=Na.sizeFromShape(i),c=Na.getTypedArrayFromDType(s,u),p=t.length,d=n.length,h=Na.computeStrides(t),f=Na.computeStrides(n),m=Aw.getBroadcastDims(t,i),g=Aw.getBroadcastDims(n,i);if(m.length+g.length===0)for(let y=0;y<c.length;++y)c[y]=e(r[y%r.length],a[y%a.length]);else for(let y=0;y<c.length;++y){let t=Na.indexToLoc(y,o,l),n=t.slice(-p);m.forEach((e=>n[e]=0));let s=Na.locToIndex(n,p,h),i=t.slice(-d);g.forEach((e=>i[e]=0));let u=Na.locToIndex(i,d,f);c[y]=e(r[s],a[u])}return[c,i]}}function VM(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=n.makeTensorInfo(r.shape,"complex64"),l=n.data.get(o.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",s),imag:n.makeTensorInfo(a.shape,"float32",i)},o}var UM={kernelName:Ct,backendName:"cpu",kernelFunc:VM};function GM(e,t,n="float32"){if("complex64"===n){let n=GM(e,t,"float32"),r=GM(e,t,"float32");return VM({inputs:{real:n,imag:r},backend:e})}let r=Na.makeZerosTypedArray(Na.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function HM(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var jM={kernelName:yn,backendName:"cpu",kernelFunc:HM};function qM(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.real,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}var KM={kernelName:cr,backendName:"cpu",kernelFunc:qM};function XM(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if("complex64"===s){if("complex64"===a.dtype)return HM({inputs:{x:a},backend:n});let e=GM(n,a.shape,a.dtype),t=XM({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),r=VM({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===a.dtype){let e=qM({inputs:{input:a},backend:n}),t=XM({inputs:{x:e},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(e),t}if(!Na.hasEncodingLoss(a.dtype,s)){let e=HM({inputs:{x:a},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}if("int32"===s){let e=n.data.get(a.dataId).values,t=Int32Array.from(e);return n.makeTensorInfo(a.shape,"int32",t)}if("bool"===s){let e=n.data.get(a.dataId).values,t=Na.toTypedArray([0],a.dtype),[r,s]=WM(((e,t)=>e!==t?1:0))(a.shape,[],e,t,"bool");return n.makeTensorInfo(s,"bool",r)}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${s}`)}var YM={kernelName:Nt,backendName:"cpu",kernelFunc:XM};function JM(e,t,n,r){return null==n?({inputs:n,backend:a})=>{let{a:s,b:i}=n,o=a;DM([s,i],e);let l=o.data.get(s.dataId).values,u=o.data.get(i.dataId).values,c="string"===s.dtype?Aw.fromUint8ToStringArray(l):l,p="string"===s.dtype?Aw.fromUint8ToStringArray(u):u,d=r||s.dtype,[h,f]=t(s.shape,i.shape,c,p,d);return o.makeTensorInfo(f,d,h)}:({inputs:e,backend:a})=>{let{a:s,b:i}=e,o=a;if("complex64"===s.dtype||"complex64"===i.dtype){let e=XM({inputs:{x:s},backend:o,attrs:{dtype:"complex64"}}),t=o.data.get(e.dataId),r=t.complexTensorInfos.real,a=t.complexTensorInfos.imag,l=o.data.get(r.dataId).values,u=o.data.get(a.dataId).values,c=XM({inputs:{x:i},backend:o,attrs:{dtype:"complex64"}}),p=o.data.get(c.dataId),d=p.complexTensorInfos.real,h=p.complexTensorInfos.imag,f=o.data.get(d.dataId).values,m=o.data.get(h.dataId).values,[g,y,b]=n(s.shape,i.shape,l,u,f,m),w=o.makeTensorInfo(b,"float32",g),x=o.makeTensorInfo(b,"float32",y),v=VM({inputs:{real:w,imag:x},backend:o});return o.disposeIntermediateTensorInfo(e),o.disposeIntermediateTensorInfo(c),o.disposeIntermediateTensorInfo(w),o.disposeIntermediateTensorInfo(x),v}{let e=o.data.get(s.dataId).values,n=o.data.get(i.dataId).values,a=r||s.dtype,[l,u]=t(s.shape,i.shape,e,n,a);return o.makeTensorInfo(u,a,l)}}}function ZM(e){return(t,n,r,a,s,i)=>{let o=Aw.assertAndGetBroadcastShape(t,n),l=Na.sizeFromShape(o),u=o.length,c=Na.computeStrides(o),p=Na.getTypedArrayFromDType("float32",l),d=Na.getTypedArrayFromDType("float32",l),h=Aw.getBroadcastDims(t,o),f=Aw.getBroadcastDims(n,o),m=Aw.mergeRealAndImagArrays(r,a),g=Aw.mergeRealAndImagArrays(s,i),y=t.length,b=Na.computeStrides(t),w=n.length,x=Na.computeStrides(n);if(h.length+f.length===0)for(let v=0;v<p.length;v++){let t=v%m.length,n=v%g.length,r=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);p[v]=r.real,d[v]=r.imag}else for(let v=0;v<p.length;v++){let t=Na.indexToLoc(v,u,c),n=t.slice(-y);h.forEach((e=>n[e]=0));let r=Na.locToIndex(n,y,b),a=t.slice(-w);f.forEach((e=>a[e]=0));let s=Na.locToIndex(a,w,x),i=e(m[2*r],m[2*r+1],g[2*s],g[2*s+1]);p[v]=i.real,d[v]=i.imag}return[p,d,o]}}var QM=WM(((e,t)=>e+t)),eO=ZM(((e,t,n,r)=>({real:e+n,imag:t+r}))),tO=JM(st,QM,eO),nO={kernelName:st,backendName:"cpu",kernelFunc:tO};function rO(e,t,n,r,a){let s=Na.sizeFromShape(r),i=Na.makeZerosTypedArray(a,n);for(let o=0;o<e.length;o++){let n=e[o];if(n<0)throw new Error("Input x must be non-negative!");n>=a||(i[n]+=s>0?t[o]:1)}return i}function aO(e,t,n,r=!1){let a=e.shape[0],s=e.shape[1],i=fo([a,n],t.dtype);for(let o=0;o<a;o++)for(let a=0;a<s;a++){let s=e.get(o,a);if(s<0)throw new Error("Input x must be non-negative!");s>=n||(r?i.set(1,o,s):t.size>0?i.set(i.get(o,s)+t.get(o,a),o,s):i.set(i.get(o,s)+1,o,s))}return i}function sO(e){return(t,n,r)=>{let a=Na.getTypedArrayFromDType(n,t.length);for(let s=0;s<t.length;++s)a[s]=e(t[s],r);return a}}function iO(e,t,n){return({inputs:r,attrs:a,backend:s})=>{let{x:i}=r;if(DM(i,e),"string"===i.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");let o=s,l=o.data.get(i.dataId).values,u=Na.sizeFromShape(i.shape),c=n||i.dtype,p=Na.getArrayFromDType(c,u);for(let e=0;e<u;++e)p[e]=t(l[e],a);return o.makeTensorInfo(i.shape,c,p)}}function oO(e,t,n){return({inputs:r,attrs:a,backend:s})=>{let{x:i}=r;if(DM(i,e),"string"===i.dtype||"string"===n)throw new Error("unaryKernelFunc does not support string input/output");let o=s,l=o.data.get(i.dataId).values,u=n||i.dtype,c=t(l,u,a);return o.makeTensorInfo(i.shape,u,c)}}var lO=sO((e=>Math.ceil(e))),uO=oO(Tt,lO),cO={kernelName:Tt,backendName:"cpu",kernelFunc:uO};function pO(e,t,n,r){let a=Na.getArrayFromDType(n,Na.sizeFromShape(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{let n=Na.sizeFromShape(e.shape);a.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{let s="string"===n?Aw.fromUint8ToStringArray(e.vals):e.vals,i=0;for(let n=0;n<e.shape[0];++n){let o=n*t[1]+r;for(let t=0;t<e.shape[1];++t)a[o+t]=s[i++]}r+=e.shape[1]}))}return a}var dO=WM(((e,t)=>e===t?1:0)),hO=JM(nn,dO,null,"bool"),fO={kernelName:nn,backendName:"cpu",kernelFunc:hO},mO=sO((e=>Math.exp(e))),gO=oO(rn,mO,"float32"),yO={kernelName:rn,backendName:"cpu",kernelFunc:gO},bO=sO((e=>Math.expm1(e))),wO=oO(sn,bO),xO={kernelName:sn,backendName:"cpu",kernelFunc:wO},vO=sO((e=>Math.floor(e))),kO=oO(cn,vO),IO={kernelName:cn,backendName:"cpu",kernelFunc:kO};function SO(e,t,n,r,a,s,i,o,l){let u=fo([r,s],n);for(let c=0;c<r;c++){let n=[],r=0;for(let t=0;t<a;t++){let s=e[c*a+t];r+=s*i[t],n.push(s)}if(r<0||r>=l/s)throw new Error(`Invalid indices: ${n} does not index into ${o}`);for(let e=0;e<s;e++)u.values[c*s+e]=t.get(...t.indexToLoc(r*s+e))}return u}function NO(e,t,n){let r=fo(n,e.dtype);for(let a=0;a<r.size;++a){let n=r.indexToLoc(a).slice(),s=n[0],i=n[2],o=t.locToIndex([s,i]);n[2]=t.values[o];let l=e.locToIndex(n);0<=l&&l<e.values.length&&(r.values[a]=e.values[l])}return r}var TO=WM(((e,t)=>e>t?1:0)),_O=JM(mn,TO,null,"bool"),CO={kernelName:mn,backendName:"cpu",kernelFunc:_O},EO=WM(((e,t)=>e>=t?1:0)),AO=JM(gn,EO,null,"bool"),$O={kernelName:gn,backendName:"cpu",kernelFunc:AO},FO=WM(((e,t)=>e<t?1:0)),RO=JM(Sn,FO,null,"bool"),DO={kernelName:Sn,backendName:"cpu",kernelFunc:RO},MO=WM(((e,t)=>e<=t?1:0)),OO=JM(Nn,MO,null,"bool"),LO={kernelName:Nn,backendName:"cpu",kernelFunc:OO};function PO(e,t,n){let r=(t-e)/(n-1),a=Na.makeZerosTypedArray(n,"float32");a[0]=e;for(let s=1;s<a.length;s++)a[s]=a[s-1]+r;return a}var zO=sO((e=>Math.log(e))),BO=oO(_n,zO),WO={kernelName:_n,backendName:"cpu",kernelFunc:BO};function VO(e,t,n,r){let a=Na.getTypedArrayFromDType(r,Na.sizeFromShape(n));for(let s=0;s<a.length;++s){let n=s*t,r=e[n];for(let a=0;a<t;++a){let t=e[n+a];(Number.isNaN(t)||t>r)&&(r=t)}a[s]=r}return a}var UO=WM(((e,t)=>Math.max(e,t))),GO=JM(Ln,UO),HO={kernelName:Ln,backendName:"cpu",kernelFunc:GO},jO=WM(((e,t)=>Math.min(e,t))),qO=JM(Hn,jO),KO={kernelName:Hn,backendName:"cpu",kernelFunc:qO},XO=WM(((e,t)=>e*t)),YO=ZM(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n}))),JO=JM(Xn,XO,YO),ZO={kernelName:Xn,backendName:"cpu",kernelFunc:JO};function QO(e,t,n){let r=Na.createScalarValue(-1,n);return XO([],t,r,e,n)}function eL(e){let{inputs:t,backend:n}=e,{x:r}=t;DM(r,"neg");let a=n.data.get(r.dataId).values,[s,i]=QO(a,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,s)}var tL={kernelName:Yn,backendName:"cpu",kernelFunc:eL},nL=WM(((e,t)=>e!==t?1:0)),rL=JM(Jn,nL,null,"bool"),aL={kernelName:Jn,backendName:"cpu",kernelFunc:rL};function sL(e,t,n,r,a){let s=t.length,i=Na.sizeFromShape(t),o=Na.computeStrides(t),l=Na.computeStrides(a),u=Na.getTypedArrayFromDType(n,Na.sizeFromShape(a));for(let c=0;c<i;++c){let t=Na.indexToLoc(c,s,o),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[r[e]];let a=Na.locToIndex(n,s,l);u[a]=e[c]}return u}function iL(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{perm:s}=n;DM(a,"transpose");let i=a.shape.length,o=new Array(i);for(let c=0;c<o.length;c++)o[c]=a.shape[s[c]];let l=r.data.get(a.dataId).values,u=sL(l,a.shape,a.dtype,s,o);return{dataId:r.write(u,o,a.dtype),shape:o,dtype:a.dtype}}var oL={kernelName:ea,backendName:"cpu",kernelFunc:iL};function lL(e,t,n,r){let[a,s]=Aw.computeOutAndReduceShapes(e,r),i=_s(t,"int32"),o=Na.makeZerosTypedArray(Na.sizeFromShape(a),i),l=Na.sizeFromShape(s);for(let u=0;u<o.length;++u){let e=u*l,t=1;for(let r=0;r<l;++r)t*=n[e+r];o[u]=t}return{outVals:o,outShape:a,outDtype:i}}function uL(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;DM(a,"prod");let o=a.shape.length,l=Na.parseAxisParam(s,a.shape),u=Aw.getAxesPermutation(l,o),c=l,p=a,d=[];null!=u&&(p=iL({inputs:{x:a},backend:n,attrs:{perm:u}}),d.push(p),c=Aw.getInnerMostAxes(c.length,o));let h=n.data.get(p.dataId).values,{outVals:f,outShape:m,outDtype:g}=lL(p.shape,p.dtype,h,c),y=m;return i&&(y=Aw.expandShapeToKeepDim(m,l)),d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(y,g,f)}var cL={kernelName:lr,backendName:"cpu",kernelFunc:uL};function pL(e,t,n,r){let a=e===t,s=e<t&&n<0,i=t<e&&n>1;if(a||s||i)return Na.makeZerosTypedArray(0,r);let o=Math.abs(Math.ceil((t-e)/n)),l=Na.makeZerosTypedArray(o,r);t<e&&1===n&&(n=-1),l[0]=e;for(let u=1;u<l.length;u++)l[u]=l[u-1]+n;return l}var dL=sO((e=>1/Math.sqrt(e))),hL=oO(vr,dL),fL={kernelName:vr,backendName:"cpu",kernelFunc:hL};function mL(e,t,n,r,a,s,i,o,l,u){let c=[r/a,a],p=e.values,d=t.values;if(0===r)return fo(n,t.dtype);let h=fo(c,t.dtype);"string"==typeof l||"number"==typeof l?h.values.fill(l):"boolean"==typeof l&&h.values.fill(+l);for(let f=0;f<s;f++){let e=[],s=0;for(let t=0;t<i;t++){let n=p[f*i+t];e.push(n),s+=n*o[t]}if(s<0||s>=r/a)throw new Error(`Invalid indices: ${e} does not index into ${n}`);for(let n=0;n<a;n++)u?h.values[s*a+n]+=d[f*a+n]:h.values[s*a+n]=0===t.rank?d[0]:d[f*a+n]}return h}var gL=sO((e=>1/(1+Math.exp(-e)))),yL=iO(Ar,(e=>1/(1+Math.exp(-e)))),bL={kernelName:Ar,backendName:"cpu",kernelFunc:yL};function wL(e,t,n,r,a){let s=Ql.isSliceContinous(r,t,n),i=Na.sizeFromShape(n),o=Na.computeStrides(r);if(s){let n=Ql.computeFlatOffset(t,o);return"string"===a?e.slice(n,n+i):e.subarray(n,n+i)}let l="string"===a?Aw.fromUint8ToStringArray(e):e,u=fo(r,a,l),c=fo(n,a);for(let p=0;p<c.size;++p){let e=c.indexToLoc(p),n=e.map(((e,n)=>e+t[n]));c.set(u.get(...n),...e)}return"string"===a?Aw.fromStringArrayToUint8(c.values):c.values}function xL(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r;DM(a,"slice");let[o,l]=Ql.parseSliceParams(a,s,i);Ql.assertParamsValid(a,o,l);let u=n.data.get(a.dataId).values,c=wL(u,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,c)}var vL={kernelName:Tr,backendName:"cpu",kernelFunc:xL};function kL(e,t,n,r,a,s,i){let o=t[0],l=s[0],u=new Array(l),c=new Array(o),p=t[1];if(0===l){if(0!==o)throw new Error(Aw.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));let e=Na.getArrayFromDType(n,0),t=Na.getArrayFromDType(a,0);return[e,[0,p],t,u,c]}let d=!0,h=0,f=new Array(l).fill(0);for(let g=0;g<o;++g){let t=e[g*p];if(t<0)throw new Error(Aw.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,t));if(t>=l)throw new Error(Aw.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,t,l));++f[t],d=d&&t>=h,h=t}let m=!0;for(let g=0;g<l;++g){let e=0===f[g];u[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&d){let t=e,n=r;for(let e=0;e<o;++e)c[e]=e;return[t,[o,p],n,u,c]}{let t=f[l-1],s=Na.getArrayFromDType(n,t*p),d=Na.getArrayFromDType(a,t),h=new Array(l).fill(0);for(let n=0;n<o;++n){let t=e[n*p],a=h[t],i=(0===t?0:f[t-1])+a;h[t]++;for(let r=0;r<p;++r)s[i*p+r]=e[n*p+r];d[i]=r[n],c[n]=i}for(let e=0;e<l;++e)if(0===h[e]){let t=0===e?0:f[e-1];s[t*p+0]=e;for(let e=1;e<p;++e)s[t*p+e]=0;d[t]=i}return[s,[t,p],d,u,c]}}function IL(e,t,n,r,a){let s=Na.sizeFromShape(r),i=t[0],o=a.length,l=[],u=1,c=-1;for(let m=0;m<o;++m){let e=a[m];if(-1===e){if(-1!==c)throw new Error(Aw.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,m));c=m,l.push(1)}else{if(e<0)throw new Error(Aw.getSparseReshapeNegativeOutputDimErrorMessage(m,e));u*=e,l.push(e)}}if(-1!==c){if(u<=0)throw new Error(Aw.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let e=Math.trunc(s/u);if(u*e!==s)throw new Error(Aw.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[c]=e}if(Na.sizeFromShape(l)!==s)throw new Error(Aw.getSparseReshapeInputOutputMismatchErrorMessage(r,l));let p=r.length,d=[];if(p>0){d[p-1]=1;for(let e=p-2;e>=0;--e)d[e]=d[e+1]*r[e+1]}let h=[];if(o>0){h[o-1]=1;for(let e=o-2;e>=0;--e)h[e]=h[e+1]*l[e+1]}let f=Na.getArrayFromDType(n,i*o);for(let m=0;m<i;++m){let t=0;for(let n=0;n<p;++n)t+=e[m*p+n]*d[n];for(let e=0;e<o;++e)f[m*o+e]=Math.trunc(t/h[e]),t%=h[e]}return[f,[i,o],l]}function SL(e,t,n,r,a,s=!1,i=0){let o=r.length,l=[t[0],e.length/t[0]],u=l[1],c=o>0?a[o-1]+1:0;if(c<0)throw new Error(Aw.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let p=t.slice();p[0]=c;let d=p.reduce(((e,t)=>e*t),1),h=Na.getArrayFromDType(n,d);if(0===o)return c>0&&h.fill(i),[h,p];if(c<=0)throw new Error(Aw.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=0,m=1,g=0,y=a[f];for(;;){let t=0;if(m<o){if(t=a[m],y===t){++m;continue}if(y>=t)throw new Error(Aw.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(y<0||y>=c)throw new Error(Aw.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y,c));y>g&&h.fill(i,g*u,y*u);for(let n=f;n<m;++n){let t=r[n];if(t<0||t>=l[0])throw new Error(Aw.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(n,r[n],l[0]));for(let n=0;n<u;n++)h[y*u+n]+=e[t*u+n]}if(s)for(let e=0;e<u;e++)h[y*u+e]/=m-f;if(f=m,++m,g=y+1,y=t,m>o)break}return g<c&&h.fill(i,g*u,c*u),[h,p]}var NL=sO((e=>Math.sqrt(e))),TL=iO(Fr,(e=>Math.sqrt(e))),_L={kernelName:Fr,backendName:"cpu",kernelFunc:TL},CL=WM(((e,t)=>{let n=e-t;return n*n})),EL=JM(Vr,CL),AL={kernelName:Vr,backendName:"cpu",kernelFunc:EL};function $L(e,t,n,r){let a=fo(e,t.dtype);for(let s=0;s<a.size;s++){let e=a.indexToLoc(s),i=new Array(e.length);for(let t=0;t<i.length;t++)i[t]=e[t]*n[t]+r[t];a.set(t.get(...i),...e)}return a}var FL=class{constructor(e,t,n,r,a,s){this.separator=Na.encodeString(e),this.nGramWidths=t,this.leftPad=Na.encodeString(n),this.rightPad=Na.encodeString(r),this.padWidth=a,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,a,s){for(let i=0;i<a;++i){let o=this.getPadWidth(s),l=Math.max(0,o-i),u=Math.max(0,o-(a-(i+1))),c=s-(l+u),p=t+(l>0?0:i-o),d=0;d+=l*this.leftPad.length;for(let t=0;t<c;++t)d+=e[p+t].length;d+=u*this.rightPad.length,d+=(l+u+c-1)*this.separator.length,n[r+i]=new Uint8Array(d);let h=n[r+i],f=0,m=e=>e.forEach((e=>h[f++]=e));for(let e=0;e<l;++e)m(this.leftPad),m(this.separator);for(let t=0;t<c-1;++t)m(e[p+t]),m(this.separator);if(c>0){m(e[p+c-1]);for(let e=0;e<u;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<u-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){let n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let a=1;a<r;++a){let r=t[a]>=e;if(r=r&&t[a]<=n,!r)throw new Error(`Invalid split value ${t[a]}, must be in [${e}, ${n}]`);e=t[a]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}let a=r-1,s=Na.getArrayFromDType("int32",r);if(0===n||0===r){let e=new Array(n);for(let t=0;t<=a;++t)s[t]=0;return[e,s]}s[0]=0;for(let o=1;o<=a;++o){let e=t[o]-t[o-1],n=0;this.nGramWidths.forEach((t=>{n+=this.getNumNGrams(e,t)})),this.preserveShort&&e>0&&0===n&&(n=1),s[o]=s[o-1]+n}let i=new Array(s[a]);for(let o=0;o<a;++o){let n=t[o],r=s[o];if(this.nGramWidths.forEach((a=>{let s=t[o+1]-t[o],l=this.getNumNGrams(s,a);this.createNGrams(e,n,i,r,l,a),r+=l})),this.preserveShort&&r===s[o]){let a=t[o+1]-t[o];if(0===a)continue;let s=a+2*this.padWidth,l=1;this.createNGrams(e,n,i,r,l,s)}}return[i,s]}};function RL(e,t,n,r,a,s,i,o){return new FL(n,r,a,s,i,o).compute(e,t)}function DL(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){let a=t[0],s=e.indexOf(a);for(;-1!==s;){let t=e.subarray(0,s);(!n||0!==t.length)&&r.push(t),e=e.subarray(s+1),s=e.indexOf(a)}return void((!n||0!==e.length)&&r.push(e))}let a=0;for(let s=0;s<e.length+1;s++)if(s===e.length||-1!==t.indexOf(e[s])){let t=e.subarray(a,s);(!n||0!==t.length)&&r.push(t),a=s+1}}function ML(e,t,n){let r=e.length,a=[],s=0,i=0,o=new Array(r);for(let d=0;d<r;++d){let r=a.length;DL(e[d],t,n,a);let l=a.length-r;o[d]=l,s+=l,i=Math.max(i,l)}let l=Na.getArrayFromDType("int32",2*s),u=new Array(s),c=[r,i],p=0;for(let d=0;d<r;++d)for(let e=0;e<o[d];++e)l[2*p]=d,l[2*p+1]=e,u[p]=a[p],++p;return[l,u,c]}function OL(e,t){let n=Na.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=Na.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}var LL=WM(((e,t)=>e-t)),PL=ZM(((e,t,n,r)=>({real:e-n,imag:t-r}))),zL=JM(Kr,LL,PL),BL={kernelName:Kr,backendName:"cpu",kernelFunc:zL};function WL(e,t){let n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=e.shape[a]*t[a];let r=fo(n,e.dtype);for(let a=0;a<r.values.length;++a){let t=r.indexToLoc(a),n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=t[r]%e.shape[r];let s=e.locToIndex(n);r.values[a]=e.values[s]}return r}var VL=(e,t)=>{let n=t.value-e.value;return 0===n?e.index-t.index:n};function UL(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){let a=r-n+1,s=t-n+1,i=Math.log(a),o=.5*Math.exp(2*i/3),l=.5*Math.sqrt(i*o*(a-o)/a)*Math.sign(s-a/2),u=Math.max(n,Math.floor(t-s*o/a+l)),c=Math.min(r,Math.floor(t+(a-s)*o/a+l));UL(e,t,u,c)}let a=e[t],s=n,i=r;for(Na.swap(e,n,t),VL(e[r],a)>0&&Na.swap(e,n,r);s<i;){for(Na.swap(e,s,i),s++,i--;VL(e[s],a)<0;)s+=1;for(;VL(e[i],a)>0;)i-=1}0===VL(e[n],a)?Na.swap(e,n,i):(i+=1,Na.swap(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function GL(e,t,n,r,a){let s=t[t.length-1],[i,o]=[e.length/s,s],l=Na.getTypedArrayFromDType(n,i*r),u=Na.getTypedArrayFromDType("int32",i*r);for(let p=0;p<i;p++){let t=p*o,n=e.subarray(t,t+o),s=new Array(n.length);n.forEach(((e,t)=>s[t]={value:e,index:t})),r<s.length&&(UL(s,r),s=s.slice(0,r)),a&&s.sort(VL);let i=p*r,c=l.subarray(i,i+r),d=u.subarray(i,i+r);for(let e=0;e<r;e++)c[e]=s[e].value,d[e]=s[e].index}let c=t.slice();return c[c.length-1]=r,[fo(c,n,l),fo(c,"int32",u)]}function HL(e,t,n,r){let a=Na.parseAxisParam(t,n)[0],s=[1,n[0],1];for(let f=0;f<a;f++)s[0]*=n[f];s[1]=n[a];for(let f=a+1;f<n.length;f++)s[2]*=n[f];let i={},o=new Int32Array(n[a]),l=new ps(s,r,e),u=[],c=1===s[0]&&1===s[2];for(let f=0;f<n[a];f++){let t;if(c)t=e[f].toString();else{let e=[];for(let t=0;t<s[0];t++)for(let n=0;n<s[2];n++)e.push(l.get(t,f,n));t=e.join(",")}if(void 0!==i[t])o[f]=i[t];else{let e=Object.keys(i).length;i[t]=e,o[f]=e,u.push(f)}}let p=s.slice();p[1]=Object.keys(i).length;let d=new ps(p,r);u.forEach(((e,t)=>{for(let n=0;n<s[0];n++)for(let r=0;r<s[2];r++)d.set(l.get(n,e,r),n,t,r)}));let h=n.slice();return h[a]=p[1],{outputValues:d.values,outputShape:h,indices:o}}wl("cpu",(()=>new OM),1);var jL=iO(Qt,(e=>e>=0?e:Math.exp(e)-1)),qL={kernelName:Qt,backendName:"cpu",kernelFunc:jL};function KL(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r;DM([a],"leakyRelu");let i=Na.sizeFromShape(a.shape),o=n.data.get(a.dataId).values,l=Na.getTypedArrayFromDType("float32",i);for(let u=0;u<o.length;u++)l[u]=o[u]<0?s*o[u]:o[u];return n.makeTensorInfo(a.shape,"float32",l)}var XL={kernelName:In,backendName:"cpu",kernelFunc:KL},YL=WM(((e,t)=>e<0?t*e:e));function JL(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t;DM([r,a],"prelu");let s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,[o,l]=YL(r.shape,a.shape,s,i,"float32");return n.makeTensorInfo(l,"float32",o)}var ZL={kernelName:or,backendName:"cpu",kernelFunc:JL},QL=iO(dr,(e=>Math.max(0,e))),eP={kernelName:dr,backendName:"cpu",kernelFunc:QL},tP=iO(br,(e=>Math.min(Math.max(0,e),6))),nP={kernelName:br,backendName:"cpu",kernelFunc:tP};function rP(e,t,n,r,a){if("linear"===n)return HM({inputs:{x:t},backend:e});if("relu"===n)return QL({inputs:{x:t},backend:e});if("elu"===n)return jL({inputs:{x:t},backend:e});if("relu6"===n)return tP({inputs:{x:t},backend:e});if("prelu"===n)return JL({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return KL({inputs:{x:t},backend:e,attrs:{alpha:a}});if("sigmoid"===n)return yL({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function aP(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=Na.sizeFromShape(a.shape),o=Na.inferFromImplicitShape(s,i),l=Na.sizeFromShape(o);Na.assert(i===l,(()=>`The new shape (${o}) has ${l} elements and the old shape (${a.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(a.dataId);let u=n.data.get(a.dataId);if(null!=u.complexTensorInfos){let e=u.complexTensorInfos.real,t=u.complexTensorInfos.imag;e.shape=o,t.shape=o}return{dataId:a.dataId,shape:o,dtype:a.dtype}}var sP={kernelName:hr,backendName:"cpu",kernelFunc:aP};function iP(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:i,transposeB:o}=r;DM([a,s],"matMul");let l=a.shape.length,u=s.shape.length,c=i?a.shape[l-2]:a.shape[l-1],p=o?s.shape[u-1]:s.shape[u-2],d=i?a.shape[l-1]:a.shape[l-2],h=o?s.shape[u-2]:s.shape[u-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),g=Na.sizeFromShape(f),y=Na.sizeFromShape(m),b=Fl.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([d,h]);Na.assert(c===p,(()=>`Error in matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`));let w=i?[g,c,d]:[g,d,c],x=o?[y,h,p]:[y,p,h],v=aP({inputs:{x:a},backend:n,attrs:{shape:w}}),k=aP({inputs:{x:s},backend:n,attrs:{shape:x}}),I=i?v.shape[1]:v.shape[2],S=i?v.shape[2]:v.shape[1],N=o?k.shape[1]:k.shape[2],T=Math.max(g,y),_=n.data.get(v.dataId).values,C=n.data.get(k.dataId).values,E=Na.computeStrides(v.shape),A=Na.computeStrides(k.shape),[$,F,R]=i?[E[0],1,E[1]]:[E[0],E[1],1],[D,M,O]=o?[1,A[1],A[0]]:[A[1],1,A[0]],L=S*N,P=fo([T,S,N],v.dtype),z=P.values,B=n.blockSize;for(let W=0;W<T;W++)for(let e=0;e<S;e+=B)for(let t=0;t<N;t+=B)for(let n=0;n<I;n+=B){let r=Math.min(e+B,S),a=Math.min(t+B,N),s=Math.min(n+B,I);for(let i=e;i<r;i++)for(let e=t;e<a;e++){let t=0;for(let r=n;r<s;r++){let n=Math.min(W,g-1)*$,a=Math.min(W,y-1)*O,s=_[n+i*F+r*R],o=C[r*D+e*M+a];t+=s*o}z[W*L+(i*N+e)]+=t}}return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(k),n.makeTensorInfo(b,P.dtype,P.values)}var oP={kernelName:xt,backendName:"cpu",kernelFunc:iP};function lP(e){let t,n,r,{inputs:a,backend:s,attrs:i}=e,{a:o,b:l,bias:u,preluActivationWeights:c}=a,{transposeA:p,transposeB:d,activation:h,leakyreluAlpha:f}=i,m=[];t=iP({inputs:{a:o,b:l},attrs:{transposeA:p,transposeB:d},backend:s}),u&&(n=tO({inputs:{a:t,b:u},backend:s}),m.push(t),t=n),h&&(r=rP(s,t,h,c,f),m.push(t),t=r);for(let g of m)s.disposeIntermediateTensorInfo(g);return t}var uP={kernelName:ua,backendName:"cpu",kernelFunc:lP},cP=iO(rt,(e=>Math.acos(e))),pP={kernelName:rt,backendName:"cpu",kernelFunc:cP},dP=iO(at,(e=>Math.acosh(e))),hP={kernelName:at,backendName:"cpu",kernelFunc:dP};function fP(e){let{inputs:t,backend:n}=e,r=t;DM(t,"addN");let a=r.map((e=>n.data.get(e.dataId).values)),s=fo(r[0].shape,r[0].dtype),i=s.values;for(let o=0;o<r.length;o++){let e=a[o];for(let t=0;t<i.length;t++)i[t]+=e[t]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}var mP={kernelName:it,backendName:"cpu",kernelFunc:fP};function gP(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;DM(a,"all");let o=Na.parseAxisParam(s,a.shape),l=o,u=Aw.getAxesPermutation(l,a.shape.length),c=a;null!=u&&(c=iL({inputs:{x:a},backend:n,attrs:{perm:u}}),l=Aw.getInnerMostAxes(l.length,a.shape.length)),Aw.assertAxesAreInnerMostDims("all",l,c.shape.length);let[p,d]=Aw.computeOutAndReduceShapes(c.shape,l),h=Na.sizeFromShape(d),f=Na.makeZerosTypedArray(Na.sizeFromShape(p),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){let e=y*h,t=m[e];for(let n=0;n<h;++n){let r=m[e+n];t=t&&r}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(p,c.dtype,f);if(i){let e=Aw.expandShapeToKeepDim(p,o),t=aP({inputs:{x:g},backend:n,attrs:{shape:e}});return n.disposeIntermediateTensorInfo(g),t}return g}var yP={kernelName:ot,backendName:"cpu",kernelFunc:gP};function bP(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;DM(a,"any");let o=Na.parseAxisParam(s,a.shape),l=o,u=Aw.getAxesPermutation(l,a.shape.length),c=a;null!=u&&(c=iL({inputs:{x:a},backend:n,attrs:{perm:u}}),l=Aw.getInnerMostAxes(l.length,a.shape.length)),Aw.assertAxesAreInnerMostDims("any",l,c.shape.length);let[p,d]=Aw.computeOutAndReduceShapes(c.shape,l),h=Na.sizeFromShape(d),f=Na.makeZerosTypedArray(Na.sizeFromShape(p),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){let e=y*h,t=m[e];for(let n=0;n<h;++n){let r=m[e+n];t=t||r}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(p,c.dtype,f);if(i){let e=Aw.expandShapeToKeepDim(p,o),t=aP({inputs:{x:g},backend:n,attrs:{shape:e}});return n.disposeIntermediateTensorInfo(g),t}return g}var wP={kernelName:lt,backendName:"cpu",kernelFunc:bP};function xP(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;DM(a,"argMax");let i=Na.parseAxisParam(s,a.shape),o=Aw.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(l=iL({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=Aw.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],Aw.assertAxesAreInnerMostDims("argMax",i,l.shape.length);let[c,p]=Aw.computeOutAndReduceShapes(l.shape,i),d=Na.sizeFromShape(c),h=Na.makeZerosTypedArray(d,"int32"),f=Na.sizeFromShape(p),m=n.data.get(l.dataId).values;for(let g=0;g<h.length;++g){let e=g*f,t=m[e],n=0;for(let r=0;r<f;++r){let a=m[e+r];a>t&&(t=a,n=r)}h[g]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",h)}var vP={kernelName:ut,backendName:"cpu",kernelFunc:xP};function kP(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r;DM(a,"argMin");let i=Na.parseAxisParam(s,a.shape),o=Aw.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(l=iL({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=Aw.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],Aw.assertAxesAreInnerMostDims("argMin",i,l.shape.length);let[c,p]=Aw.computeOutAndReduceShapes(l.shape,i),d=Na.sizeFromShape(c),h=Na.makeZerosTypedArray(d,"int32"),f=Na.sizeFromShape(p),m=n.data.get(l.dataId).values;for(let g=0;g<h.length;++g){let e=g*f,t=m[e],n=0;for(let r=0;r<f;++r){let a=m[e+r];a<t&&(t=a,n=r)}h[g]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",h)}var IP={kernelName:ct,backendName:"cpu",kernelFunc:kP},SP=iO(pt,(e=>Math.asin(e))),NP={kernelName:pt,backendName:"cpu",kernelFunc:SP},TP=iO(dt,(e=>Math.asinh(e))),_P={kernelName:dt,backendName:"cpu",kernelFunc:TP},CP=iO(ht,(e=>Math.atan(e))),EP={kernelName:ht,backendName:"cpu",kernelFunc:CP},AP=WM(((e,t)=>Math.atan2(e,t))),$P=JM(mt,AP),FP={kernelName:mt,backendName:"cpu",kernelFunc:$P},RP=iO(ft,(e=>Math.atanh(e))),DP={kernelName:ft,backendName:"cpu",kernelFunc:RP};function MP(e,t,n,r,a,s){let i=a.strideHeight,o=a.strideWidth,l=a.dilationHeight,u=a.dilationWidth,c=a.effectiveFilterHeight,p=a.effectiveFilterWidth,d=a.padInfo.top,h=a.padInfo.left,f="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=fo(a.outShape,n),g=m.values,y=a.outShape[1]*a.outShape[2]*a.outShape[3],b=a.outShape[2]*a.outShape[3],w=a.outShape[3];for(let x=0;x<a.batchSize;++x){let t=x*y,n=x*r[0];for(let m=0;m<a.inChannels;++m)for(let y=0;y<a.outHeight;++y){let x=y*i-d,v=Math.max(0,x),k=Math.min(a.inHeight,c+x),I=t+y*b;for(let t=0;t<a.outWidth;++t){let i=t*o-h,c=Math.max(0,i),d=Math.min(a.inWidth,p+i),y=f,b=0,x=0;for(let t=v;t<k;t+=l){let a=n+t*r[1];for(let t=c;t<d;t+=u){let n=a+t*r[2],i=e[n+m];"max"===s&&i>y?y=i:"avg"===s&&(b+=i,x++)}if(isNaN(y))break}let S=I+t*w+m;g[S]="avg"===s?b/x:y}}}return m}function OP(e,t,n,r,a=!1,s=!1){let i=fo(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,p=r.effectiveFilterHeight,d=r.effectiveFilterWidth,h=r.padInfo.top,f=r.padInfo.left,m=fo(t,n,e);for(let g=0;g<r.batchSize;++g)for(let e=0;e<r.inChannels;++e)for(let t=0;t<r.outHeight;++t){let n=t*o-h,y=n;for(;y<0;)y+=u;let b=Math.min(r.inHeight,p+n);for(let o=0;o<r.outWidth;++o){let p=o*l-f,h=p;for(;h<0;)h+=c;let w=Math.min(r.inWidth,d+p),x=Number.NEGATIVE_INFINITY,v=-1;for(let t=y;t<b;t+=u){let i=t-n;for(let n=h;n<w;n+=c){let o=n-p,l=m.get(g,t,n,e);l>x&&(x=l,v=a?s?((g*r.inHeight+t)*r.inWidth+n)*r.inChannels+e:(t*r.inWidth+n)*r.inChannels+e:i*d+o)}}i.set(v,g,t,o,e)}}return i}function LP(e,t,n,r,a,s){let i=a.strideDepth,o=a.strideHeight,l=a.strideWidth,u=a.dilationDepth,c=a.dilationHeight,p=a.dilationWidth,d=a.effectiveFilterDepth,h=a.effectiveFilterHeight,f=a.effectiveFilterWidth,m=a.padInfo.front,g=a.padInfo.top,y=a.padInfo.left,b="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,w=fo(a.outShape,n),x=w.values,v=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],k=a.outShape[2]*a.outShape[3]*a.outShape[4],I=a.outShape[3]*a.outShape[4],S=a.outShape[4];for(let N=0;N<a.batchSize;++N){let t=N*v,n=N*r[0];for(let w=0;w<a.inChannels;++w)for(let v=0;v<a.outDepth;++v){let N=v*i-m,T=N;for(;T<0;)T+=u;let _=Math.min(a.inDepth,d+N),C=t+v*k;for(let t=0;t<a.outHeight;++t){let i=t*o-g,d=i;for(;d<0;)d+=c;let m=Math.min(a.inHeight,h+i),v=C+t*I;for(let t=0;t<a.outWidth;++t){let i=t*l-y,o=i;for(;o<0;)o+=p;let h=Math.min(a.inWidth,f+i),g=v+t*S,k=b,I=0,N=0;for(let t=T;t<_;t+=u){let a=n+t*r[1];for(let t=d;t<m;t+=c){let n=a+t*r[2];for(let t=o;t<h;t+=p){let a=n+t*r[3],i=e[a+w];if("max"===s&&i>k?k=i:"avg"===s&&(I+=i,N++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}let C=g+w;x[C]="avg"===s?I/N:k}}}}return w}function PP(e,t){let n=fo(t.outShape,"int32"),r=t.strideDepth,a=t.strideHeight,s=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,p=t.effectiveFilterWidth,d=t.padInfo.front,h=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){let b=y*r-d,w=b;for(;w<0;)w+=i;let x=Math.min(t.inDepth,u+b);for(let r=0;r<t.outHeight;++r){let u=r*a-h,d=u;for(;d<0;)d+=o;let v=Math.min(t.inHeight,c+u);for(let a=0;a<t.outWidth;++a){let h=a*s-f,k=h;for(;k<0;)k+=l;let I=Math.min(t.inWidth,p+h),S=Number.NEGATIVE_INFINITY,N=-1;for(let t=w;t<x;t+=i){let n=t-b;for(let r=d;r<v;r+=o){let a=r-u;for(let s=k;s<I;s+=l){let i=s-h,o=e.get(m,t,r,s,g);o>=S&&(S=o,N=n*c*p+a*c+i)}}}n.set(N,m,y,r,a,g)}}}return n}function zP(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;DM(a,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,u=1;Na.assert(Aw.eitherStridesOrDilationsAreOne(i,u),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`));let c,p=Aw.computePool2DInfo(a.shape,s,i,u,o,l);if(1===p.filterWidth&&1===p.filterHeight&&Na.arraysEqual(p.inShape,p.outShape))c=HM({inputs:{x:a},backend:n});else{let e=n.data.get(a.dataId).values,t=Na.computeStrides(a.shape),r=MP(e,a.shape,a.dtype,t,p,"avg");c=n.makeTensorInfo(p.outShape,a.dtype,r.values)}return c}var BP={kernelName:gt,backendName:"cpu",kernelFunc:zP};function WP(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;DM(a,"avgPool3d");let c=Aw.computePool3DInfo(a.shape,s,i,1,o,l,u),p=n.data.get(a.dataId).values,d=LP(p,a.shape,a.dtype,Na.computeStrides(a.shape),c,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}var VP={kernelName:bt,backendName:"cpu",kernelFunc:WP};function UP(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;DM([a,s],"avgPool3DGrad");let c=Aw.computePool3DInfo(s.shape,i,o,1,l,u),p=c.strideDepth,d=c.strideHeight,h=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,w=c.dilationWidth,x=c.effectiveFilterDepth,v=c.effectiveFilterHeight,k=c.effectiveFilterWidth,I=x-1-c.padInfo.front,S=k-1-c.padInfo.left,N=v-1-c.padInfo.top,T=fo(s.shape,"float32"),_=1/(f*m*g),C=n.bufferSync(a);for(let E=0;E<c.batchSize;++E)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){let a=t-I,s=n-N,i=r-S,o=0;for(let t=0;t<x;t+=y){let n=(a+t)/p;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let t=0;t<v;t+=b){let r=(s+t)/d;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let t=0;t<k;t+=w){let a=(i+t)/h;a<0||a>=c.outWidth||Math.floor(a)!==a||(o+=C.get(E,n,r,a,e))}}}T.set(o*_,E,t,n,r,e)}return n.makeTensorInfo(T.shape,T.dtype,T.values)}var GP={kernelName:wt,backendName:"cpu",kernelFunc:UP};function HP(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;DM([a,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=r,c=Aw.computePool2DInfo(i.shape,o,l,1,u),p=c.strideHeight,d=c.strideWidth,h=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,w=b-1-c.padInfo.left,x=y-1-c.padInfo.top,v=fo(i.shape,"float32"),k=1/(h*f),I=n.data.get(a.dataId).values,S=fo(a.shape,"float32",I);for(let N=0;N<c.batchSize;++N)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inHeight;++t)for(let n=0;n<c.inWidth;++n){let r=t-x,a=n-w,s=0;for(let t=0;t<y;t+=m){let n=(r+t)/p;if(!(n<0||n>=c.outHeight||Math.floor(n)!==n))for(let t=0;t<b;t+=g){let r=(a+t)/d;r<0||r>=c.outWidth||Math.floor(r)!==r||(s+=S.get(N,n,r,e))}}v.set(s*k,N,t,n,e)}return n.makeTensorInfo(v.shape,v.dtype,v.values)}var jP={kernelName:yt,backendName:"cpu",kernelFunc:HP};function qP(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,scale:s,offset:i,mean:o,variance:l}=t;Na.assert(o.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Na.assert(null==i||o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Na.assert(null==s||o.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),DM([a,o,l,s,i],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);let c=n.data.get(a.dataId).values,p=n.data.get(o.dataId).values,d=n.data.get(l.dataId).values,h=s?n.data.get(s.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,y=h.length,b=d.length,w=p.length,x=0,v=0,k=0,I=0;for(let S=0;S<c.length;++S)m[S]=f[x++]+(c[S]-p[v++])*h[k++]/Math.sqrt(d[I++]+u),x>=g&&(x=0),v>=w&&(v=0),k>=y&&(k=0),I>=b&&(I=0);return n.makeTensorInfo(a.shape,a.dtype,m)}var KP={kernelName:dn,backendName:"cpu",kernelFunc:qP};function XP(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;DM([a],"batchToSpaceND");let o=s.reduce(((e,t)=>e*t)),l=Aw.getReshaped(a.shape,s,o),u=Aw.getPermuted(l.length,s.length),c=Aw.getReshapedPermuted(a.shape,s,o),p=Aw.getSliceBeginCoords(i,s.length),d=Aw.getSliceSize(c,i,s.length),h=aP({inputs:{x:a},backend:n,attrs:{shape:l}}),f=iL({inputs:{x:h},backend:n,attrs:{perm:u}}),m=aP({inputs:{x:f},backend:n,attrs:{shape:c}}),g=xL({inputs:{x:m},backend:n,attrs:{begin:p,size:d}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var YP={kernelName:vt,backendName:"cpu",kernelFunc:XP};function JP(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,u=rO(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}var ZP={kernelName:kt,backendName:"cpu",kernelFunc:JP};function QP(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values,o=Aw.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var ez={kernelName:St,backendName:"cpu",kernelFunc:QP},tz=iO(_t,((e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),nz={kernelName:_t,backendName:"cpu",kernelFunc:tz},rz=e=>{let{x:t}=e.inputs,n=e.backend,r=new Float32Array(Na.sizeFromShape(t.shape)),a=n.data.get(t.dataId),s=a.complexTensorInfos.real,i=a.complexTensorInfos.imag,o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values;for(let u=0;u<o.length;u++){let e=o[u],t=l[u];r[u]=Math.hypot(e,t)}return n.makeOutput(r,t.shape,"float32")},az={kernelName:Et,backendName:"cpu",kernelFunc:rz};function sz(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.data.get(r.dataId).complexTensorInfos.imag,s=n.data.get(a.dataId).values;return n.makeTensorInfo(a.shape,a.dtype,s)}var iz={kernelName:wn,backendName:"cpu",kernelFunc:sz};function oz(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=Na.parseAxisParam(a,t[0].shape)[0],i=Aw.computeOutShape(t.map((e=>e.shape)),s);if(0===Na.sizeFromShape(i))return n.makeTensorInfo(i,t[0].dtype,[]);let o=t.filter((e=>Na.sizeFromShape(e.shape)>0));if(1===o.length)return HM({inputs:{x:o[0]},backend:n});let l=o.map((e=>e.shape));if(Aw.assertParamsConsistent(l,s),"complex64"===o[0].dtype){let e=o.map((e=>qM({inputs:{input:e},backend:n}))),t=o.map((e=>sz({inputs:{input:e},backend:n}))),r=oz({inputs:e,backend:n,attrs:{axis:s}}),a=oz({inputs:t,backend:n,attrs:{axis:s}}),i=VM({inputs:{real:r,imag:a},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a),i}let u=o.map((e=>{let t=Na.sizeFromShape(e.shape.slice(s));return aP({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),c=u.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));i=Aw.computeOutShape(u.map((e=>e.shape)),1);let p=1===u[0].shape[0],d=pO(c,i,t[0].dtype,p),h=Aw.computeOutShape(o.map((e=>e.shape)),s),f=n.makeTensorInfo(h,t[0].dtype,d);return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}var lz={kernelName:At,backendName:"cpu",kernelFunc:oz};function uz(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r;DM([a,s],"conv2d");let p=Aw.convertConv2DDataFormat(l),d=Aw.computeConv2DInfo(a.shape,s.shape,i,u,o,c,!1,p),h=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,y=d.padInfo.left,b=d.padInfo.top,w="channelsLast"===d.dataFormat,x=new ps(d.outShape,a.dtype),v=Na.computeStrides(a.shape),k=Na.computeStrides(s.shape),I=v[0],S=w?v[1]:v[2],N=w?v[2]:1,T=w?1:v[1],_=x.strides[0],C=w?x.strides[1]:x.strides[2],E=w?x.strides[2]:1,A=w?1:x.strides[1],$=n.data.get(a.dataId).values,F=n.data.get(s.dataId).values,R=x.values;for(let D=0;D<d.batchSize;++D){let e=D*I,t=D*_;for(let n=0;n<d.outHeight;++n){let r=t+n*C,a=n*d.strideHeight-b;for(let t=0;t<h;++t){let n=a+t*m;if(n<0||n>=d.inHeight)continue;let s=t*k[0],i=e+n*S;for(let e=0;e<d.outWidth;++e){let t=r+e*E,n=e*d.strideWidth-y;for(let e=0;e<f;++e){let r=n+e*g;if(r<0||r>=d.inWidth)continue;let a=s+e*k[1],o=i+r*N,l=a;for(let e=0;e<d.inChannels;++e){let n=$[o+e*T];for(let e=0;e<d.outChannels;++e)R[t+e*A]+=n*F[l+e];l+=d.outChannels}}}}}}return n.makeTensorInfo(x.shape,x.dtype,R)}var cz={kernelName:$t,backendName:"cpu",kernelFunc:uz};function pz(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;DM([a,s],"conv2dBackpropFilter");let p=Aw.convertConv2DDataFormat(l),d=Aw.computeConv2DInfo(a.shape,c,i,1,o,u,!1,p),{strideHeight:h,strideWidth:f,filterHeight:m,filterWidth:g}=d,y="channelsLast"===d.dataFormat,b=new ps(d.filterShape,"float32"),w=d.padInfo.left,x=d.padInfo.top,v=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,I=new ps(a.shape,a.dtype,v),S=new ps(s.shape,s.dtype,k);for(let N=0;N<m;++N){let e=Math.max(0,Math.ceil((x-N)/h)),t=Math.min(d.outHeight,(d.inHeight+x-N)/h);for(let n=0;n<g;++n){let r=Math.max(0,Math.ceil((w-n)/f)),a=Math.min(d.outWidth,(d.inWidth+w-n)/f);for(let s=0;s<d.inChannels;++s)for(let i=0;i<d.outChannels;++i){let o=0;for(let l=0;l<d.batchSize;++l)for(let u=e;u<t;++u){let e=N+u*h-x;for(let t=r;t<a;++t){let r=n+t*f-w;o+=y?I.get(l,e,r,s)*S.get(l,u,t,i):I.get(l,s,e,r)*S.get(l,i,u,t)}}b.set(o,N,n,s,i)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var dz={kernelName:Ft,backendName:"cpu",kernelFunc:pz};function hz(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r;DM([a,s],"conv2dBackpropInput");let p=Na.computeStrides(s.shape),d=Na.computeStrides(a.shape),h=Aw.convertConv2DDataFormat(u),f=Aw.computeConv2DInfo(i,s.shape,o,1,l,c,!1,h),m=new ps(f.inShape,"float32"),g=m.values,y=n.data.get(a.dataId).values,b=n.data.get(s.dataId).values,[w,x,v]=p,{batchSize:k,filterHeight:I,filterWidth:S,inChannels:N,inHeight:T,inWidth:_,outChannels:C,outHeight:E,outWidth:A,strideHeight:$,strideWidth:F}=f;h=f.dataFormat;let R=I-1-f.padInfo.top,D=S-1-f.padInfo.left,M="channelsLast"===h,O=m.strides[0],L=M?m.strides[1]:m.strides[2],P=M?m.strides[2]:1,z=M?1:m.strides[1],B=d[0],W=M?d[1]:d[2],V=M?d[2]:1,U=M?1:d[1];for(let G=0;G<k;++G)for(let e=0;e<N;++e)for(let t=0;t<T;++t){let n=t-R,r=Math.max(0,Math.ceil(n/$)),a=Math.min(E,(I+n)/$);for(let s=0;s<_;++s){let i=s-D,o=Math.max(0,Math.ceil(i/F)),l=Math.min(A,(S+i)/F),u=0;for(let t=r;t<a;++t){let r=t*$-n;for(let n=o;n<l;++n){let a=n*F-i,s=B*G+W*t+V*n,o=w*(I-1-r)+x*(S-1-a)+v*e;for(let e=0;e<C;++e){let t=y[s+U*e],n=b[o+e];u+=t*n}}}let c=O*G+L*t+P*s+z*e;g[c]=u}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}var fz={kernelName:Rt,backendName:"cpu",kernelFunc:hz};function mz(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r;DM([a,s],"conv3d");let u=Aw.computeConv3DInfo(a.shape,s.shape,i,l,o),{filterDepth:c,filterHeight:p,filterWidth:d,dilationDepth:h,dilationHeight:f,dilationWidth:m,padInfo:g}=u,y=g.front,b=g.left,w=g.top,x=new ps(u.outShape,a.dtype),v=n.data.get(a.dataId).values,k=n.data.get(s.dataId).values,I=x.values,S=Na.computeStrides(a.shape),N=Na.computeStrides(s.shape);for(let T=0;T<u.batchSize;++T){let e=T*S[0],t=T*x.strides[0];for(let n=0;n<u.outDepth;++n){let r=t+n*x.strides[1],a=n*u.strideDepth-y;for(let t=0;t<c;++t){let n=a+t*h;if(n<0||n>=u.inDepth)continue;let s=t*N[0],i=e+n*S[1];for(let e=0;e<u.outHeight;++e){let t=r+e*x.strides[2],n=e*u.strideHeight-w;for(let e=0;e<p;++e){let r=n+e*f;if(r<0||r>=u.inHeight)continue;let a=s+e*N[1],o=i+r*S[2];for(let e=0;e<u.outWidth;++e){let n=t+e*u.outChannels,r=e*u.strideWidth-b;for(let e=0;e<d;++e){let t=r+e*m;if(t<0||t>=u.inWidth)continue;let s=a+e*N[2],i=o+t*u.inChannels,l=s;for(let e=0;e<u.inChannels;++e){let t=v[i+e];for(let e=0;e<u.outChannels;++e)I[n+e]+=t*k[l+e];l+=u.outChannels}}}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}var gz={kernelName:Dt,backendName:"cpu",kernelFunc:mz};function yz(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r;DM([a,s],"conv3dBackpropFilterV2");let u=Na.computeStrides(a.shape),c=Na.computeStrides(s.shape),p=Aw.computeConv3DInfo(a.shape,l,i,1,o),d=p.strideDepth,h=p.strideHeight,f=p.strideWidth,m=p.filterDepth,g=p.filterHeight,y=p.filterWidth,b=new ps(p.filterShape,"float32"),w=b.values,[x,v,k,I]=b.strides,S=n.data.get(s.dataId).values,[N,T,_,C]=c,E=n.data.get(a.dataId).values,[A,$,F,R]=u,D=p.padInfo.front,M=p.padInfo.left,O=p.padInfo.top;for(let L=0;L<m;++L){let e=Math.max(0,Math.ceil((D-L)/d)),t=Math.min(p.outDepth,(p.inDepth+D-L)/d),n=L*x;for(let r=0;r<g;++r){let a=Math.max(0,Math.ceil((O-r)/h)),s=Math.min(p.outHeight,(p.inHeight+O-r)/h),i=r*v+n;for(let n=0;n<y;++n){let o=Math.max(0,Math.ceil((M-n)/f)),l=Math.min(p.outWidth,(p.inWidth+M-n)/f),u=n*k+i;for(let i=0;i<p.inChannels;++i){let c=i*I+u;for(let u=0;u<p.outChannels;++u){let m=0;for(let c=0;c<p.batchSize;++c){let p=c*A,g=c*N;for(let c=e;c<t;++c){let e=(L+c*d-D)*$+p,t=c*T+g;for(let c=a;c<s;++c){let a=(r+c*h-O)*F+e,s=c*_+t;for(let e=o;e<l;++e){let t=(n+e*f-M)*R+a,r=e*C+s;m+=E[t+i]*S[r+u]}}}}w[c+u]=m}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var bz={kernelName:Mt,backendName:"cpu",kernelFunc:yz};function wz(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r;DM([a],"conv3dBackpropInputV2");let u=Na.computeStrides(a.shape),c=Na.computeStrides(s.shape),p=Aw.computeConv3DInfo(l,s.shape,o,1,i),d=new ps(p.inShape,"float32"),h=d.values,[f,m,g,y]=d.strides,b=n.data.get(a.dataId).values,[w,x,v,k]=u,I=n.data.get(s.dataId).values,[S,N,T,_]=c,{batchSize:C,filterDepth:E,filterHeight:A,filterWidth:$,inChannels:F,inDepth:R,inHeight:D,inWidth:M,outChannels:O,outDepth:L,outHeight:P,outWidth:z,strideDepth:B,strideHeight:W,strideWidth:V}=p,U=E-1-p.padInfo.front,G=A-1-p.padInfo.top,H=$-1-p.padInfo.left;for(let j=0;j<C;++j)for(let e=0;e<F;++e)for(let t=0;t<R;++t){let n=t-U,r=Math.max(0,Math.ceil(n/B)),a=Math.min(L,(E+n)/B);for(let s=0;s<D;++s){let i=s-G,o=Math.max(0,Math.ceil(i/W)),l=Math.min(P,(A+i)/W);for(let u=0;u<M;++u){let c=u-H,p=Math.max(0,Math.ceil(c/V)),d=Math.min(z,($+c)/V),C=0;for(let t=r;t<a;++t){let r=t*B-n;for(let n=o;n<l;++n){let a=n*W-i;for(let s=p;s<d;++s){let i=s*V-c,o=w*j+x*t+v*n+k*s,l=S*(E-1-r)+N*(A-1-a)+T*($-1-i)+_*e;for(let e=0;e<O;++e){let t=b[o+e],n=I[l+e];C+=t*n}}}}h[f*j+m*t+g*s+y*u+e]=C}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}var xz={kernelName:Ot,backendName:"cpu",kernelFunc:wz},vz=iO(Lt,(e=>Math.cos(e))),kz={kernelName:Lt,backendName:"cpu",kernelFunc:vz},Iz=iO(Pt,(e=>Math.cosh(e))),Sz={kernelName:Pt,backendName:"cpu",kernelFunc:Iz};function Nz(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,[c,p,d,h]=a.shape,f=s.shape[0],[m,g]=o,y=fo([f,m,g,h],"float32"),b=n.data.get(s.dataId).values,w=n.data.get(i.dataId).values,x=n.data.get(a.dataId).values,v=Na.computeStrides(a.shape),k=Na.computeStrides(y.shape);for(let I=0;I<f;I++){let e=4*I,t=b[e],n=b[e+1],r=b[e+2],a=b[e+3],s=w[I];if(s>=c)continue;let i=m>1?(r-t)*(p-1)/(m-1):0,o=g>1?(a-n)*(d-1)/(g-1):0;for(let c=0;c<m;c++){let e=m>1?t*(p-1)+c*i:.5*(t+r)*(p-1);if(e<0||e>p-1)for(let t=0;t<g;t++)for(let e=0;e<h;e++){let n=e+t*k[2]+c*k[1]+I*k[0];y.values[n]=u}else if("bilinear"===l){let t=Math.floor(e),r=Math.ceil(e),i=e-t;for(let e=0;e<g;e++){let l=g>1?n*(d-1)+e*o:.5*(n+a)*(d-1);if(l<0||l>d-1){for(let t=0;t<h;t++){let n=t+e*k[2]+c*k[1]+I*k[0];y.values[n]=u}continue}let p=Math.floor(l),f=Math.ceil(l),m=l-p;for(let n=0;n<h;n++){let a=n+p*v[2]+t*v[1]+s*v[0],o=x[a];a=n+f*v[2]+t*v[1]+s*v[0];let l=x[a];a=n+p*v[2]+r*v[1]+s*v[0];let u=x[a];a=n+f*v[2]+r*v[1]+s*v[0];let d=x[a],h=o+(l-o)*m,g=u+(d-u)*m;a=n+e*k[2]+c*k[1]+I*k[0],y.values[a]=h+(g-h)*i}}}else for(let t=0;t<g;++t){let r=g>1?n*(d-1)+t*o:.5*(n+a)*(d-1);if(r<0||r>d-1){for(let e=0;e<h;e++){let n=e+t*k[2]+c*k[1]+I*k[0];y.values[n]=u}continue}let i=Math.round(r),l=Math.round(e);for(let e=0;e<h;e++){let n=e+i*v[2]+l*v[1]+s*v[0],r=e+t*k[2]+c*k[1]+I*k[0];y.values[r]=x[n]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}var Tz={kernelName:Wt,backendName:"cpu",kernelFunc:Nz};function _z(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;DM(a,"cumprod");let l=Aw.getAxesPermutation([s],a.shape.length),u=a;null!=l&&(u=iL({inputs:{x:a},backend:n,attrs:{perm:l}}));let c=Aw.getInnerMostAxes(1,a.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let p=_s(u.dtype,"int32"),d=Na.makeOnesTypedArray(Na.sizeFromShape(u.shape),p),h=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<h.length;y+=f)for(let e=0;e<f;e++){let t=m(y,e);if(0===e)d[t]=i?1:h[t];else{let n=m(y,e-1);d[t]=i?h[n]*d[n]:h[t]*d[n]}}let g=n.makeTensorInfo(u.shape,p,d);if(null!=l){let e=Aw.getUndoAxesPermutation(l),t=iL({inputs:{x:g},backend:n,attrs:{perm:e}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),t}return g}var Cz={kernelName:zt,backendName:"cpu",kernelFunc:_z};function Ez(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;DM(a,"cumsum");let l=Aw.getAxesPermutation([s],a.shape.length),u=a;null!=l&&(u=iL({inputs:{x:a},backend:n,attrs:{perm:l}}));let c=Aw.getInnerMostAxes(1,a.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let p=_s(u.dtype,"int32"),d=Na.makeZerosTypedArray(Na.sizeFromShape(u.shape),p),h=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<h.length;y+=f)for(let e=0;e<f;e++){let t=m(y,e);if(0===e)d[t]=i?0:h[t];else{let n=m(y,e-1);d[t]=i?h[n]+d[n]:h[t]+d[n]}}let g=n.makeTensorInfo(u.shape,p,d);if(null!=l){let e=Aw.getUndoAxesPermutation(l),t=iL({inputs:{x:g},backend:n,attrs:{perm:e}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),t}return g}var Az={kernelName:Bt,backendName:"cpu",kernelFunc:Ez};function $z(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(1===a.shape.length){let e=n.data.get(a.dataId).values,t=n.data.get(s.dataId).values,r=rO(e,t,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,r)}if(2===a.shape.length){let e=n.bufferSync(a),t=n.bufferSync(s),r=aO(e,t,i,o);return n.makeTensorInfo(r.shape,s.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}var Fz={kernelName:Vt,backendName:"cpu",kernelFunc:$z};function Rz(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r;Na.assert("NHWC"===i,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`));let o=a.shape[0],l=a.shape[1],u=a.shape[2],c=a.shape[3],p=l*s,d=u*s,h=c/(s*s),f=n.data.get(a.dataId).values,m=new Float32Array(o*p*d*h),g=0;for(let y=0;y<o;++y)for(let e=0;e<p;++e){let t=Math.floor(e/s),n=e%s;for(let e=0;e<d;++e){let r=Math.floor(e/s),a=e%s,i=(n*s+a)*h;for(let e=0;e<h;++e){let n=e+i+c*(r+u*(t+l*y));m[g++]=f[n]}}}return n.makeTensorInfo([o,p,d,h],a.dtype,m)}var Dz={kernelName:Ut,backendName:"cpu",kernelFunc:Rz};function Mz(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;DM([a,s],"depthwiseConv2DNative");let c=Na.computeStrides(a.shape),p=Na.computeStrides(s.shape),d=l;null==d&&(d=[1,1]),Na.assert(Aw.eitherStridesOrDilationsAreOne(i,d),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`));let h=Aw.computeConv2DInfo(a.shape,s.shape,i,d,o,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=h,w=b.left,x=b.top,v=h.outChannels/h.inChannels,k=new ps(h.outShape,a.dtype),I=n.data.get(a.dataId).values,S=n.data.get(s.dataId).values,N=k.values;for(let T=0;T<h.batchSize;++T){let e=T*c[0],t=T*k.strides[0];for(let n=0;n<h.outHeight;++n){let r=t+n*k.strides[1],a=n*h.strideHeight-x;for(let t=0;t<f;++t){let n=a+t*g;if(n<0||n>=h.inHeight)continue;let s=t*p[0],i=e+n*c[1];for(let e=0;e<h.outWidth;++e){let t=r+e*k.strides[2],n=e*h.strideWidth-w;for(let e=0;e<m;++e){let r=n+e*y;if(r<0||r>=h.inWidth)continue;let a=s+e*p[1],o=i+r*h.inChannels,l=t,u=a;for(let e=0;e<h.inChannels;++e){let t=I[o+e];for(let e=0;e<v;++e)N[l+e]+=t*S[u+e];l+=v,u+=v}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}var Oz={kernelName:Gt,backendName:"cpu",kernelFunc:Mz};function Lz(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r;DM([a,s],"depthwiseConv2dNativeBackpropFilter");let p=Aw.computeConv2DInfo(a.shape,c,i,o,l,u,!0),{strideHeight:d,strideWidth:h,filterHeight:f,filterWidth:m}=p,g=new ps(p.filterShape,"float32"),y=p.padInfo.left,b=p.padInfo.top,w=p.outChannels/p.inChannels,x=n.data.get(a.dataId).values,v=new ps(a.shape,a.dtype,x),k=n.data.get(s.dataId).values,I=new ps(s.shape,s.dtype,k);for(let S=0;S<f;++S){let e=Math.max(0,Math.ceil((b-S)/d)),t=Math.min(p.outHeight,(p.inHeight+b-S)/d);for(let n=0;n<m;++n){let r=Math.max(0,Math.ceil((y-n)/h)),a=Math.min(p.outWidth,(p.inWidth+y-n)/h);for(let s=0;s<p.outChannels;++s){let i=Math.trunc(s/w),o=s%w,l=0;for(let u=0;u<p.batchSize;++u)for(let o=e;o<t;++o){let e=S+o*d-b;for(let t=r;t<a;++t){let r=n+t*h-y;l+=v.get(u,e,r,i)*I.get(u,o,t,s)}}g.set(l,S,n,i,o)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}var Pz={kernelName:Ht,backendName:"cpu",kernelFunc:Lz};function zz(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r;DM([a,s],"depthwiseConv2DNativeBackpropInput");let p=Na.computeStrides(a.shape),d=Na.computeStrides(s.shape),h=Aw.computeConv2DInfo(c,s.shape,i,o,l,u,!0),f=new ps(h.inShape,"float32"),m=f.values,[g,y,b]=f.strides,w=n.data.get(a.dataId).values,[x,v,k]=p,I=n.data.get(s.dataId).values,[S,N,T]=d,{batchSize:_,filterHeight:C,filterWidth:E,inChannels:A,inHeight:$,inWidth:F,outChannels:R,outHeight:D,outWidth:M,strideHeight:O,strideWidth:L}=h,P=C-1-h.padInfo.top,z=E-1-h.padInfo.left,B=R/A;for(let W=0;W<_;++W)for(let e=0;e<A;++e)for(let t=0;t<$;++t){let n=t-P,r=Math.max(0,Math.ceil(n/O)),a=Math.min(D,(C+n)/O);for(let s=0;s<F;++s){let i=s-z,o=Math.max(0,Math.ceil(i/L)),l=Math.min(M,(E+i)/L),u=0;for(let t=r;t<a;++t){let r=t*O-n;for(let n=o;n<l;++n){let a=n*L-i,s=x*W+v*t+k*n,o=S*(C-1-r)+N*(E-1-a)+T*e;for(let t=0;t<B;++t){let n=e*B+t,r=w[s+n],a=I[o+t];u+=r*a}}}m[g*W+y*t+b*s+e]=u}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}var Bz={kernelName:jt,backendName:"cpu",kernelFunc:zz};function Wz(e){let{inputs:t,backend:n}=e,{x:r}=t,a=Na.sizeFromShape(r.shape),s=n.data.get(r.dataId).values,i=fo([a,a],r.dtype),o=i.values;for(let u=0;u<s.length;u++)o[u*a+u]=s[u];let l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}var Vz={kernelName:qt,backendName:"cpu",kernelFunc:Wz},Uz={kernelName:Kt,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a}=e,{strides:s,pad:i,dilations:o}=n,l=t,u=l.data.get(r.dataId).values,c=r.shape.length,p=l.data.get(a.dataId).values,d=a.shape.length,{batchSize:h,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:w,strideHeight:x,strideWidth:v,filterHeight:k,filterWidth:I,dilationHeight:S,dilationWidth:N,outShape:T}=Aw.computeDilation2DInfo(r.shape,a.shape,s,i,"NHWC",o),_=Na.sizeFromShape(T),C=T.length,E=Na.getArrayFromDType(r.dtype,_);for(let A=0;A<h;++A)for(let e=0;e<y;++e){let t=e*x-w.top;for(let n=0;n<b;++n){let s=n*v-w.left;for(let i=0;i<g;++i){let o=Number.MIN_SAFE_INTEGER;for(let e=0;e<k;++e){let n=t+e*S;if(n>=0&&n<f)for(let t=0;t<I;++t){let l=s+t*N;if(l>=0&&l<m){let s=Na.locToIndex([A,n,l,i],c,Na.computeStrides(r.shape)),h=Na.locToIndex([e,t,i],d,Na.computeStrides(a.shape)),f=u[s]+p[h];f>o&&(o=f)}}}let l=Na.locToIndex([A,e,n,i],C,Na.computeStrides(T));E[l]=o}}}return{dataId:l.write(Na.toTypedArray(E,r.dtype),T,r.dtype),shape:T,dtype:r.dtype}}},Gz={kernelName:Yt,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a,dy:s}=e,{strides:i,pad:o,dilations:l}=n,u=t,c=Na.toNestedArray(r.shape,u.data.get(r.dataId).values),p=Na.toNestedArray(a.shape,u.data.get(a.dataId).values),{batchSize:d,inHeight:h,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:w,strideWidth:x,filterHeight:v,filterWidth:k,dilationHeight:I,dilationWidth:S,outShape:N}=Aw.computeDilation2DInfo(r.shape,a.shape,i,o,"NHWC",l);Na.assert(s.rank===N.length,(()=>`Error in ${Yt}, dy must have the same rank as output ${N.length}, but got ${s.rank}`));let T=Na.toNestedArray(N,u.data.get(s.dataId).values),_=Na.makeZerosNestedTypedArray(a.shape,a.dtype);for(let C=0;C<d;++C)for(let e=0;e<g;++e){let t=e*w-b.top;for(let n=0;n<y;++n){let r=n*x-b.left;for(let a=0;a<m;++a){let s=Number.MIN_SAFE_INTEGER,i=0,o=0;for(let e=0;e<v;++e){let n=t+e*I;if(n>=0&&n<h)for(let t=0;t<k;++t){let l=r+t*S;if(l>=0&&l<f){let r=c[C][n][l][a]+p[e][t][a];r>s&&(s=r,i=e,o=t)}}}_[i][o][a]+=T[C][e][n][a]}}}return{dataId:u.write(Na.toTypedArray(_,r.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},Hz={kernelName:Xt,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:a,dy:s}=e,{strides:i,pad:o,dilations:l}=n,u=t,c=Na.toNestedArray(r.shape,u.data.get(r.dataId).values),p=Na.toNestedArray(a.shape,u.data.get(a.dataId).values),{batchSize:d,inHeight:h,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:w,strideWidth:x,filterHeight:v,filterWidth:k,dilationHeight:I,dilationWidth:S,outShape:N}=Aw.computeDilation2DInfo(r.shape,a.shape,i,o,"NHWC",l);Na.assert(s.rank===N.length,(()=>`Error in ${Xt}, dy must have the same rank as output ${N.length}, but got ${s.rank}`));let T=Na.toNestedArray(N,u.data.get(s.dataId).values),_=Na.makeZerosNestedTypedArray(r.shape,r.dtype);for(let C=0;C<d;++C)for(let e=0;e<g;++e){let t=e*w-b.top;for(let n=0;n<y;++n){let r=n*x-b.left;for(let a=0;a<m;++a){let s=Number.MIN_SAFE_INTEGER,i=t<0?0:t,o=r<0?0:r;for(let e=0;e<v;++e){let n=t+e*I;if(n>=0&&n<h)for(let t=0;t<k;++t){let l=r+t*S;if(l>=0&&l<f){let r=c[C][n][l][a]+p[e][t][a];r>s&&(s=r,i=n,o=l)}}}_[C][i][o][a]+=T[C][e][n][a]}}}return{dataId:u.write(Na.toTypedArray(_,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function jz(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{axis:i,keepDims:o}=a;DM(s,"sum"),t="bool"===s.dtype?XM({inputs:{x:s},backend:r,attrs:{dtype:"int32"}}):HM({inputs:{x:s},backend:r});let l=t.shape.length,u=Na.parseAxisParam(i,t.shape),c=Aw.getAxesPermutation(u,l),p=u,d=t;null!=c&&(d=iL({inputs:{x:t},backend:r,attrs:{perm:c}}),p=Aw.getInnerMostAxes(p.length,l)),Aw.assertAxesAreInnerMostDims("sum",p,d.shape.length);let[h,f]=Aw.computeOutAndReduceShapes(d.shape,p),m=Aw.upcastType(d.dtype,"int32"),g=GM(r,h,m),y=Na.sizeFromShape(f),b=r.data.get(g.dataId).values,w=r.data.get(d.dataId).values;for(let x=0;x<b.length;++x){let e=x*y,t=0;for(let n=0;n<y;++n)t+=w[e+n];b[x]=t}if(o){let e=Aw.expandShapeToKeepDim(g.shape,u),t=g;g=aP({inputs:{x:g},backend:r,attrs:{shape:e}}),r.disposeIntermediateTensorInfo(t)}return r.disposeIntermediateTensorInfo(t),null!=c&&r.disposeIntermediateTensorInfo(d),g}var qz={kernelName:Rr,backendName:"cpu",kernelFunc:jz};function Kz(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=Aw.decodeEinsumEquation(a,s.length);Aw.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:c}=Aw.getEinsumComputePath(o,l),p=c.length,d=null,h=i.length,f=[];for(let m=0;m<p;++m){for(let e of c[m]){let t,{permutationIndices:r,expandDims:a}=Aw.getEinsumPermutation(h,l[e]);Aw.isIdentityPermutation(r)?t=s[e]:(t=iL({inputs:{x:s[e]},backend:n,attrs:{perm:r}}),f.push(t));let i=t.shape.slice();for(let e=0;e<a.length;++e)i.splice(a[e],0,1);Na.arraysEqual(t.shape,i)||(t=aP({inputs:{x:t},backend:n,attrs:{shape:i}}),f.push(t)),null===d?d=t:(d=JO({inputs:{a:t,b:d},backend:n}),f.push(d))}m<p-1&&(u[m]>=0&&(d=jz({inputs:{x:d},backend:n,attrs:{axis:u[m]-(i.length-h),keepDims:!1}}),f.push(d)),h--)}for(let m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}var Xz={kernelName:Zt,backendName:"cpu",kernelFunc:Kz};function Yz(e){let{inputs:t,backend:n}=e,{dy:r,y:a}=t;DM([r,a],"eluGrad");let s=new Float32Array(Na.sizeFromShape(a.shape)),i=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<i.length;++l){let e=i[l];s[l]=e>=1?o[l]:o[l]*(e+1)}return n.makeTensorInfo(a.shape,"float32",s)}var Jz={kernelName:en,backendName:"cpu",kernelFunc:Yz},Zz=Aw.ERF_P,Qz=Aw.ERF_A1,eB=Aw.ERF_A2,tB=Aw.ERF_A3,nB=Aw.ERF_A4,rB=Aw.ERF_A5,aB=iO(tn,(e=>{let t=Math.sign(e),n=Math.abs(e),r=1/(1+Zz*n);return t*(1-((((rB*r+nB)*r+tB)*r+eB)*r+Qz)*r*Math.exp(-n*n))})),sB={kernelName:tn,backendName:"cpu",kernelFunc:aB};function iB(e){let{inputs:t,backend:n,attrs:r}=e,{input:a}=t,{dim:s}=r,i=a.shape.length,o=a.shape.slice(),l=s;return s<0&&(Na.assert(-(i+1)<=s,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+s+1),o.splice(l,0,1),aP({inputs:{x:a},backend:n,attrs:{shape:o}})}var oB={kernelName:an,backendName:"cpu",kernelFunc:iB},lB=WM(((e,t)=>e/t)),uB=JM(Jt,lB),cB={kernelName:Jt,backendName:"cpu",kernelFunc:uB};function pB(e,t,n){let r=e.shape,a=r[0],s=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[a,s],c=Na.sizeFromShape(u),p=Na.getTypedArrayFromDType("float32",c),d=Na.getTypedArrayFromDType("float32",c);for(let g=0;g<a;g++){let e=xL({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,s]}}),r=xL({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,s]}}),a=VM({inputs:{real:e,imag:r},backend:n}),{real:i,imag:u}=dB(a,t,n),c=Aw.mergeRealAndImagArrays(i,u);for(let t=0;t<s;t++){let e=Aw.getComplexWithIndex(c,t);p[g*s+t]=e.real,d[g*s+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(a)}let h=n.makeTensorInfo(u,"float32",p),f=n.makeTensorInfo(u,"float32",d),m=VM({inputs:{real:h,imag:f},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),m}function dB(e,t,n){let r=Na.sizeFromShape(e.shape),a=n.data.get(e.dataId),s=n.data.get(a.complexTensorInfos.real.dataId).values,i=n.data.get(a.complexTensorInfos.imag.dataId).values;if(hB(r)){let a=fB(s,i,r,t,n),o=[e.shape[0],e.shape[1]];if(t){let e=n.makeTensorInfo(o,"float32",a.real),t=n.makeTensorInfo(o,"float32",a.imag),s=n.makeTensorInfo([],"float32",Na.createScalarValue(r,"float32")),i=HM({inputs:{x:s},backend:n}),l=cB.kernelFunc({inputs:{a:e,b:s},backend:n}),u=cB.kernelFunc({inputs:{a:t,b:i},backend:n}),c=n.data.get(l.dataId).values,p=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),{real:c,imag:p}}return a}{let e=Aw.mergeRealAndImagArrays(s,i),n=mB(e,r,t);return Aw.splitRealAndImagArrays(n)}}function hB(e){return 0===(e&e-1)}function fB(e,t,n,r,a){if(1===n)return{real:e,imag:t};let s=Aw.mergeRealAndImagArrays(e,t),i=n/2,o=Aw.complexWithEvenIndex(s),l=o.real,u=o.imag,c=[l.length],p=a.makeTensorInfo(c,"float32",l),d=a.makeTensorInfo(c,"float32",u),h=VM({inputs:{real:p,imag:d},backend:a}),f=Aw.complexWithOddIndex(s),m=f.real,g=f.imag,y=[m.length],b=a.makeTensorInfo(y,"float32",m),w=a.makeTensorInfo(y,"float32",g),x=VM({inputs:{real:b,imag:w},backend:a}),v=fB(l,u,i,r,a),k=v.real,I=v.imag,S=[k.length],N=a.makeTensorInfo(S,"float32",k),T=a.makeTensorInfo(S,"float32",I),_=VM({inputs:{real:N,imag:T},backend:a}),C=fB(m,g,i,r,a),E=C.real,A=C.imag,$=[E.length],F=a.makeTensorInfo($,"float32",E),R=a.makeTensorInfo($,"float32",A),D=VM({inputs:{real:F,imag:R},backend:a}),M=Aw.exponents(n,r),O=[M.real.length],L=a.makeTensorInfo(O,"float32",M.real),P=a.makeTensorInfo(O,"float32",M.imag),z=VM({inputs:{real:L,imag:P},backend:a}),B=JO({inputs:{a:z,b:D},backend:a}),W=tO({inputs:{a:_,b:B},backend:a}),V=zL({inputs:{a:_,b:B},backend:a}),U=qM({inputs:{input:W},backend:a}),G=qM({inputs:{input:V},backend:a}),H=sz({inputs:{input:W},backend:a}),j=sz({inputs:{input:V},backend:a}),q=oz({inputs:[U,G],backend:a,attrs:{axis:0}}),K=oz({inputs:[H,j],backend:a,attrs:{axis:0}}),X=a.data.get(q.dataId).values,Y=a.data.get(K.dataId).values;return a.disposeIntermediateTensorInfo(p),a.disposeIntermediateTensorInfo(d),a.disposeIntermediateTensorInfo(h),a.disposeIntermediateTensorInfo(b),a.disposeIntermediateTensorInfo(w),a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(N),a.disposeIntermediateTensorInfo(T),a.disposeIntermediateTensorInfo(_),a.disposeIntermediateTensorInfo(F),a.disposeIntermediateTensorInfo(R),a.disposeIntermediateTensorInfo(D),a.disposeIntermediateTensorInfo(L),a.disposeIntermediateTensorInfo(P),a.disposeIntermediateTensorInfo(z),a.disposeIntermediateTensorInfo(B),a.disposeIntermediateTensorInfo(W),a.disposeIntermediateTensorInfo(V),a.disposeIntermediateTensorInfo(U),a.disposeIntermediateTensorInfo(H),a.disposeIntermediateTensorInfo(G),a.disposeIntermediateTensorInfo(j),a.disposeIntermediateTensorInfo(q),a.disposeIntermediateTensorInfo(K),{real:X,imag:Y}}function mB(e,t,n){let r=new Float32Array(2*t);for(let a=0;a<t;a++){let s=0,i=0;for(let r=0;r<t;r++){let o=Aw.exponent(a*r,t,n),l=Aw.getComplexWithIndex(e,r);s+=l.real*o.real-l.imag*o.imag,i+=l.real*o.imag+l.imag*o.real}n&&(s/=t,i/=t),Aw.assignToTypedArray(r,s,i,a)}return r}function gB(e){let{inputs:t,backend:n}=e,{input:r}=t,a=Na.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=a/s,o=aP({inputs:{x:r},backend:n,attrs:{shape:[i,s]}}),l=pB(o,!1,n),u=aP({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}var yB={kernelName:on,backendName:"cpu",kernelFunc:gB};function bB(e){let{backend:t,attrs:n}=e,{shape:r,value:a,dtype:s}=n,i=s||Na.inferDtype(a),o=Na.getArrayFromDType(i,Na.sizeFromShape(r));return xB(o,a,i),t.makeTensorInfo(r,i,o)}var wB={kernelName:ln,backendName:"cpu",kernelFunc:bB};function xB(e,t,n){e.fill(t)}var vB={kernelName:un,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,a=n,s=Na.getTypedArrayFromDType(r.dtype,Na.sizeFromShape(r.shape)),[i,o,l,u]=r.shape,c=a.data.get(r.dataId).values;for(let p=0;p<i;p++){let e=p*l*o*u;for(let t=0;t<o;t++){let n=t*(l*u);for(let t=0;t<l;t++){let r=t*u;for(let a=0;a<u;a++){let i=Math.round(l-t-1),o=e+n+r+a,p=c[o];if(i>=0&&i<l){let t=i*u,r=e+n+t+a;p=c[r]}s[o]=p}}}}return{dataId:a.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},kB=WM(((e,t)=>Math.floor(e/t))),IB=JM(pn,kB,null,"int32"),SB={kernelName:pn,backendName:"cpu",kernelFunc:IB};function NB(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:d,activation:h,leakyreluAlpha:f}=r,m=uz({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:d}});if(i){let e=m;if("NCHW"===c&&1===i.shape.length&&1!==i.shape[0]){let e=aP({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=tO({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=tO({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(e)}if(h){let e=m;if("NCHW"===c&&"prelu"===h&&1===o.shape.length&&1!==o.shape[0]){let e=aP({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=rP(n,m,h,e,f),n.disposeIntermediateTensorInfo(e)}else m=rP(n,m,h,o,f);n.disposeIntermediateTensorInfo(e)}return m}var TB={kernelName:ca,backendName:"cpu",kernelFunc:NB};function _B(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:d,activation:h,leakyreluAlpha:f}=r,m=Mz({inputs:{x:a,filter:s},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:p,dimRoundingMode:d}});if(i){let e=m;m=tO({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(h){let e=m;m=rP(n,m,h,o,f),n.disposeIntermediateTensorInfo(e)}return m}var CB={kernelName:pa,backendName:"cpu",kernelFunc:_B};function EB(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=Na.sizeFromShape(r.shape),i=a.shape,o=i[i.length-1],[l,u,c,p]=Aw.prepareAndValidate(r,a);if(0===u)return n.makeTensorInfo(l,r.dtype,[]);let d=n.data.get(a.dataId).values,h=n.bufferSync(r),f=SO(d,h,r.dtype,u,o,c,p,r.shape,s);return n.makeTensorInfo(l,r.dtype,f.values)}var AB={kernelName:fn,backendName:"cpu",kernelFunc:EB};function $B(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r;DM([a,s],"gatherV2");let l=Na.parseAxisParam(i,a.shape)[0],u=n.data.get(s.dataId).values,c=a.shape[l];for(let x=0;x<u.length;++x){let e=u[x];Na.assert(e<=c-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${c-1}]`))}let p=o;null==o&&(p=0);let d=Na.sizeFromShape(s.shape),h=Aw.segment_util.collectGatherOpShapeInfo(a,s,l,p),f=aP({inputs:{x:a},backend:n,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),m=aP({inputs:{x:s},backend:n,attrs:{shape:[h.batchSize,d/h.batchSize]}}),g=[h.batchSize,h.outerSize,d/h.batchSize,h.sliceSize],y=n.bufferSync(m),b=n.bufferSync(f),w=NO(b,y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(h.outputShape,w.dtype,w.values)}var FB={kernelName:hn,backendName:"cpu",kernelFunc:$B};function RB(e){let{inputs:t,backend:n}=e,{input:r}=t,a=Na.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=a/s,o=aP({inputs:{x:r},backend:n,attrs:{shape:[i,s]}}),l=pB(o,!0,n),u=aP({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}var DB={kernelName:bn,backendName:"cpu",kernelFunc:RB},MB=iO(xn,(e=>Number.isFinite(e)?1:0),"bool"),OB={kernelName:xn,backendName:"cpu",kernelFunc:MB},LB=iO(vn,(e=>Math.abs(e)===1/0?1:0),"bool"),PB={kernelName:vn,backendName:"cpu",kernelFunc:LB},zB=iO(kn,(e=>Number.isNaN(e)?1:0),"bool"),BB={kernelName:kn,backendName:"cpu",kernelFunc:zB};function WB(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=PO(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}var VB={kernelName:Tn,backendName:"cpu",kernelFunc:WB},UB=iO(Cn,(e=>Math.log1p(e))),GB={kernelName:Cn,backendName:"cpu",kernelFunc:UB},HB=WM(((e,t)=>e&&t)),jB=JM(En,HB,null,"bool"),qB={kernelName:En,backendName:"cpu",kernelFunc:jB},KB=iO(An,(e=>e?0:1),"bool"),XB={kernelName:An,backendName:"cpu",kernelFunc:KB},YB=WM(((e,t)=>e||t)),JB=JM($n,YB,null,"bool"),ZB={kernelName:$n,backendName:"cpu",kernelFunc:JB};function QB(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r;DM(a,"LRN");let u=a.shape[3],c=u-1,p=n.data.get(a.dataId).values,d=Na.sizeFromShape(a.shape),h=new Float32Array(d);function f(e){let t=e%u,n=e-t+Math.max(0,t-s),r=e-t+Math.min(t+s,c),a=0;for(;n<=r;n++){let e=p[n];a+=e*e}return a}for(let m=0;m<d;m++){let e=f(m),t=p[m]*Math.pow(i+o*e,-l);h[m]=t}return n.makeTensorInfo(a.shape,a.dtype,h)}var eW={kernelName:Dn,backendName:"cpu",kernelFunc:QB};function tW(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r;DM(i,"LRNGrad");let p=Na.sizeFromShape(i.shape),d=i.shape[3],h=n.data.get(i.dataId).values,f=n.data.get(a.dataId).values,m=n.data.get(s.dataId).values,g=new Float32Array(p),y=p;for(let b=0;b<y;b++){let e=b%d,t=b-e+Math.max(0,e-o),n=b-e+Math.min(d,e+o+1),r=0;for(let a=t;a<n;a++)r+=Math.pow(f[a],2);r=u*r+l;for(let a=t;a<n;a++){let e=-2*u*c*f[a]*m[b]/r;b===a&&(e+=Math.pow(r,-c)),e*=h[b],g[a]+=e}}return n.makeTensorInfo(i.shape,a.dtype,g)}var nW={kernelName:Mn,backendName:"cpu",kernelFunc:tW};function rW(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=n,l=a.shape,u=l.length,c=Na.parseAxisParam(s,l),p=c,d=Aw.getAxesPermutation(p,u),h=o.data.get(a.dataId).values;if(null!=d){let e=new Array(u);for(let t=0;t<e.length;t++)e[t]=l[d[t]];h=sL(h,l,a.dtype,d,e),p=Aw.getInnerMostAxes(p.length,u),l=e}DM(a,"max"),Aw.assertAxesAreInnerMostDims("max",p,u);let[f,m]=Aw.computeOutAndReduceShapes(l,p),g=Na.sizeFromShape(m),y=VO(h,g,f,a.dtype),b=o.write(y,f,a.dtype),w=f;return i&&(w=Aw.expandShapeToKeepDim(f,c)),{dataId:b,shape:w,dtype:a.dtype}}var aW={kernelName:On,backendName:"cpu",kernelFunc:rW};function sW(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;DM(a,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,u=1;Na.assert(Aw.eitherStridesOrDilationsAreOne(i,u),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`));let c,p=Aw.computePool2DInfo(a.shape,s,i,u,o,l);if(1===p.filterWidth&&1===p.filterHeight&&Na.arraysEqual(p.inShape,p.outShape))c=HM({inputs:{x:a},backend:n});else{let e=n.data.get(a.dataId).values,t=Na.computeStrides(a.shape),r=MP(e,a.shape,a.dtype,t,p,"max");c=n.makeTensorInfo(p.outShape,a.dtype,r.values)}return c}var iW={kernelName:Pn,backendName:"cpu",kernelFunc:sW};function oW(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;DM(a,"maxPool3d");let c=Aw.computePool3DInfo(a.shape,s,i,1,o,l,u),p=n.data.get(a.dataId).values,d=LP(p,a.shape,a.dtype,Na.computeStrides(a.shape),c,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}var lW={kernelName:Bn,backendName:"cpu",kernelFunc:oW};function uW(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;DM([a,s],"maxPool3DGrad");let c=Aw.computePool3DInfo(s.shape,i,o,1,l,u),p=n.bufferSync(s),d=PP(p,c),h=c.strideDepth,f=c.strideHeight,m=c.strideWidth,g=c.dilationDepth,y=c.dilationHeight,b=c.dilationWidth,w=c.effectiveFilterDepth,x=c.effectiveFilterHeight,v=c.effectiveFilterWidth,k=w-1-c.padInfo.front,I=v-1-c.padInfo.left,S=x-1-c.padInfo.top,N=fo(s.shape,"float32"),T=n.bufferSync(a);for(let _=0;_<c.batchSize;++_)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){let a=t-k,s=n-S,i=r-I,o=0;for(let t=0;t<w;t+=g){let n=(a+t)/h;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let r=0;r<x;r+=y){let a=(s+r)/f;if(!(a<0||a>=c.outHeight||Math.floor(a)!==a))for(let s=0;s<v;s+=b){let l=(i+s)/m;if(l<0||l>=c.outWidth||Math.floor(l)!==l)continue;let u=w*x*v-1-d.get(_,n,a,l,e),p=t*x*v+r*v+s,h=u===p?1:0;0!==h&&(o+=T.get(_,n,a,l,e)*h)}}}N.set(o,_,t,n,r,e)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}var cW={kernelName:Wn,backendName:"cpu",kernelFunc:uW};function pW(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;DM([s,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:p}=r,d=Aw.computePool2DInfo(o.shape,l,u,1,c,p),h=n.data.get(o.dataId).values,f=fo(d.outShape,o.dtype,OP(h,o.shape,o.dtype,d).values),m=d.strideHeight,g=d.strideWidth,y=d.dilationHeight,b=d.dilationWidth,w=d.effectiveFilterHeight,x=d.effectiveFilterWidth,v=x-1-d.padInfo.left,k=w-1-d.padInfo.top,I=fo(o.shape,"float32"),S=n.data.get(a.dataId).values,N=fo(a.shape,"float32",S);for(let T=0;T<d.batchSize;++T)for(let e=0;e<d.inChannels;++e)for(let t=0;t<d.inHeight;++t)for(let n=0;n<d.inWidth;++n){let r=t-k,a=n-v,s=0;for(let t=0;t<w;t+=y){let n=(r+t)/m;if(!(n<0||n>=d.outHeight||Math.floor(n)!==n))for(let r=0;r<x;r+=b){let i=(a+r)/g;if(i<0||i>=d.outWidth||Math.floor(i)!==i)continue;let o=w*x-1-f.get(T,n,i,e),l=t*x+r,u=o===l?1:0;0!==u&&(s+=N.get(T,n,i,e)*u)}}I.set(s,T,t,n,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}var dW={kernelName:zn,backendName:"cpu",kernelFunc:pW};function hW(e,t,n,r,a){let s=Na.computeStrides(t),i=MP(e,t,n,s,a,"max"),o=OP(e,t,n,a,!0,r);return[i.values,o.values]}var fW={kernelName:Vn,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:a,strides:s,pad:i,includeBatchInIndex:o}=t,l=n;DM(r,"MaxPoolWithArgmax");let u=l.data.get(r.dataId).values,c=Aw.computePool2DInfo(r.shape,a,s,[1,1],i),[p,d]=hW(u,r.shape,r.dtype,o,c),h=l.write(p,c.outShape,r.dtype),f=l.write(d,c.outShape,r.dtype);return[{dataId:h,shape:c.outShape,dtype:r.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}};function mW(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=Na.parseAxisParam(s,a.shape),l=Aw.computeOutAndReduceShapes(a.shape,o)[1],u=Na.sizeFromShape(l),c=[],p=n.makeTensorInfo([],"float32",new Float32Array([u]));c.push(p);let d=XM({inputs:{x:a},backend:n,attrs:{dtype:"float32"}});c.push(d);let h=uB({inputs:{a:d,b:p},backend:n});c.push(h);let f=jz({inputs:{x:h},backend:n,attrs:{axis:s,keepDims:i}});return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}var gW={kernelName:Un,backendName:"cpu",kernelFunc:mW};function yW(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;DM(a,"min");let o=Na.parseAxisParam(s,a.shape),l=o,u=Aw.getAxesPermutation(l,a.shape.length),c=a;null!=u&&(c=iL({inputs:{x:a},backend:n,attrs:{perm:u}}),l=Aw.getInnerMostAxes(l.length,a.shape.length)),Aw.assertAxesAreInnerMostDims("min",l,c.shape.length);let[p,d]=Aw.computeOutAndReduceShapes(c.shape,l),h=Na.sizeFromShape(d),f=Na.makeZerosTypedArray(Na.sizeFromShape(p),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){let e=y*h,t=m[e];for(let n=0;n<h;++n){let r=m[e+n];(Number.isNaN(r)||r<t)&&(t=r)}f[y]=t}null!=u&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(p,c.dtype,f);if(i){let e=Aw.expandShapeToKeepDim(p,o),t=aP({inputs:{x:g},backend:n,attrs:{shape:e}});return n.disposeIntermediateTensorInfo(g),t}return g}var bW={kernelName:Gn,backendName:"cpu",kernelFunc:yW};function wW(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,mode:i}=r;DM(a,"mirrorPad");let o=s.map(((e,t)=>e[0]+a.shape[t]+e[1])),l=s.map((e=>e[0])),u=s.map(((e,t)=>e[0]+a.shape[t])),c="reflect"===i?0:1,p=n.data.get(a.dataId).values,d=a.shape.length,h=Na.computeStrides(a.shape),f=Na.sizeFromShape(o),m=o.length,g=Na.computeStrides(o),y=Na.getTypedArrayFromDType(a.dtype,f);for(let b=0;b<f;b++){let e=Na.indexToLoc(b,m,g);for(let n=0;n<m;n++)e[n]<l[n]?e[n]=2*l[n]-e[n]-c:e[n]>=u[n]&&(e[n]=2*(u[n]-1)-e[n]+c);e=e.map(((e,t)=>e-l[t]));let t=Na.locToIndex(e,d,h);y[b]=p[t]}return{dataId:n.write(y,o,a.dtype),shape:o,dtype:a.dtype}}var xW={kernelName:jn,backendName:"cpu",kernelFunc:wW},vW=WM(((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),kW=JM(qn,vW),IW={kernelName:qn,backendName:"cpu",kernelFunc:kW},SW=b(A());function NW(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=a.shape.length,o=s;if(-1===o&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);let l=Na.parseAxisParam([o],a.shape),u=rW({inputs:{x:a},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=Aw.expandShapeToKeepDim(u.shape,l),p=aP({inputs:{x:u},backend:n,attrs:{shape:c}}),d=zL({inputs:{a:a,b:p},backend:n}),h=gO({inputs:{x:d},backend:n}),f=jz({inputs:{x:h},backend:n,attrs:{axis:l,keepDims:!1}}),m=aP({inputs:{x:f},backend:n,attrs:{shape:c}}),g=uB({inputs:{a:h,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var TW={kernelName:Or,backendName:"cpu",kernelFunc:NW};function _W(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r;DM(a,"multinomial");let l=o?a:NW({inputs:{logits:a},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],p=n.data.get(l.dataId).values,d=[u,s],h=Na.makeZerosTypedArray(Na.sizeFromShape(d),"int32");for(let f=0;f<u;++f){let e=f*c,t=new Float32Array(c-1);t[0]=p[e];for(let a=1;a<t.length;++a)t[a]=t[a-1]+p[e+a];let n=SW.alea(i.toString()),r=f*s;for(let a=0;a<s;++a){let e=n();h[r+a]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){h[r+a]=n;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(d,"int32",h)}var CW={kernelName:Kn,backendName:"cpu",kernelFunc:_W},EW=Fx.nonMaxSuppressionV3Impl;function AW(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;DM(a,"NonMaxSuppression");let u=n.data.get(a.dataId).values,c=n.data.get(s.dataId).values,{selectedIndices:p}=EW(u,c,i,o,l);return n.makeTensorInfo([p.length],"int32",new Int32Array(p))}var $W={kernelName:Zn,backendName:"cpu",kernelFunc:AW},FW=Fx.nonMaxSuppressionV4Impl;function RW(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;DM(a,"NonMaxSuppressionPadded");let c=n.data.get(a.dataId).values,p=n.data.get(s.dataId).values,{selectedIndices:d,validOutputs:h}=FW(c,p,i,o,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}var DW={kernelName:Qn,backendName:"cpu",kernelFunc:RW},MW=Fx.nonMaxSuppressionV5Impl;function OW(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;DM(a,"NonMaxSuppressionWithScore");let c=n.data.get(a.dataId).values,p=n.data.get(s.dataId).values,d=i,h=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=MW(c,p,d,h,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var LW={kernelName:er,backendName:"cpu",kernelFunc:OW};function PW(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{depth:s,onValue:i,offValue:o}=r;DM(a,"oneHot");let l=Na.sizeFromShape(a.shape),u=new Float32Array(l*s);u.fill(o);let c=n.data.get(a.dataId).values;for(let p=0;p<l;++p)c[p]>=0&&c[p]<s&&(u[p*s+c[p]]=i);return n.makeTensorInfo([...a.shape,s],"int32",u)}var zW={kernelName:nr,backendName:"cpu",kernelFunc:PW};function BW(e){let{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){let e=qM({inputs:{input:r},backend:n}),t=BW({inputs:{x:e},backend:n}),a=sz({inputs:{input:r},backend:n}),s=BW({inputs:{x:a},backend:n}),i=VM({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}return bB({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var WW={kernelName:sa,backendName:"cpu",kernelFunc:BW};function VW(e){let{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){let e=qM({inputs:{input:r},backend:n}),t=VW({inputs:{x:e},backend:n}),a=sz({inputs:{input:r},backend:n}),s=BW({inputs:{x:a},backend:n}),i=VM({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}return bB({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}var UW={kernelName:tr,backendName:"cpu",kernelFunc:VW};function GW(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return iB({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach((e=>{Na.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),Na.assert(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));let o=[],l=t.map((e=>{let t=iB({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),u=oz({inputs:l,backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}var HW={kernelName:rr,backendName:"cpu",kernelFunc:GW};function jW(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;DM(a,"pad");let o=s.map(((e,t)=>e[0]+a.shape[t]+e[1])),l=s.map((e=>e[0])),u=n.data.get(a.dataId).values,c=Na.sizeFromShape(a.shape),p=a.shape.length,d=Na.computeStrides(a.shape),h=Na.sizeFromShape(o),f=o.length,m=Na.computeStrides(o),g=Na.getTypedArrayFromDType(a.dtype,h);0!==i&&g.fill(i);for(let y=0;y<c;y++){let e=Na.indexToLoc(y,p,d).map(((e,t)=>e+l[t])),t=Na.locToIndex(e,f,m);g[t]=u[y]}return{dataId:n.write(g,o,a.dtype),shape:o,dtype:a.dtype}}var qW={kernelName:ar,backendName:"cpu",kernelFunc:jW},KW=WM(((e,t)=>Math.pow(e,t))),XW=JM(ir,KW),YW={kernelName:ir,backendName:"cpu",kernelFunc:XW};function JW(e){let{backend:t,attrs:n}=e,{start:r,stop:a,dtype:s,step:i}=n,o=pL(r,a,i,s);return t.makeTensorInfo([o.length],s,o)}var ZW={kernelName:ur,backendName:"cpu",kernelFunc:JW},QW=iO(pr,(e=>1/e)),eV={kernelName:pr,backendName:"cpu",kernelFunc:QW};function tV(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;DM(a,"resizeBilinear");let l=Na.computeStrides(a.shape),[u,c]=o,[p,d,h,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(Na.sizeFromShape([p,u,c,f])),y=[s&&u>1?d-1:d,s&&c>1?h-1:h],b=[s&&u>1?u-1:u,s&&c>1?c-1:c],w=0,x=y[0]/b[0],v=y[1]/b[1];for(let k=0;k<p;k++)for(let e=0;e<u;e++){let t;t=i?x*(e+.5)-.5:x*e;let n=Math.max(0,Math.floor(t)),r=t-n,a=Math.min(d-1,Math.ceil(t)),s=k*l[0]+n*l[1],o=k*l[0]+a*l[1];for(let e=0;e<c;e++){let t;t=i?v*(e+.5)-.5:v*e;let n=Math.max(0,Math.floor(t)),a=t-n,u=Math.min(h-1,Math.ceil(t)),c=s+n*l[2],p=o+n*l[2],d=s+u*l[2],y=o+u*l[2];for(let e=0;e<f;e++){let t=m[c+e],n=m[p+e],s=m[d+e],i=m[y+e],o=t+(s-t)*a,l=n+(i-n)*a,u=o+(l-o)*r;g[w++]=u}}}return n.makeTensorInfo([p,u,c,f],"float32",g)}var nV={kernelName:gr,backendName:"cpu",kernelFunc:tV};function rV(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;DM([s,a],"resizeBilinearGrad");let o=Na.computeStrides(a.shape),[l,u,c,p]=a.shape,[,d,h]=s.shape,f=new Float32Array(l*u*c*p),m=[i&&d>1?u-1:u,i&&h>1?c-1:c],g=[i&&d>1?d-1:d,i&&h>1?h-1:h],y=m[0]/g[0],b=m[1]/g[1],w=n.data.get(s.dataId).values,x=0;for(let v=0;v<l;v++){let e=v*o[0];for(let t=0;t<d;t++){let n=t*y,r=Math.floor(n),a=Math.min(Math.ceil(n),u-1),s=e+r*o[1],i=e+a*o[1],l=n-r,d=1-l;for(let e=0;e<h;e++){let t=e*b,n=Math.floor(t),r=Math.min(Math.ceil(t),c-1),a=t-n,u=1-a,h=s+n*o[2],m=s+r*o[2],g=i+n*o[2],y=i+r*o[2],v=d*u,k=d*a,I=l*u,S=l*a;for(let e=0;e<p;e++){let t=w[x++];f[h+e]+=t*v,f[m+e]+=t*k,f[g+e]+=t*I,f[y+e]+=t*S}}}}return n.makeTensorInfo([l,c,u,p],"float32",f)}var aV={kernelName:yr,backendName:"cpu",kernelFunc:rV};function sV(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r;DM(a,"resizeNearestNeighbor");let l=Na.computeStrides(a.shape),[u,c]=o,[p,d,h,f]=a.shape,m=n.data.get(a.dataId).values,g=new Float32Array(p*u*c*f),y=[s&&u>1?d-1:d,s&&c>1?h-1:h],b=[s&&u>1?u-1:u,s&&c>1?c-1:c],w=y[0]/b[0],x=y[1]/b[1],v=0;for(let k=0;k<p;k++){let e=k*l[0];for(let t=0;t<u;t++){let n=i?w*(t+.5):w*t,r=Math.min(d-1,s?Math.round(n):Math.floor(n));i&&(r=Math.max(0,r));let a=e+r*l[1];for(let e=0;e<c;e++){let t=i?x*(e+.5):x*e,n=Math.min(h-1,s?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));let r=a+n*l[2];for(let e=0;e<f;e++){let t=m[r+e];g[v++]=t}}}}return n.makeTensorInfo([p,u,c,f],a.dtype,g)}var iV={kernelName:fr,backendName:"cpu",kernelFunc:sV};function oV(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r;DM([s,a],"resizeNearestNeighborGrad");let o=Na.computeStrides(a.shape),l=Na.computeStrides(s.shape),[u,c,p,d]=a.shape,[,h,f]=s.shape,m=new Float32Array(u*c*p*d),g=n.data.get(s.dataId).values,y=[i&&h>1?c-1:c,i&&f>1?p-1:p],b=[i&&h>1?h-1:h,i&&f>1?f-1:f],w=y[0]/b[0],x=y[1]/b[1],v=1/w,k=1/x,I=2*Math.ceil(v)+2,S=2*Math.ceil(k)+2;for(let N=0;N<u;N++){let e=N*o[0];for(let t=0;t<c;t++){let n=e+t*o[1],r=Math.floor(t*v),a=Math.floor(r-I/2);for(let s=0;s<p;s++){let r=n+s*o[2],u=Math.floor(s*k),y=Math.floor(u-S/2);for(let n=0;n<d;n++){let o=0;for(let r=0;r<I;r++){let u=r+a;if(u<0||u>=h)continue;let d=e+u*l[1],m=u*w,b=Math.min(c-1,i?Math.round(m):Math.floor(m));if(t===b)for(let e=0;e<S;e++){let t=e+y;if(t<0||t>=f)continue;let r=d+t*l[2],a=t*x,u=Math.min(p-1,i?Math.round(a):Math.floor(a));s===u&&(o+=g[r+n])}}m[r+n]=o}}}}return n.makeTensorInfo(a.shape,a.dtype,m)}var lV={kernelName:mr,backendName:"cpu",kernelFunc:oV};function uV(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r;DM(a,"reverse");let i=a.shape.length,o=Na.parseAxisParam(s,a.shape);if(0===i)return HM({inputs:{x:a},backend:n});let l=new ps(a.shape,a.dtype),u=n.bufferSync(a);for(let c=0;c<l.size;c++){let e=l.indexToLoc(c),t=e.slice();o.forEach((e=>t[e]=a.shape[e]-1-t[e])),l.set(u.get(...t),...e)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}var cV={kernelName:wr,backendName:"cpu",kernelFunc:uV},pV={kernelName:la,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:a,fillValue:s,center:i}=t,o=n,l=Na.getTypedArrayFromDType(r.dtype,Na.sizeFromShape(r.shape)),[u,c,p,d]=r.shape,[h,f]=Aw.getImageCenter(i,c,p),m=255,g=Math.sin(a),y=Math.cos(a),b=o.data.get(r.dataId).values;for(let w=0;w<u;w++){let e=w*p*c*d;for(let t=0;t<c;t++){let n=t*(p*d);for(let r=0;r<p;r++){let a=r*d;for(let i=0;i<d;i++){let o=[u,t,r,i],w=o[2],x=o[1],v=(w-h)*y-(x-f)*g,k=(w-h)*g+(x-f)*y;v=Math.round(v+h),k=Math.round(k+f);let I=s;if("number"!=typeof s&&(I=3===i?m:s[i]),v>=0&&v<p&&k>=0&&k<c){let t=k*(p*d),n=v*d,r=e+t+n+i;I=b[r]}let S=e+n+a+i;l[S]=I}}}}return{dataId:o.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},dV=iO(xr,(e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1})),hV={kernelName:xr,backendName:"cpu",kernelFunc:dV};function fV(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:p}=Aw.calculateShapes(s,a,i),d=!0,h=n.bufferSync(a),f=n.bufferSync(s),m=mL(h,f,i,p,u,l,o,c,0,d);return n.makeTensorInfo(i,m.dtype,m.values)}var mV={kernelName:kr,backendName:"cpu",kernelFunc:fV};function gV(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<t?n=a+1:r=a;return r}function yV(e,t){let n=0,r=e.length,a=0;for(;n<r;)a=Math.floor((n+r)/2),e[a]<=t?n=a+1:r=a;return r}function bV(e,t,n,r,a,s){let i=Na.getArrayFromDType("int32",n*a);for(let o=0;o<n;++o){let n=e.slice(o*r,(o+1)*r),l=o*a;for(let e=0;e<a;++e)i[l+e]="left"===s?gV(n,t[e+l]):yV(n,t[e+l])}return i}function wV(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,u=bV(o,l,a.shape[0],a.shape[1],s.shape[1],i);return n.makeTensorInfo(s.shape,"int32",u)}var xV={kernelName:Ir,backendName:"cpu",kernelFunc:wV};function vV(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t;DM([r,a,s],"select");let i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,c=_s(a.dtype,s.dtype),p=Na.makeZerosTypedArray(Na.sizeFromShape(a.shape),c),d=0,h=0===i||i>1||1===a.shape.length?1:Na.sizeFromShape(a.shape.slice(1));for(let f=0;f<o.length;f++)for(let e=0;e<h;e++)1===o[f]?p[d++]=l[f]:p[d++]=u[f];return n.makeTensorInfo(a.shape,c,p)}var kV={kernelName:Sr,backendName:"cpu",kernelFunc:vV},IV=Aw.SELU_SCALEALPHA,SV=Aw.SELU_SCALE,NV=iO(Nr,(e=>e>=0?SV*e:IV*(Math.exp(e)-1))),TV={kernelName:Nr,backendName:"cpu",kernelFunc:NV},_V=iO(Er,(e=>e<0?-1:e>0?1:0)),CV={kernelName:Er,backendName:"cpu",kernelFunc:_V},EV=iO(_r,(e=>Math.sin(e))),AV={kernelName:_r,backendName:"cpu",kernelFunc:EV},$V=iO(Cr,(e=>Math.sinh(e))),FV={kernelName:Cr,backendName:"cpu",kernelFunc:$V},RV=1.1920928955078125e-7,DV=Math.log(RV)+2,MV=iO($r,(e=>{let t,n=e>-DV,r=e<DV,a=Math.exp(e);return t=r?a:n?e:Math.log(1+a),t})),OV={kernelName:$r,backendName:"cpu",kernelFunc:MV};function LV(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;DM([a],"spaceToBatchND");let o=Na.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<a.shape.length;++g)l.push([0,0]);let u=qW.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),c=Aw.getReshaped(u.shape,s,o,!1),p=Aw.getPermuted(c.length,s.length,!1),d=Aw.getReshapedPermuted(u.shape,s,o,!1),h=aP({inputs:{x:u},backend:n,attrs:{shape:c}}),f=iL({inputs:{x:h},backend:n,attrs:{perm:p}}),m=aP({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),m}var PV={kernelName:Dr,backendName:"cpu",kernelFunc:LV};function zV(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n        ${a.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);let o=n.data.get(r.dataId).values,l=n.data.get(a.dataId).values,u=n.data.get(s.dataId).values,c=n.data.get(i.dataId).values[0],[p,d,h,f,m]=kL(o,r.shape,r.dtype,l,a.dtype,u,c);return[n.makeTensorInfo(d,r.dtype,p),n.makeTensorInfo([d[0]],a.dtype,h),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}var BV={kernelName:Lr,backendName:"cpu",kernelFunc:zV};function WV(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.data.get(a.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(s.dataId).values),[u,c,p]=IL(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var VV={kernelName:Pr,backendName:"cpu",kernelFunc:WV};function UV(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,c]=SL(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}var GV={kernelName:zr,backendName:"cpu",kernelFunc:UV};function HV(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,[u,c]=SL(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}var jV={kernelName:Br,backendName:"cpu",kernelFunc:HV};function qV(e){let t,{inputs:n,backend:r,attrs:a}=e,{sparseIndices:s,sparseValues:i,defaultValue:o}=n,{outputShape:l}=a,{sliceRank:u,numUpdates:c,sliceSize:p,strides:d,outputSize:h}=Aw.calculateShapes(i,s,l),f=!1,m=r.bufferSync(s);switch(i.dtype){case"bool":{let e=r.bufferSync(i),n=Boolean(r.data.get(o.dataId).values[0]);t=mL(m,e,l,h,p,c,u,d,n,f);break}case"float32":{let e=r.bufferSync(i),n=r.data.get(o.dataId).values[0];t=mL(m,e,l,h,p,c,u,d,n,f);break}case"int32":{let e=r.bufferSync(i),n=r.data.get(o.dataId).values[0];t=mL(m,e,l,h,p,c,u,d,n,f);break}case"string":{let e=r.bufferSync(i),n=Na.decodeString(r.data.get(o.dataId).values[0]);t=mL(m,e,l,h,p,c,u,d,n,f);break}default:throw new Error(`Unsupported type ${i.dtype}`)}return r.makeTensorInfo(l,t.dtype,t.values)}var KV={kernelName:Wr,backendName:"cpu",kernelFunc:qV};function XV(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=Na.parseAxisParam(i,a.shape)[0],l=Aw.prepareSplitSize(a,s,o),u=new Array(a.shape.length).fill(0),c=a.shape.slice();return l.map((e=>{let t=[...c];t[o]=e;let r=xL({inputs:{x:a},backend:n,attrs:{begin:u,size:t}});return u[o]+=e,r}))}var YV={kernelName:Mr,backendName:"cpu",kernelFunc:XV},JV={kernelName:Ur,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{let{x:n}=e,r=t;DM(n,"square");let a=r.data.get(n.dataId).values,s=new Float32Array(a.length);for(let i=0;i<a.length;++i){let e=a[i];s[i]=e*e}return{dataId:r.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},ZV=iO(ia,((e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),QV={kernelName:ia,backendName:"cpu",kernelFunc:ZV};function eU(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:d}=r;DM(a,"stridedSlice");let h,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:w,end:x,strides:v}=Ql.sliceInfo(a.shape,s,i,o,l,u,c,p,d);if(g)h=aP({inputs:{x:a},backend:n,attrs:{shape:m}});else if(y||b){Na.assert(a.shape.length>=1,(()=>`Input must have rank at least 1, got: ${a.shape.length}`));let e=Ql.computeOutShape(w,x,v),t=xL({inputs:{x:a},backend:n,attrs:{begin:w,size:e}});h=aP({inputs:{x:t},backend:n,attrs:{shape:m}}),n.disposeIntermediateTensorInfo(t)}else{let e=n.bufferSync(a),t=$L(f,e,v,w);h=n.makeTensorInfo(m,t.dtype,t.values)}return h}var tU={kernelName:Gr,backendName:"cpu",kernelFunc:eU};function nU(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:p}=t,d=n.data.get(c.dataId).values,h=n.data.get(p.dataId).values,[f,m]=RL(d,h,a,s,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(p.shape,"int32",m)]}var rU={kernelName:Hr,backendName:"cpu",kernelFunc:nU};function aU(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.data.get(s.dataId).values,l=n.data.get(i.dataId).values[0],[u,c,p]=ML(o,l,a),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(p))]}var sU={kernelName:jr,backendName:"cpu",kernelFunc:aU};function iU(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let i=n.data.get(s.dataId).values,o=OL(i,a);return n.makeTensorInfo(s.shape,"int32",o)}var oU={kernelName:qr,backendName:"cpu",kernelFunc:iU},lU=iO(Xr,(e=>Math.tan(e))),uU={kernelName:Xr,backendName:"cpu",kernelFunc:lU},cU=iO(Yr,(e=>Math.tanh(e))),pU={kernelName:Yr,backendName:"cpu",kernelFunc:cU};function dU(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;DM(a,"tile");let i=WL(n.bufferSync(a),s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}var hU={kernelName:Jr,backendName:"cpu",kernelFunc:dU};function fU(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r;DM(a,"topk");let o=n.data.get(a.dataId).values,[l,u]=GL(o,a.shape,a.dtype,s,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}var mU={kernelName:Zr,backendName:"cpu",kernelFunc:fU};function gU(e){let{inputs:t,attrs:n,backend:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[c,p,d,h]=a.shape,[f,m]=null!=u?u:[p,d],g=[c,f,m,h],y=Na.computeStrides(a.shape),b=y[0],w=y[1],x=y[2],v=Na.getTypedArrayFromDType(a.dtype,Na.sizeFromShape(g));v.fill(l);let k=r.data.get(a.dataId).values,I=r.data.get(s.dataId).values;for(let S=0;S<c;++S){let e=1===s.shape[0]?I:I.subarray(8*S,8*S+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let r=0;r<h;++r){let a,s=e[6]*n+e[7]*t+1;if(0===s)continue;let u=(e[0]*n+e[1]*t+e[2])/s,c=(e[3]*n+e[4]*t+e[5])/s,h=bU(u,d,o),f=bU(c,p,o);switch(i){case"nearest":a=SU(k,p,d,b,w,x,S,f,h,r,l);break;case"bilinear":a=NU(k,p,d,b,w,x,S,f,h,r,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let m=S*b+t*w+n*x+r;v[m]=a}return r.makeTensorInfo(g,a.dtype,v)}return{dataId:r.write(v,g,a.dtype),shape:a.shape,dtype:a.dtype}}var yU={kernelName:Qr,backendName:"cpu",kernelFunc:gU};function bU(e,t,n){switch(n){case"reflect":return wU(e,t);case"wrap":return xU(e,t);case"nearest":return kU(e,t);case"constant":default:return vU(e,t)}}function wU(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{let e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return Na.clamp(0,n,t-1)}function xU(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{let e=t-1;n-=t*Math.trunc(n/e)}return Na.clamp(0,n,t-1)}function vU(e,t){return e}function kU(e,t){return Na.clamp(0,e,t-1)}function IU(e,t,n,r,a,s,i,o,l,u,c){let p=i*r+o*a+l*s+u;return 0<=o&&o<t&&0<=l&&l<n?e[p]:c}function SU(e,t,n,r,a,s,i,o,l,u,c){let p=Math.round(o),d=Math.round(l);return IU(e,t,n,r,a,s,i,p,d,u,c)}function NU(e,t,n,r,a,s,i,o,l,u,c){let p=Math.floor(o),d=Math.floor(l),h=p+1,f=d+1,m=(f-l)*IU(e,t,n,r,a,s,i,p,d,u,c)+(l-d)*IU(e,t,n,r,a,s,i,p,f,u,c),g=(f-l)*IU(e,t,n,r,a,s,i,h,d,u,c)+(l-d)*IU(e,t,n,r,a,s,i,h,f,u,c);return(h-o)*m+(o-p)*g}function TU(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;DM(s,"unique");let i=r.data.get(s.dataId).values,{outputValues:o,outputShape:l,indices:u}=HL(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}var _U={kernelName:ta,backendName:"cpu",kernelFunc:TU};function CU(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a.shape.length,o=a.shape[s],l=new Array(i-1),u=0;for(let h=0;h<i;h++)h!==s&&(l[u++]=a.shape[h]);let c=new Array(i).fill(0),p=a.shape.slice();p[s]=1;let d=new Array(o);for(let h=0;h<d.length;h++){c[s]=h;let e=xL({inputs:{x:a},backend:n,attrs:{begin:c,size:p}});d[h]=aP({inputs:{x:e},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(e)}return d}var EU={kernelName:na,backendName:"cpu",kernelFunc:CU};function AU(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r;DM(a,"unsortedSegmentSum");let o=a.shape.length,l=s.shape.length,u=[],c=[],p=o-l,d=s;for(let f=0;f<p;++f){let e=iB({inputs:{input:d},backend:n,attrs:{dim:f+1}});d=e,c.push(e)}for(let f=0;f<i;++f){let e=Na.createScalarValue(f,"int32"),t=n.makeTensorInfo([],"int32",e),r=hO({inputs:{a:t,b:d},backend:n}),s=XM({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),i=JO({inputs:{a:s,b:a},backend:n}),o=jz({inputs:{x:i},backend:n,attrs:{axis:0,keepDims:!1}});u.push(o),c.push(t),c.push(r),c.push(s),c.push(i),c.push(o)}let h=GW({inputs:u,backend:n,attrs:{axis:0}});return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}var $U={kernelName:ra,backendName:"cpu",kernelFunc:AU},FU=[uP,BM,pP,hP,nO,mP,yP,wP,vP,IP,NP,_P,EP,FP,DP,BP,VP,GP,jP,oP,KP,YP,ZP,ez,YM,cO,nz,UM,az,lz,cz,dz,fz,gz,bz,xz,kz,Sz,Tz,Cz,Az,Fz,Dz,Oz,Pz,Bz,Vz,Uz,Gz,Hz,Xz,qL,Jz,fO,sB,yO,oB,xO,yB,wB,vB,IO,SB,TB,CB,AB,FB,CO,$O,jM,DB,iz,OB,PB,BB,XL,DO,LO,VB,WO,GB,qB,XB,ZB,eW,nW,aW,HO,iW,lW,cW,dW,fW,gW,bW,KO,xW,IW,CW,ZO,tL,$W,DW,LW,aL,zW,UW,HW,qW,YW,ZL,cL,ZW,KM,cB,eV,eP,nP,sP,nV,aV,iV,lV,cV,pV,hV,fL,mV,xV,kV,TV,bL,CV,AV,FV,vL,TW,OV,PV,BV,VV,GV,jV,KV,YV,_L,JV,AL,QV,tU,rU,sU,oU,BL,qz,uU,pU,hU,mU,yU,oL,_U,EU,$U,WW];for(let Jre of FU)wa(Jre);var RU={};g(RU,{assertNotComplex:()=>KG,bindCanvasToFramebuffer:()=>IG,bindColorTextureToFramebuffer:()=>SG,bindTextureToProgramUniformSampler:()=>kG,bindTextureUnit:()=>bG,bindVertexBufferToProgramAttribute:()=>yG,callAndCheck:()=>XU,canBeRepresented:()=>QU,createFragmentShader:()=>rG,createFramebuffer:()=>gG,createProgram:()=>lG,createStaticIndexBuffer:()=>dG,createStaticVertexBuffer:()=>pG,createTexture:()=>fG,createVertexShader:()=>nG,getBatchDim:()=>AG,getExtensionOrThrow:()=>tG,getFramebufferErrorMessage:()=>_G,getMaxTexturesInShader:()=>zG,getNumChannels:()=>hG,getProgramUniformLocation:()=>vG,getProgramUniformLocationOrThrow:()=>xG,getRowsCols:()=>$G,getShapeAs3D:()=>FG,getTextureShapeFromLogicalShape:()=>RG,getWebGLDisjointQueryTimerVersion:()=>BG,getWebGLErrorMessage:()=>eG,getWebGLMaxTextureSize:()=>OG,hasExtension:()=>WG,isCapableOfRenderingToFloatTexture:()=>UG,isDownloadFloatTextureEnabled:()=>GG,isReshapeFree:()=>MG,isWebGLFenceEnabled:()=>qG,isWebGLVersionEnabled:()=>VG,linkProgram:()=>uG,logShaderSourceAndInfoLog:()=>oG,resetMaxTextureSize:()=>LG,resetMaxTexturesInShader:()=>PG,unbindColorTextureFromFramebuffer:()=>NG,unbindTextureUnit:()=>wG,validateFramebuffer:()=>TG,validateProgram:()=>cG,validateTextureSize:()=>mG});var DU,MU,OU,LU={},PU={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function zU(e,t){LU[e]=t}function BU(e,t){if(!(e in LU)||null!=t){let n=VU(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;LU[e]=n}let n=LU[e];return null==n||n.isContextLost()?(delete LU[e],BU(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),LU[e])}function WU(e){if("undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function VU(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let n=null==t?WU(e):t;return n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete LU[e]}),!1),1===e?n.getContext("webgl",PU)||n.getContext("experimental-webgl",PU):n.getContext("webgl2",PU)}function UU(e,t){return[t,e]}function GU(e,t){return e*t}function HU(e){let t=Na.sizeFromShape(e),n=Math.ceil(t/4);return Na.sizeToSquarishShape(n)}function jU(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function qU(e,t){let[n,r]=jU(e,t);return n*r*4}function KU(e,t){let n,r,a,s,i,o,l,u,c,p,d=e;return 2===Xe().getNumber("WEBGL_VERSION")?(n=d.R32F,r=d.R16F,a=d.RGBA16F,s=d.RGBA32F,i=d.RED,l=4,u=1,c=d.HALF_FLOAT,p=d.FLOAT,o=d.RGBA8):(n=e.RGBA,r=e.RGBA,a=e.RGBA,s=d.RGBA,i=e.RGBA,l=4,u=4,c=null!=t?t.HALF_FLOAT_OES:null,p=e.FLOAT,o=e.RGBA),{internalFormatFloat:n,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:s,textureFormatFloat:i,downloadTextureFormat:o,downloadUnpackNumChannels:l,defaultNumChannels:u,textureTypeHalfFloat:c,textureTypeFloat:p}}function XU(e,t){let n=t();return Xe().getBool("DEBUG")&&YU(e),n}function YU(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+eG(e,t))}(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"})(DU||(DU={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(MU||(MU={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(OU||(OU={}));var JU=5.96e-8,ZU=65504;function QU(e){return!!(Xe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||JU<Math.abs(e)&&Math.abs(e)<ZU)}function eG(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function tG(e,t){return CG(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}function nG(e,t){let n=CG(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(XU(e,(()=>e.shaderSource(n,t))),XU(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function rG(e,t){let n=CG(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(XU(e,(()=>e.shaderSource(n,t))),XU(e,(()=>e.compileShader(n))),Xe().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw oG(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var aG,sG,iG=/ERROR: [0-9]+:([0-9]+):/g;function oG(e,t){let n=iG.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);let r=+n[1],a=e.split("\n"),s=a.length.toString().length+2,i=a.map(((e,t)=>Na.rightPad((t+1).toString(),s)+e)),o=0;for(let p=0;p<i.length;p++)o=Math.max(i[p].length,o);let l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${Na.rightPad(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function lG(e){return CG(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}function uG(e,t){if(XU(e,(()=>e.linkProgram(t))),!Xe().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function cG(e,t){if(XU(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function pG(e,t){let n=CG(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return XU(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),XU(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function dG(e,t){let n=CG(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return XU(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),XU(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}function hG(){return 2===Xe().getNumber("WEBGL_VERSION")?1:4}function fG(e){return CG(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}function mG(e,t){let n=Xe().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){let n=`[${e}x${t}]`;throw new Error("Requested texture size "+n+" is invalid.")}if(e>n||t>n){let r=`[${e}x${t}]`,a=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+a+".")}}function gG(e){return CG(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}function yG(e,t,n,r,a,s,i){let o=e.getAttribLocation(t,n);return-1!==o&&(XU(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,r))),XU(e,(()=>e.vertexAttribPointer(o,a,e.FLOAT,!1,s,i))),XU(e,(()=>e.enableVertexAttribArray(o))),!0)}function bG(e,t,n){EG(e,n),XU(e,(()=>e.activeTexture(e.TEXTURE0+n))),XU(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}function wG(e,t){EG(e,t),XU(e,(()=>e.activeTexture(e.TEXTURE0+t))),XU(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function xG(e,t,n){return CG(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}function vG(e,t,n){return e.getUniformLocation(t,n)}function kG(e,t,n,r){XU(e,(()=>bG(e,t,r))),XU(e,(()=>e.uniform1i(n,r)))}function IG(e){XU(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),XU(e,(()=>e.viewport(0,0,e.canvas.width,e.canvas.height))),XU(e,(()=>e.scissor(0,0,e.canvas.width,e.canvas.height)))}function SG(e,t,n){XU(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),XU(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function NG(e,t){XU(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),XU(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function TG(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+_G(e,t))}function _G(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function CG(e,t,n){let r=XU(e,(()=>t()));if(null==r)throw new Error(n);return r}function EG(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){let e=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${e}.`)}}function AG(e,t=2){return Na.sizeFromShape(e.slice(0,e.length-t))}function $G(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function FG(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[AG(e),...$G(e)]),t}function RG(e,t=!1){let n=Xe().getNumber("WEBGL_MAX_TEXTURE_SIZE");t&&(n*=2,e=e.map(((t,n)=>n>=e.length-2?Na.nearestLargerEven(e[n]):e[n])),1===e.length&&(e=[2,e[0]])),2!==e.length&&(e=Na.squeezeShape(e).newShape);let r=Na.sizeFromShape(e);if(e.length<=1&&r<=n)return[1,r];if(2===e.length&&e[0]<=n&&e[1]<=n)return e;if(3===e.length&&e[0]*e[1]<=n&&e[2]<=n)return[e[0]*e[1],e[2]];if(3===e.length&&e[0]<=n&&e[1]*e[2]<=n)return[e[0],e[1]*e[2]];if(4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n)return[e[0]*e[1]*e[2],e[3]];if(4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n)return[e[0],e[1]*e[2]*e[3]];if(t){let t=AG(e),n=2,a=2;return e.length&&([n,a]=$G(e)),r=t*(n/2)*(a/2),Na.sizeToSquarishShape(r).map((e=>2*e))}return Na.sizeToSquarishShape(r)}function DG(e){return e%2===0}function MG(e,t){if(e=e.slice(-2),t=t.slice(-2),Na.arraysEqual(e,t)||!e.length||!t.length||0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){let n=e.slice(-1)[0],r=t.slice(-1)[0];if(n===r||DG(n)&&DG(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&DG(e[0])&&DG(t[0])}function OG(e){if(null==aG){let t=BU(e);aG=t.getParameter(t.MAX_TEXTURE_SIZE)}return aG}function LG(){aG=null}function PG(){sG=null}function zG(e){if(null==sG){let t=BU(e);sG=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,sG)}function BG(e){if(0===e)return 0;let t,n=BU(e);return t=WG(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:WG(n,"EXT_disjoint_timer_query")?1:0,t}function WG(e,t){return null!=e.getExtension(t)}function VG(e){try{if(null!=BU(e))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function UG(e){if(0===e)return!1;let t=BU(e);if(1===e){if(!WG(t,"OES_texture_float"))return!1}else if(!WG(t,"EXT_color_buffer_float"))return!1;return HG(t)}function GG(e){if(0===e)return!1;let t=BU(e);if(1!==e){if(WG(t,"EXT_color_buffer_float"))return HG(t);let e="EXT_color_buffer_half_float";if(WG(t,e)){let n=t.getExtension(e);return jG(t,n)}return!1}return!(!WG(t,"OES_texture_float")||!WG(t,"WEBGL_color_buffer_float"))&&HG(t)}function HG(e){let t=KU(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);let r=1,a=1;e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,r,a,0,t.textureFormatFloat,t.textureTypeFloat,null);let s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(s),i}function jG(e,t){let n=KU(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);let a=1,s=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,a,s,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(i),o}function qG(e){return 2===e&&null!=BU(e).fenceSync}function KG(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&Na.assert("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}var XG=Xe();function YG(){let e,t,n,r,a,s,i,o,l,u;return 2===Xe().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",a="texture",s="outputColor",i="out vec4 outputColor;",o="\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",a="texture2D",s="gl_FragColor",i="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:a,output:s,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function JG(e,t,n="index"){let r=Na.computeStrides(t);return r.map(((t,a)=>{let s=`int ${e[a]} = ${n} / ${t}`,i=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${t}`:`index -= ${e[a]} * ${t}`;return`${s}; ${i};`})).join("")}function ZG(e,t,n="index"){let r=Na.computeStrides(t);return r.map(((t,a)=>{let s=`int ${e[a]} = ${n} / outShapeStrides[${a}]`,i=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * outShapeStrides[${a}]`:`index -= ${e[a]} * outShapeStrides[${a}]`;return`${s}; ${i};`})).join("")}function QG(e,t){let n=e.length,r=e.map((e=>`${t}[${e}]`)),a=new Array(n-1);a[n-2]=r[n-1];for(let s=n-3;s>=0;--s)a[s]=`(${a[s+1]} * ${r[s+1]})`;return a}function eH(e,t,n="index"){let r=e.map(((e,t)=>t)),a=QG(r,t);return a.map(((t,r)=>{let s=`int ${e[r]} = ${n} / ${a[r]}`,i=r===a.length-1?`int ${e[r+1]} = ${n} - ${e[r]} * ${a[r]}`:`index -= ${e[r]} * ${a[r]}`;return`${s}; ${i};`})).join("")}function tH(e){let t=Na.computeStrides(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}function nH(){return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n"}XG.registerFlag("HAS_WEBGL",(()=>XG.getNumber("WEBGL_VERSION")>0)),XG.registerFlag("WEBGL_VERSION",(()=>VG(2)?2:VG(1)?1:0)),XG.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),XG.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===XG.get("WEBGL_VERSION"))),XG.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),XG.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),XG.registerFlag("WEBGL_PACK",(()=>XG.getBool("HAS_WEBGL"))),XG.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>XG.getBool("WEBGL_PACK"))),XG.registerFlag("WEBGL_PACK_CLIP",(()=>XG.getBool("WEBGL_PACK"))),XG.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>XG.getBool("WEBGL_PACK"))),XG.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>XG.getBool("WEBGL_PACK"))),XG.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>XG.getBool("WEBGL_PACK"))),XG.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>XG.getBool("WEBGL_PACK"))),XG.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>XG.getBool("WEBGL_PACK"))),XG.registerFlag("WEBGL_PACK_REDUCE",(()=>XG.getBool("WEBGL_PACK"))),XG.registerFlag("WEBGL_LAZILY_UNPACK",(()=>XG.getBool("WEBGL_PACK"))),XG.registerFlag("WEBGL_CONV_IM2COL",(()=>XG.getBool("WEBGL_PACK"))),XG.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>OG(XG.getNumber("WEBGL_VERSION")))),XG.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>zG(XG.getNumber("WEBGL_VERSION")))),XG.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{let e=XG.getNumber("WEBGL_VERSION");return 0===e?0:BG(e)})),XG.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>XG.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Us.isMobile())),XG.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>UG(XG.getNumber("WEBGL_VERSION")))),XG.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!XG.getBool("WEBGL_FORCE_F16_TEXTURES")&&XG.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),XG.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>GG(XG.getNumber("WEBGL_VERSION")))),XG.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>qG(XG.getNumber("WEBGL_VERSION")))),XG.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>XG.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),XG.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),XG.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>Us.isMobile()?1:-1),(e=>{if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),XG.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),XG.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),XG.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),XG.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128));var rH="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:aH}=Aw;function sH(e,t,n){let r=[];if(e.forEach((e=>{let t=Na.sizeFromShape(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){let{uniformShape:t}=qH(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`);break;default:break}r.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break;default:break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));let a,s,i=r.join("\n"),o=e.map((e=>lH(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),l=t.texShape,u=YG(),c=pH(u),p=fH(u);return t.isPacked?(a=uH(t.logicalShape,l,n.enableShapeUniforms),s=hH(u)):(a=cH(t.logicalShape,l,n.enableShapeUniforms),s=dH(u)),n.packedInputs&&(p+=bH),[p,c,s,i,a,o,n.userCode].join("\n")}function iH(e,t=!1){let n=e.shapeInfo.logicalShape;switch(n.length){case 0:return FH(e,t);case 1:return DH(e,t);case 2:return OH(e,t);case 3:return PH(e,t);case 4:return BH(e,t);case 5:return WH(e);case 6:return VH(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function oH(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return $H(e);case 1:return RH(e,t);case 2:return MH(e,t);case 3:return LH(e,t);default:return zH(e,t)}}function lH(e,t,n=!1,r){let a="";a+=n?oH(e,r):iH(e,r);let s=e.shapeInfo.logicalShape,i=t.logicalShape;return s.length<=i.length&&(a+=n?GH(e,t):HH(e,t)),a}function uH(e,t,n){switch(e.length){case 0:return wH();case 1:return xH(e,t,n);case 2:return CH(e,t,n);case 3:return kH(e,t,n);default:return SH(e,t,n)}}function cH(e,t,n){switch(e.length){case 0:return wH();case 1:return vH(e,t,n);case 2:return EH(e,t,n);case 3:return IH(e,t,n);case 4:return NH(e,t,n);case 5:return TH(e,t);case 6:return _H(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function pH(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}function dH(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}function hH(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}function fH(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${mH}\n    ${gH}\n    ${yH}\n  `}var mH="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",gH="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",yH="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",bH="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function wH(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function xH(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}function vH(e,t,n){return 1===t[0]?n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}function kH(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[2]/2),s=a*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}function IH(e,t,n){if(n)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${ZG(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`;let r=JG(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}function SH(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(e[e.length-1]/2),s=a*Math.ceil(e[e.length-2]/2),i=s,o="",l="b, r, c";for(let u=2;u<e.length-1;u++)i*=e[e.length-u-1],o=`\n      int b${u} = index / ${i};\n      index -= b${u} * ${i};\n    `+o,l=`b${u}, `+l;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${s};\n      index -= b * ${s};\n\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec${e.length}(${l});\n    }\n  `}function NH(e,t,n){if(n)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${ZG(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `;let r=JG(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}function TH(e,t){let n=JG(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}function _H(e,t){let n=JG(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}function CH(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Na.arraysEqual(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;let a=Math.ceil(e[1]/2);return n?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${a});\n      int c = imod(index, ${a}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}function EH(e,t,n){return Na.arraysEqual(e,t)?n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===e[1]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:n?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}function AH(e){return`offset${e}`}function $H(e){let t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=YG();return`\n    vec4 ${n}() {\n      return ${r.texture2D}(${t}, halfCR);\n    }\n  `}function FH(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;let[a,s]=e.shapeInfo.texShape;if(1===a&&1===s)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;let i=AH(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `;let[o,l]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${o}, ${l}, ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}function RH(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e.shapeInfo.texShape,s=YG();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `;let i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}function DH(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${UH(e)}\n      }\n    `;let a=e.shapeInfo.texShape,s=a[0],i=a[1];if(1===i&&1===s)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;let o=AH(n);return 1===i?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:1===s?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${s}, ${i}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}function MH(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=s[0],o=s[1],l=YG();if(null!=s&&Na.arraysEqual(n,s))return t?`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${a}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;let u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],c=Math.ceil(n[1]/2);return`\n    vec4 ${a}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}function OH(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape;if(null!=s&&Na.arraysEqual(n,s)){if(t)return`\n      float ${a}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;let e=s[0],n=s[1];return`\n    float ${a}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}let{newShape:i,keptDims:o}=Na.squeezeShape(n),l=i;if(l.length<n.length){let n=KH(e,l),r=["row","col"];return`\n      ${iH(n,t)}\n      float ${a}(int row, int col) {\n        return ${a}(${XH(r,o)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${UH(e)}\n      }\n    `;let u=s[0],c=s[1],p=AH(r);return 1===c?t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${p}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===u?t?`\n      float ${a}(int row, int col) {\n        float index = dot(vec3(row, col, ${p}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col) {\n      float index = dot(vec3(row, col, ${p}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${a}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${p};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${a}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${p};\n    vec2 uv = uvFromFlat(${u}, ${c}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}function LH(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===n[0]){let r=n.slice(1),s=[1,2],i=KH(e,r),o=["b","row","col"];return`\n        ${oH(i,t)}\n        vec4 ${a}(int b, int row, int col) {\n          return ${a}(${XH(o,s)});\n        }\n      `}let o=YG();if(t)return`\n    vec4 ${a}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `;let l=i[0],u=i[1],c=Math.ceil(n[2]/2),p=c*Math.ceil(n[1]/2);return`\n    vec4 ${a}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${p}, ${c}, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `}function PH(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=Na.squeezeShape(n),u=o;if(u.length<n.length){let n=KH(e,u),r=["row","col","depth"];return`\n        ${iH(n,t)}\n        float ${a}(int row, int col, int depth) {\n          return ${a}(${XH(r,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${s}, ${i}, 1)));\n        ${UH(e)}\n      }\n    `;let c=e.shapeInfo.texShape,p=c[0],d=c[1],h=e.shapeInfo.flatOffset;if(d===s&&null==h)return t?`\n      float ${a}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${a}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${d}.0, ${p}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(d===i&&null==h)return t?`\n      float ${a}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${a}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${p}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;let f=AH(r);return t?`\n    float ${a}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * ${s} + col * ${i} + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${a}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s} + col * ${i} + depth + ${f};\n        vec2 uv = uvFromFlat(${p}, ${d}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}function zH(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=YG();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${a.texture2D}(${n}, uv);\n    }\n  `;let s=e.shapeInfo.logicalShape,i=s.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],p=Math.ceil(s[i-1]/2),d=p*Math.ceil(s[i-2]/2),h="int b, int row, int col",f=`b * ${d} + (row / 2) * ${p} + (col / 2)`;for(let m=2;m<i-1;m++)h=`int b${m}, `+h,d*=s[i-m-1],f=`b${m} * ${d} + `+f;return`\n    vec4 ${r}(${h}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}function BH(e,t){let n=e.shapeInfo.logicalShape,r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[3],i=n[2]*s,o=n[1]*i,{newShape:l,keptDims:u}=Na.squeezeShape(n);if(l.length<n.length){let n=KH(e,l),r=["row","col","depth","depth2"];return`\n      ${iH(n,t)}\n      float ${a}(int row, int col, int depth, int depth2) {\n        return ${a}(${XH(r,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${a}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${i}, ${s}, 1)));\n        ${UH(e)}\n      }\n    `;let c=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,d=p[0],h=p[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(h===o&&null==c)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${h}.0, ${d}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(h===s&&null==c)return t?`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${a}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${h}.0, ${d}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;let y=AH(r);return t?`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${a}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} +\n          depth * ${s} + depth2;\n      vec2 uv = uvFromFlat(${d}, ${h}, index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `}function WH(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),a=t[4],s=t[3]*a,i=t[2]*s,o=t[1]*i,{newShape:l,keptDims:u}=Na.squeezeShape(t);if(l.length<t.length){let t=KH(e,l),n=["row","col","depth","depth2","depth3"];return`\n      ${iH(t)}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${XH(n,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${i}, ${s}, ${a})) +\n          depth3;\n        ${UH(e)}\n      }\n    `;let c=e.shapeInfo.flatOffset,p=e.shapeInfo.texShape,d=p[0],h=p[1];if(h===o&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${s}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${h}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(h===a&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${h}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;let f=AH(n);return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} + depth * ${s} +\n          depth2 * ${a} + depth3 + ${f};\n      vec2 uv = uvFromFlat(${d}, ${h}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}function VH(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:a,keptDims:s}=Na.squeezeShape(t);if(a.length<t.length){let t=KH(e,a),n=["row","col","depth","depth2","depth3","depth4"];return`\n      ${iH(t)}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${XH(n,s)});\n      }\n    `}let i=t[5],o=t[4]*i,l=t[3]*o,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${UH(e)}\n      }\n    `;let p=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],f=d[1];if(f===c&&null==p)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${o}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===i&&null==p)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;let m=AH(n);return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};\n      vec2 uv = uvFromFlat(${h}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}function UH(e){let t=e.name,n=Na.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function GH(e,t){let n,r=e.name,a=r.charAt(0).toUpperCase()+r.slice(1),s="get"+a+"AtOutCoords",i=e.shapeInfo.logicalShape.length,o=t.logicalShape.length,l=aH(e.shapeInfo.logicalShape,t.logicalShape),u=jH(o),c=o-i,p=["x","y","z","w","u","v"];n=0===i?"":o<2&&l.length>=1?"coords = 0;":l.map((e=>`coords.${p[e+c]} = 0;`)).join("\n");let d="";d=o<2&&i>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${p[t+c]}`)).join(", ");let h="return outputValue;",f=1===Na.sizeFromShape(e.shapeInfo.logicalShape),m=1===Na.sizeFromShape(t.logicalShape);if(1!==i||f||m){if(f&&!m)h=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(l.length){let e=i-2,t=i-1;l.indexOf(e)>-1&&l.indexOf(t)>-1?h="return vec4(outputValue.x);":l.indexOf(e)>-1?h="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":l.indexOf(t)>-1&&(h="return vec4(outputValue.xx, outputValue.zz);")}}else h="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${u} coords = getOutputCoords();\n      ${n}\n      vec4 outputValue = get${a}(${d});\n      ${h}\n    }\n  `}function HH(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),a="get"+r+"AtOutCoords",s=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&null==e.shapeInfo.flatOffset&&Na.arraysEqual(i,s))return`\n      float ${a}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;let u,c=jH(l),p=aH(e.shapeInfo.logicalShape,t.logicalShape),d=l-o,h=["x","y","z","w","u","v"];u=0===o?"":l<2&&p.length>=1?"coords = 0;":p.map((e=>`coords.${h[e+d]} = 0;`)).join("\n");let f="";return f=l<2&&o>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${h[t+d]}`)).join(", "),`\n    float ${a}() {\n      ${c} coords = getOutputCoords();\n      ${u}\n      return get${r}(${f});\n    }\n  `}function jH(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function qH(e,t,n){let{newShape:r,keptDims:a}=Na.squeezeShape(t),s=t.length,i=e&&3===s&&1===t[0],o=i?t.slice(1):r,l=!e&&s>1&&!Na.arraysEqual(t,n)&&r.length<s||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:a}}function KH(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function XH(e,t){return t.map((t=>e[t])).join(", ")}function YH(e,t,n,r){let a=n.map(((e,n)=>{let r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}})),s=a.map((e=>e.shapeInfo)),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=sH(a,i,t),l=rG(e.gl,o),u=e.createProgram(l);return Xe().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:s,outShapeInfo:i},JH(e,t,u))}function JH(e,t,n){let r,a,s,i={},o={},l={},u=[],c=null,p=null;p=e.getUniformLocation(n,"NAN",!1),1===Xe().getNumber("WEBGL_VERSION")&&(c=e.getUniformLocation(n,"INFINITY",!1));let d=!1;for(let h=0;h<t.variableNames.length;h++){let r=t.variableNames[h];i[r]=e.getUniformLocation(n,r,d),i[`offset${r}`]=e.getUniformLocation(n,`offset${r}`,d),t.enableShapeUniforms&&(o[`${r}Shape`]=e.getUniformLocation(n,`${r}Shape`,d),l[`${r}TexShape`]=e.getUniformLocation(n,`${r}TexShape`,d))}return t.enableShapeUniforms&&(r=e.getUniformLocation(n,"outShape",d),s=e.getUniformLocation(n,"outShapeStrides",d),a=e.getUniformLocation(n,"outTexShape",d)),t.customUniforms&&t.customUniforms.forEach(((t,r)=>{u[r]=e.getUniformLocation(n,t.name,d)})),{uniformLocations:i,customUniformLocations:u,infLoc:c,nanLoc:p,inShapesLocations:o,inTexShapesLocations:l,outShapeLocation:r,outShapeStridesLocation:s,outTexShapeLocation:a}}function ZH(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{let r=e.logicalShape,a=t[n],s=a.shape;if(!Na.arraysEqual(r,s))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${s} must match`);if(e.isUniform&&a.isUniform)return;let i=e.texShape,o=a.isUniform?null:a.texData.texShape;if(!Na.arraysEqual(i,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${o} must match`)}))}function QH(e,t,n,r,a){t.program.enableShapeUniforms||(ZH(t.inShapeInfos,n),ZH([t.outShapeInfo],[r]));let s=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,i[0],i[1]):e.setOutputMatrixTexture(s.texture,i[0],i[1]),e.setProgram(t.webGLProgram),1===Xe().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN),n.forEach(((n,r)=>{let a=t.program.variableNames[r],s=t.uniformLocations[a],i=t.uniformLocations[`offset${a}`],o=t.inShapesLocations[`${a}Shape`],l=t.inTexShapesLocations[`${a}TexShape`];if(o){let{uniformShape:r}=qH(t.program.packedInputs,n.shape,n.texData.texShape);switch(r.length){case 1:e.gl.uniform1iv(o,new Int32Array(r));break;case 2:e.gl.uniform2iv(o,new Int32Array(r));break;case 3:e.gl.uniform3iv(o,new Int32Array(r));break;case 4:e.gl.uniform4iv(o,new Int32Array(r));break;default:break}}if(l&&e.gl.uniform2i(l,n.texData.texShape[0],n.texData.texShape[1]),null!=s){if(n.isUniform){if(Na.sizeFromShape(n.shape)<2)e.gl.uniform1f(s,n.uniformValues[0]);else{let t=n.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(s,t)}return}null!=n.texData.slice&&null!=i&&e.gl.uniform1i(i,n.texData.slice.flatOffset),e.setInputMatrixTexture(n.texData.texture.texture,s,r)}}));let o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape));break;default:break}if(t.outShapeStridesLocation){let n=Na.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n));break;default:break}}t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&a&&t.program.customUniforms.forEach(((n,r)=>{let s=t.customUniformLocations[r],i=a[r];if("float"===n.type)e.gl.uniform1fv(s,i);else if("vec2"===n.type)e.gl.uniform2fv(s,i);else if("vec3"===n.type)e.gl.uniform3fv(s,i);else if("vec4"===n.type)e.gl.uniform4fv(s,i);else if("int"===n.type)e.gl.uniform1iv(s,i);else if("ivec2"===n.type)e.gl.uniform2iv(s,i);else if("ivec3"===n.type)e.gl.uniform3iv(s,i);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(s,i)}})),e.executeProgram()}function ej(e,t,n){let r="";t.concat(n).forEach((t=>{let a=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){let s=t.texData.texShape,{useSqueezeShape:i,uniformShape:o,keptDims:l}=qH(e.packedInputs,t.shape,s),u="",c="",p="";if(1===o.length&&e.packedInputs){let e=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];u=`${e[0]>1}_${e[1]>1}`}else if(2!==o.length||e.packedInputs){if(o.length>2&&!e.packedInputs){let e=Na.computeStrides(o);p=`${e[0]===s[1]}_${e[e.length-1]===s[1]}`}}else c=`${o[0]>1}_${o[1]>1}`;let d=t.shape.length,h=2===o.length&&Na.arraysEqual(t.shape,s),f=1===Na.sizeFromShape(t.shape),m=Aw.getBroadcastDims(t.shape,n.shape),g=!e.packedInputs&&d===n.shape.length&&Na.arraysEqual(s,n.texData.texShape),y=e.packedInputs||o.length>2?"":`${s[0]>1}_${s[1]>1}`;r+=`${d}_${g}_${i?l:""}_${o.length}_${f}_${m}_${h}_${u}_${c}_${p}_${y}_${a}`}else{let e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${a}`}}));let a=e.userCode,s=e.constructor.name;return s+="_"+r+"_"+a+`${Xe().getNumber("WEBGL_VERSION")}`,s}function tj(e){return Xe().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var nj=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=DU.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=YG();this.outputShape=e,this.enableShapeUniforms=tj(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?ZG(["r","c","d"],e):JG(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}},rj=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=DU.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=YG();this.outputShape=e,this.enableShapeUniforms=tj(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?ZG(["r","c","d"],e):JG(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}},aj=class{constructor(e){this.variableNames=["A"],this.outTexUsage=MU.DOWNLOAD;let t=YG();this.outputShape=e,this.userCode=`\n      ${rH}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}},sj=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=MU.DOWNLOAD;let t=YG();this.outputShape=e,this.userCode=`\n      ${rH}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}},ij=class{constructor(e,t=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=YG();this.outputShape=e,this.enableShapeUniforms=tj(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)"),this.userCode=`\n      ${this.enableShapeUniforms?nH():tH(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / texShape[1];\n        int c = imod(flatIndex, texShape[1]);\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n        vec4 values = ${n.texture2D}(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ${n.output} = vec4(${r}, 0., 0., 0.);\n      }\n    `}},oj=class{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=YG();this.outputShape=e,this.enableShapeUniforms=tj(this.outputShape.length);let r="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let s=0;s<=1;s++)for(let t=0;t<=1;t++){let a=2*s+t;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${t} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${t};\n          if (localCoords[1] + ${s} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${s};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${a}] = values[0];\n            } else if (offset == 1) {\n              result[${a}] = values[1];\n            } else if (offset == 2) {\n              result[${a}] = values[2];\n            } else {\n              result[${a}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?nH():tH(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${a};\n        }\n    `}},lj={};function uj(e){let t=YG(),n=`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`;return nG(e,n)}function cj(e){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return pG(e,t)}function pj(e){let t=new Uint16Array([0,1,2,2,1,3]);return dG(e,t)}function dj(e,t,n,r,a,s){mG(t,n);let i=fG(e),o=e.TEXTURE_2D;return XU(e,(()=>e.bindTexture(o,i))),XU(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),XU(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),XU(e,(()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST))),XU(e,(()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===Xe().getNumber("WEBGL_VERSION")?XU(e,(()=>e.texImage2D(o,0,r,t,n,0,a,s,null))):XU(e,(()=>e.texStorage2D(o,1,r,t,n))),XU(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:i,texShape:[n,t]}}function hj(e){return e.internalFormatFloat}function fj(e,t,n,r){let[a,s]=UU(t,n);return dj(e,a,s,hj(r),r.textureFormatFloat,e.FLOAT)}function mj(e){return e.internalFormatHalfFloat}function gj(e,t,n,r){let[a,s]=UU(t,n);return dj(e,a,s,mj(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function yj(e){return e.downloadTextureFormat}function bj(e,t,n,r){let[a,s]=UU(t,n);return dj(e,a,s,yj(r),e.RGBA,e.UNSIGNED_BYTE)}function wj(e){return e.internalFormatPackedFloat}function xj(e,t,n,r){let[a,s]=jU(t,n);return dj(e,a,s,wj(r),e.RGBA,e.FLOAT)}function vj(e){return e.internalFormatPackedHalfFloat}function kj(e,t,n,r){let[a,s]=jU(t,n);return dj(e,a,s,vj(r),e.RGBA,r.textureTypeHalfFloat)}function Ij(e,t,n){return XU(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),yG(e,t,"clipSpacePos",n,3,20,0)&&yG(e,t,"uv",n,2,20,12)}function Sj(e,t,n,r,a,s){let i,o,l;XU(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),a instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=s.internalFormatPackedFloat),i.set(a),2===Xe().getNumber("WEBGL_VERSION")?XU(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i))):XU(e,(()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i))),XU(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function Nj(e,t,n){XU(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===Xe().getNumber("WEBGL_VERSION")?XU(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):XU(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===Xe().getNumber("WEBGL_VERSION")?XU(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):XU(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),XU(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}function Tj(e,t,n,r){let a=e.createBuffer();XU(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,a)));let s=16*t*n;return XU(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ))),XU(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),XU(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),a}function _j(e,t,n){let r=e,a=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}function Cj(e,t,n,r){let[a,s]=UU(t,n),i=4,o=new Uint8Array(GU(t*n,i));return XU(e,(()=>e.readPixels(0,0,a,s,r.downloadTextureFormat,e.UNSIGNED_BYTE,o))),new Float32Array(o.buffer)}function Ej(e,t,n,r,a,s,i,o){let l=e,u=new Float32Array(qU(s,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function Aj(e,t,n){let r=new Float32Array(t*n*4);return XU(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r))),r}g(lj,{bindVertexProgramAttributeStreams:()=>Ij,createBufferFromOutputTexture:()=>Tj,createFloat16MatrixTexture:()=>gj,createFloat16PackedMatrixTexture:()=>kj,createFloat32MatrixTexture:()=>fj,createIndexBuffer:()=>pj,createPackedMatrixTexture:()=>xj,createUnsignedBytesMatrixTexture:()=>bj,createVertexBuffer:()=>cj,createVertexShader:()=>uj,downloadByteEncodedFloatMatrixFromOutputTexture:()=>Cj,downloadFloat32MatrixFromBuffer:()=>_j,downloadMatrixFromPackedOutputTexture:()=>Aj,downloadPackedMatrixFromBuffer:()=>Ej,getInternalFormatForFloat16MatrixTexture:()=>mj,getInternalFormatForFloat16PackedMatrixTexture:()=>vj,getInternalFormatForFloat32MatrixTexture:()=>hj,getInternalFormatForPackedMatrixTexture:()=>wj,getInternalFormatForUnsignedBytesMatrixTexture:()=>yj,uploadDenseMatrixToTexture:()=>Sj,uploadPixelDataToTexture:()=>Nj});var $j=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];let t=Xe().getNumber("WEBGL_VERSION");null!=e?(this.gl=e,zU(t,e)):this.gl=BU(t);let n="WEBGL_color_buffer_float",r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===Xe().getNumber("WEBGL_VERSION")){let e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=tG(this.gl,e),WG(this.gl,t))this.textureHalfFloatExtension=tG(this.gl,t);else if(Xe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),WG(this.gl,r))this.colorBufferHalfFloatExtension=tG(this.gl,r);else if(Xe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",WG(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!WG(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=cj(this.gl),this.indexBuffer=pj(this.gl),this.framebuffer=gG(this.gl),this.textureConfig=KU(this.gl,this.textureHalfFloatExtension)}get debug(){return Xe().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;XU(e,(()=>e.finish())),XU(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),XU(e,(()=>e.deleteFramebuffer(this.framebuffer))),XU(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),XU(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),XU(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),fj(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),gj(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),bj(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),Nj(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),Sj(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),kj(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),xj(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(NG(this.gl,this.framebuffer),this.outputTexture=null),XU(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>Cj(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,r,a,s){return Ej(this.gl,e,t,n,r,a,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return _j(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let r=Tj(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(Xe().getBool("WEBGL_FENCE_API_ENABLED")){let r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let e=r.clientWaitSync(a,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=a}else Xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,Xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>Aj(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();let t=this.gl;null==this.vertexShader&&(this.vertexShader=uj(t));let n=lG(t);return XU(t,(()=>t.attachShader(n,this.vertexShader))),XU(t,(()=>t.attachShader(n,e))),uG(t,n),this.debug&&cG(t,n),this.vertexAttrsAreBound||(this.setProgram(n),this.vertexAttrsAreBound=Ij(t,this.program,this.vertexBuffer)),n}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&XU(this.gl,(()=>this.gl.deleteProgram(e)))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&cG(this.gl,this.program),XU(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?xG(this.gl,e,t):vG(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),XU(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),kG(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[r,a]=jU(t,n);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&cG(this.gl,this.program),TG(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;this.debug&&this.debugValidate(),XU(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),XU(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=tG(this.gl,2===Xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===Xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Na.repeatedTry((()=>this.disposed||this.isQueryAvailable(e,Xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,Xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){let t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{let t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){let t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{let t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){let e=Fj(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){let{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),!(this.itemsToPoll.length>1)&&Na.repeatedTry((()=>(this.pollItems(),0===this.itemsToPoll.length)))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),SG(this.gl,e,this.framebuffer),this.debug&&TG(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(SG(this.gl,this.outputTexture,this.framebuffer),this.debug&&TG(this.gl)):NG(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let r=this.gl;SG(r,e,this.framebuffer),this.debug&&TG(r),this.outputTexture=e,XU(r,(()=>r.viewport(0,0,t,n))),XU(r,(()=>r.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),XU(this.gl,(()=>this.gl.scissor(e,t,n,r)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}};function Fj(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}var{addImpl:Rj,bincountImpl:Dj,bincountReduceImpl:Mj,ceilImpl:Oj,concatImpl:Lj,equalImpl:Pj,expImpl:zj,expm1Impl:Bj,floorImpl:Wj,gatherNdImpl:Vj,gatherV2Impl:Uj,greaterImpl:Gj,greaterEqualImpl:Hj,lessImpl:jj,lessEqualImpl:qj,linSpaceImpl:Kj,logImpl:Xj,maxImpl:Yj,maximumImpl:Jj,minimumImpl:Zj,multiplyImpl:Qj,negImpl:eq,notEqualImpl:tq,prodImpl:nq,rangeImpl:rq,rsqrtImpl:aq,scatterImpl:sq,sigmoidImpl:iq,simpleAbsImpl:oq,sliceImpl:lq,sparseFillEmptyRowsImpl:uq,sparseReshapeImpl:cq,sparseSegmentReductionImpl:pq,sqrtImpl:dq,stridedSliceImpl:hq,stringNGramsImpl:fq,stringSplitImpl:mq,stringToHashBucketFastImpl:gq,subImpl:yq,tileImpl:bq,topKImpl:wq,transposeImpl:xq,uniqueImpl:vq}=LM;function kq(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function Iq(e,t){return 1===t?[e]:kq(e,t)}function Sq(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}var Nq=class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=tj(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{let e=Iq("rc",this.rank),t=jH(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),a=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${a}));\n          }\n        }\n      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let a=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let t=2;t<this.rank;t++)a=`${e[e.length-1-t]},`+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(e){let t=this.getSourceCoordsArr(e);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}},Tq=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=tj(this.outputShape.length);let n="";for(let r=0;r<4;r++){let e="thisRC = rc;";r%2===1&&(e+="thisRC.z += 1;"),r>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${r}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${r>0?"}":""}\n      `}this.userCode=`\n      ${_q(t,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?nH():tH(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}};function _q(e,t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t?eH(["r","c","d"],"inputShape"):JG(["r","c","d"],e)}\n      return ivec3(r, c, d);\n    }\n  `}var Cq=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,n){let r=Rq(t,n),a=Dq(e,r,n);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);let s,i=Aq(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();let e=this.freeTextures[a].shift();return this.usedTextures[a].push(e),e}return r===OU.PACKED_2X2_FLOAT32?s=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===OU.PACKED_2X2_FLOAT16?s=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===OU.UNPACKED_FLOAT32?s=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===OU.UNPACKED_FLOAT16?s=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===OU.PACKED_4X1_UNSIGNED_BYTE&&(s=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(s),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),s}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;let a=Rq(n,r),s=Dq(t,a,r);s in this.freeTextures||(this.freeTextures[s]=[]);let i=Aq(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=Xe().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let l=this.usedTextures[s],u=l.indexOf(e);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(u,1),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(let e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(let e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function Eq(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F||t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function Aq(e,t,n,r,a){let s,i=$q(t,r);if(a){let[t,n]=jU(e[0],e[1]);s=t*n}else{let[t,n]=UU(e[0],e[1]);s=t*n}let o=Eq(n,i);return s*o}function $q(e,t){switch(e){case OU.PACKED_2X2_FLOAT32:return wj(t);case OU.PACKED_2X2_FLOAT16:return vj(t);case OU.UNPACKED_FLOAT32:return hj(t);case OU.UNPACKED_FLOAT16:return mj(t);case OU.PACKED_4X1_UNSIGNED_BYTE:return yj(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function Fq(e){return Xe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?OU.PACKED_2X2_FLOAT32:OU.UNPACKED_FLOAT32:e?OU.PACKED_2X2_FLOAT16:OU.UNPACKED_FLOAT16}function Rq(e,t){if(e===MU.UPLOAD)return OU.PACKED_2X2_FLOAT32;if(e===MU.RENDER||null==e)return Fq(t);if(e===MU.DOWNLOAD||e===MU.PIXELS)return OU.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function Dq(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var Mq=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=tj(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}},Oq="if (isnan(x)) return x;",Lq="return x;",Pq="return abs(x);",zq="return (x >= 0.0) ? x : (exp(x) - 1.0);",Bq=Oq+"\n  return (x < 0.0) ? 0.0 : x;\n",Wq=Oq+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",Vq="return x;",Uq="return 1.0 / (1.0 + exp(-1.0 * x));",Gq="return x;",Hq="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",jq="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",qq="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",Kq="return 1.0 / (1.0 + exp(-1.0 * x));",Xq=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=tj(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}},Yq=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=tj(this.outputShape.length);let t=e.length,n=Iq("rc",t),r=jH(t),a=Sq(t,n),s=n.slice(-2),i=t<=1?"rc":`vec2(${s.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${a});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}},Jq=Fx.whereImpl,Zq=1e-7,Qq=1e-4,eK={};function tK(e){return e in eK||(eK[e]={}),eK[e]}var nK=Xe().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),rK=600;function aK(){return null==Xe().global.screen?1024:Xe().global.screen.height*Xe().global.screen.width*window.devicePixelRatio*rK/1024/1024}var sK=class extends K{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Xe().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof $j)t=e;else{let n=BU(Xe().getNumber("WEBGL_VERSION"),e);t=new $j(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let e=BU(Xe().getNumber("WEBGL_VERSION"));t=new $j(e),this.binaryCache=tK(Xe().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new Cq(this.gpgpu),this.numMBBeforeWarning=aK(),this.texData=new q(this,il())}nextDataId(){return sK.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,n){if((Xe().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Xe().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:MU.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){let t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){let t=this.texData.get(e);t.refCount--}}move(e,t,n,r,a){if(Xe().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:MU.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:a,slice:s,shape:i,isPacked:o}=t;if(null!=s){let t;t=o?new Xq(i,Vq):new Mq(i,Vq);let n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:r}],r),a=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;let l,u,c=null!=this.activeTimers;if(c&&(l=Na.now()),"complex64"===r){let e=this.readSync(a.real.dataId),t=this.readSync(a.imag.dataId);u=Aw.mergeRealAndImagArrays(e,t)}else u=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=Na.now()-l),this.convertAndCacheOnCPU(e,u)}async read(e){if(this.pendingRead.has(e)){let t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}let t=this.texData.get(e),{values:n,shape:r,slice:a,dtype:s,complexTensorInfos:i,isPacked:o}=t;if(null!=a){let t;t=o?new Xq(r,Vq):new Mq(r,Vq);let n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:s}],s),a=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),a}if(null!=n)return this.convertAndCacheOnCPU(e);if(Xe().getBool("DEBUG")&&!Xe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Xe().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,u,c=null;if("complex64"!==s&&Xe().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);let t=this.texData.get(l.dataId);c=this.gpgpu.createBufferFromTexture(t.texture.texture,...HU(r))}if(this.pendingRead.set(e,[]),"complex64"!==s&&await this.gpgpu.createAndWaitForFence(),"complex64"===s){let e=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]),t=e[0],n=e[1];u=Aw.mergeRealAndImagArrays(t,n)}else if(null==c)u=this.getValuesFromTexture(e);else{let e=Na.sizeFromShape(r);u=this.gpgpu.downloadFloat32MatrixFromBuffer(c,e)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=c){let e=this.gpgpu.gl;XU(e,(()=>e.deleteBuffer(c)))}let p=this.convertAndCacheOnCPU(e,u),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach((e=>e(p))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&il().removeDataId(e,this),this.pendingDeletes--),p}readToGPU(e,t={}){let n=this.texData.get(e),{values:r,shape:a,slice:s,dtype:i,isPacked:o,texture:l}=n;if("complex64"===i)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=s){let n;n=o?new Xq(a,Vq):new Mq(a,Vq);let r=this.runWebGLProgram(n,[{dataId:e,shape:a,dtype:i}],i),s=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),s}if(null==l)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let u=this.decode(e,t.customTexShape),c=il().makeTensorFromTensorInfo(u),p=this.texData.get(u.dataId);return Object.assign({tensorRef:c},p.texture)}bufferSync(e){let t=this.readSync(e.dataId);if("string"===e.dtype)try{let n=t.map((e=>Na.decodeString(e)));return fo(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return fo(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){let n=e[t];if(!QU(n))throw Xe().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(e){let{shape:t,dtype:n,isPacked:r}=this.texData.get(e),a=Na.sizeFromShape(t);if(Xe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let n=this.decode(e),r=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...HU(t)).subarray(0,a);return this.disposeIntermediateTensorInfo(n),s}let s=Xe().getBool("WEBGL_PACK")&&!0===r,i=s?FG(t):t,o=s?new sj(i):new aj(i),l=this.runWebGLProgram(o,[{shape:i,dtype:n,dataId:e}],"float32"),u=this.texData.get(l.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(l),c}timerAvailable(){return Xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){let t=this.activeTimers,n=[],r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();let a=Na.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),s=Na.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);let i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let e=await Promise.all(a);i.kernelMs=Na.sum(e),i.getExtraProfileInfo=()=>e.map(((e,t)=>({name:s[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Na.now(),endMs:null}}endTimer(e){return Xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Na.now(),e)}async getQueryTime(e){if(Xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);let t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:t,dtype:n,texShape:r,usage:a,isPacked:s,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,a,s)));let u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=nK){return Xe().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&Na.sizeFromShape(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){Aw.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let t=e.dataSync();return Jq(e.shape,t)}packedUnaryOp(e,t,n){let r=new Xq(e.shape,t),a=this.compileAndRun(r,[e],n);return il().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){let t=oq(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(Xe().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,Pq,e.dtype);let t=new Mq(e.shape,Pq),n=this.compileAndRun(t,[e]);return il().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&Na.isString(n[0])){let a=n.map((e=>Na.encodeString(e)));r=this.write(a,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return il().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){let t=new Yq(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){let t=new Nq(e.shape),n=!0;return this.runWebGLProgram(t,[e],e.dtype,null,n)}packedReshape(e,t){let n=[AG(e.shape),...$G(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},a=[AG(t),...$G(t)],s=new Tq(a,n),i=!0,o=[n],l=this.runWebGLProgram(s,[r],e.dtype,o,i);return{dataId:l.dataId,shape:t,dtype:l.dtype}}decode(e,t){let n=this.texData.get(e),{isPacked:r,shape:a,dtype:s}=n;if(null!=t){let e=Na.sizeFromShape(a),n=t[0]*t[1]*4;Na.assert(e<=n,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}let i,o=FG(a);i=r?new rj(o):new nj(o);let l=!0,u=[null!=t?t:HU(o)],c=this.runWebGLProgram(i,[{shape:o,dtype:s,dataId:e}],s,u,l,t);return{dtype:s,shape:a,dataId:c.dataId}}runWebGLProgram(e,t,n,r,a=!1,s){let i=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(i.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===DU.DENSE){let t=null!=s?s:HU(e.outputShape);o.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(o.usage=e.outTexUsage),0===Na.sizeFromShape(i.shape))return o.values=Na.getTypedArrayFromDType(i.dtype,0),i;let l=[],u=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&Na.sizeFromShape(t.shape)<=Xe().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),l.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!MG(n.shape,t.shape)){let e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),l.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(i.dataId);let c,p={shape:i.shape,texData:o,isUniform:!1},d=ej(e,u,p),h=this.getAndSaveBinary(d,(()=>YH(this.gpgpu,e,u,p))),f=null!=this.activeTimers;f&&(c=this.startTimer()),Xe().get("ENGINE_COMPILE_ONLY")||QH(this.gpgpu,h,u,p,r),l.forEach((e=>this.disposeIntermediateTensorInfo(e))),f&&(c=this.endTimer(c),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(c)}));let m=Xe().get("WEBGL_FLUSH_THRESHOLD");if(m>0){let e=Na.now();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!Xe().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===a){let e=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),e}return i}compileAndRun(e,t,n,r,a=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,r,a)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Xe().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]})),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=ul((()=>{if(!Xe().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=Xe().getBool("DEBUG");Xe().set("DEBUG",!1);let t=this.abs(Md(1e-8)).dataSync()[0];if(Xe().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?Zq:Qq}uploadToGPU(e){let t=this.texData.get(e),{shape:n,dtype:r,values:a,texture:s,usage:i,isPacked:o}=t;if(null!=s)return;let l,u=null!=this.activeTimers;u&&(l=Na.now());let c=t.texShape;if(null==c&&(c=RG(n,o),t.texShape=c),null!=a){let e,s=FG(n),i=c[1],p=c[0],d=a instanceof Uint8Array||a instanceof Uint8ClampedArray;(o||!d)&&([i,p]=jU(c[0],c[1])),e=o?new oj(s,d):new ij(s,d);let h=d?[p,i]:c,f=this.makeTensorInfo(h,r),m=this.texData.get(f.dataId);m.usage=d?MU.PIXELS:MU.UPLOAD,m.texShape=h,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),i,p,a);let g=[[p,i]],y=!0,b=this.runWebGLProgram(e,[f],r,g,y),w=this.texData.get(b.dataId);t.texShape=w.texShape,t.isPacked=w.isPacked,t.usage=w.usage,Xe().get("ENGINE_COMPILE_ONLY")?this.disposeData(b.dataId):(t.texture=w.texture,t.values=null,this.texData.delete(b.dataId)),this.disposeIntermediateTensorInfo(f),u&&(this.uploadWaitMs+=Na.now()-l)}else{let e=this.acquireTexture(c,i,r,o);t.texture=e}}convertAndCacheOnCPU(e,t){let n=this.texData.get(e),{dtype:r}=n;return this.releaseGPUData(e),null!=t&&(n.values=iK(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){let e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*Na.bytesPerElement(t)}checkCompileCompletion(){for(let[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){let e=[];if(this.gpgpu.parallelCompilationExtension){for(let[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(let[,t]of Object.entries(this.binaryCache)){let n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Ew(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(oG(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let[,e]of Object.entries(this.binaryCache)){let{uniformLocations:t,customUniformLocations:n,infLoc:r,nanLoc:a,inShapesLocations:s,inTexShapesLocations:i,outShapeLocation:o,outShapeStridesLocation:l,outTexShapeLocation:u}=JH(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=a,e.inShapesLocations=s,e.inTexShapesLocations=i,e.outShapeLocation=o,e.outShapeStridesLocation=l,e.outTexShapeLocation=u}}};function iK(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){let n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}sK.nextDataId=0;var oK="3.18.0";function lK(){Xe().set("WEBGL_FORCE_F16_TEXTURES",!0)}Us.isBrowser()&&wl("webgl",(()=>new sK),2);var uK={forceHalfFloat:lK},cK="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n",pK=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=Aw.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=tj(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}},dK="\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n",hK=class{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Aw.assertAndGetBroadcastShape(t,n);let a=this.outputShape.length;this.enableShapeUniforms=tj(a);let s="";if(r)if(0===a||1===Na.sizeFromShape(this.outputShape))s="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(s=`\n          ${jH(a)} coords = getOutputCoords();\n        `,1===a)this.enableShapeUniforms?s+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":s+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{let e=Iq("coords",a);this.enableShapeUniforms?s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= outShape[${a} - 2];\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= outShape[${a} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:s+=`\n            bool nextRowOutOfBounds =\n              (${e[a-2]} + 1) >= ${this.outputShape[a-2]};\n            bool nextColOutOfBounds =\n              (${e[a-1]} + 1) >= ${this.outputShape[a-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${s}\n\n        setOutput(result);\n      }\n    `}};function fK(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var mK={kernelName:yn,backendName:"webgl",kernelFunc:fK};function gK(e){let{inputs:t,backend:n}=e,{real:r,imag:a}=t,s=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(s.dataId),o=fK({inputs:{x:r},backend:n}),l=fK({inputs:{x:a},backend:n});return i.complexTensorInfos={real:o,imag:l},s}var yK={kernelName:Ct,backendName:"webgl",kernelFunc:gK},bK="return (a < 0.) ? b * a : a;",wK="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";function xK(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{alpha:s}=r,i=n.makeTensorInfo([],"float32",Na.createScalarValue(s,"float32")),o=Xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new hK(wK,a.shape,i.shape):new pK(bK,a.shape,i.shape),l=n.runWebGLProgram(o,[a,i],"float32");return n.disposeIntermediateTensorInfo(i),l}var vK={kernelName:In,backendName:"webgl",kernelFunc:xK},kK="return (a < 0.) ? b * a : a;",IK="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";function SK(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=Xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new hK(IK,r.shape,a.shape):new pK(kK,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],"float32")}var NK={kernelName:or,backendName:"webgl",kernelFunc:SK},TK="if (isnan(x)) return x;",_K="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n",CK="\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n";function EK({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:a,backend:s})=>{let{x:i}=a,o=s,l=r||i.dtype;if(o.shouldExecuteOnCPU([i])&&null!=n){let e=o.texData.get(i.dataId),t=n(e.values,l);return o.makeTensorInfo(i.shape,l,t)}let u,c=Xe().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t;return u=c?new Xq(i.shape,t):new Mq(i.shape,e),o.runWebGLProgram(u,[i],l)}}function AK({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:a,dtype:s}){return({inputs:i,backend:o})=>{let{a:l,b:u}=i,c=o;if(r&&"complex64"===l.dtype){let t=c.texData.get(l.dataId),n=c.texData.get(u.dataId),[r,a]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{let[n,r]=t,a={dataId:n.dataId,dtype:n.dtype,shape:l.shape},s={dataId:r.dataId,dtype:r.dtype,shape:u.shape},i=new pK(e,l.shape,u.shape);return c.runWebGLProgram(i,[a,s],_s(n.dtype,r.dtype))})),s=gK({inputs:{real:r,imag:a},backend:c});return c.disposeIntermediateTensorInfo(r),c.disposeIntermediateTensorInfo(a),s}let p=s||_s(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||c.shouldExecuteOnCPU([l,u]))&&null!=a){let e=c.texData.get(l.dataId).values,t=c.texData.get(u.dataId).values,n="string"===l.dtype?Aw.fromUint8ToStringArray(e):e,r="string"===l.dtype?Aw.fromUint8ToStringArray(t):t,[s,i]=a(l.shape,u.shape,n,r,p),o=c.makeTensorInfo(i,p),d=c.texData.get(o.dataId);return d.values=s,o}let d,h=Xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t;return d=h?new hK(t,l.shape,u.shape,n):new pK(e,l.shape,u.shape),c.runWebGLProgram(d,[l,u],p)}}function $K(e,t=!1){if("linear"===e)return t?Gq:Lq;if("relu"===e)return t?jq:Bq;if("elu"===e)return t?Hq:zq;if("relu6"===e)return t?qq:Wq;if("prelu"===e)return t?IK:kK;if("leakyrelu"===e)return t?wK:bK;if("sigmoid"===e)return t?Kq:Uq;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var FK=class{constructor(e,t,n,r=!1,a=!1,s=!1,i=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=tj(this.outputShape.length);let u=r?e[1]:e[2],c=Math.ceil(u/2),p=r?"i * 2, rc.y":"rc.y, i * 2",d=a?"rc.z, i * 2":"i * 2, rc.z",h=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],m="",g="";i&&(m=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,g="result = activation(result);");let y=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let b="rc.x",w="rc.x";e[0]<t[0]?b=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(w=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ${c}; i++) {\n          int batchA = ${b};\n          int batchB = ${w};\n          vec4 a = getMatrixA(batchA, ${p});\n          vec4 b = getMatrixB(batchB, ${d});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${h[0]} * ${f[0]});\n          result += (${h[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${y}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}},RK={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},DK=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Aw.assertAndGetBroadcastShape(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}},MK="return a * b;";function OK(e){let t,{inputs:n,backend:r}=e,{a:a,b:s}=n,i=Aw.upcastType(a.dtype,s.dtype);if("complex64"===a.dtype){let e=r.texData.get(a.dataId),t=r.texData.get(s.dataId),n=new DK(RK.REAL,a.shape,s.shape),i=new DK(RK.IMAG,a.shape,s.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape}],l=r.runWebGLProgram(n,o,"float32"),u=r.runWebGLProgram(i,o,"float32"),c=gK({inputs:{real:l,imag:u},backend:r});return r.disposeIntermediateTensorInfo(l),r.disposeIntermediateTensorInfo(u),c}if(r.shouldExecuteOnCPU([a,s])){let e=r.texData.get(a.dataId),t=r.texData.get(s.dataId),[n,o]=Qj(a.shape,s.shape,e.values,t.values,i),l=r.makeTensorInfo(o,i),u=r.texData.get(l.dataId);return u.values=n,l}return t=Xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new hK(MK,a.shape,s.shape):new pK(MK,a.shape,s.shape),r.runWebGLProgram(t,[a,s],i)}var LK={kernelName:Xn,backendName:"webgl",kernelFunc:OK};function PK(e,t,n){let r=[AG(e.shape),...$G(e.shape)],a={dtype:e.dtype,shape:r,dataId:e.dataId},s=[AG(t),...$G(t)],i=new Tq(s,r),o=!0,l=[r],u=n.runWebGLProgram(i,[a],e.dtype,l,o);return{dataId:u.dataId,shape:t,dtype:u.dtype}}function zK(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{shape:s}=r,i=n,o=Na.sizeFromShape(a.shape),l=Na.inferFromImplicitShape(s,o),u=Na.sizeFromShape(l);Na.assert(o===u,(()=>`The new shape (${l}) has ${u} elements and the old shape (${a.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`));let c=i.texData.get(a.dataId);return!c.isPacked||MG(a.shape,l)||null!==c.texture&&MG(c.shape,l)?(i.incRef(a.dataId),{dataId:a.dataId,shape:l,dtype:a.dtype}):PK(a,l,i)}var BK={kernelName:hr,backendName:"webgl",kernelFunc:zK},WK=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let i=4*Math.floor(n/4),o=n%4,l="sumValue += dot(values, ones);";if(null!=t){let e=1/t;l=`sumValue += dot(values * ${Na.isInt(e)?e.toPrecision(2):e}, ones);`}let u="";a%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}},VK=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:a,outSize:s}=e;this.outputShape=[r,s];let i="0.0",o="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",o="min"):"max"===t&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");let u=4*Math.floor(n/4),c=n%4,p=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,d="vec4";"all"===t?(i="1.0",p="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===t&&(i="0.0",p="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let h="";a%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${h}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${p}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${p}\n        } else if (${2===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${p}\n        } else if (${3===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${p}\n        }\n        setOutput(${l});\n      }\n    `}};function UK(e){let t=[];for(;0===t.length||1!==t[t.length-1].outSize;){let n=t.length?t[t.length-1].outSize:e[1],r=Aw.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}function GK(e,t,n,r){let a=UK(e.shape),s=e;for(let i=0;i<a.length;i++){let o,l,{inSize:u,windowSize:c,outSize:p}=a[i];o="mean"===n?0===i?new WK({windowSize:c,inSize:u,batchSize:e.shape[0],outSize:p},u):new WK({windowSize:c,inSize:u,batchSize:e.shape[0],outSize:p}):new VK({windowSize:c,inSize:u,batchSize:e.shape[0],outSize:p},n),l=s,s=r.runWebGLProgram(o,[s],t),l.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(l)}return s}var HK=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[t[s]];this.outputShape=n,this.rank=n.length;let r=jH(this.rank),a=jK(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${a}));\n    }\n    `}};function jK(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let a=0;a<e.length;a++)r[e[a]]=n[a];return r.join()}var qK=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let u=0;u<n.length;u++)n[u]=e[t[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let r=jH(this.rank),a=kq("rc",this.rank),s=new Array(this.rank);for(let u=0;u<t.length;u++)s[t[u]]=a[u];let i=`vec2(${s.slice(-2).join()})`,o=`++${a[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${s.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${a[this.rank-1]};\n      if(++${a[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}};function KK(e,t,n){let r=Xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new qK(e.shape,t):new HK(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function XK(e,t,n,r){let a=t,s=e.shape.length,i=Na.parseAxisParam(a,e.shape),o=i,l=Aw.getAxesPermutation(o,s),u=null!=l,c=e;u&&(c=KK(e,l,r),o=Aw.getInnerMostAxes(o.length,s)),Aw.assertAxesAreInnerMostDims("sum",o,s);let[p,d]=Aw.computeOutAndReduceShapes(c.shape,o),h=p;n&&(h=Aw.expandShapeToKeepDim(p,i));let f=Na.sizeFromShape(d),m=Na.sizeFromShape(e.shape)/f,g=zK({inputs:{x:c},attrs:{shape:[m,f]},backend:r}),y=Cs(e.dtype),b=GK(g,y,"sum",r),w=zK({inputs:{x:b},attrs:{shape:h},backend:r});return r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(b),u&&r.disposeIntermediateTensorInfo(c),w}function YK(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r;return XK(a,s,i,n)}var JK={kernelName:Rr,backendName:"webgl",kernelFunc:YK};function ZK(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{perm:i}=a,o=r,l=s.shape.length,u=new Array(l);for(let c=0;c<u.length;c++)u[c]=s.shape[i[c]];if(o.shouldExecuteOnCPU([s])){let e=o.texData.get(s.dataId).values,n=xq(e,s.shape,s.dtype,i,u);t=o.makeTensorInfo(u,s.dtype);let r=o.texData.get(t.dataId);r.values=n}else t=KK(s,i,o);return t}var QK={kernelName:ea,backendName:"webgl",kernelFunc:ZK},eX=1e3;function tX({a:e,b:t,transposeA:n,transposeB:r,backend:a,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){let u=e.shape.length,c=t.shape.length,p=n?e.shape[u-2]:e.shape[u-1],d=r?t.shape[c-1]:t.shape[c-2],h=n?e.shape[u-1]:e.shape[u-2],f=r?t.shape[c-2]:t.shape[c-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),y=Na.sizeFromShape(m),b=Na.sizeFromShape(g),w=Fl.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([h,f]);Na.assert(p===d,(()=>`Error in matMul: inner shapes (${p}) and (${d}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`));let x,v=n?[y,p,h]:[y,h,p],k=r?[b,f,d]:[b,d,f],I=zK({inputs:{x:e},backend:a,attrs:{shape:v}}),S=zK({inputs:{x:t},backend:a,attrs:{shape:k}}),N=[I,S],T=Math.max(y,b),_=n?I.shape[1]:I.shape[2],C=null!=s,E=null!=i,A="leakyrelu"===l,$=null!=l?$K(l,!0):null,F=C||E||A||null!=$;if((1===h||1===f)&&_>eX&&!1===F){let e=I,t=S;n&&(e=ZK({inputs:{x:I},backend:a,attrs:{perm:[0,2,1]}}),N.push(e)),r&&(t=ZK({inputs:{x:S},backend:a,attrs:{perm:[0,2,1]}}),N.push(t));let s=1!==f,i=1===f,o=e;s&&(o=zK({inputs:{x:e},backend:a,attrs:{shape:[T,_,1]}}),N.push(o));let l=1===f?2:1,u=t;i&&(u=zK({inputs:{x:t},backend:a,attrs:{shape:[T,1,_]}}),N.push(u));let c=OK({inputs:{a:o,b:u},backend:a});x=YK({inputs:{x:c},backend:a,attrs:{axis:l,keepDims:!0}}),N.push(c)}else{let l=_s(e.dtype,t.dtype),u=new FK(v,k,[T,h,f],n,r,C,$,E,A),c=[I,S];if(null!=s&&c.push(s),E&&c.push(i),A){let e=a.makeTensorInfo([],"float32",Na.createScalarValue(o,"float32"));c.push(e),N.push(e)}x=a.runWebGLProgram(u,c,l)}let R=zK({inputs:{x:x},backend:a,attrs:{shape:w}});N.push(x);for(let D of N)a.disposeIntermediateTensorInfo(D);return R}function nX(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:p}=r;return tX({a:a,b:s,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:p,activation:c})}var rX={kernelName:ua,backendName:"webgl",kernelFunc:nX},aX="return abs(x);";function sX(e){let t,{inputs:n,backend:r}=e,{x:a}=n;if(r.shouldExecuteOnCPU([a])&&"complex64"!==a.dtype){let e=r.texData.get(a.dataId),t=oq(e.values);return r.makeTensorInfo(a.shape,a.dtype,t)}return t=Xe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Xq(a.shape,aX):new Mq(a.shape,aX),r.runWebGLProgram(t,[a],a.dtype)}var iX={kernelName:nt,backendName:"webgl",kernelFunc:sX},oX=Oq+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n",lX=EK({opSnippet:oX}),uX={kernelName:rt,backendName:"webgl",kernelFunc:lX},cX=Oq+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));",pX=EK({opSnippet:cX}),dX={kernelName:at,backendName:"webgl",kernelFunc:pX},hX="return a + b;",fX=AK({opSnippet:hX,packedOpSnippet:hX,supportsComplex:!0,cpuKernelImpl:Rj}),mX={kernelName:st,backendName:"webgl",kernelFunc:fX},gX=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));let n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));let r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}},yX=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));let n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));let r=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}};function bX(e){let{inputs:t,backend:n}=e,r=t;if(1===r.length)return fK({inputs:{x:r[0]},backend:n});if(r.length>Xe().get("WEBGL_MAX_TEXTURES_IN_SHADER")){let e=Math.floor(r.length/2),t=bX({inputs:r.slice(0,e),backend:n}),a=bX({inputs:r.slice(e),backend:n});return bX({inputs:[t,a],backend:n})}let a=r.map((e=>e.dtype)).reduce(((e,t)=>_s(e,t))),s=r.map((e=>e.shape)),i=Xe().getBool("WEBGL_PACK")?new yX(r[0].shape,s):new gX(r[0].shape,s);return n.runWebGLProgram(i,r,a)}var wX={kernelName:it,backendName:"webgl",kernelFunc:bX};function xX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=Na.parseAxisParam(s,a.shape),u=l,c=Aw.getAxesPermutation(u,o),p=a;null!=c&&(p=ZK({inputs:{x:a},backend:n,attrs:{perm:c}}),u=Aw.getInnerMostAxes(u.length,o)),Aw.assertAxesAreInnerMostDims("all",u,o);let d,[h,f]=Aw.computeOutAndReduceShapes(p.shape,u),m=Na.sizeFromShape(f),g=zK({inputs:{x:p},backend:n,attrs:{shape:[-1,m]}}),y=GK(g,g.dtype,"all",n);if(i){let e=Aw.expandShapeToKeepDim(h,l);d=zK({inputs:{x:y},backend:n,attrs:{shape:e}})}else d=zK({inputs:{x:y},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),null!=c&&n.disposeIntermediateTensorInfo(p),d}var vX={kernelName:ot,backendName:"webgl",kernelFunc:xX};function kX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=Na.parseAxisParam(s,a.shape),u=l,c=Aw.getAxesPermutation(u,o),p=a;null!=c&&(p=ZK({inputs:{x:a},backend:n,attrs:{perm:c}}),u=Aw.getInnerMostAxes(u.length,o)),Aw.assertAxesAreInnerMostDims("any",u,o);let d,[h,f]=Aw.computeOutAndReduceShapes(p.shape,u),m=Na.sizeFromShape(f),g=zK({inputs:{x:p},backend:n,attrs:{shape:[-1,m]}}),y=GK(g,g.dtype,"any",n);if(i){let e=Aw.expandShapeToKeepDim(h,l);d=zK({inputs:{x:y},backend:n,attrs:{shape:e}})}else d=zK({inputs:{x:y},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),null!=c&&n.disposeIntermediateTensorInfo(p),d}var IX={kernelName:lt,backendName:"webgl",kernelFunc:kX},SX=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:r,batchSize:a,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[a,s];let i="max"===t?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}},NX=class{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Na.assert(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));let a=e[e.length-1],s=Math.ceil(a/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");let i,o,l=this.outputShape,u=l.length,c=jH(u),p=Iq("coords",u);if(1===s){o=u+1;let e=jH(o);i=`\n        ${e} sourceLocR = ${e}(${p.join()}, 0);\n        ++${p[u-1]};\n        ${e} sourceLocG = ${e}(${p.join()}, 0);\n        ++${p[u-2]};\n        ${e} sourceLocA = ${e}(${p.join()}, 0);\n        --${p[u-1]};\n        ${e} sourceLocB = ${e}(${p.join()}, 0);\n        --${p[u-2]};`}else o=u,i=`\n        ${c} sourceLocR = coords;\n        ++${p[u-1]};\n        ${c} sourceLocG = coords;\n        ++${p[u-2]};\n        ${c} sourceLocA = coords;\n        --${p[u-1]};\n        ${c} sourceLocB = coords;\n        --${p[u-2]};`;let d=["x","y","z","w","u","v"].slice(0,o),h="."+d[o-1],f=d.map((e=>"int "+e)),m=Iq("sourceLocR",o-1).concat("inIdx.r"),g=Iq("sourceLocG",o-1).concat("inIdx.g"),y=Iq("sourceLocB",o-1).concat("inIdx.b"),b=Iq("sourceLocA",o-1).concat("inIdx.a"),w="max"===n?"greaterThan":"lessThan",x=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,v=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,k=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${d.join()}),\n                                          vec2(${d.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${d.join()}),\n                               vec2(${d.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${c} coords = getOutputCoords();\n        bool hasNextCol = ${p[u-1]} < ${l[u-1]-1};\n        bool hasNextRow = ${p[u-2]} < ${l[u-2]-1};\n        ${i}\n        ivec4 srcIdx = ivec4(sourceLocR${h}, sourceLocG${h},\n          sourceLocB${h}, sourceLocA${h}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${v};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${x}\n          vec4 candidate = ${v};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${w}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}};function TX(e,t,n,r=null){let a=t.shape[0],s=t.shape[1];null!=r&&(a=r.shape[0],s=r.shape[1]);let i=Aw.computeOptimalWindowSize(s),o={windowSize:i,inSize:s,batchSize:a,outSize:Math.ceil(s/i)},l=new SX(o,n,null==r),u=[t];null!=r&&u.push(r);let c=e.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;let p=TX(e,t,n,c);return e.disposeIntermediateTensorInfo(c),p}function _X(e,t,n,r=null){let a=null!=r?r.shape:t.shape,s=a[a.length-1],i=Aw.computeOptimalWindowSize(s),o=new NX(a,i,n,null==r),l=null==r?[t]:[t,r],u=e.runWebGLProgram(o,l,"int32");if(u.shape.length===t.shape.length){let r=_X(e,t,n,u);return e.disposeIntermediateTensorInfo(u),r}return u}function CX(e,t,n,r){let a=[n];if(Aw.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,t.shape.length),!Xe().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let n=[],s=e.texData.get(t.dataId),i=null!==s&&s.isPacked,o=t;i&&(o=e.unpackTensor(t),n.push(o));let[l,u]=Aw.computeOutAndReduceShapes(o.shape,a),c=Na.sizeFromShape(u),p=zK({inputs:{x:o},backend:e,attrs:{shape:[-1,c]}});n.push(p);let d=TX(e,p,r);n.push(d);let h=zK({inputs:{x:d},backend:e,attrs:{shape:l}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),h}return _X(e,t,r)}function EX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r,i=Na.parseAxisParam(s,a.shape),o=Aw.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(l=ZK({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=Aw.getInnerMostAxes(i.length,l.shape.length)),Aw.assertAxesAreInnerMostDims("argMax",[i[0]],l.shape.length);let c=CX(n,l,i[0],"max");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}var AX={kernelName:ut,backendName:"webgl",kernelFunc:EX};function $X(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s}=r,i=Na.parseAxisParam(s,a.shape),o=Aw.getAxesPermutation(i,a.shape.length),l=a,u=[];null!=o&&(l=ZK({inputs:{x:a},backend:n,attrs:{perm:o}}),u.push(l),i=Aw.getInnerMostAxes(i.length,l.shape.length)),Aw.assertAxesAreInnerMostDims("argMin",[i[0]],l.shape.length);let c=CX(n,l,i[0],"min");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}var FX={kernelName:ct,backendName:"webgl",kernelFunc:$X},RX=Oq+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n",DX=EK({opSnippet:RX}),MX={kernelName:pt,backendName:"webgl",kernelFunc:DX},OX=Oq+"return log(x + sqrt(x * x + 1.0));",LX=EK({opSnippet:OX}),PX={kernelName:dt,backendName:"webgl",kernelFunc:LX},zX=Oq+"\n  return atan(x);\n",BX=EK({opSnippet:zX}),WX={kernelName:ht,backendName:"webgl",kernelFunc:BX},VX=_K+"\n  return atan(a, b);\n",UX="\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  "+CK+"\n  return result;\n",GX=AK({opSnippet:VX,packedOpSnippet:UX}),HX={kernelName:mt,backendName:"webgl",kernelFunc:GX},jX=Oq+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;",qX=EK({opSnippet:jX}),KX={kernelName:ft,backendName:"webgl",kernelFunc:qX},XX=class{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterHeight,p=e.effectiveFilterWidth,d=e.padInfo.top,h=e.padInfo.left;this.outputShape=e.outShape;let f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,y="0.0";if(f||(y="-1.0 / 1e-20"),n){let t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${o});\n        const ivec2 pads = ivec2(${d}, ${h});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${p};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?a?m:g:`wR * ${p} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b="max",w=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(w="avgValue / count");let x=4*Math.floor(s/4),v=s%4,k=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${b}(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${d}, ${h});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${x}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${k}\n          }\n\n          int xC = xCCorner + ${x};\n          if (${1===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${k}\n          } else if (${2===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${k}\n          } else if (${3===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${k}\n          }\n        }\n        setOutput(${w});\n      }\n    `}},YX=class{constructor(e,t,n,r=!1,a=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");let s=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,p=e.dilationWidth,d=e.effectiveFilterDepth,h=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;let b="avg"===t,w="0.0";if(b||(w="-1.0 / 1e-20"),n){let t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${o}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${d};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${h};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${p}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${h} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let x="max",v=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(v="avgValue / count");let k=4*Math.floor(s/4),I=s%4,S=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ${x}(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${o}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${w};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${w});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${k}; wC += 4) {\n              int xC = xCCorner + wC * ${p};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${p}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${p}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${p}, ch)\n              );\n\n              ${S}\n            }\n\n            int xC = xCCorner + ${k};\n            if (${1===I}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${2===I}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${p}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${3===I}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${p}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${p}, ch),\n                initializationValue\n              );\n\n              ${S}\n            }\n          }\n          setOutput(${v});\n        }\n      }\n    `}};function JX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;KG(a,"avgPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,u=1;Na.assert(Aw.eitherStridesOrDilationsAreOne(i,u),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`));let c=Aw.computePool2DInfo(a.shape,s,i,u,o,l);if(1===c.filterWidth&&1===c.filterHeight&&Na.arraysEqual(c.inShape,c.outShape))return fK({inputs:{x:a},backend:n});let p=new XX(c,"avg",!1);return n.runWebGLProgram(p,[a],"float32")}var ZX={kernelName:gt,backendName:"webgl",kernelFunc:JX};function QX(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=[1,1,1],p=Aw.computePool3DInfo(a.shape,s,i,c,o,l,u),d=new YX(p,"avg",!1);return n.runWebGLProgram(d,[a],"float32")}var eY={kernelName:bt,backendName:"webgl",kernelFunc:QX},tY=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.top,c=l-1-e.padInfo.left,p=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${c});\n      const float avgMultiplier = float(${p});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${s}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},nY=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterDepth,p=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=c-1-e.padInfo.front,f=p-1-e.padInfo.top,m=d-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${h}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${a}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${p};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${d};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};function rY(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,p=[1,1,1],d=Aw.computePool3DInfo(i.shape,o,l,p,u,c),h=new nY(d);return n.runWebGLProgram(h,[a],i.dtype)}var aY={kernelName:wt,backendName:"webgl",kernelFunc:rY};function sY(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s;KG([a,s],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=r,c=Aw.computePool2DInfo(i.shape,o,l,1,u),p=new tY(c);return n.runWebGLProgram(p,[a],i.dtype)}var iY={kernelName:yt,backendName:"webgl",kernelFunc:sY};function oY(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:i,transposeB:o}=r;return tX({a:a,b:s,transposeA:i,transposeB:o,backend:n})}var lY={kernelName:xt,backendName:"webgl",kernelFunc:oY},uY=class{constructor(e,t,n,r,a,s){this.outputShape=[],this.variableNames=["x","mean","variance"],Aw.assertAndGetBroadcastShape(e,t),Aw.assertAndGetBroadcastShape(e,n);let i="0.0";null!=r&&(Aw.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";null!=a&&(Aw.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${s}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}},cY=class{constructor(e,t,n,r,a,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Aw.assertAndGetBroadcastShape(e,t),Aw.assertAndGetBroadcastShape(e,n);let i="vec4(0.0)";null!=r&&(Aw.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=a&&(Aw.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${s}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}},pY=({inputs:e,backend:t,attrs:n})=>{let{x:r,mean:a,variance:s,offset:i,scale:o}=e;Na.assert(a.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Na.assert(null==i||a.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Na.assert(null==o||a.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:l}=n;null==l&&(l=.001);let u=[r,a,s],c=null;null!=i&&(c=i.shape,u.push(i));let p=null;null!=o&&(p=o.shape,u.push(o));let d=Xe().getBool("WEBGL_PACK_NORMALIZATION")?new cY(r.shape,a.shape,s.shape,c,p,l):new uY(r.shape,a.shape,s.shape,c,p,l);return t.runWebGLProgram(d,u,u[0].dtype)},dY={kernelName:dn,backendName:"webgl",kernelFunc:pY},hY=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=jH(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n,r=mY(this.rank),a=e.map(((e,t)=>`sourceLoc.${fY[t]} = start[${t}] + coords.${fY[t]};`));n=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${a.join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${n}\n        setOutput(getSource(${r}));\n      }\n    `}},fY=["x","y","z","w","u","v"];function mY(e){if(1===e)return"sourceLoc";if(e<=6)return fY.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}var gY=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=jH(this.rank),n=Iq("coords",this.rank),r=Iq("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,s=`getChannel(getSource(${r.join()}), ${a})`,i=`\n      result.x = ${s};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${s};\n        --${r[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${s};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${s};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${i}\n        ${o}\n        setOutput(result);\n      }\n    `}};function yY(e,t,n,r){let a=r.texData.get(e.dataId),s=r.makeTensorInfo(n,e.dtype),i=r.texData.get(s.dataId);Object.assign(i,a),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=Ql.computeFlatOffset(t,Na.computeStrides(e.shape));a.slice&&(o+=a.slice.flatOffset),i.slice={flatOffset:o,origDataId:a.slice&&a.slice.origDataId||e.dataId};let l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),s}function bY(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{begin:s,size:i}=r,[o,l]=Ql.parseSliceParams(a,s,i);if(Ql.assertParamsValid(a,o,l),0===Na.sizeFromShape(l))return n.makeTensorInfo(l,a.dtype,[]);if(n.shouldExecuteOnCPU([a])||"string"===a.dtype){let e=n.texData.get(a.dataId),t=lq(e.values,o,l,a.shape,a.dtype);return n.makeTensorInfo(l,a.dtype,t)}let{isPacked:u}=n.texData.get(a.dataId),c=Ql.isSliceContinous(a.shape,o,l);if(u||!c){let e=Xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new gY(l):new hY(l),t=[o];return n.runWebGLProgram(e,[a],a.dtype,t)}return n.uploadToGPU(a.dataId),yY(a,o,l,n)}var wY={kernelName:Tr,backendName:"webgl",kernelFunc:bY},xY=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r;Na.assert(a.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));let o=s.reduce(((e,t)=>e*t)),l=Aw.getReshaped(a.shape,s,o),u=Aw.getPermuted(l.length,s.length),c=Aw.getReshapedPermuted(a.shape,s,o),p=Aw.getSliceBeginCoords(i,s.length),d=Aw.getSliceSize(c,i,s.length),h=[],f=zK({inputs:{x:a},backend:n,attrs:{shape:l}}),m=ZK({inputs:{x:f},backend:n,attrs:{perm:u}}),g=zK({inputs:{x:m},backend:n,attrs:{shape:c}}),y=bY({inputs:{x:g},backend:n,attrs:{begin:p,size:d}});return h.push(f),h.push(m),h.push(g),h.forEach((e=>n.disposeIntermediateTensorInfo(e))),y},vY={kernelName:vt,backendName:"webgl",kernelFunc:xY};function kY(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i}=r,o=n.readSync(a.dataId),l=n.readSync(s.dataId),u=Dj(o,l,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,u)}var IY={kernelName:kt,backendName:"webgl",kernelFunc:kY};function SY(e){let{inputs:t,backend:n}=e,{s0:r,s1:a}=t,s=n.readSync(r.dataId),i=n.readSync(a.dataId),o=Aw.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var NY={kernelName:St,backendName:"webgl",kernelFunc:SY},TY="return float(a != b);",_Y=AK({opSnippet:TY,cpuKernelImpl:tq,dtype:"bool"}),CY={kernelName:Jn,backendName:"webgl",kernelFunc:_Y};function EY(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.texData.get(r.dataId);return fK({inputs:{x:a.complexTensorInfos.real},backend:n})}var AY={kernelName:cr,backendName:"webgl",kernelFunc:EY},$Y="return float(int(x));";function FY(e,t){let n=new Mq(e.shape,$Y),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function RY(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dtype:s}=r;if("complex64"===s){if("complex64"===a.dtype)return fK({inputs:{x:a},backend:n});let e=yf(a.shape),t=RY({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),r=gK({inputs:{real:t,imag:e},backend:n});return e.dispose(),n.disposeIntermediateTensorInfo(t),r}if("complex64"===a.dtype){let e=EY({inputs:{input:a},backend:n}),t=RY({inputs:{x:e},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(e),t}if(!Na.hasEncodingLoss(a.dtype,s)){let e=fK({inputs:{x:a},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}if("int32"===s)return FY(a,n);if("bool"===s){let e=n.makeTensorInfo([],"bool",Na.getTypedArrayFromDType("bool",1)),t=_Y({inputs:{a:a,b:e},backend:n});return n.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${s}`)}var DY={kernelName:Nt,backendName:"webgl",kernelFunc:RY},MY="return ceil(x);",OY=EK({opSnippet:MY,packedOpSnippet:MY,cpuKernelImpl:Oj}),LY={kernelName:Tt,backendName:"webgl",kernelFunc:OY},PY=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}},zY=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}};function BY(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{clipValueMin:i,clipValueMax:o}=a;t=Xe().getBool("WEBGL_PACK_CLIP")?new zY(s.shape):new PY(s.shape);let l=[[i],[o]];return r.runWebGLProgram(t,[s],s.dtype,l)}var WY={kernelName:_t,backendName:"webgl",kernelFunc:BY},VY=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}};function UY(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function GY(e){let{inputs:t,backend:n}=e,{x:r}=t,a=n.texData.get(r.dataId),s=new VY(r.shape),i=[UY(r,a.complexTensorInfos.real),UY(r,a.complexTensorInfos.imag)];return n.runWebGLProgram(s,i,i[0].dtype)}var HY={kernelName:Et,backendName:"webgl",kernelFunc:GY},jY=class{constructor(e){this.outputShape=[],this.outputShape=Aw.computeOutShape(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));let t=new Array(e.length-1);t[0]=e[0][1];for(let s=1;s<t.length;s++)t[s]=t[s-1]+e[s][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let s=1;s<t.length;s++){let e=t[s-1];n.push(`else if (yC < ${t[s]}) setOutput(getT${s}(yR, yC-${e}));`)}let r=t.length,a=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${a}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}},qY=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Aw.computeOutShape(e,t);let n=this.outputShape,r=n.length,a=jH(r),s=Iq("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map(((e,t)=>`T${t}`));let o=new Array(e.length-1);o[0]=e[0][t];for(let f=1;f<o.length;f++)o[f]=o[f-1]+e[f][t];let l=i[t],u=i.slice(-2),c=i.join(),p=`if (${l} < ${o[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${u.join()}));\n        }`;for(let f=1;f<o.length;f++){let e=o[f-1];p+=`\n        if (${l} < ${o[f]}  && ${l} >= ${o[f-1]}) {\n          return getChannel(\n            getT${f}(${KY(i,l,e)}),\n            vec2(${KY(u,l,e)}));\n        }`}let d=o.length,h=o[o.length-1];p+=`\n        return getChannel(\n          getT${d}(${KY(i,l,h)}),\n          vec2(${KY(u,l,h)}));`,this.userCode=`\n      float getValue(${i.map((e=>"int "+e))}) {\n        ${p}\n      }\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${s}), 0., 0., 0.);\n\n        ${s[r-1]} = ${s[r-1]} + 1;\n        if (${s[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${s});\n        }\n\n        ${s[r-2]} = ${s[r-2]} + 1;\n        if (${s[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${s});\n        }\n\n        ${s[r-1]} = ${s[r-1]} - 1;\n        if (${s[r-2]} < ${n[r-2]} &&\n            ${s[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${s});\n        }\n        setOutput(result);\n      }\n    `}};function KY(e,t,n){let r=e.indexOf(t);return e.map(((e,t)=>t===r?`${e} - ${n}`:e)).join()}function XY(e){let{inputs:t,backend:n}=e,{input:r}=t,a=n.texData.get(r.dataId);return fK({inputs:{x:a.complexTensorInfos.imag},backend:n})}var YY={kernelName:wn,backendName:"webgl",kernelFunc:XY};function JY(e,t,n){let r=e[0].dtype;if("complex64"===r){let r=e.map((e=>EY({inputs:{input:e},backend:n}))),a=e.map((e=>XY({inputs:{input:e},backend:n}))),s=JY(r,t,n),i=JY(a,t,n),o=gK({inputs:{real:s,imag:i},backend:n});return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),a.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i),o}let a=n.shouldExecuteOnCPU(e);if("string"===r&&(a=!0),a){let a=e.map((e=>{let r=Na.sizeFromShape(e.shape.slice(t));return zK({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})})),s=a.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),i=Aw.computeOutShape(a.map((e=>e.shape)),1),o=1===a[0].shape[0],l=Lj(s,i,r,o),u=Aw.computeOutShape(e.map((e=>e.shape)),t),c=n.makeTensorInfo(u,r,l);return a.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}if(e.length>Xe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let r=Math.floor(e.length/2),a=JY(e.slice(0,r),t,n),s=JY(e.slice(r),t,n),i=JY([a,s],t,n);return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}if(Xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].shape.length>1){let a=new qY(e.map((e=>e.shape)),t);return n.runWebGLProgram(a,e,r)}let{tensors2D:s,outShape:i}=ZY(e,t,n),o=new jY(s.map((e=>e.shape))),l=n.runWebGLProgram(o,s,r);s.forEach((e=>n.disposeIntermediateTensorInfo(e)));let u=zK({inputs:{x:l},attrs:{shape:i},backend:n});return n.disposeIntermediateTensorInfo(l),u}function ZY(e,t,n){let r=Aw.computeOutShape(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>zK({inputs:{x:e},attrs:{shape:[-1,Na.sizeFromShape(e.shape.slice(t))]},backend:n}))),outShape:r}}function QY(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r,s=Na.parseAxisParam(a,t[0].shape)[0],i=Aw.computeOutShape(t.map((e=>e.shape)),s);if(0===Na.sizeFromShape(i))return n.makeTensorInfo(i,t[0].dtype,[]);let o=t.filter((e=>Na.sizeFromShape(e.shape)>0));if(1===o.length)return fK({inputs:{x:o[0]},backend:n});let l=o.map((e=>e.shape));return Aw.assertParamsConsistent(l,s),JY(o,s,n)}var eJ={kernelName:At,backendName:"webgl",kernelFunc:QY},tJ=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let s=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,p=e.filterHeight,d=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,y=m?2:3,b=m?3:1,w="",x="";n&&(w=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,x="result = activation(result);");let v=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${w}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${p}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${d}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${h}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${h}) *\n                    getW(wR, wC, ${h}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${h}, xR, xC) *\n                    getW(wR, wC, ${h}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${h}, d2),\n                getW(wR, wC, ${h} + 1, d2),\n                getW(wR, wC, ${h} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${h}),\n                  getX(batch, xR, xC, ${h} + 1),\n                  getX(batch, xR, xC, ${h} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${h}, xR, xC),\n                  getX(batch, ${h} + 1, xR, xC),\n                  getX(batch, ${h} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${v}\n        ${x}\n        setOutput(result);\n      }\n    `}},nJ=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.filterDepth,p=e.filterHeight,d=e.filterWidth,h=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${a}, ${s}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${h}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${h}) *\n                  getW(wF, wR, wC, ${h}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${h}),\n                  getX(batch, xF, xR, xC, ${h} + 1),\n                  getX(batch, xF, xR, xC, ${h} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${h}, d2),\n                  getW(wF, wR, wC, ${h} + 1, d2),\n                  getW(wF, wR, wC, ${h} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},rJ=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=tj(this.outputShape.length);let{dataFormat:n}=t,r=YG(),a="channelsLast"===n,s=a?0:1,i=a?1:2,o=this.enableShapeUniforms?"if(blockIndex < outShape[1] && pos < outShape[0]) {":`if(blockIndex < ${e[1]} && pos < ${e[0]}) {`,l="";for(let u=0;u<=1;u++)for(let e=0;e<=1;e++)l+=`\n          blockIndex = rc.y + ${e};\n          pos = rc.x + ${u};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${s}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${i}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${a}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*u+e}] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*u+e}] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${r.output} = result;\n      }\n    `}};function aJ({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let l,u=e.shape,c=r.texData.get(e.dataId),p=n.inChannels,d=u[0]*u[1]*u[2],h=n.outChannels,f="channelsLast"===n.dataFormat,m=!1,g=!1,y=[];if(null!=s&&!f&&3===s.shape.length){let e=ZK({inputs:{x:s},backend:r,attrs:{perm:[1,2,0]}});y.push(e),s=e}if((1!==d&&1!==h||!(p>eX))&&c.isPacked&&f&&null!=c.texture&&u[2]%2!==0&&Na.arraysEqual(c.shape.slice(-3),u.slice(-3))){let p=u[0]*u[1]*(u[2]+1),d={dataId:e.dataId,shape:[1,p,n.inChannels],dtype:e.dtype},h=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,Na.assert(MG(c.shape,d.shape),(()=>`packed reshape ${c.shape} to ${d.shape} isn't free`));let f=zK({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});y.push(f);let b=tX({a:d,b:f,backend:r,transposeA:m,transposeB:g,bias:a,activation:o,preluActivationWeights:s,leakyreluAlpha:i}),w=r.texData.get(b.dataId);Na.assert(w.isPacked,(()=>"batchMatMul result is expected to be packed")),c.shape=h,w.shape=n.outShape,l=fK({inputs:{x:b},backend:r}),l.shape=n.outShape,y.push(b)}else{let u=f?e:ZK({inputs:{x:e},backend:r,attrs:{perm:[0,2,3,1]}}),c=u.shape,p=c[0]*c[1]*c[2],d=zK({inputs:{x:u},backend:r,attrs:{shape:[1,p,n.inChannels]}}),h=zK({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),b=tX({a:d,b:h,transposeA:m,transposeB:g,backend:r,bias:a,activation:o,preluActivationWeights:s,leakyreluAlpha:i}),w=[n.batchSize,n.outHeight,n.outWidth,n.outChannels],x=zK({inputs:{x:b},backend:r,attrs:{shape:w}});l=f?x:ZK({inputs:{x:x},backend:r,attrs:{perm:[0,3,1,2]}}),f||(y.push(u),y.push(x)),y.push(d),y.push(h),y.push(b)}for(let b of y)r.disposeIntermediateTensorInfo(b);return l}function sJ({x:e,filter:t,convInfo:n,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:o=null}){let{filterWidth:l,filterHeight:u,inChannels:c,outWidth:p,outHeight:d,dataFormat:h}=n,f="channelsLast"===h,m=l*u*c,g=d*p,y=[m,g],b=!0,w=!1,x=[];if(null!=s&&!f&&3===s.shape.length){let e=ZK({inputs:{x:s},backend:r,attrs:{perm:[1,2,0]}});x.push(e),s=e}let v=zK({inputs:{x:e},backend:r,attrs:{shape:e.shape.slice(1)}}),k=zK({inputs:{x:t},backend:r,attrs:{shape:[1,m,Na.sizeFromShape(t.shape)/m]}});x.push(v),x.push(k);let I=new rJ(y,n),S=[v.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],N=r.runWebGLProgram(I,[v],"float32",S),T=zK({inputs:{x:N},backend:r,attrs:{shape:[1,y[0],y[1]]}});x.push(N),x.push(T);let _=null!=a,C=null!=s,E="leakyrelu"===o,A=o?$K(o,!0):null,$=new FK(T.shape,k.shape,[1,g,n.outChannels],b,w,_,A,C,E),F=[T,k];if(a&&F.push(a),C&&F.push(s),E){let e=r.makeTensorInfo([],"float32",Na.createScalarValue(i,"float32"));F.push(e),x.push(e)}let R=r.runWebGLProgram($,F,"float32"),D=[1,d,p,n.outChannels],M=zK({inputs:{x:R},backend:r,attrs:{shape:D}}),O=f?M:ZK({inputs:{x:M},backend:r,attrs:{perm:[0,3,1,2]}});f||x.push(M),x.push(R);for(let L of x)r.disposeIntermediateTensorInfo(L);return O}function iJ(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s,filter:i}=n,{strides:o,pad:l,dataFormat:u,dilations:c,dimRoundingMode:p}=a,d=Aw.convertConv2DDataFormat(u),h=Aw.computeConv2DInfo(s.shape,i.shape,o,c,l,p,!1,d);if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(Xe().getBool("WEBGL_CONV_IM2COL")&&1===s.shape[0])t=sJ({x:s,filter:i,convInfo:h,backend:r});else{let e=new tJ(h);t=r.runWebGLProgram(e,[s,i],"float32")}else t=aJ({x:s,filter:i,convInfo:h,backend:r});let f=zK({inputs:{x:t},backend:r,attrs:{shape:h.outShape}});return r.disposeIntermediateTensorInfo(t),f}var oJ={kernelName:$t,backendName:"webgl",kernelFunc:iJ},lJ=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              if (${s}) {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},uJ=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=s?1:2,u=s?2:3,c=s?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${s}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},cJ=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${a};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${s};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${i};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},pJ=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,a=e.strideDepth,s=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${o}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${a}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${s}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};function dJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,p=Aw.convertConv2DDataFormat(l),d=Aw.computeConv2DInfo(a.shape,c,i,1,o,u,!1,p),h=new lJ(d);return n.runWebGLProgram(h,[a,s],"float32")}var hJ={kernelName:Ft,backendName:"webgl",kernelFunc:dJ};function fJ(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r,p=Aw.convertConv2DDataFormat(u),d=Aw.computeConv2DInfo(i,s.shape,o,1,l,c,!1,p),h=new uJ(d);return n.runWebGLProgram(h,[a,s],"float32")}var mJ={kernelName:Rt,backendName:"webgl",kernelFunc:fJ};function gJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l}=r,u=Aw.computeConv3DInfo(a.shape,s.shape,i,l,o),c=new nJ(u);return n.runWebGLProgram(c,[a,s],"float32")}var yJ={kernelName:Dt,backendName:"webgl",kernelFunc:gJ};function bJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,pad:o,filterShape:l}=r,u=Aw.computeConv3DInfo(a.shape,l,i,1,o),c=new cJ(u);return n.runWebGLProgram(c,[a,s],"float32")}var wJ={kernelName:Mt,backendName:"webgl",kernelFunc:bJ};function xJ(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{pad:i,strides:o,inputShape:l}=r,u=Aw.computeConv3DInfo(l,s.shape,o,1,i),c=new pJ(u);return n.runWebGLProgram(c,[a,s],"float32")}var vJ,kJ={kernelName:Ot,backendName:"webgl",kernelFunc:xJ},IJ=TK+"\n  return cos(x);\n",SJ=EK({opSnippet:IJ}),NJ={kernelName:Lt,backendName:"webgl",kernelFunc:SJ},TJ="\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n",_J=EK({opSnippet:TJ}),CJ={kernelName:Pt,backendName:"webgl",kernelFunc:_J},EJ=class{constructor(e,t,n,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[s,i,o,l]=e,[u]=t,[c,p]=n;this.outputShape=[u,c,p,l];let d="bilinear"===r?1:0,[h,f]=[i-1+".0",o-1+".0"],[m,g,y]=c>1?[""+(i-1)/(c-1),"(y2-y1) * height_ratio",`y1*${h} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${h}`],[b,w,x]=p>1?[""+(o-1)/(p-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${s}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${w};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${h} ) {\n          setOutput(float(${a}));\n          return;\n        }\n        float in_x = ${x};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${a}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}},AJ=e=>{let{inputs:t,backend:n,attrs:r}=e,{image:a,boxes:s,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,c=new EJ(a.shape,s.shape,o,l,u);return n.runWebGLProgram(c,[a,s,i],"float32")},$J={kernelName:Wt,backendName:"webgl",kernelFunc:AJ};(function(e){e.Prod="*",e.Sum="+"})(vJ||(vJ={}));var FJ=class{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let a=this.outputShape.length,s=this.op===vJ.Prod?"1.0":"0.0",i=n?s:`getX(${RJ(a,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1],l="",u="";n?(l=r?"end != "+(o-1):"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${jH(a)} coords = getOutputCoords();\n        int end = ${DJ(a,"coords",this.op)};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${u};\n          ${DJ(a,"coords",this.op)} = idx;\n          val ${this.op}= getX(${RJ(a,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}};function RJ(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function DJ(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function MJ(e,t,n,r,a,s){let i=t.shape.length,o=Aw.getAxesPermutation([r],i),l=t;null!=o&&(l=ZK({inputs:{x:t},backend:n,attrs:{perm:o}}));let u=Aw.getInnerMostAxes(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);let c=l.shape[u],p=fK({inputs:{x:l},backend:n});for(let d=0;d<=Math.ceil(Math.log2(c))-1;d++){let t=new FJ(e,l.shape,!1,s),r=[[d]],a=p;p=n.runWebGLProgram(t,[p],p.dtype,r),n.disposeIntermediateTensorInfo(a)}if(a){let t=new FJ(e,l.shape,a,s),r=p;p=n.runWebGLProgram(t,[p],p.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=o){let e=Aw.getUndoAxesPermutation(o),t=ZK({inputs:{x:p},backend:n,attrs:{perm:e}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(l),t}return p}function OJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return MJ(vJ.Prod,a,n,s,i,o)}var LJ={kernelName:zt,backendName:"webgl",kernelFunc:OJ};function PJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r;return MJ(vJ.Sum,a,n,s,i,o)}var zJ={kernelName:Bt,backendName:"webgl",kernelFunc:PJ};function BJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,weights:s}=t,{size:i,binaryOutput:o}=r;if(1===a.shape.length){let e=n.readSync(a.dataId),t=n.readSync(s.dataId),r=Dj(e,t,s.dtype,s.shape,i);return n.makeTensorInfo([i],s.dtype,r)}if(2===a.shape.length){let e=n.bufferSync(a),t=n.bufferSync(s),r=Mj(e,t,i,o);return n.makeTensorInfo(r.shape,s.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}var WJ={kernelName:Vt,backendName:"webgl",kernelFunc:BJ},VJ=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function UJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockSize:s,dataFormat:i}=r,o=a.shape[0],l="NHWC"===i?a.shape[1]:a.shape[2],u="NHWC"===i?a.shape[2]:a.shape[3],c="NHWC"===i?a.shape[3]:a.shape[1],p=l*s,d=u*s,h=c/(s*s),f="NHWC"===i?[o,p,d,h]:[o,h,p,d],m=new VJ(f,s,i);return n.runWebGLProgram(m,[a],a.dtype)}var GJ={kernelName:Ut,backendName:"webgl",kernelFunc:UJ},HJ=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=tj(this.outputShape.length);let s=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels,l="",u="";n&&(l=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,u="result = activation(result);");let c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${s}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${c}\n        ${u}\n        setOutput(result);\n      }\n    `}},jJ=class{constructor(e,t=!1,n=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=tj(this.outputShape.length);let s=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,p=c,d="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<c;g++)d+=`\n          vec4 xTexelC${2*g};\n          int xTexelC${2*g}Ready;\n          vec4 xTexelC${2*g+1};\n          int xTexelC${2*g+1}Ready;\n          vec4 xC${g};`;d+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let g=0;g<c;g++)d+=`\n          xTexelC${2*g} = vec4(0.0);\n          xTexelC${2*g}Ready = 0;\n          xTexelC${2*g+1} = vec4(0.0);\n          xTexelC${2*g+1}Ready = 0;\n          xC${g} = vec4(0.0);`;d+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let g=0;g<(p+1)/2;g++){let e=2*g;if(d+=`\n          xC = xCCorner + ${e*l};\n          `,1===o){if(e<c&&(i%2===1?(d+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n              `,d+=1===l&&e>0?`\n                xC${e} = vec4(xTexelC${e-2}.zw, xTexelC${e}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${e} = vec4(previous.zw, xTexelC${e}.xy);\n                  } else {\n                    xC${e} = vec4(0.0, 0.0, xTexelC${e}.xy);\n                  }\n                  `):d+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xC${e} = xTexelC${e};\n                `,e+1<c)){let t=i%2===0?Na.nearestLargerEven(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(d+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${t};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                    xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${e+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${e+1}Ready = 1;\n                  }\n                  `,l>1&&(d+=`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                      xTexelC${e} = getX(batch, xR, xCOffset, d1);\n                      xTexelC${e}Ready = 1;\n                    }\n                    `),d+=`\n                  xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.xy);\n                  `):d+=1===t?`\n                    xC${e+1} = xTexelC${e};\n                    `:`\n                    xCOffset = xC + ${t};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                      xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${e+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${e+1}Ready = 1;\n                    }\n\n                    xC${e+1} = xTexelC${e+1};\n                    `}}else e<c&&(i%2===1?(d+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n              `,e+1<c&&(d+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${e+1} = vec4(xTexelC${e+1}.xy, final.xy);\n                `)):(d+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(\n                  xTexelC${e}.xy, xTexelC${e+1}.xy);\n              `,e+1<c&&(d+=`\n                  xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n                `)));e<c&&(d+=`\n            wTexel = getW(r, ${e}, d1, q);\n            dotProd += xC${e} * vec4(wTexel.xz, wTexel.xz);\n          `,e+1<c&&(d+=`\n              wTexel = getW(r, ${e+1}, d1, q);\n              dotProd += xC${e+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}d+="\n    }\n  ",d+="\n      }\n    ";let h="",f="";n&&(h=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:a?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,f="result = activation(result);");let m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${h}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${s};\n        int q = d2 - d1 * ${s};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${d}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${f}\n        setOutput(result);\n      }\n    `}};function qJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r,c=l;null==c&&(c=[1,1]),Na.assert(Aw.eitherStridesOrDilationsAreOne(i,c),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`));let p,d=Aw.computeConv2DInfo(a.shape,s.shape,i,c,o,u,!0);p=Xe().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?new jJ(d):new HJ(d);let h=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(p,[a,s],"float32",h)}var KJ={kernelName:Gt,backendName:"webgl",kernelFunc:qJ},XJ=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${s} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${a};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},YJ=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,a=e.strideWidth,s=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${a}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};function JJ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,dy:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r,p=Aw.computeConv2DInfo(a.shape,c,i,o,l,u,!0),d=new XJ(p);return n.runWebGLProgram(d,[a,s],"float32")}var ZJ={kernelName:Ht,backendName:"webgl",kernelFunc:JJ};function QJ(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,filter:s}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r,p=Aw.computeConv2DInfo(c,s.shape,i,o,l,u,!0),d=new YJ(p);return n.runWebGLProgram(d,[a,s],"float32")}var eZ={kernelName:jt,backendName:"webgl",kernelFunc:QJ},tZ=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}};function nZ(e){let{inputs:t,backend:n}=e,{x:r}=t,a=[...r.shape,...r.shape],s=Na.sizeFromShape(r.shape),i=zK({inputs:{x:r},backend:n,attrs:{shape:[s]}}),o=new tZ(s),l=n.runWebGLProgram(o,[i],i.dtype),u=zK({inputs:{x:l},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}var rZ={kernelName:qt,backendName:"webgl",kernelFunc:nZ},aZ=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:r,strideHeight:a,strideWidth:s,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:c,left:p}=r;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${s});\n      const ivec2 pads = ivec2(${c}, ${p});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}};function sZ(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s,filter:i}=n,{strides:o,pad:l,dilations:u}=a,c=Aw.computeDilation2DInfo(s.shape,i.shape,o,l,"NHWC",u),p=new aZ(c);t=r.runWebGLProgram(p,[s,i],"float32");let d=zK({inputs:{x:t},backend:r,attrs:{shape:c.outShape}});return r.disposeIntermediateTensorInfo(t),d}var iZ={kernelName:Kt,backendName:"webgl",kernelFunc:sZ};function oZ(e){let{inputs:t,backend:n,attrs:r}=e,{equation:a}=r,s=t,{allDims:i,summedDims:o,idDims:l}=Aw.decodeEinsumEquation(a,s.length);Aw.checkEinsumDimSizes(i.length,l,s);let{path:u,steps:c}=Aw.getEinsumComputePath(o,l),p=c.length,d=null,h=i.length,f=[];for(let m=0;m<p;++m){for(let e of c[m]){let t,{permutationIndices:r,expandDims:a}=Aw.getEinsumPermutation(h,l[e]);Aw.isIdentityPermutation(r)?t=s[e]:(t=ZK({inputs:{x:s[e]},backend:n,attrs:{perm:r}}),f.push(t));let i=t.shape.slice();for(let e=0;e<a.length;++e)i.splice(a[e],0,1);Na.arraysEqual(t.shape,i)||(t=zK({inputs:{x:t},backend:n,attrs:{shape:i}}),f.push(t)),null===d?d=t:(d=OK({inputs:{a:t,b:d},backend:n}),f.push(d))}m<p-1&&(u[m]>=0&&(d=YK({inputs:{x:d},backend:n,attrs:{axis:u[m]-(i.length-h),keepDims:!1}}),f.push(d)),h--)}for(let m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}var lZ={kernelName:Zt,backendName:"webgl",kernelFunc:oZ},uZ="return (x >= 0.0) ? x : (exp(x) - 1.0);",cZ="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",pZ=EK({opSnippet:uZ,packedOpSnippet:cZ}),dZ={kernelName:Qt,backendName:"webgl",kernelFunc:pZ},hZ="return (b >= 1.0) ? a : a * (b + 1.0);",fZ="\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",mZ=e=>{let{inputs:t,backend:n}=e,{dy:r,y:a}=t,s=Xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new hK(fZ,r.shape,a.shape):new pK(hZ,r.shape,a.shape);return n.runWebGLProgram(s,[r,a],r.dtype)},gZ={kernelName:en,backendName:"webgl",kernelFunc:mZ},yZ="\n  return vec4(equal(a, b));\n",bZ="return float(a == b);",wZ=AK({opSnippet:bZ,packedOpSnippet:yZ,dtype:"bool",cpuKernelImpl:Pj}),xZ={kernelName:nn,backendName:"webgl",kernelFunc:wZ},vZ=`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${Aw.ERF_P};\n  float a1 = ${Aw.ERF_A1};\n  float a2 = ${Aw.ERF_A2};\n  float a3 = ${Aw.ERF_A3};\n  float a4 = ${Aw.ERF_A4};\n  float a5 = ${Aw.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`,kZ=EK({opSnippet:vZ}),IZ={kernelName:tn,backendName:"webgl",kernelFunc:kZ},SZ=TK+"\n  return exp(x);\n",NZ="\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",TZ=EK({opSnippet:SZ,packedOpSnippet:NZ,cpuKernelImpl:zj,dtype:"float32"}),_Z={kernelName:rn,backendName:"webgl",kernelFunc:TZ};function CZ(e){let{inputs:t,attrs:n,backend:r}=e,{dim:a}=n,{input:s}=t,i=s.shape.length,o=s.shape.slice(),l=a;return a<0&&(Na.assert(-(i+1)<=a,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+a+1),o.splice(l,0,1),zK({inputs:{x:s},backend:r,attrs:{shape:o}})}var EZ={kernelName:an,backendName:"webgl",kernelFunc:CZ},AZ="return exp(x) - 1.0;",$Z=EK({opSnippet:AZ,packedOpSnippet:AZ,cpuKernelImpl:Bj}),FZ={kernelName:sn,backendName:"webgl",kernelFunc:$Z},RZ=class{constructor(e,t,n){this.variableNames=["real","imag"];let r=t[1];this.outputShape=t;let a,s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=n?`${r}.0`:"1.0";if("real"===e)a="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${i};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}};function DZ(e,t,n){let r=n.texData.get(e.dataId),a=Na.sizeFromShape(e.shape),s=e.shape[e.shape.length-1],i=a/s,o=zK({inputs:{x:e},backend:n,attrs:{shape:[i,s]}}),l=o.shape,u=new RZ("real",l,t),c=new RZ("imag",l,t),p=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],d=n.runWebGLProgram(u,p,"float32"),h=n.runWebGLProgram(c,p,"float32"),f=gK({inputs:{real:d,imag:h},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h);let m=zK({inputs:{x:f},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(f),m}function MZ(e){let{inputs:t,backend:n}=e,{input:r}=t;return DZ(r,!1,n)}var OZ={kernelName:on,backendName:"webgl",kernelFunc:MZ},LZ=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}};function PZ(e){let{backend:t,attrs:n}=e,{shape:r,value:a}=n,{dtype:s}=n;if(s=s||Na.inferDtype(a),"string"===s){let e=Na.getArrayFromDType(s,Na.sizeFromShape(r));return e.fill(a),t.makeTensorInfo(r,s,e)}{let e=new LZ(r,a),n=[[a]];return t.runWebGLProgram(e,[],s,n)}}var zZ,BZ={kernelName:ln,backendName:"webgl",kernelFunc:PZ},WZ=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}},VZ={kernelName:un,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{let{image:n}=e,r=t,a=new WZ(n.shape);return r.runWebGLProgram(a,[n],n.dtype)}},UZ="return floor(x);",GZ=EK({opSnippet:UZ,packedOpSnippet:UZ,cpuKernelImpl:Wj}),HZ={kernelName:cn,backendName:"webgl",kernelFunc:GZ},jZ="\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",qZ="\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",KZ=AK({opSnippet:jZ,packedOpSnippet:qZ,dtype:"int32"}),XZ={kernelName:pn,backendName:"webgl",kernelFunc:KZ},YZ=class{constructor(e){this.variableNames=["A"];let t=YG(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}},JZ=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=YG(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}},ZZ={kernelName:oa,backendName:"webgl",kernelFunc:QZ};function QZ(e){let{inputs:t,backend:n,attrs:r}=e,{pixels:a}=t,{numChannels:s}=r,i="undefined"!=typeof HTMLVideoElement&&a instanceof HTMLVideoElement,o="undefined"!=typeof HTMLImageElement&&a instanceof HTMLImageElement,[l,u]=i?[a.videoWidth,a.videoHeight]:[a.width,a.height],c=[u,l],p=[u,l,s];(o||i)&&(null==zZ&&(zZ=document.createElement("canvas").getContext("2d")),zZ.canvas.width=l,zZ.canvas.height=u,zZ.drawImage(a,0,0,l,u),a=zZ.canvas);let d=n.makeTensorInfo(c,"int32");n.texData.get(d.dataId).usage=MU.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),a);let h=Xe().getBool("WEBGL_PACK")?new JZ(p):new YZ(p),f=n.runWebGLProgram(h,[d],"int32");return n.disposeData(d.dataId),f}function eQ(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s,filter:i,bias:o,preluActivationWeights:l}=n,{strides:u,pad:c,dataFormat:p,dilations:d,dimRoundingMode:h,activation:f,leakyreluAlpha:m}=a,g=Aw.convertConv2DDataFormat(p),y=Aw.computeConv2DInfo(s.shape,i.shape,u,d,c,h,!1,g),b=[];if(1!==y.filterHeight||1!==y.filterWidth||1!==y.dilationHeight||1!==y.dilationWidth||1!==y.strideHeight||1!==y.strideWidth||"SAME"!==y.padInfo.type&&"VALID"!==y.padInfo.type)if(Xe().getBool("WEBGL_CONV_IM2COL")&&1===s.shape[0])t=sJ({x:s,filter:i,convInfo:y,backend:r,bias:o,activation:f,preluActivationWeights:l,leakyreluAlpha:m});else{let e=null!=o,n=null!=l,a="leakyrelu"===f,u=f?$K(f,!1):null,c=new tJ(y,e,u,n,a),d=[s,i],h=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){let t=zK({inputs:{x:e},backend:r,attrs:{shape:[e.shape[0],1,1]}});return b.push(t),t}return e};if(e&&d.push(h(o,p)),n&&d.push(h(l,p)),a){let e=r.makeTensorInfo([],"float32",Na.createScalarValue(m,"float32"));d.push(e),b.push(e)}t=r.runWebGLProgram(c,d,"float32")}else t=aJ({x:s,filter:i,convInfo:y,backend:r,bias:o,activation:f,preluActivationWeights:l,leakyreluAlpha:m});let w=zK({inputs:{x:t},backend:r,attrs:{shape:y.outShape}});return b.push(t),b.forEach((e=>r.disposeIntermediateTensorInfo(e))),w}var tQ={kernelName:ca,backendName:"webgl",kernelFunc:eQ};function nQ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:p,activation:d,leakyreluAlpha:h}=r,f=[],m=c;null==m&&(m=[1,1]),Na.assert(Aw.eitherStridesOrDilationsAreOne(l,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));let g,y=Aw.computeConv2DInfo(a.shape,s.shape,l,m,u,p,!0),b=Xe().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels===1,w=d?$K(d,b):null,x=[a,s],v=null!=i,k=null!=o,I="leakyrelu"===d;if(v&&x.push(i),k&&x.push(o),I){let e=n.makeTensorInfo([],"float32",Na.createScalarValue(h,"float32"));x.push(e),f.push(e)}g=b?new jJ(y,v,w,k,I):new HJ(y,v,w,k,I);let S=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],N=n.runWebGLProgram(g,x,"float32",S);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),N}var rQ={kernelName:pa,backendName:"webgl",kernelFunc:nQ},aQ=class{constructor(e,t,n){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=n;let r=jH(t.length),a=jH(n.length),s=this.sliceDim>1?"strides[j]":"strides";this.userCode=`\n        ${r} strides = ${r}(${this.strides});\n         void main() {\n          ${a} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ${this.sliceDim}; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ${s};\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      `}};function sQ(e){let{inputs:t,backend:n}=e,{params:r,indices:a}=t,s=a.shape,i=s[s.length-1],o=Na.sizeFromShape(r.shape),[l,u,c,p]=Aw.prepareAndValidate(r,a),d=zK({inputs:{x:a},backend:n,attrs:{shape:[u,i]}}),h=zK({inputs:{x:r},backend:n,attrs:{shape:[Na.sizeFromShape(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,a])||"string"===r.dtype){let e=n.readSync(a.dataId),t=n.bufferSync(r),s=Vj(e,t,r.dtype,u,i,c,p,r.shape,o);return n.makeTensorInfo(l,r.dtype,s.values)}let f=new aQ(i,p,[u,c]),m=n.runWebGLProgram(f,[h,d],h.dtype),g=zK({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(m),g}var iQ={kernelName:fn,backendName:"webgl",kernelFunc:sQ},oQ=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=jH(this.rank),r=lQ(e,2);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}};function lQ(e,t){let n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let a=0;a<e.length;a++)2===a?r.push("index"):r.push(`${n[a]}`);return r.join()}function uQ(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,indices:s}=t,{axis:i,batchDims:o}=r,l=Na.parseAxisParam(i,a.shape)[0];if(Xe().get("DEBUG")){let e=n.readSync(s.dataId),t=a.shape[l];for(let n=0;n<e.length;++n){let r=e[n];Na.assert(r<=t-1&&r>=0,(()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`))}}let u=Aw.segment_util.collectGatherOpShapeInfo(a,s,l,o),c=Na.sizeFromShape(s.shape),p=[],d=zK({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),h=zK({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});p.push(d),p.push(h);let f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([a,s])||"string"===a.dtype){let e=n.bufferSync(h),t=n.bufferSync(d),r=Uj(t,e,f);return p.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u.outputShape,r.dtype,r.values)}let m=new oQ(d.shape,f),g=n.runWebGLProgram(m,[d,h],d.dtype);p.push(g);let y=zK({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return p.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}var cQ={kernelName:hn,backendName:"webgl",kernelFunc:uQ},pQ="return float(a > b);",dQ="\n  return vec4(greaterThan(a, b));\n",hQ=AK({opSnippet:pQ,packedOpSnippet:dQ,cpuKernelImpl:Gj,dtype:"bool"}),fQ={kernelName:mn,backendName:"webgl",kernelFunc:hQ},mQ="return float(a >= b);",gQ="\n  return vec4(greaterThanEqual(a, b));\n",yQ=AK({opSnippet:mQ,packedOpSnippet:gQ,dtype:"bool",cpuKernelImpl:Hj}),bQ={kernelName:gn,backendName:"webgl",kernelFunc:yQ};function wQ(e){let{inputs:t,backend:n}=e,{input:r}=t;return DZ(r,!0,n)}var xQ={kernelName:bn,backendName:"webgl",kernelFunc:wQ},vQ="return float(!isnan(x) && !isinf(x));",kQ=EK({opSnippet:vQ,dtype:"bool"}),IQ={kernelName:xn,backendName:"webgl",kernelFunc:kQ},SQ="return float(isinf(x));",NQ=EK({opSnippet:SQ,dtype:"bool"}),TQ={kernelName:vn,backendName:"webgl",kernelFunc:NQ},_Q="return float(isnan(x));",CQ=EK({opSnippet:_Q,dtype:"bool"}),EQ={kernelName:kn,backendName:"webgl",kernelFunc:CQ},AQ="return float(a < b);",$Q="\n  return vec4(lessThan(a, b));\n",FQ=AK({opSnippet:AQ,packedOpSnippet:$Q,cpuKernelImpl:jj,dtype:"bool"}),RQ={kernelName:Sn,backendName:"webgl",kernelFunc:FQ},DQ="return float(a <= b);",MQ="\n  return vec4(lessThanEqual(a, b));\n",OQ=AK({opSnippet:DQ,packedOpSnippet:MQ,cpuKernelImpl:qj,dtype:"bool"}),LQ={kernelName:Nn,backendName:"webgl",kernelFunc:OQ};function PQ(e){let{backend:t,attrs:n}=e,{start:r,stop:a,num:s}=n,i=Kj(r,a,s);return t.makeTensorInfo([i.length],"float32",i)}var zQ={kernelName:Tn,backendName:"webgl",kernelFunc:PQ},BQ=TK+"\n  return x < 0.0 ? 0./0. : log(x);\n",WQ="\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",VQ=EK({opSnippet:BQ,packedOpSnippet:WQ,cpuKernelImpl:Xj}),UQ={kernelName:_n,backendName:"webgl",kernelFunc:VQ},GQ=TK+"\n  return log(1.0 + x);\n",HQ=EK({opSnippet:GQ}),jQ={kernelName:Cn,backendName:"webgl",kernelFunc:HQ},qQ="return float(a >= 1.0 && b >= 1.0);",KQ="\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",XQ=AK({opSnippet:qQ,packedOpSnippet:KQ,dtype:"bool"}),YQ={kernelName:En,backendName:"webgl",kernelFunc:XQ},JQ="return float(!(x >= 1.0));",ZQ=EK({opSnippet:JQ}),QQ={kernelName:An,backendName:"webgl",kernelFunc:ZQ},e0="return float(a >= 1.0 || b >= 1.0);",t0="\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",n0=AK({opSnippet:e0,packedOpSnippet:t0,dtype:"bool"}),r0={kernelName:$n,backendName:"webgl",kernelFunc:n0},a0=class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[];let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;o=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${s}; j <= ${s}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}},s0=class{constructor(e,t,n,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let s=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;o=.5===a?`inversesqrt(${l})`:1===a?`1.0/(${l})`:`exp(log(${l}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${s};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${s}; j <= ${s}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}},i0=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{depthRadius:s,bias:i,alpha:o,beta:l}=r,u=Xe().getBool("WEBGL_PACK_NORMALIZATION")?new s0(a.shape,s,i,o,l):new a0(a.shape,s,i,o,l);return n.runWebGLProgram(u,[a],a.dtype)},o0={kernelName:Dn,backendName:"webgl",kernelFunc:i0},l0=class{constructor(e,t,n,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=a,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${a})\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${a});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}},u0=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a,y:s,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r,p=new l0(a.shape,o,l,u,c);return n.runWebGLProgram(p,[a,s,i],a.dtype)},c0={kernelName:Mn,backendName:"webgl",kernelFunc:u0};function p0(e,t,n,r){let a=Na.sizeFromShape(t),s=Na.sizeFromShape(e.shape)/a,i=zK({inputs:{x:e},attrs:{shape:[s,a]},backend:r}),o=GK(i,e.dtype,"max",r),l=zK({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),l}function d0(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reductionIndices:s,keepDims:i}=r,o=a.shape.length,l=Na.parseAxisParam(s,a.shape),u=l,c=Aw.getAxesPermutation(u,o),p=null!=c,d=n.shouldExecuteOnCPU([a]),h=a;if(p){if(d){let e=n.texData.get(h.dataId).values,t=new Array(o);for(let n=0;n<t.length;n++)t[n]=a.shape[c[n]];let r=xq(e,a.shape,a.dtype,c,t);h=n.makeTensorInfo(t,a.dtype);let s=n.texData.get(h.dataId);s.values=r}else h=KK(a,c,n);u=Aw.getInnerMostAxes(u.length,o)}Aw.assertAxesAreInnerMostDims("max",u,o);let f,[m,g]=Aw.computeOutAndReduceShapes(h.shape,u),y=m;if(i&&(y=Aw.expandShapeToKeepDim(m,l)),d){let e=n.texData.get(h.dataId).values,t=Yj(e,Na.sizeFromShape(g),y,a.dtype);f=n.makeTensorInfo(y,a.dtype);let r=n.texData.get(f.dataId);r.values=t}else f=p0(h,g,y,n);return p&&n.disposeIntermediateTensorInfo(h),f}var h0={kernelName:On,backendName:"webgl",kernelFunc:d0},f0=cK+"\n  return max(a, b);\n",m0="\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  "+dK+"\n  return result;\n",g0=AK({opSnippet:f0,packedOpSnippet:m0,cpuKernelImpl:Jj}),y0={kernelName:Ln,backendName:"webgl",kernelFunc:g0};function b0(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t;KG(a,"maxPool");let{filterSize:s,strides:i,pad:o,dimRoundingMode:l}=r,u=1;Na.assert(Aw.eitherStridesOrDilationsAreOne(i,u),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`));let c=Aw.computePool2DInfo(a.shape,s,i,u,o,l);if(1===c.filterWidth&&1===c.filterHeight&&Na.arraysEqual(c.inShape,c.outShape))return fK({inputs:{x:a},backend:n});let p=new XX(c,"max",!1);return n.runWebGLProgram(p,[a],a.dtype)}var w0={kernelName:Pn,backendName:"webgl",kernelFunc:b0};function x0(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{filterSize:s,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=r,c=[1,1,1],p=Aw.computePool3DInfo(a.shape,s,i,c,o,u,l),d=new YX(p,"max",!1);return n.runWebGLProgram(d,[a],a.dtype)}var v0={kernelName:Bn,backendName:"webgl",kernelFunc:x0},k0=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,s=e.effectiveFilterWidth,i=a-1-e.padInfo.top,o=s-1-e.padInfo.left,l=a*s-1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${a};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${s} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}},I0=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,s=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=o-1-e.padInfo.front,p=l-1-e.padInfo.top,d=u-1-e.padInfo.left,h=o*l*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${p}, ${d});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${a}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${s}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${i}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${h} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}};function S0(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s}=t,i=s,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,p=[1,1,1],d=Aw.computePool3DInfo(i.shape,o,l,p,u,c),h=new YX(d,"max",!0),f=n.runWebGLProgram(h,[i],i.dtype),m=new I0(d),g=n.runWebGLProgram(m,[a,f],i.dtype);return n.disposeIntermediateTensorInfo(f),g}var N0={kernelName:Wn,backendName:"webgl",kernelFunc:S0};function T0(e){let{inputs:t,backend:n,attrs:r}=e,{dy:a,input:s,output:i}=t,o=s;KG([s,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:p}=r,d=Aw.computePool2DInfo(o.shape,l,u,1,c,p),h=!0,f=new XX(d,"max",h),m=n.runWebGLProgram(f,[o],o.dtype),g=new k0(d),y=n.runWebGLProgram(g,[a,m],o.dtype);return n.disposeIntermediateTensorInfo(m),y}var _0={kernelName:zn,backendName:"webgl",kernelFunc:T0};function C0(e,t,n,r){let a=new XX(n,"max",!1),s=r.runWebGLProgram(a,[e],"float32");a=new XX(n,"max",!0,!0,t);let i=r.runWebGLProgram(a,[e],"float32");return[s,i]}var E0={kernelName:Vn,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:a,strides:s,pad:i,includeBatchInIndex:o}=t,l=n;Na.assert(4===r.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`));let u=[1,1];Na.assert(Aw.eitherStridesOrDilationsAreOne(s,u),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${u}'`));let c=Aw.computePool2DInfo(r.shape,a,s,u,i),[p,d]=C0(r,o,c,l);return[p,d]}};function A0(e,t,n,r){let a=Na.sizeFromShape(t),s=Na.sizeFromShape(e.shape)/a,i=zK({inputs:{x:e},attrs:{shape:[s,a]},backend:r}),o=GK(i,"float32","mean",r),l=zK({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),l}var $0={kernelName:Un,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{keepDims:a,axis:s}=t,i=n,o=r.shape.length,l=Na.parseAxisParam(s,r.shape),u=l,c=Aw.getAxesPermutation(u,o),p=null!=c,d=i.shouldExecuteOnCPU([r]),h=[],f=r;if(p){if(d){let e=i.texData.get(f.dataId).values,t=new Array(o);for(let s=0;s<t.length;s++)t[s]=r.shape[c[s]];let n=xq(e,r.shape,r.dtype,c,t);f=i.makeTensorInfo(t,r.dtype);let a=i.texData.get(f.dataId);a.values=n}else f=KK(r,c,i);h.push(f),u=Aw.getInnerMostAxes(u.length,o)}Aw.assertAxesAreInnerMostDims("sum",u,o);let[m,g]=Aw.computeOutAndReduceShapes(f.shape,u),y=m;a&&(y=Aw.expandShapeToKeepDim(m,l));let b=A0(f,g,y,i);for(let w of h)i.disposeIntermediateTensorInfo(w);return b}};function F0(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,keepDims:i}=r,o=a.shape.length,l=Na.parseAxisParam(s,a.shape),u=l,c=Aw.getAxesPermutation(u,o),p=a;null!=c&&(p=ZK({inputs:{x:a},backend:n,attrs:{perm:c}}),u=Aw.getInnerMostAxes(u.length,a.shape.length)),Aw.assertAxesAreInnerMostDims("min",u,o);let d,[h,f]=Aw.computeOutAndReduceShapes(p.shape,u),m=Na.sizeFromShape(f),g=zK({inputs:{x:p},backend:n,attrs:{shape:[-1,m]}}),y=GK(g,g.dtype,"min",n);if(i){let e=Aw.expandShapeToKeepDim(h,l);d=zK({inputs:{x:y},backend:n,attrs:{shape:e}})}else d=zK({inputs:{x:y},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(y),null!=c&&n.disposeIntermediateTensorInfo(p),d}var R0={kernelName:Gn,backendName:"webgl",kernelFunc:F0},D0=cK+"\n  return min(a, b);\n",M0="\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  "+dK+"\n  return result;\n",O0=AK({opSnippet:D0,packedOpSnippet:M0,cpuKernelImpl:Zj}),L0={kernelName:Hn,backendName:"webgl",kernelFunc:O0},P0=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=jH(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l="reflect"===n?0:1;this.userCode=1!==r?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${a} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${s};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}},z0=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=jH(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=Iq("rc",r),l=Iq("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,p="reflect"===n?0:1,d="";if(1===r){let e=`\n        ${a} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${p};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${p};\n        }\n        source -= start;\n      `;d=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n      `}else{let e=`\n        ${a} source = rc;\n        ${a} lt = ${a}(lessThan(source, start));\n        ${a} gte = ${a}(greaterThanEqual(source, end));\n        ${a} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${p}) +\n                gte * ((end - 1) * 2 - source + ${p});\n        source -= start;\n      `;d=`\n        ${a} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[r-2]} += 1;\n        if(${o[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${l.join()}), ${c});\n          ${o[r-1]} += 1;\n          if(${u}) {\n            ${e}\n            result[3] = getChannel(getX(${l.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `}},B0=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{paddings:a,mode:s}=n,i=Xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new z0(r.shape,a,s):new P0(r.shape,a,s);return t.runWebGLProgram(i,[r],r.dtype)},W0={kernelName:jn,backendName:"webgl",kernelFunc:B0},V0="if (b == 0.0) return NAN;\n  return mod(a, b);",U0="\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  "+dK+"\n  return result;\n",G0=AK({opSnippet:V0,packedOpSnippet:U0}),H0={kernelName:qn,backendName:"webgl",kernelFunc:G0},j0=class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}},q0="\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",K0="\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",X0=AK({opSnippet:q0,packedOpSnippet:K0,checkOutOfBounds:!0}),Y0={kernelName:Jt,backendName:"webgl",kernelFunc:X0},J0="return a - b;",Z0=AK({opSnippet:J0,packedOpSnippet:J0,supportsComplex:!0,cpuKernelImpl:yq}),Q0={kernelName:Kr,backendName:"webgl",kernelFunc:Z0};function e1(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{dim:s}=r,i=Na.parseAxisParam([s],a.shape),o=d0({inputs:{x:a},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=Aw.expandShapeToKeepDim(o.shape,i),u=zK({inputs:{x:o},backend:n,attrs:{shape:l}}),c=Z0({inputs:{a:a,b:u},backend:n}),p=TZ({inputs:{x:c},backend:n}),d=YK({inputs:{x:p},backend:n,attrs:{axis:i,keepDims:!1}}),h=zK({inputs:{x:d},backend:n,attrs:{shape:l}}),f=X0({inputs:{a:p,b:h},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),f}var t1={kernelName:Or,backendName:"webgl",kernelFunc:e1};function n1(e){let{inputs:t,backend:n,attrs:r}=e,{logits:a}=t,{numSamples:s,seed:i,normalized:o}=r,l=o?a:e1({inputs:{logits:a},backend:n,attrs:{dim:a.shape.length-1}}),u=l.shape[0],c=l.shape[1],p=new j0(u,c,s),d=[[i]],h=n.runWebGLProgram(p,[l],"int32",d);return o||n.disposeIntermediateTensorInfo(l),h}var r1={kernelName:Kn,backendName:"webgl",kernelFunc:n1},a1=Oq+"\n  return -x;\n",s1="\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n";function i1(e){let t,{inputs:n,backend:r}=e,{x:a}=n;if(r.shouldExecuteOnCPU([a])){let e=r.texData.get(a.dataId),[t,n]=eq(e.values,a.shape,a.dtype);return r.makeTensorInfo(n,a.dtype,t)}return t=Xe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Xq(a.shape,s1):new Mq(a.shape,a1),r.runWebGLProgram(t,[a],a.dtype)}var o1={kernelName:Yn,backendName:"webgl",kernelFunc:i1},l1=Fx.nonMaxSuppressionV3Impl;function u1(e){Aw.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(a.dataId),c=n.readSync(s.dataId),{selectedIndices:p}=l1(u,c,i,o,l);return n.makeTensorInfo([p.length],"int32",new Int32Array(p))}var c1={kernelName:Zn,backendName:"webgl",kernelFunc:u1},p1=Fx.nonMaxSuppressionV4Impl;function d1(e){Aw.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(a.dataId),p=n.readSync(s.dataId),{selectedIndices:d,validOutputs:h}=p1(c,p,i,o,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}var h1={kernelName:Qn,backendName:"webgl",kernelFunc:d1},f1=Fx.nonMaxSuppressionV5Impl;function m1(e){Aw.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:a,scores:s}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(a.dataId),p=n.readSync(s.dataId),d=i,h=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=f1(c,p,d,h,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var g1={kernelName:er,backendName:"webgl",kernelFunc:m1},y1=class{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}},b1=e=>{let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{depth:s,onValue:i,offValue:o}=r,l=Na.sizeFromShape(a.shape),u=new y1(l,s,i,o),c=zK({inputs:{x:a},backend:n,attrs:{shape:[l]}}),p=n.runWebGLProgram(u,[c],a.dtype);n.disposeIntermediateTensorInfo(c);let d=[...a.shape,s],h=zK({inputs:{x:p},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(p),h},w1={kernelName:nr,backendName:"webgl",kernelFunc:b1};function x1(e){let{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){let e=EY({inputs:{input:r},backend:n}),t=x1({inputs:{x:e},backend:n}),a=XY({inputs:{input:r},backend:n}),s=x1({inputs:{x:a},backend:n}),i=gK({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}return PZ({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}var v1={kernelName:sa,backendName:"webgl",kernelFunc:x1};function k1(e){let{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){let e=EY({inputs:{input:r},backend:n}),t=k1({inputs:{x:e},backend:n}),a=XY({inputs:{input:r},backend:n}),s=x1({inputs:{x:a},backend:n}),i=gK({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),i}return PZ({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}var I1={kernelName:tr,backendName:"webgl",kernelFunc:k1};function S1(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return CZ({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach((e=>{Na.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),Na.assert(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));let o=[],l=t.map((e=>{let t=CZ({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),u=QY({inputs:l,backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}var N1={kernelName:rr,backendName:"webgl",kernelFunc:S1},T1=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=jH(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${a} start = ${a}(${s});\n      ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${a} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${s};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}},_1=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));let r=e.length,a=jH(r),s=t.map((e=>e[0])).join(","),i=t.map(((t,n)=>t[0]+e[n])).join(","),o=Iq("rc",r),l=Iq("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,p=[`${a} rc = outputLoc;`,`${o[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${o[r-2]} += 1;\n       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;\n         if(${u}) {`],d=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",h="";for(let f=0,m=1===r?2:4;f<m;f++)h+=`\n        ${p[f]}\n        if (${d}) {\n          result[${f}] = float(value);\n        } else {\n          ${a} source = rc - start;\n          result[${f}] = getChannel(getX(${l.join()}), ${c});\n        }\n      `;h+=1===r?"} ":"}}",this.userCode=`\n      const ${a} start = ${a}(${s});\n      const ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}},C1=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{paddings:s,constantValue:i}=r;if(0===Na.sizeFromShape(a.shape)){let e=s.map(((e,t)=>e[0]+a.shape[t]+e[1]));return PZ({backend:n,attrs:{shape:e,value:i,dtype:a.dtype}})}let o=Xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new _1(a.shape,s,i):new T1(a.shape,s,i),l=[[i]];return n.runWebGLProgram(o,[a],a.dtype,l)},E1={kernelName:ar,backendName:"webgl",kernelFunc:C1},A1="\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",$1="\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  "+dK+"\n  return result;\n",F1=AK({opSnippet:A1,packedOpSnippet:$1}),R1={kernelName:ir,backendName:"webgl",kernelFunc:F1};function D1(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{axis:i,keepDims:o}=a,l=s.shape.length,u=[],c=Na.parseAxisParam(i,s.shape),p=c,d=Aw.getAxesPermutation(p,l),h=s;if(null!=d&&(h=ZK({inputs:{x:s},backend:r,attrs:{perm:d}}),p=Aw.getInnerMostAxes(p.length,l),u.push(h)),Aw.assertAxesAreInnerMostDims("prod",p,l),r.shouldExecuteOnCPU([h])){let e=r.texData.get(h.dataId).values,{outVals:n,outShape:a,outDtype:s}=nq(h.shape,h.dtype,e,p);t=r.makeTensorInfo(a,s,n)}else{let[e,n]=Aw.computeOutAndReduceShapes(h.shape,p),a=Na.sizeFromShape(n),i=zK({inputs:{x:h},backend:r,attrs:{shape:[-1,a]}}),o=Cs(s.dtype),l=GK(i,o,"prod",r);t=zK({inputs:{x:l},backend:r,attrs:{shape:e}}),u.push(i),u.push(l)}if(o){u.push(t);let e=Aw.expandShapeToKeepDim(t.shape,c);t=zK({inputs:{x:t},backend:r,attrs:{shape:e}})}return u.forEach((e=>r.disposeIntermediateTensorInfo(e))),t}var M1={kernelName:lr,backendName:"webgl",kernelFunc:D1},O1=e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:i}=n,o=rq(r,a,s,i);return t.makeTensorInfo([o.length],i,o)},L1={kernelName:ur,backendName:"webgl",kernelFunc:O1},P1="return 1.0 / x;",z1=EK({opSnippet:P1}),B1={kernelName:pr,backendName:"webgl",kernelFunc:z1},W1=Oq+"\n  return (x < 0.0) ? 0.0 : x;\n",V1="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",U1=EK({opSnippet:W1,packedOpSnippet:V1}),G1={kernelName:dr,backendName:"webgl",kernelFunc:U1},H1=Oq+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",j1="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",q1=EK({opSnippet:H1,packedOpSnippet:j1}),K1={kernelName:br,backendName:"webgl",kernelFunc:q1},X1=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u,c=[r&&t>1?i-1:i,r&&n>1?o-1:o],p=[r&&t>1?t-1:t,r&&n>1?n-1:n];u=a?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/p[0]},\n          ${c[1]/p[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${u};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}},Y1=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u,c=[r&&t>1?i-1:i,r&&n>1?o-1:o],p=[r&&t>1?t-1:t,r&&n>1?n-1:n];u=a?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/p[0]},\n          ${c[1]/p[1]},\n          ${c[1]/p[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${u};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}};function J1(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,c=Xe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Y1(a.shape,l,u,s,i):new X1(a.shape,l,u,s,i);return n.runWebGLProgram(c,[a],"float32")}var Z1={kernelName:gr,backendName:"webgl",kernelFunc:J1},Q1=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],p=1/u,d=1/c,h=2*Math.ceil(p)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${p});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}};function e2(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new Q1(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}var t2={kernelName:yr,backendName:"webgl",kernelFunc:e2},n2=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u,c=[r&&t>1?i-1:i,r&&n>1?o-1:o],p=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";u=a?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/p[0]},\n          ${c[1]/p[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${u};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}},r2=class{constructor(e,t,n,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[s,i,o,l]=e;this.outputShape=[s,t,n,l];let u,c=[r&&t>1?i-1:i,r&&n>1?o-1:o],p=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";u=a?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/p[0]},\n          ${c[1]/p[1]},\n          ${c[1]/p[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${u};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}};function a2(e){let{inputs:t,backend:n,attrs:r}=e,{images:a}=t,{alignCorners:s,halfPixelCenters:i,size:o}=r,[l,u]=o,c=Xe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new r2(a.shape,l,u,s,i):new n2(a.shape,l,u,s,i);return n.runWebGLProgram(c,[a],a.dtype)}var s2={kernelName:fr,backendName:"webgl",kernelFunc:a2},i2=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,a]=t,[,s,i]=e,o=[n&&s>1?r-1:r,n&&i>1?a-1:a],l=[n&&s>1?s-1:s,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],p=1/u,d=1/c,h=2*Math.ceil(p)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${p});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${h});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${s}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${a}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}};function o2(e){let{inputs:t,backend:n,attrs:r}=e,{images:a,dy:s}=t,{alignCorners:i}=r,o=new i2(s.shape,a.shape,i);return n.runWebGLProgram(o,[s],s.dtype)}var l2={kernelName:mr,backendName:"webgl",kernelFunc:o2},u2=class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);let r=n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`,a=e.map(((e,t)=>r(t))).join(","),s=jH(n);this.userCode=`\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}},c2=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let r=Iq("rc",n),a=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,s=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=jH(n);function o(e){return p(e)}function l(e){return e[n-1]="("+e[n-1]+" + 1)",p(e)}function u(e){return e[n-2]="("+e[n-2]+" + 1)",p(e)}function c(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",p(e)}function p(t){let n=e.map(((e,n)=>d(n,t))),r=n.join(","),a=n.slice(-2).join(",");return`getChannel(getX(${r}), vec2(${a}))`}function d(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${a}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${o(r.slice())};\n          if(${a}){\n            result.g = ${l(r.slice())};\n          }\n          if(${s}) {\n            result.b = ${u(r.slice())};\n            if(${a}) {\n              result.a = ${c(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}};function p2(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,i=a.shape.length,o=Na.parseAxisParam(s,a.shape);if(0===i)return fK({inputs:{x:a},backend:n});let l=Xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new c2(a.shape,o):new u2(a.shape,o);return n.runWebGLProgram(l,[a],a.dtype)}var d2={kernelName:wr,backendName:"webgl",kernelFunc:p2},h2=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],r=e[2];this.outputShape=e;let a="";a="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${a}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}},f2={kernelName:la,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:a,fillValue:s,center:i}=t,o=n,l=new h2(r.shape,s),[u,c]=Aw.getImageCenter(i,r.shape[1],r.shape[2]),p=[[u,c,Math.sin(a),Math.cos(a)]];return o.runWebGLProgram(l,[r],r.dtype,p)}},m2="\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n",g2=EK({opSnippet:m2}),y2={kernelName:xr,backendName:"webgl",kernelFunc:g2},b2="return inversesqrt(x);",w2=EK({opSnippet:b2,cpuKernelImpl:aq}),x2={kernelName:vr,backendName:"webgl",kernelFunc:w2},v2=class{constructor(e,t,n,r,a,s,i=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;let o=jH(a.length),l=jH(s.length),u="";1===n?u="i":2===n&&(u="i, j");let c=`getIndices(${u})`,p="";1===r?p="i":2===r&&(p="i, coords[1]");let d=`getUpdates(${p})`,h=t>1?"strides[j]":"strides";this.userCode=`\n        ${o} strides = ${o}(${a});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${h};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${d};\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      `}};function k2(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a,updates:s}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:p}=Aw.calculateShapes(s,a,i),d=[p/u,u];if(0===p)return n.makeTensorInfo(i,a.dtype);let h=zK({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),f=zK({inputs:{x:s},backend:n,attrs:{shape:[l,u]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),g=new v2(l,o,h.shape.length,f.shape.length,c,d),y=n.runWebGLProgram(g,[f,h,m],f.dtype),b=zK({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),b}var I2={kernelName:kr,backendName:"webgl",kernelFunc:k2},S2=class{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];let a="while (left < right) {",s=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=2===Xe().getNumber("WEBGL_VERSION")?a:s,o="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${i}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${o} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}};function N2(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:a,values:s}=t,{side:i}=r,o=new S2(a.shape[0],a.shape[1],s.shape[1],i),l=[[a.shape[1]]];return n.runWebGLProgram(o,[a,s],"int32",l)}var T2={kernelName:Ir,backendName:"webgl",kernelFunc:N2},_2=class{constructor(e,t,n){let r,a;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)a="resRC",r="resRC";else{let n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],i=[];for(let r=0;r<t.length;r++)i.push(`${n[r]}`),r<e&&s.push(`${n[r]}`);r=s.join(),a=i.join()}let s=jH(n);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${a}));\n        } else {\n          setOutput(getB(${a}));\n        }\n      }\n    `}};function C2(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,i=new _2(r.shape.length,a.shape,a.shape.length);return n.runWebGLProgram(i,[r,a,s],_s(a.dtype,s.dtype))}var E2={kernelName:Sr,backendName:"webgl",kernelFunc:C2},A2=`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${Aw.SELU_SCALEALPHA};\n  float scale = ${Aw.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`,$2=EK({opSnippet:A2}),F2={kernelName:Nr,backendName:"webgl",kernelFunc:$2},R2=TK+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",D2="\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",M2=EK({opSnippet:R2,packedOpSnippet:D2,cpuKernelImpl:iq}),O2={kernelName:Ar,backendName:"webgl",kernelFunc:M2},L2="\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n",P2=EK({opSnippet:L2}),z2={kernelName:Er,backendName:"webgl",kernelFunc:P2},B2=TK+"\n  return sin(x);\n",W2=EK({opSnippet:B2}),V2={kernelName:_r,backendName:"webgl",kernelFunc:W2},U2="\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n",G2=EK({opSnippet:U2}),H2={kernelName:Cr,backendName:"webgl",kernelFunc:G2},j2="\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n",q2=EK({opSnippet:j2}),K2={kernelName:$r,backendName:"webgl",kernelFunc:q2},X2=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r;Na.assert(a.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));let o=s.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...i);for(let y=1+s.length;y<a.shape.length;++y)l.push([0,0]);let u=[],c=C1({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),p=Aw.getReshaped(c.shape,s,o,!1),d=Aw.getPermuted(p.length,s.length,!1),h=Aw.getReshapedPermuted(c.shape,s,o,!1),f=zK({inputs:{x:c},backend:n,attrs:{shape:p}}),m=ZK({inputs:{x:f},backend:n,attrs:{perm:d}}),g=zK({inputs:{x:m},backend:n,attrs:{shape:h}});return u.push(c),u.push(f),u.push(m),u.forEach((e=>n.disposeIntermediateTensorInfo(e))),g},Y2={kernelName:Dr,backendName:"webgl",kernelFunc:X2};function J2(e){let{inputs:t,backend:n}=e,{indices:r,values:a,denseShape:s,defaultValue:i}=t;if(1!==s.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${s.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==a.shape.length)throw new Error(`Values must be a vector, saw:\n         ${a.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);let o=n.readSync(r.dataId),l=n.readSync(a.dataId),u=n.readSync(s.dataId),c=n.readSync(i.dataId)[0],[p,d,h,f,m]=uq(o,r.shape,r.dtype,l,a.dtype,u,c);return[n.makeTensorInfo(d,r.dtype,p),n.makeTensorInfo([d[0]],a.dtype,h),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}var Z2={kernelName:Lr,backendName:"webgl",kernelFunc:J2};function Q2(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:a,newShape:s}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(n.readSync(a.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(s.dataId)),[u,c,p]=cq(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([p.length],s.dtype,new Int32Array(p))]}var e3={kernelName:Pr,backendName:"webgl",kernelFunc:Q2};function t3(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${s.shape}`);let i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,c]=pq(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}var n3={kernelName:zr,backendName:"webgl",kernelFunc:t3};function r3(e){let{inputs:t,backend:n}=e,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${a.shape}`);if(1!==s.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${s.shape}`);let i=n.readSync(r.dataId),o=n.readSync(a.dataId),l=n.readSync(s.dataId),[u,c]=pq(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}var a3={kernelName:Br,backendName:"webgl",kernelFunc:r3};function s3(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:a,sparseValues:s,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:p,outputSize:d}=Aw.calculateShapes(s,a,o),h=!1;if("string"===s.dtype){let e=n.bufferSync(a),t=n.bufferSync(s),r=Na.decodeString(n.readSync(i.dataId)[0]),f=sq(e,t,o,d,c,u,l,p,r,h);return n.makeTensorInfo(o,f.dtype,f.values)}let f=new v2(u,l,a.shape.length,s.shape.length,p,[d,1],h),m=n.runWebGLProgram(f,[s,a,i],s.dtype),g=zK({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}var i3={kernelName:Wr,backendName:"webgl",kernelFunc:s3};function o3(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=r,o=Na.parseAxisParam(i,a.shape)[0],l=Aw.prepareSplitSize(a,s,o),u=a.shape.length,c=new Array(u).fill(0),p=a.shape.slice();return l.map((e=>{let t=[...p];t[o]=e;let r=bY({inputs:{x:a},backend:n,attrs:{begin:c,size:t}});return c[o]+=e,r}))}var l3={kernelName:Mr,backendName:"webgl",kernelFunc:o3},u3="return sqrt(x);",c3=EK({opSnippet:u3,packedOpSnippet:u3,cpuKernelImpl:dq}),p3={kernelName:Fr,backendName:"webgl",kernelFunc:c3},d3="return x * x;",h3=EK({opSnippet:d3}),f3={kernelName:Ur,backendName:"webgl",kernelFunc:h3},m3="return (a - b) * (a - b);",g3=AK({opSnippet:m3,packedOpSnippet:m3}),y3={kernelName:Vr,backendName:"webgl",kernelFunc:g3};function b3({inputs:e,attrs:t,backend:n}){let{x:r}=e,a=Oq+`\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `,s=new Mq(r.shape,a);return n.runWebGLProgram(s,[r],r.dtype)}var w3={kernelName:ia,backendName:"webgl",kernelFunc:b3},x3=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;let r=n.length,a=jH(n.length),s=jH(n.length),i="";if(1===r)i="coords * strides + begin";else{let e=0;i=n.map(((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`))).join(",")}this.userCode=`\n      ${a} begin = ${a}(${e});\n      ${a} strides = ${a}(${t});\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}};function v3(e){let t,{inputs:n,backend:r,attrs:a}=e,{x:s}=n,{begin:i,end:o,strides:l,beginMask:u,endMask:c,ellipsisMask:p,newAxisMask:d,shrinkAxisMask:h}=a,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:w,end:x,strides:v}=Ql.sliceInfo(s.shape,i,o,l,u,c,p,d,h);if(g)t=zK({inputs:{x:s},backend:r,attrs:{shape:m}});else if(y||b){Na.assert(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));let e=Ql.computeOutShape(w,x,v),n=bY({inputs:{x:s},backend:r,attrs:{begin:w,size:e}});t=zK({inputs:{x:n},backend:r,attrs:{shape:m}}),r.disposeIntermediateTensorInfo(n)}else if(r.shouldExecuteOnCPU([s])){let e=r.readSync(s.dataId),n=fo(s.shape,s.dtype,e),a=hq(f,n,v,w);t=r.makeTensorInfo(m,s.dtype,a.values)}else{let e=new x3(w,v,f);t=r.runWebGLProgram(e,[s],s.dtype)}let k=zK({inputs:{x:t},backend:r,attrs:{shape:m}});return r.disposeIntermediateTensorInfo(t),k}var k3={kernelName:Gr,backendName:"webgl",kernelFunc:v3};function I3(e){let{inputs:t,backend:n,attrs:r}=e,{separator:a,nGramWidths:s,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:p}=t,d=n.readSync(c.dataId),h=n.readSync(p.dataId),[f,m]=fq(d,h,a,s,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(p.shape,"int32",m)]}var S3={kernelName:Hr,backendName:"webgl",kernelFunc:I3};function N3(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:a}=r,{input:s,delimiter:i}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.readSync(s.dataId),l=n.readSync(i.dataId)[0],[u,c,p]=mq(o,l,a),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(p))]}var T3={kernelName:jr,backendName:"webgl",kernelFunc:N3};function _3(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:a}=r,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");let i=n.readSync(s.dataId),o=gq(i,a);return n.makeTensorInfo(s.shape,"int32",o)}var C3={kernelName:qr,backendName:"webgl",kernelFunc:_3},E3="return tan(x);",A3=EK({opSnippet:E3}),$3={kernelName:Xr,backendName:"webgl",kernelFunc:A3},F3="\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n",R3=EK({opSnippet:F3}),D3={kernelName:Yr,backendName:"webgl",kernelFunc:R3},M3=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[s]*t[s];this.outputShape=n,this.rank=n.length;let r=jH(this.rank),a=O3(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${a}));\n      }\n    `}};function O3(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let a=0;a<e.length;a++)r.push(`imod(${n[a]}, ${e[a]})`);return r.join()}function L3(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{reps:s}=r;if("string"===a.dtype||a.shape.length>5){let e=n.readSync(a.dataId),t="string"===a.dtype?e.map((e=>Na.decodeString(e))):e,r=fo(a.shape,a.dtype,t),i=bq(r,s);return n.makeTensorInfo(i.shape,i.dtype,i.values)}let i=new M3(a.shape,s);return n.runWebGLProgram(i,[a],a.dtype)}var P3={kernelName:Jr,backendName:"webgl",kernelFunc:L3},z3=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}},B3=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}};function W3(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function V3(e){let t=1;for(;t<e;)t*=2;return t}function U3(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{k:s,sorted:i}=r,o=Xe().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Xe().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=a.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([a])||c<o||s>l){let e=n.readSync(a.dataId),[t,r]=wq(e,u,a.dtype,s,i);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===s)return u[u.length-1]=0,[n.makeTensorInfo(u,a.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===c)return[a,PZ({attrs:{shape:u,dtype:"int32",value:0},backend:n})];let p=n.texData.get(a.dataId),d=null!==p&&p.isPacked,h=d?n.unpackTensor(a):a,f=Na.sizeFromShape(u)/c,m=zK({inputs:{x:h},attrs:{shape:[f,c]},backend:n});d&&W3(n,h);let g=V3(s),y=V3(c),b=null,w=()=>null===b?[m,m]:[m,b],x=(e,t,r)=>{let a=w(),s=new z3(r),i=[[c],[null===b?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],o=b;b=n.runWebGLProgram(s,a,"int32",i),W3(n,o)};for(let N=1;N<g;N*=2){let e=2*N;for(let t=N;t>=1;t/=2)x(e,t,[f,y])}for(let N=y;N>g;N/=2){let e=w(),t=new B3([f,N/2]),r=[[c],[null===b?1:0],[g]],a=b;b=n.runWebGLProgram(t,e,"int32",r),W3(n,a);let s=g/2,i=2*s;for(let n=s;n>=1;n/=2)x(i,n,b.shape)}let v=b;b=bY({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,s]}}),W3(n,v);let k=uQ({inputs:{x:m,indices:b},backend:n,attrs:{axis:1,batchDims:1}});W3(n,m);let I=u.slice(0,-1);I.push(s),v=b,b=zK({inputs:{x:b},attrs:{shape:I},backend:n}),W3(n,v);let S=k;return k=zK({inputs:{x:k},attrs:{shape:I},backend:n}),W3(n,S),[k,b]}var G3={kernelName:Zr,backendName:"webgl",kernelFunc:U3},H3=class{constructor(e,t,n,r,a,s){this.variableNames=["Image","Transforms"],this.outputShape=s;let i,o="nearest"===n?1:2;switch(r){case"constant":i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4;break;default:i=1;break}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${i} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${i} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${a});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${a});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${o} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}};function j3(e){let{inputs:t,backend:n,attrs:r}=e,{image:a,transforms:s}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[c,p,d,h]=a.shape,[f,m]=null!=u?u:[p,d],g=[c,f,m,h],y=new H3(p,d,i,o,l,g);return n.runWebGLProgram(y,[a,s],"float32")}var q3={kernelName:Qr,backendName:"webgl",kernelFunc:j3};function K3(e){let{inputs:t,attrs:n,backend:r}=e,{axis:a}=n,{x:s}=t;KG(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=r.readSync(s.dataId),{outputValues:o,outputShape:l,indices:u}=vq(i,a,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}var X3={kernelName:ta,backendName:"webgl",kernelFunc:K3};function Y3(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a,o=i.shape.length,l=a.shape[s],u=new Array(o-1),c=0;for(let m=0;m<o;m++)m!==s&&(u[c++]=i.shape[m]);let p=[],d=new Array(o).fill(0),h=i.shape.slice();h[s]=1;let f=new Array(l);for(let m=0;m<f.length;m++){d[s]=m;let e=bY({inputs:{x:i},backend:n,attrs:{begin:d,size:h}}),t=zK({inputs:{x:e},backend:n,attrs:{shape:u}});f[m]=t,p.push(e)}return p.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}var J3={kernelName:na,backendName:"webgl",kernelFunc:Y3},Z3=class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,r=e.batchSize,a=e.inSize,s=e.numSegments,i=s*Math.ceil(a/n);this.outputShape=[r,i];let o="0.0",l="sumValue",u=4*Math.floor(n/4),c=n%4,p="\n        sumValue += dot(values, segFilter);\n    ",d="";a%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `);let h="";a%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${o};\n\n      float getValue(int batch, int inIdx) {\n        ${d}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${s})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${s})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${p}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${p}\n        } else if (${2===c}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${p}\n        } else if (${3===c}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${p}\n        }\n        setOutput(${l});\n      }\n    `}};function Q3(e){let{inputs:t,backend:n,attrs:r}=e,{x:a,segmentIds:s}=t,{numSegments:i}=r,o=a.shape.length,l=[],u=0,c=Aw.getAxesPermutation([u],o),p=a;null!=c&&(p=ZK({inputs:{x:a},backend:n,attrs:{perm:c}}),l.push(p),u=Aw.getInnerMostAxes(1,o)[0]);let d=Aw.segment_util.computeOutShape(p.shape,u,i),h=Na.sizeFromShape([p.shape[u]]),f=zK({inputs:{x:p},backend:n,attrs:{shape:[-1,h]}});l.push(f);let m=Cs(a.dtype),g=(e,t,r,a,s)=>{let i=e.shape[0],o=e.shape[1],u=Aw.segment_util.segOpComputeOptimalWindowSize(o,s),c={windowSize:u,inSize:o,batchSize:i,numSegments:s},p=new Z3(c,t),d=n.compileAndRun(p,[e,r],a);if(l.push(d),d.shape[1]===s)return d;let h=O1({backend:n,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),f=L3({inputs:{x:h},backend:n,attrs:{reps:[o/u]}});return l.push(h),l.push(f),g(d,t,f,a,s)},y=g(f,"unsortedSegmentSum",s,m,i),b=zK({inputs:{x:y},backend:n,attrs:{shape:d}}),w=b;if(null!=c){l.push(b);let e=Aw.getUndoAxesPermutation(c);w=ZK({inputs:{x:w},backend:n,attrs:{perm:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),w}var e4,t4,n4,r4={kernelName:ra,backendName:"webgl",kernelFunc:Q3},a4=[rX,iX,uX,dX,mX,wX,vX,IX,AX,FX,MX,PX,WX,HX,KX,ZX,eY,aY,iY,lY,dY,vY,IY,NY,DY,LY,WY,yK,HY,eJ,oJ,hJ,mJ,yJ,wJ,kJ,NJ,CJ,$J,LJ,zJ,WJ,GJ,KJ,ZJ,eZ,rZ,iZ,lZ,dZ,gZ,xZ,IZ,_Z,EZ,FZ,OZ,BZ,VZ,HZ,XZ,ZZ,tQ,rQ,iQ,cQ,fQ,bQ,mK,xQ,YY,IQ,TQ,EQ,vK,RQ,LQ,zQ,UQ,jQ,YQ,QQ,r0,o0,c0,h0,y0,w0,v0,N0,_0,E0,$0,R0,L0,W0,H0,r1,LK,o1,c1,h1,g1,CY,w1,I1,N1,E1,R1,NK,M1,L1,AY,Y0,B1,G1,K1,BK,Z1,t2,s2,l2,d2,f2,y2,x2,I2,T2,E2,F2,O2,z2,V2,H2,wY,t1,K2,Y2,Z2,e3,n3,a3,i3,l3,p3,f3,y3,w3,k3,S3,T3,C3,Q0,JK,$3,D3,P3,G3,q3,QK,X3,J3,r4,v1];for(let Jre of a4)wa(Jre);function s4(e){n4=e.wasm.cwrap(ua,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function i4(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s,bias:i,preluActivationWeights:o}=t;if("float32"!==a.dtype||"float32"!==s.dtype)throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:p}=r,d=n.dataIdMap.get(a.dataId).id,h=n.dataIdMap.get(s.dataId).id,f=0;if(null!=i){let e=n.dataIdMap.get(i.dataId);if(1!==e.shape.length)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${e.shape.length}.`);f=e.id}let m=null==o?0:n.dataIdMap.get(o.dataId).id,g=t4[c];if(null==g)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);let y=l?a.shape[2]:a.shape[1],b=u?s.shape[1]:s.shape[2],w=Fl.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)),x=n.makeOutput([...w,y,b],a.dtype),v=n.dataIdMap.get(x.dataId).id,k=new Uint8Array(new Int32Array(a.shape).buffer),I=new Uint8Array(new Int32Array(s.shape).buffer);return n4(d,k,a.shape.length,h,I,s.shape.length,l,u,g,f,m,p||0,v),x}(function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"})(e4||(e4={})),function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"}(t4||(t4={}));var o4={kernelName:ua,backendName:"wasm",setupFunc:s4,kernelFunc:i4};function l4(e,t){let n;function r(t){n=t.wasm.cwrap(e,null,["number","number","number"])}function a(e){let{backend:r,inputs:{x:a}}=e,s=r.dataIdMap.get(a.dataId).id,i=r.makeOutput(a.shape,t||a.dtype),o=r.dataIdMap.get(i.dataId).id;return 0===Na.sizeFromShape(i.shape)||n(s,e4[a.dtype],o),i}return{kernelName:e,backendName:"wasm",setupFunc:r,kernelFunc:a}}var u4=l4(nt);function c4(e,t,n){let r;function a(t){r=t.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])}function s(e){let{backend:t,inputs:a}=e,{a:s,b:i}=a,o=t.dataIdMap.get(s.dataId).id,l=t.dataIdMap.get(i.dataId).id,u=null!=n?n:s.dtype,c=Aw.assertAndGetBroadcastShape(s.shape,i.shape),p=t.makeOutput(c,u);if(0===Na.sizeFromShape(c))return p;let d=new Uint8Array(new Int32Array(s.shape).buffer),h=new Uint8Array(new Int32Array(i.shape).buffer),f=t.dataIdMap.get(p.dataId).id;return r(o,d,s.shape.length,l,h,i.shape.length,e4[s.dtype],f),p}return{kernelName:e,backendName:"wasm",setupFunc:a,kernelFunc:s}}var p4,d4=!0,h4=c4(st,d4);function f4(e){p4=e.wasm.cwrap(it,null,["array","number","number","number"])}function m4(e){let{inputs:t,backend:n}=e,r=n.makeOutput(t[0].shape,t[0].dtype);if(0===Na.sizeFromShape(r.shape))return r;let a=t.map((e=>n.dataIdMap.get(e.dataId).id)),s=new Uint8Array(new Int32Array(a).buffer),i=n.dataIdMap.get(r.dataId).id;return p4(s,a.length,e4[r.dtype],i),r}var g4={kernelName:it,backendName:"wasm",setupFunc:f4,kernelFunc:m4};function y4(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype),a=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(r).set(a),r}var b4,w4={kernelName:yn,backendName:"wasm",kernelFunc:y4};function x4(e){b4=e.wasm.cwrap(ea,null,["number","array","number","number","number","array","number"])}function v4(e){let{inputs:t,backend:n,attrs:r}=e,[a,s]=I4(t.x.shape,r.perm),i=!0;for(let f=0;f<s.length;f++)s[f]!==f&&(i=!1);let o=k4(t.x.shape,r.perm),l={dataId:t.x.dataId,shape:a,dtype:t.x.dtype};if(i){let e=y4({inputs:t,backend:n});return e.shape=o,e}let u=n.makeOutput(o,l.dtype),c=n.dataIdMap.get(l.dataId).id,p=n.dataIdMap.get(u.dataId).id,d=new Uint8Array(new Int32Array(s).buffer),h=new Uint8Array(new Int32Array(l.shape).buffer);return b4(c,h,l.shape.length,e4[l.dtype],p,d,s.length),u}function k4(e,t){let n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];return n}function I4(e,t){let n=[],r=[];for(let a=0;a<e.length;++a)1!==e[a]&&n.push(e[a]),1!==e[t[a]]&&r.push(t[a]);for(let a=0;a<r.length;++a){let e=-1;for(let t=0;t<r.length;++t)r[t]>=a&&(-1===e||r[e]>r[t])&&(e=t);r[e]=a}return[n,r]}var S4,N4={kernelName:ea,backendName:"wasm",kernelFunc:v4,setupFunc:x4};function T4(e,t,n){let r=e.shape,a=e.shape.length,s=Na.parseAxisParam(t,r),i=s,o=Aw.getAxesPermutation(i,a),l=null,u=!1;if(null!=o){let t=new Array(a);for(let e=0;e<t.length;e++)t[e]=r[o[e]];i=Aw.getInnerMostAxes(i.length,a),l=v4({inputs:{x:e},attrs:{perm:o},backend:n});let s=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(l.dataId).id!==s&&(u=!0)}return{transposed:l,originalAxes:s,axes:i,inputWasTransposed:u}}function _4(e){S4=e.wasm.cwrap(ot,null,["number, number, number"])}function C4(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:c,originalAxes:p,inputWasTransposed:d}=T4(i,a,t);if(d){let e=t.dataIdMap.get(u.dataId).id;l=u,o=e}let h=l.shape.length;Aw.assertAxesAreInnerMostDims("all",c,h);let[f,m]=Aw.computeOutAndReduceShapes(l.shape,c),g=Na.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(0!==Na.sizeFromShape(l.shape)){let e=t.dataIdMap.get(y.dataId).id;S4(o,g,e)}if(d&&t.disposeData(u.dataId),s){let e=Aw.expandShapeToKeepDim(y.shape,p);y.shape=e}return y}var E4,A4={kernelName:ot,backendName:"wasm",setupFunc:_4,kernelFunc:C4};function $4(e){E4=e.wasm.cwrap(lt,null,["number, number, number"])}function F4(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:c,originalAxes:p,inputWasTransposed:d}=T4(i,a,t);if(d){let e=t.dataIdMap.get(u.dataId).id;l=u,o=e}let h=l.shape.length;Aw.assertAxesAreInnerMostDims("any",c,h);let[f,m]=Aw.computeOutAndReduceShapes(l.shape,c),g=Na.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(0!==Na.sizeFromShape(l.shape)){let e=t.dataIdMap.get(y.dataId).id;E4(o,g,e)}if(d&&t.disposeData(u.dataId),s){let e=Aw.expandShapeToKeepDim(y.shape,p);y.shape=e}return y}var R4,D4={kernelName:lt,backendName:"wasm",setupFunc:$4,kernelFunc:F4};function M4(e){R4=e.wasm.cwrap(ut,null,["number","number","number","number","number"])}function O4(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a}=r,{x:s}=n,i=t.dataIdMap.get(s.dataId).id,o=i,l=s,{transposed:u,axes:c,inputWasTransposed:p}=T4(s,a,t);if(p){let e=t.dataIdMap.get(u.dataId).id;e!==i&&(l=u,o=e)}let d=l.shape.slice(0,-1),h=t.makeOutput(d,"int32"),f=t.dataIdMap.get(h.dataId).id,m=Na.sizeFromShape(h.shape),g=l.shape[c[0]];return R4(o,e4[l.dtype],m,g,f),p&&t.disposeData(u.dataId),h}var L4,P4={kernelName:ut,backendName:"wasm",kernelFunc:O4,setupFunc:M4};function z4(e){L4=e.wasm.cwrap(gt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function B4(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,s=r.dataIdMap.get(a.dataId).id,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,c=Aw.computePool2DInfo(a.shape,i,o,1,l,u),p=c.filterHeight,d=c.filterWidth,h=c.padInfo.top,f=c.padInfo.right,m=c.padInfo.bottom,g=c.padInfo.left,y=c.strideHeight,b=c.strideWidth,w=c.inChannels;if("channelsLast"!==c.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);if(1!==c.dilationWidth||1!==c.dilationHeight)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);let x=r.makeOutput(c.outShape,"float32"),v=r.dataIdMap.get(x.dataId).id;return L4(s,a.shape[0],a.shape[1],a.shape[2],p,d,h,f,m,g,y,b,w,v),x}var W4={kernelName:gt,backendName:"wasm",setupFunc:z4,kernelFunc:B4};function V4(e){let{inputs:t,attrs:n}=e,{x:r}=t,{shape:a}=n,s=Na.sizeFromShape(r.shape),i=Na.inferFromImplicitShape(a,s);return Na.assert(s===Na.sizeFromShape(i),(()=>`new shape: ${i}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`)),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:i,dtype:r.dtype}}var U4,G4={kernelName:hr,backendName:"wasm",kernelFunc:V4};function H4(e){U4=e.wasm.cwrap(xt,null,["number","array","number","number","array","number","number","number","number"])}function j4(e){let{inputs:t,backend:n,attrs:r}=e,{a:a,b:s}=t,{transposeA:i,transposeB:o}=r;if("float32"!==a.dtype||"float32"!==s.dtype)throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let l=a.shape.length,u=s.shape.length,c=i?a.shape[l-2]:a.shape[l-1],p=o?s.shape[u-1]:s.shape[u-2],d=i?a.shape[l-1]:a.shape[l-2],h=o?s.shape[u-2]:s.shape[u-1],f=a.shape.slice(0,-2),m=s.shape.slice(0,-2),g=Na.sizeFromShape(f),y=Na.sizeFromShape(m),b=Fl.assertAndGetBroadcastShape(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([d,h]);Na.assert(c===p,(()=>`Error in matMul: inner shapes (${c}) and (${p}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${i} and transposeB=${o} must match.`));let w=i?[g,c,d]:[g,d,c],x=o?[y,h,p]:[y,p,h],v=V4({inputs:{x:a},backend:n,attrs:{shape:w}}),k=V4({inputs:{x:s},backend:n,attrs:{shape:x}}),I=n.dataIdMap.get(v.dataId).id,S=n.dataIdMap.get(k.dataId).id,N=i?v.shape[2]:v.shape[1],T=o?k.shape[1]:k.shape[2],_=Math.max(g,y),C=n.makeOutput([_,N,T],v.dtype),E=n.dataIdMap.get(C.dataId).id,A=new Uint8Array(new Int32Array(v.shape).buffer),$=new Uint8Array(new Int32Array(k.shape).buffer);return U4(I,A,v.shape.length,S,$,k.shape.length,i,o,E),n.disposeData(v.dataId),n.disposeData(k.dataId),C.shape=b,C}var q4={kernelName:xt,backendName:"wasm",setupFunc:H4,kernelFunc:j4};function K4(e){let{inputs:{x:t},attrs:{begin:n,size:r},backend:a}=e,[s,i]=Ql.parseSliceParams(t,n,r),o=Ql.isSliceContinous(t.shape,s,i),l=a.readSync(t.dataId),u=a.makeOutput(i,t.dtype),c=Na.computeStrides(t.shape),p=a.dataIdMap.get(u.dataId);if(o){let e=Ql.computeFlatOffset(s,c);return"string"===t.dtype?p.stringBytes=l.slice(e,e+Na.sizeFromShape(i)):a.typedArrayFromHeap(u).set(l.subarray(e,e+Na.sizeFromShape(i))),u}if("string"===t.dtype){let e=wL(l,s,i,t.shape,t.dtype);return p.stringBytes=e,u}let d=a.typedArrayFromHeap(u),h=t.shape.length;if(2===h)X4(l,c[0],d,s,i);else if(3===h)Y4(l,c[0],c[1],d,s,i);else if(4===h)J4(l,c[0],c[1],c[2],d,s,i);else{let e=wL(l,s,i,t.shape,t.dtype);d.set(e)}return u}function X4(e,t,n,r,a){let s=0,i=r[0],o=r[1],l=i+a[0];for(let u=i;u<l;u++){let r=u*t+o;n.set(e.subarray(r,r+a[1]),s),s+=a[1]}}function Y4(e,t,n,r,a,s){let i=0,o=a[0],l=a[1],u=a[2],c=o+s[0],p=l+s[1];for(let d=o;d<c;d++)for(let a=l;a<p;a++){let o=d*t+a*n+u;r.set(e.subarray(o,o+s[2]),i),i+=s[2]}}function J4(e,t,n,r,a,s,i){let o=0,l=s[0],u=s[1],c=s[2],p=l+i[0],d=u+i[1],h=c+i[2],f=s[3];for(let m=l;m<p;m++)for(let s=u;s<d;s++)for(let l=c;l<h;l++){let u=m*t+s*n+l*r+f;a.set(e.subarray(u,u+i[3]),o),o+=i[3]}}var Z4={kernelName:Tr,backendName:"wasm",kernelFunc:K4};function Q4(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,crops:i}=r,o=s.reduce(((e,t)=>e*t)),l=Aw.getReshaped(a.shape,s,o),u=Aw.getPermuted(l.length,s.length),c=Aw.getReshapedPermuted(a.shape,s,o),p=Aw.getSliceBeginCoords(i,s.length),d=Aw.getSliceSize(c,i,s.length),h=V4({inputs:{x:a},backend:n,attrs:{shape:l}}),f=v4({inputs:{x:h},backend:n,attrs:{perm:u}}),m=V4({inputs:{x:f},backend:n,attrs:{shape:c}}),g=K4({inputs:{x:m},backend:n,attrs:{begin:p,size:d}});return n.disposeData(h.dataId),n.disposeData(f.dataId),n.disposeData(h.dataId),g}var e5={kernelName:vt,backendName:"wasm",kernelFunc:Q4};function t5(e){let{inputs:{x:t},attrs:{dtype:n},backend:r}=e,a=r.makeOutput(t.shape,n),s=r.typedArrayFromHeap(t);return r.typedArrayFromHeap(a).set(s),a}var n5,r5={kernelName:Nt,backendName:"wasm",kernelFunc:t5},a5=l4(Tt);function s5(e){n5=e.wasm.cwrap(_t,null,["number","number","number","number"])}function i5(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{clipValueMin:s,clipValueMax:i}=r,o=n.dataIdMap.get(a.dataId).id,l=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(l.dataId).id;return n5(o,s,i,u),l}var o5={kernelName:_t,backendName:"wasm",setupFunc:s5,kernelFunc:i5};function l5(e){let{inputs:t,backend:n}=e,r=Na.parseAxisParam(e.attrs.axis,t[0].shape)[0],a=Aw.computeOutShape(t.map((e=>e.shape)),r),s=t.filter((e=>Na.sizeFromShape(e.shape)>0));if(1===s.length)return y4({inputs:{x:s[0]},backend:n});let i=n.makeOutput(a,t[0].dtype);if(0===Na.sizeFromShape(a))return i;let o=s.map((e=>e.shape));if(Aw.assertParamsConsistent(o,r),"string"===s[0].dtype){let e=s.map((e=>{let t=Na.sizeFromShape(e.shape.slice(r));return V4({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),o=e.map((e=>({vals:n.readSync(e.dataId),shape:e.shape})));a=Aw.computeOutShape(e.map((e=>e.shape)),1);let l=1===e[0].shape[0],u=pO(o,a,t[0].dtype,l),c=Aw.computeOutShape(s.map((e=>e.shape)),r);i.shape=c;let p=n.dataIdMap.get(i.dataId);return p.stringBytes=Aw.fromStringArrayToUint8(u),e.forEach((e=>n.disposeData(e.dataId))),i}let l=Na.sizeFromShape(s[0].shape.slice(0,r)),u=0,c=s.map((e=>{let t=Na.sizeFromShape(e.shape.slice(r));return u+=t,t})),p=s.map((e=>n.typedArrayFromHeap(e))),d=n.typedArrayFromHeap(i);for(let h=0;h<l;h++){let e=h*u;for(let t=0;t<p.length;t++){let n=c[t],r=h*n,a=p[t].subarray(r,r+n);d.set(a,e),e+=n}}return i}var u5,c5={kernelName:At,backendName:"wasm",kernelFunc:l5};function p5(e){u5=e.wasm.cwrap($t,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function d5(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,i=r.dataIdMap.get(a.dataId).id,o=r.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:c,dimRoundingMode:p,dataFormat:d}=n,h=Aw.convertConv2DDataFormat(d),f=Aw.computeConv2DInfo(a.shape,s.shape,l,u,c,p,!1,h),m=f.filterHeight,g=f.filterWidth,y=f.padInfo.top,b=f.padInfo.right,w=f.padInfo.bottom,x=f.padInfo.left,v=f.dilationHeight,k=f.dilationWidth,I=f.strideHeight,S=f.strideWidth,N=f.inChannels,T=f.outChannels,_="SAME"===f.padInfo.type?1:0;if("channelsLast"!==f.dataFormat)throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let C=r.makeOutput(f.outShape,"float32"),E=r.dataIdMap.get(C.dataId).id;return u5(i,a.shape[0],a.shape[1],a.shape[2],o,m,g,y,b,w,x,_,v,k,I,S,N,T,E),C}var h5,f5={kernelName:$t,backendName:"wasm",setupFunc:p5,kernelFunc:d5};function m5(e){h5=e.wasm.cwrap(Rt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function g5(e){let{backend:t,inputs:n,attrs:r}=e,{dy:a,filter:s}=n,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,inputShape:c}=r,p=1,d=Aw.convertConv2DDataFormat(l),h=Aw.computeConv2DInfo(c,s.shape,i,p,o,u,!1,d),{batchSize:f,filterHeight:m,filterWidth:g,inChannels:y,inHeight:b,inWidth:w,outChannels:x,outHeight:v,outWidth:k,strideHeight:I,strideWidth:S}=h,N=m-1-h.padInfo.top,T=g-1-h.padInfo.left,_="channelsLast"===h.dataFormat,C=Na.computeStrides(h.inShape),E=Na.computeStrides(a.shape),[A,$,F]=Na.computeStrides(s.shape),R=C[0],D=_?C[1]:C[2],M=_?C[2]:1,O=_?1:C[1],L=E[0],P=_?E[1]:E[2],z=_?E[2]:1,B=_?1:E[1],W=t.makeOutput(h.inShape,"float32"),V=t.dataIdMap.get(W.dataId).id,U=t.dataIdMap.get(a.dataId).id,G=t.dataIdMap.get(s.dataId).id;return h5(U,G,f,m,g,b,w,y,v,k,x,I,S,N,T,A,$,F,R,D,M,O,L,P,z,B,V),W}var y5,b5,w5={kernelName:Rt,backendName:"wasm",setupFunc:m5,kernelFunc:g5},x5=l4(Lt),v5=l4(Pt);function k5(e){b5=e.wasm.cwrap(Wt,null,["number","number","number","number","array","number","number","number","number","number"])}function I5(e){let t,{backend:n,inputs:r,attrs:a}=e,{method:s,extrapolationValue:i,cropSize:o}=a,{image:l,boxes:u,boxInd:c}=r,p=u.shape[0],[d,h]=o,f=[p,d,h,l.shape[3]],m=n.dataIdMap.get(l.dataId);"float32"!==l.dtype&&(t=t5({backend:n,inputs:{x:l},attrs:{dtype:"float32"}}),m=n.dataIdMap.get(t.dataId));let g=m.id,y=n.dataIdMap.get(u.dataId).id,b=n.dataIdMap.get(c.dataId).id,w=n.makeOutput(f,"float32"),x=n.dataIdMap.get(w.dataId).id,v=new Uint8Array(new Int32Array(l.shape).buffer);return b5(g,y,b,p,v,d,h,y5[s],i,x),null!=t&&n.disposeData(t.dataId),w}(function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"})(y5||(y5={}));var S5,N5={kernelName:Wt,backendName:"wasm",setupFunc:k5,kernelFunc:I5};function T5(e){S5=e.wasm.cwrap(zt,null,["number","number","number","number","number","number"])}function _5(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r,l=a.shape.length;Na.assert("float32"===a.dtype||"int32"===a.dtype,(()=>`cumprod does not support ${a.dtype} tensors in the WASM backend`));let u=Aw.getAxesPermutation([s],l),c=a;null!==u&&(c=v4({inputs:{x:a},attrs:{perm:u},backend:n}));let p=Aw.getInnerMostAxes(1,l)[0];Aw.assertAxesAreInnerMostDims("cumprod",[p],l);let d=n.makeOutput(c.shape,c.dtype),h=c.shape[p],f=n.dataIdMap.get(c.dataId).id,m=n.dataIdMap.get(d.dataId).id;S5(f,i?1:0,o?1:0,h,m,e4[a.dtype]);let g=d;if(null!==u){let e=Aw.getUndoAxesPermutation(u);g=v4({inputs:{x:d},attrs:{perm:e},backend:n}),n.disposeData(c.dataId),n.disposeData(d.dataId)}return g}var C5,E5={kernelName:zt,backendName:"wasm",setupFunc:T5,kernelFunc:_5};function A5(e){C5=e.wasm.cwrap(Bt,null,["number","number","number","number","number","number"])}function $5(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{axis:s,exclusive:i,reverse:o}=r,l=a.shape.length;Na.assert("float32"===a.dtype||"int32"===a.dtype,(()=>`cumsum does not support ${a.dtype} tensors in the WASM backend`));let u=Aw.getAxesPermutation([s],l),c=a;null!==u&&(c=v4({inputs:{x:a},attrs:{perm:u},backend:n}));let p=Aw.getInnerMostAxes(1,l)[0];Aw.assertAxesAreInnerMostDims("cumsum",[p],l);let d=n.makeOutput(c.shape,c.dtype),h=c.shape[p],f=n.dataIdMap.get(c.dataId).id,m=n.dataIdMap.get(d.dataId).id;C5(f,i?1:0,o?1:0,h,m,e4[a.dtype]);let g=d;if(null!==u){let e=Aw.getUndoAxesPermutation(u);g=v4({inputs:{x:d},attrs:{perm:e},backend:n}),n.disposeData(c.dataId),n.disposeData(d.dataId)}return g}var F5,R5={kernelName:Bt,backendName:"wasm",setupFunc:A5,kernelFunc:$5};function D5(e){F5=e.wasm.cwrap(Ut,null,["number","number","number","array","number","array","array","number","number"])}function M5(e){let{backend:t,inputs:n,attrs:r}=e,{x:a}=n,{blockSize:s,dataFormat:i}=r,o=a.shape[0],l="NHWC"===i?a.shape[1]:a.shape[2],u="NHWC"===i?a.shape[2]:a.shape[3],c="NHWC"===i?a.shape[3]:a.shape[1],p=l*s,d=u*s,h=c/(s*s),f="NHWC"===i?[o,p,d,h]:[o,h,p,d],m=t.makeOutput(f,"float32"),g=t.dataIdMap.get(a.dataId).id,y=new Uint8Array(new Int32Array(Na.computeStrides(a.shape)).buffer),b=new Uint8Array(new Int32Array(f).buffer),w=new Uint8Array(new Int32Array(Na.computeStrides(f)).buffer),x=t.dataIdMap.get(m.dataId).id;return F5(g,s,"NHWC"===i?1:0,y,a.shape.length-1,b,w,f.length,x),m}var O5,L5={kernelName:Ut,backendName:"wasm",setupFunc:D5,kernelFunc:M5};function P5(e){O5=e.wasm.cwrap(Gt,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function z5(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s}=t,i=r.dataIdMap.get(a.dataId).id,o=r.dataIdMap.get(s.dataId).id,{strides:l,dilations:u,pad:c,dimRoundingMode:p}=n,d=null==u?[1,1]:u,h=Aw.computeConv2DInfo(a.shape,s.shape,l,d,c,p,!0),f=h.filterHeight,m=h.filterWidth,g=h.padInfo.top,y=h.padInfo.right,b=h.padInfo.bottom,w=h.padInfo.left,x=h.dilationHeight,v=h.dilationWidth,k=h.strideHeight,I=h.strideWidth,S=h.inChannels,N=h.outChannels,T="SAME"===h.padInfo.type?1:0;if("channelsLast"!==h.dataFormat)throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${h.dataFormat}'. Please use 'channelsLast'.`);let _=r.makeOutput(h.outShape,"float32"),C=r.dataIdMap.get(_.dataId).id;return O5(i,a.shape[0],a.shape[1],a.shape[2],o,f,m,g,y,b,w,T,x,v,k,I,S,N,C),_}var B5={kernelName:Gt,backendName:"wasm",setupFunc:P5,kernelFunc:z5},W5=l4(Qt),V5=!1,U5=c4(nn,V5,"bool"),G5=l4(rn,"float32");function H5(e){let{inputs:t,attrs:n,backend:r}=e,{input:a}=t,{dim:s}=n,i=a.shape.length,o=a.shape.slice(),l=s;return s<0&&(Na.assert(-(i+1)<=s,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),l=i+s+1),o.splice(l,0,1),V4({inputs:{x:a},backend:r,attrs:{shape:o}})}var j5={kernelName:an,backendName:"wasm",kernelFunc:H5};function q5(e){let{attrs:{shape:t,value:n,dtype:r},backend:a}=e,s=a.makeOutput(t,r);return a.typedArrayFromHeap(s).fill(n),s}var K5,X5={kernelName:ln,backendName:"wasm",kernelFunc:q5};function Y5(e){K5=e.wasm.cwrap(un,null,["number","number","number","number","number","number"])}function J5(e){let{inputs:t,backend:n}=e,{image:r}=t,a=n.makeOutput(r.shape,r.dtype),s=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(a.dataId).id,[o,l,u,c]=r.shape;return K5(s,o,l,u,c,i),a}var Z5,Q5={kernelName:un,backendName:"wasm",kernelFunc:J5,setupFunc:Y5},e6=l4(cn),t6=!1,n6=c4(pn,t6);function r6(e){Z5=e.wasm.cwrap(dn,null,["number","number","number","number","number","number","number"])}function a6(e){let{backend:t,inputs:n,attrs:r}=e,{varianceEpsilon:a}=r,{x:s,mean:i,variance:o,offset:l,scale:u}=n,c=t.dataIdMap.get(s.dataId).id,p=t.dataIdMap.get(i.dataId).id,d=t.dataIdMap.get(o.dataId).id,h=null!=l?t.dataIdMap.get(l.dataId).id:0,f=null!=u?t.dataIdMap.get(u.dataId).id:0,m=t.makeOutput(s.shape,s.dtype);if(0===Na.sizeFromShape(s.shape))return m;let g=t.dataIdMap.get(m.dataId).id;return Z5(c,p,d,h,f,a,g),m}var s6,i6={kernelName:dn,backendName:"wasm",setupFunc:r6,kernelFunc:a6};function o6(e){s6=e.wasm.cwrap(ca,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function l6(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dataFormat:p,dimRoundingMode:d,activation:h,leakyreluAlpha:f}=n,m=Aw.computeConv2DInfo(a.shape,s.shape,l,c,u,d),g=t4[h];if(null==g)throw new Error(`${h} activation not yet supported for FusedConv2D in the wasm backend.`);let y=r.dataIdMap.get(a.dataId).id,b=r.dataIdMap.get(s.dataId).id,w=m.outChannels,x=0;if(null!=i){let e=r.dataIdMap.get(i.dataId);if(1!==e.shape.length)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==w)throw new Error(`FusedConv2D bias shape (${e.shape}) does not match the number of output channels (${w})`);x=e.id}let v=m.filterHeight,k=m.filterWidth,I=m.padInfo.top,S=m.padInfo.right,N=m.padInfo.bottom,T=m.padInfo.left,_=m.dilationHeight,C=m.dilationWidth,E=m.strideHeight,A=m.strideWidth,$=m.inChannels,F="SAME"===m.padInfo.type?1:0,R=m.batchSize,D=m.inHeight,M=m.inWidth;if("NHWC"!==p)throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${p}'. Please use 'NHWC'.`);let O=r.makeOutput(m.outShape,"float32"),L=r.dataIdMap.get(O.dataId).id,P=null==o?0:r.dataIdMap.get(o.dataId).id;return s6(y,R,D,M,b,v,k,x,I,S,N,T,F,_,C,E,A,$,w,g,P,f||0,L),O}var u6,c6={kernelName:ca,backendName:"wasm",setupFunc:o6,kernelFunc:l6};function p6(e){u6=e.wasm.cwrap(pa,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function d6(e){let{inputs:t,attrs:n,backend:r}=e,{x:a,filter:s,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dataFormat:p,dimRoundingMode:d,activation:h,leakyreluAlpha:f}=n,m=Aw.computeConv2DInfo(a.shape,s.shape,l,c,u,d,!0),g=t4[h];if(null==g)throw new Error(`${h} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let y=r.dataIdMap.get(a.dataId).id,b=r.dataIdMap.get(s.dataId).id,w=m.outChannels,x=0;if(null!=i){let e=r.dataIdMap.get(i.dataId);if(1!==e.shape.length)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${e.shape.length}.`);if(e.shape[0]!==w)throw new Error(`FusedDepthwiseConv2D bias shape (${e.shape}) does not match the number of output channels (${w})`);x=e.id}let v=m.filterHeight,k=m.filterWidth,I=m.padInfo.top,S=m.padInfo.right,N=m.padInfo.bottom,T=m.padInfo.left,_=m.dilationHeight,C=m.dilationWidth,E=m.strideHeight,A=m.strideWidth,$=m.inChannels,F="SAME"===m.padInfo.type?1:0,R=m.batchSize,D=m.inHeight,M=m.inWidth;if("NHWC"!==p)throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${p}'. Please use 'NHWC'.`);let O=r.makeOutput(m.outShape,"float32"),L=r.dataIdMap.get(O.dataId).id,P=null==o?0:r.dataIdMap.get(o.dataId).id;return u6(y,R,D,M,b,v,k,x,I,S,N,T,F,_,C,E,A,$,w,g,P,f||0,L),O}var h6,f6={kernelName:pa,backendName:"wasm",setupFunc:p6,kernelFunc:d6};function m6(e){h6=e.wasm.cwrap(fn,null,["number","number","number","number","number","number","array","number"])}function g6(e){let{backend:t,inputs:n}=e,{params:r,indices:a}=n,[s,i,o,l]=ql.prepareAndValidate(r,a),u=t.makeOutput(s,r.dtype);if(0===i)return u;let c=a.shape,p=c[c.length-1],d=t.dataIdMap.get(r.dataId).id,h=t.dataIdMap.get(a.dataId).id,f=new Uint8Array(new Int32Array(l).buffer),m=t.dataIdMap.get(u.dataId).id;return h6(d,e4[r.dtype],h,i,p,o,f,m),u}var y6,b6={kernelName:fn,backendName:"wasm",setupFunc:m6,kernelFunc:g6};function w6(e){y6=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function x6(e){let{backend:t,inputs:n,attrs:r}=e,{x:a,indices:s}=n,{axis:i,batchDims:o}=r,l=Na.parseAxisParam(i,a.shape)[0],u=t.readSync(s.dataId),c=a.shape[l];for(let I=0;I<u.length;++I){let e=u[I];Na.assert(e<=c-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${c-1}]`))}let p=Aw.segment_util.collectGatherOpShapeInfo(a,s,l,o),d=V4({inputs:{x:a},attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]},backend:t}),h=Na.sizeFromShape(s.shape),f=V4({inputs:{x:s},attrs:{shape:[p.batchSize,h/p.batchSize]},backend:t}),m=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],g=t.makeOutput(m,a.dtype);if(0===Na.sizeFromShape(a.shape))return g;let y=d.shape.length-1,b=t.dataIdMap.get(d.dataId).id,w=t.dataIdMap.get(f.dataId).id,x=t.dataIdMap.get(g.dataId).id,v=new Uint8Array(new Int32Array(Na.computeStrides(d.shape)).buffer),k=new Uint8Array(new Int32Array(Na.computeStrides(m)).buffer);return y6(b,e4[a.dtype],v,y,w,p.batchSize,k,x),t.disposeData(d.dataId),t.disposeData(f.dataId),g.shape=p.outputShape,g}var v6,k6={kernelName:hn,backendName:"wasm",setupFunc:w6,kernelFunc:x6},I6=!1,S6=c4(mn,I6,"bool"),N6=!1,T6=c4(gn,N6,"bool");function _6(e){v6=e.wasm.cwrap(In,null,["number","number","number","number"])}function C6(e){let{inputs:{x:t},attrs:{alpha:n},backend:r}=e,a=r.dataIdMap.get(t.dataId).id,s=r.makeOutput(t.shape,"float32");if(0!==Na.sizeFromShape(t.shape)){let e=r.dataIdMap.get(s.dataId).id;v6(a,e4[t.dtype],n,e)}return s}var E6,A6={kernelName:In,backendName:"wasm",setupFunc:_6,kernelFunc:C6},$6=!1,F6=c4(Sn,$6,"bool"),R6=!1,D6=c4(Nn,R6,"bool"),M6=l4(_n),O6=!1,L6=c4(En,O6,"bool");function P6(e){E6=e.wasm.cwrap(On,null,["number","number","number","number"])}function z6(e){let{backend:t,inputs:n,attrs:r}=e,{reductionIndices:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:c,originalAxes:p,inputWasTransposed:d}=T4(i,a,t);if(d){let e=t.dataIdMap.get(u.dataId).id;l=u,o=e}let h=l.shape.length;Aw.assertAxesAreInnerMostDims("max",c,h);let[f,m]=Aw.computeOutAndReduceShapes(l.shape,c),g=Na.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(0!==Na.sizeFromShape(l.shape)){let e=t.dataIdMap.get(y.dataId).id;E6(o,e4[i.dtype],g,e)}if(d&&t.disposeData(u.dataId),s){let e=Aw.expandShapeToKeepDim(y.shape,p);y.shape=e}return y}var B6,W6={kernelName:On,backendName:"wasm",setupFunc:P6,kernelFunc:z6},V6=!1,U6=c4(Ln,V6);function G6(e){B6=e.wasm.cwrap(Pn,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function H6(e){let{inputs:t,attrs:n,backend:r}=e,a=t.x,s=r.dataIdMap.get(a.dataId).id;Na.assert("float32"===a.dtype,(()=>`Error in MaxPool: only float32 input is supported. Got ${a.dtype}.`));let{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,c=Aw.computePool2DInfo(a.shape,i,o,1,l,u),p=c.filterHeight,d=c.filterWidth,h=c.padInfo.top,f=c.padInfo.right,m=c.padInfo.bottom,g=c.padInfo.left,y=c.dilationHeight,b=c.dilationWidth,w=c.strideHeight,x=c.strideWidth,v=c.inChannels,k=c.outChannels;if("channelsLast"!==c.dataFormat)throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);let I=r.makeOutput(c.outShape,"float32"),S=r.dataIdMap.get(I.dataId).id;return B6(s,a.shape[0],a.shape[1],a.shape[2],p,d,h,f,m,g,y,b,w,x,v,k,S),I}var j6,q6={kernelName:Pn,backendName:"wasm",setupFunc:G6,kernelFunc:H6};function K6(e){j6=e.wasm.cwrap(Un,null,["number, number, number"])}function X6(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:p,originalAxes:d,inputWasTransposed:h}=T4(i,a,t),f=p;if(h){let e=t.dataIdMap.get(c.dataId).id;e!==o&&(u=c,l=e,f=Aw.getInnerMostAxes(f.length,u.shape.length))}Aw.assertAxesAreInnerMostDims("mean",f,u.shape.length);let[m,g]=Aw.computeOutAndReduceShapes(u.shape,f),y=Na.sizeFromShape(g),b=u;"float32"!==u.dtype&&(b=t5({backend:t,inputs:{x:u},attrs:{dtype:"float32"}}),l=t.dataIdMap.get(b.dataId).id);let w=t.makeOutput(m,"float32");if(0!==Na.sizeFromShape(u.shape)){let e=t.dataIdMap.get(w.dataId).id;j6(l,y,e)}if(h&&t.disposeData(c.dataId),s){let e=Aw.expandShapeToKeepDim(w.shape,d);w.shape=e}return"float32"!==u.dtype&&t.disposeData(b.dataId),w}var Y6,J6={kernelName:Un,backendName:"wasm",setupFunc:K6,kernelFunc:X6};function Z6(e){Y6=e.wasm.cwrap(Gn,null,["number","number","number","number"])}function Q6(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:p,originalAxes:d,inputWasTransposed:h}=T4(i,a,t);if(h){let e=t.dataIdMap.get(c.dataId).id;e!==o&&(u=c,l=e)}let f=u.shape.length;Aw.assertAxesAreInnerMostDims("min",p,f);let[m,g]=Aw.computeOutAndReduceShapes(u.shape,p),y=Na.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(0!==Na.sizeFromShape(u.shape)){let e=t.dataIdMap.get(b.dataId).id;Y6(l,e4[i.dtype],y,e)}if(h&&t.disposeData(c.dataId),s){let e=Aw.expandShapeToKeepDim(b.shape,d);b.shape=e}return b}var e8,t8,n8={kernelName:Gn,backendName:"wasm",setupFunc:Z6,kernelFunc:Q6},r8=!1,a8=c4(Hn,r8);function s8(e){t8=e.wasm.cwrap(jn,null,["number","array","number","number","array","array","number","number"])}function i8(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,mode:a}}=e,s=r.map(((e,n)=>e[0]+t.shape[n]+e[1])),i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),c=r.map((e=>e[0])),p=r.map((e=>e[1])),d=new Uint8Array(new Int32Array(c).buffer),h=new Uint8Array(new Int32Array(p).buffer);return t8(i,u,t.shape.length,e4[t.dtype],d,h,e8[a],l),o}(function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"})(e8||(e8={}));var o8,l8={kernelName:jn,backendName:"wasm",kernelFunc:i8,setupFunc:s8},u8=!0,c8=c4(Xn,u8),p8=l4(Yn);function d8(e,t){let n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),r=n[0],a=n[1],s=n[2],i=n[3];return e.wasm._free(t),{pSelectedIndices:r,selectedSize:a,pSelectedScores:s,pValidOutputs:i}}function h8(e){o8=e.wasm.cwrap(Zn,"number",["number","number","number","number","number"])}function f8(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i}=r,{boxes:o,scores:l}=n,u=t.dataIdMap.get(o.dataId).id,c=t.dataIdMap.get(l.dataId).id,p=o8(u,c,s,a,i),{pSelectedIndices:d,selectedSize:h,pSelectedScores:f,pValidOutputs:m}=d8(t,p);return t.wasm._free(f),t.wasm._free(m),t.makeOutput([h],"int32",d)}var m8,g8={kernelName:Zn,backendName:"wasm",setupFunc:h8,kernelFunc:f8};function y8(e){m8=e.wasm.cwrap(Qn,"number",["number","number","number","number","number","bool"])}function b8(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i,padToMaxOutputSize:o}=r,{boxes:l,scores:u}=n,c=t.dataIdMap.get(l.dataId).id,p=t.dataIdMap.get(u.dataId).id,d=m8(c,p,s,a,i,o),{pSelectedIndices:h,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=d8(t,d);t.wasm._free(m);let y=t.makeOutput([f],"int32",h),b=t.makeOutput([],"int32",g);return[y,b]}var w8,x8={kernelName:Qn,backendName:"wasm",setupFunc:y8,kernelFunc:b8};function v8(e){w8=e.wasm.cwrap(er,"number",["number","number","number","number","number","number"])}function k8(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:a,maxOutputSize:s,scoreThreshold:i,softNmsSigma:o}=r,{boxes:l,scores:u}=n,c=t.dataIdMap.get(l.dataId).id,p=t.dataIdMap.get(u.dataId).id,d=w8(c,p,s,a,i,o),{pSelectedIndices:h,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=d8(t,d);t.wasm._free(g);let y=t.makeOutput([f],"int32",h),b=t.makeOutput([f],"float32",m);return[y,b]}var I8,S8={kernelName:er,backendName:"wasm",setupFunc:v8,kernelFunc:k8},N8=!1,T8=c4(Jn,N8,"bool");function _8(e){I8=e.wasm.cwrap(nr,null,["number","number","number","number","number"])}function C8(e){let{inputs:t,backend:n,attrs:r}=e,{indices:a}=t,{depth:s,onValue:i,offValue:o}=r,l=n.makeOutput([...a.shape,s],"int32"),u=n.dataIdMap.get(l.dataId).id,c=n.dataIdMap.get(a.dataId).id;return I8(c,s,i,o,u),l}var E8={kernelName:nr,backendName:"wasm",setupFunc:_8,kernelFunc:C8};function A8(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(1),r}var $8={kernelName:tr,backendName:"wasm",kernelFunc:A8};function F8(e){let{inputs:t,backend:n,attrs:r}=e,{axis:a}=r;if(1===t.length)return H5({inputs:{input:t[0]},backend:n,attrs:{dim:a}});let s=t[0].shape,i=t[0].dtype;t.forEach((e=>{Na.assertShapesMatch(s,e.shape,"All tensors passed to stack must have matching shapes"),Na.assert(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));let o=[],l=t.map((e=>{let t=H5({inputs:{input:e},backend:n,attrs:{dim:a}});return o.push(t),t})),u=l5({inputs:l,backend:n,attrs:{axis:a}});return o.forEach((e=>n.disposeData(e.dataId))),u}var R8,D8={kernelName:rr,backendName:"wasm",kernelFunc:F8};function M8(e){R8=e.wasm.cwrap(ar,null,["number","array","number","number","array","array","number","number"])}function O8(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,constantValue:a}}=e,s=r.map(((e,n)=>e[0]+t.shape[n]+e[1]));if(0===Na.sizeFromShape(t.shape))return q5({backend:n,attrs:{shape:s,value:a,dtype:t.dtype}});let i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(s,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),c=r.map((e=>e[0])),p=r.map((e=>e[1])),d=new Uint8Array(new Int32Array(c).buffer),h=new Uint8Array(new Int32Array(p).buffer);return R8(i,u,t.shape.length,e4[t.dtype],d,h,a,l),o}var L8,P8={kernelName:ar,backendName:"wasm",kernelFunc:O8,setupFunc:M8},z8=!1,B8=c4(ir,z8);function W8(e){L8=e.wasm.cwrap(or,null,["number","number","number"])}function V8(e){let{inputs:t,backend:n}=e,{x:r,alpha:a}=t,s=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(a.dataId).id,o=s,l=r,u=l;"float32"!==l.dtype&&(u=t5({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),o=n.dataIdMap.get(u.dataId).id);let c=n.makeOutput(r.shape,"float32"),p=n.dataIdMap.get(c.dataId).id;return L8(o,i,p),"float32"!==l.dtype&&n.disposeData(u.dataId),c}var U8,G8={kernelName:or,backendName:"wasm",setupFunc:W8,kernelFunc:V8};function H8(e){U8=e.wasm.cwrap(lr,null,["number","number","number","number"])}function j8(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:p,originalAxes:d,inputWasTransposed:h}=T4(i,a,t),f=p;if(h){let e=t.dataIdMap.get(c.dataId).id;e!==o&&(u=c,l=e,f=Aw.getInnerMostAxes(f.length,u.shape.length))}Aw.assertAxesAreInnerMostDims("prod",f,u.shape.length);let[m,g]=Aw.computeOutAndReduceShapes(u.shape,f),y=Na.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(0!==Na.sizeFromShape(u.shape)){let e=t.dataIdMap.get(b.dataId).id;U8(l,y,e4[b.dtype],e)}if(h&&t.disposeData(c.dataId),s){let e=Aw.expandShapeToKeepDim(b.shape,d);b.shape=e}return b}var q8,K8={kernelName:lr,backendName:"wasm",setupFunc:H8,kernelFunc:j8},X8=e=>{let{backend:t,attrs:n}=e,{start:r,stop:a,step:s,dtype:i}=n,o=pL(r,a,s,i),l=t.makeOutput([o.length],i);return t.typedArrayFromHeap(l).set(o),l},Y8={kernelName:ur,backendName:"wasm",kernelFunc:X8},J8=!0,Z8=c4(Jt,J8),Q8=l4(dr),e7=l4(br);function t7(e){q8=e.wasm.cwrap(gr,null,["number","number","number","number","number","number","number","number","number","number"])}function n7(e){let t,{backend:n,inputs:r,attrs:a}=e,{images:s}=r,{alignCorners:i,halfPixelCenters:o,size:l}=a,[u,c]=l,[p,d,h,f]=s.shape,m=[p,u,c,f],g=n.dataIdMap.get(s.dataId);"float32"!==g.dtype&&(t=t5({backend:n,inputs:{x:s},attrs:{dtype:"float32"}}),g=n.dataIdMap.get(t.dataId));let y=g.id,b=n.makeOutput(m,"float32");if(0===Na.sizeFromShape(s.shape))return b;let w=n.dataIdMap.get(b.dataId).id;return q8(y,p,d,h,f,u,c,i?1:0,o?1:0,w),null!=t&&n.disposeData(t.dataId),b}var r7,a7={kernelName:gr,backendName:"wasm",setupFunc:t7,kernelFunc:n7};function s7(e){r7=e.wasm.cwrap(wr,null,["number","array","number","array","number","number"])}function i7(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{dims:s}=r,i=Na.parseAxisParam(s,a.shape);if(0===a.shape.length)return y4({inputs:{x:a},backend:n});let o=n.makeOutput(a.shape,a.dtype),l=n.dataIdMap.get(a.dataId).id,u=n.dataIdMap.get(o.dataId).id,c=new Uint8Array(new Int32Array(i).buffer),p=new Uint8Array(new Int32Array(a.shape).buffer);r7(l,c,i.length,p,a.shape.length,u);let d=V4({inputs:{x:o},attrs:{shape:a.shape},backend:n});return n.disposeData(o.dataId),d}var o7,l7={kernelName:wr,backendName:"wasm",kernelFunc:i7,setupFunc:s7};function u7(e){o7=e.wasm.cwrap(la,null,["number","number","number","number","number","number","number","number","array","number","number"])}function c7(e){let{inputs:t,backend:n,attrs:r}=e,{image:a}=t,{radians:s,fillValue:i,center:o}=r,l=n.makeOutput(a.shape,a.dtype),u=n.dataIdMap.get(a.dataId).id,c=n.dataIdMap.get(l.dataId).id,[p,d,h,f]=a.shape,[m,g]=Aw.getImageCenter(o,d,h),y=0===i,b=255,w="number"==typeof i?[i,i,i,y?0:b]:[...i,b],x=new Uint8Array(new Int32Array(w).buffer);return o7(u,p,d,h,f,s,m,g,x,w.length,c),l}var p7,d7={kernelName:la,backendName:"wasm",kernelFunc:c7,setupFunc:u7},h7=l4(xr),f7=l4(vr);function m7(e){p7=e.wasm.cwrap(kr,null,["number","number","number","number","number","number","array","number","number"])}function g7(e){let{backend:t,inputs:n,attrs:r}=e,{indices:a,updates:s}=n,{shape:i}=r,o=t.makeOutput(i,s.dtype);if(0===Na.sizeFromShape(i))return o;let{sliceRank:l,numUpdates:u,sliceSize:c,strides:p,outputSize:d}=Xl.calculateShapes(s,a,i),h=t.dataIdMap.get(a.dataId).id,f=t.dataIdMap.get(s.dataId).id,m=new Uint8Array(new Int32Array(p).buffer),g=t.dataIdMap.get(o.dataId).id;return p7(h,f,e4[s.dtype],l,u,c,m,d,g),o}var y7,b7={kernelName:kr,backendName:"wasm",setupFunc:m7,kernelFunc:g7};function w7(e){y7=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function x7(e){let{inputs:t,backend:n}=e,{condition:r,t:a,e:s}=t,i=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(a.dataId).id,l=n.dataIdMap.get(s.dataId).id,u=n.makeOutput(a.shape,a.dtype),c=n.dataIdMap.get(u.dataId).id,p=r.shape.length,d=a.shape.length,h=0===p||p>1||1===d?1:Na.sizeFromShape(a.shape.slice(1));return y7(i,o,l,h,c),u}var v7,k7={kernelName:Sr,backendName:"wasm",kernelFunc:x7,setupFunc:w7};function I7(e){v7=e.wasm.cwrap(Ar,null,["number","number"])}function S7(e){let{backend:t,inputs:{x:n}}=e,r=t.dataIdMap.get(n.dataId).id,a=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(a.dataId).id;return 0===Na.sizeFromShape(a.shape)||v7(r,s),a}var N7,T7={kernelName:"Sigmoid",backendName:"wasm",setupFunc:I7,kernelFunc:S7},_7=l4(_r);function C7(e){N7=e.wasm.cwrap(Or,null,["number","number","number","number"])}function E7(e){let{backend:t,inputs:{logits:n},attrs:{dim:r}}=e,a=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),i=t.dataIdMap.get(s.dataId).id,o=n.shape[r],l=Na.sizeFromShape(n.shape)/o;return 0===Na.sizeFromShape(s.shape)||N7(a,i,o,l),s}var A7={kernelName:Or,backendName:"wasm",setupFunc:C7,kernelFunc:E7};function $7(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,{blockShape:s,paddings:i}=r,o=Na.sizeFromShape(s),l=[[0,0]];l.push(...i);for(let g=1+s.length;g<a.shape.length;++g)l.push([0,0]);let u=P8.kernelFunc({inputs:{x:a},backend:n,attrs:{paddings:l,constantValue:0}}),c=Aw.getReshaped(u.shape,s,o,!1),p=Aw.getPermuted(c.length,s.length,!1),d=Aw.getReshapedPermuted(u.shape,s,o,!1),h=V4({inputs:{x:u},backend:n,attrs:{shape:c}}),f=v4({inputs:{x:h},backend:n,attrs:{perm:p}}),m=V4({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeData(u.dataId),n.disposeData(h.dataId),n.disposeData(f.dataId),m}var F7,R7={kernelName:Dr,backendName:"wasm",kernelFunc:$7};function D7(e){F7=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function M7(e){let t,{backend:n,inputs:r}=e,{indices:a,values:s,denseShape:i,defaultValue:o}=r,l=a.shape[0],u=a.shape[1],c=n.readSync(i.dataId)[0],p=[l+c,u],d=n.dataIdMap.get(a.dataId).id,h=n.dataIdMap.get(s.dataId).id,f=n.dataIdMap.get(o.dataId).id,m=n.makeOutput(p,a.dtype),g=n.dataIdMap.get(m.dataId).id,y=n.makeOutput(p.slice(0,1),s.dtype),b=n.dataIdMap.get(y.dataId).id,w=n.makeOutput([c],"bool"),x=n.dataIdMap.get(w.dataId).id,v=n.makeOutput([l],a.dtype),k=n.dataIdMap.get(v.dataId).id,I=n.makeOutput([4],"int32"),S=n.dataIdMap.get(I.dataId).id,N=F7(d,h,e4[s.dtype],l,c,u,f,g,b,x,k,S),T=n.readSync(I.dataId);switch(T[0]){case 1:t=Aw.getSparseFillEmptyRowsIndicesDenseShapeMismatch(T[1]);break;case 2:t=Aw.getSparseFillEmptyRowsNegativeIndexErrorMessage(T[1],T[2]);break;case 3:t=Aw.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(T[1],T[2],T[3]);break;default:t=""}if(n.disposeData(I.dataId),t)throw n.disposeData(m.dataId),n.disposeData(y.dataId),n.disposeData(w.dataId),n.disposeData(v.dataId),new Error(t);let _=m,C=y;return N!==p[0]&&(_=K4({inputs:{x:m},attrs:{begin:0,size:[N,u]},backend:n}),C=K4({inputs:{x:y},attrs:{begin:0,size:N},backend:n}),n.disposeData(m.dataId),n.disposeData(y.dataId)),[_,C,w,v]}var O7,L7={kernelName:Lr,backendName:"wasm",setupFunc:D7,kernelFunc:M7};function P7(e){O7=e.wasm.cwrap(Pr,null,["number","number","number","number","number","number","number"])}function z7(e){let{backend:t,inputs:n}=e,{inputIndices:r,inputShape:a,newShape:s}=n;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${a.shape}`);if(1!==s.shape.length)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=t.dataIdMap.get(r.dataId).id,o=t.dataIdMap.get(a.dataId).id,l=t.dataIdMap.get(s.dataId).id,u=r.shape[0],c=Na.sizeFromShape(s.shape),p=t.makeOutput([u,c],r.dtype),d=t.dataIdMap.get(p.dataId).id,h=t.makeOutput([c],s.dtype),f=t.dataIdMap.get(h.dataId).id,m=t.makeOutput([3],"int32"),g=t.dataIdMap.get(m.dataId).id;O7(i,o,l,u,d,f,g);let y,b=t.readSync(m.dataId);switch(b[0]){case 0:y=Aw.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(b[1],b[2]);break;case 1:y=Aw.getSparseReshapeNegativeOutputDimErrorMessage(b[1],b[2]);break;case 2:y=Aw.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let e=Array.from(t.readSync(a.dataId)),n=Array.from(t.readSync(h.dataId));y=Aw.getSparseReshapeInputOutputMultipleErrorMessage(e,n);break}case 4:{let e=Array.from(t.readSync(a.dataId)),n=Array.from(t.readSync(h.dataId));y=Aw.getSparseReshapeInputOutputMismatchErrorMessage(e,n);break}default:y=""}if(t.disposeData(m.dataId),y)throw t.disposeData(p.dataId),t.disposeData(h.dataId),new Error(y);return[p,h]}var B7,W7={kernelName:Pr,backendName:"wasm",setupFunc:P7,kernelFunc:z7};function V7(e){B7=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function U7(e,t){let{backend:n,inputs:r}=e,{data:a,indices:s,segmentIds:i}=r,o=s.shape[0],l=n.readSync(i.dataId,o-1,o)[0],u=o>0?l+1:0;if(u<0)throw new Error(Aw.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let c=a.shape.slice();c[0]=u;let p=n.dataIdMap.get(a.dataId).id,d=n.dataIdMap.get(s.dataId).id,h=n.dataIdMap.get(i.dataId).id,f=n.makeOutput(c,a.dtype),m=n.dataIdMap.get(f.dataId).id,g=n.makeOutput([4],"int32"),y=n.dataIdMap.get(g.dataId).id;B7(p,e4[a.dtype],a.shape[0],d,h,m,y,t,0);let b,w=n.readSync(g.dataId);switch(w[0]){case 0:b=Aw.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break;case 1:b=Aw.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break;case 2:b=Aw.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(w[1],w[2]);break;case 3:b=Aw.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(w[1],w[2],w[3]);break;default:b=""}if(n.disposeData(g.dataId),b)throw n.disposeData(f.dataId),new Error(b);return f}function G7(e){return U7(e,!0)}var H7={kernelName:zr,backendName:"wasm",setupFunc:V7,kernelFunc:G7};function j7(e){return U7(e,!1)}var q7={kernelName:Br,backendName:"wasm",setupFunc:V7,kernelFunc:j7};function K7(e){let{inputs:t,attrs:n,backend:r}=e,{x:a}=t,{numOrSizeSplits:s,axis:i}=n,o=Na.parseAxisParam(i,a.shape)[0],l=Aw.prepareSplitSize(a,s,o),u=new Array(a.shape.length).fill(0),c=a.shape.slice();return l.map((e=>{let t=[...c];t[o]=e;let n=K4({inputs:{x:a},attrs:{begin:u,size:t},backend:r});return u[o]+=e,n}))}var X7,Y7={kernelName:Mr,backendName:"wasm",kernelFunc:K7},J7=l4(Fr),Z7=l4(Ur),Q7=!0,e9=c4(Vr,Q7);function t9(e){X7=e.wasm.cwrap(ia,null,["number","number","number","number"])}function n9(e){let{backend:t,inputs:n,attrs:r}=e,{alpha:a}=r,{x:s}=n,i=t.dataIdMap.get(s.dataId).id,o=t.makeOutput(s.shape,s.dtype),l=t.dataIdMap.get(o.dataId).id;return X7(i,a,e4[s.dtype],l),o}var r9,a9={kernelName:ia,backendName:"wasm",setupFunc:t9,kernelFunc:n9};function s9(e){r9=e.wasm.cwrap(Gr,null,["number","array","number","array","array","array","array","array","number","number"])}function i9(e){let t,{backend:n,inputs:r,attrs:a}=e,{x:s}=r,{begin:i,end:o,strides:l,beginMask:u,endMask:c,ellipsisMask:p,newAxisMask:d,shrinkAxisMask:h}=a,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:b,begin:w,end:x,strides:v}=Ql.sliceInfo(s.shape,i,o,l,u,c,p,d,h);if(g)t=V4({inputs:{x:s},backend:n,attrs:{shape:m}});else if(y||b){Na.assert(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));let e=Ql.computeOutShape(w,x,v),r=K4({inputs:{x:s},backend:n,attrs:{begin:w,size:e}});t=V4({inputs:{x:r},backend:n,attrs:{shape:m}}),n.disposeData(r.dataId)}else{let e=n.makeOutput(f,"float32"),r=n.dataIdMap.get(s.dataId).id,a=new Uint8Array(new Int32Array(Na.computeStrides(s.shape)).buffer),i=new Uint8Array(new Int32Array(w).buffer),o=new Uint8Array(new Int32Array(x).buffer),l=new Uint8Array(new Int32Array(v).buffer),u=new Uint8Array(new Int32Array(f).buffer),c=new Uint8Array(new Int32Array(Na.computeStrides(f)).buffer),p=n.dataIdMap.get(e.dataId).id;r9(r,a,s.shape.length,i,o,l,u,c,f.length,p),t=V4({inputs:{x:e},backend:n,attrs:{shape:m}}),n.disposeData(e.dataId)}return t}var o9,l9={kernelName:Gr,backendName:"wasm",setupFunc:s9,kernelFunc:i9},u9=!0,c9=c4(Kr,u9);function p9(e){o9=e.wasm.cwrap(Rr,null,["number","number","number","number"])}function d9(e){let{backend:t,inputs:n,attrs:r}=e,{axis:a,keepDims:s}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:p,originalAxes:d,inputWasTransposed:h}=T4(i,a,t),f=p;if(h){let e=t.dataIdMap.get(c.dataId).id;e!==o&&(u=c,l=e,f=Aw.getInnerMostAxes(f.length,u.shape.length))}Aw.assertAxesAreInnerMostDims("sum",f,u.shape.length);let[m,g]=Aw.computeOutAndReduceShapes(u.shape,f),y=Na.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(0!==Na.sizeFromShape(u.shape)){let e=t.dataIdMap.get(b.dataId).id;o9(l,y,e4[b.dtype],e)}if(h&&t.disposeData(c.dataId),s){let e=Aw.expandShapeToKeepDim(b.shape,d);b.shape=e}return b}var h9,f9={kernelName:Rr,backendName:"wasm",setupFunc:p9,kernelFunc:d9},m9=l4(Xr),g9=l4(Yr);function y9(e){h9=e.wasm.cwrap(Jr,null,["number","array","number","array","number","number"])}function b9(e){let{inputs:t,backend:n,attrs:r}=e,{x:a}=t,s=n.dataIdMap.get(a.dataId).id,{reps:i}=r,o=new Array(a.shape.length);for(let d=0;d<o.length;d++)o[d]=a.shape[d]*i[d];let l=new Uint8Array(new Int32Array(a.shape).buffer),u=new Uint8Array(new Int32Array(o).buffer),c=n.makeOutput(o,a.dtype),p=n.dataIdMap.get(c.dataId).id;return h9(s,l,a.shape.length,u,o.length,e4[c.dtype],p),c}var w9,x9={kernelName:Jr,backendName:"wasm",setupFunc:y9,kernelFunc:b9};function v9(e){w9=e.wasm.cwrap(Zr,null,["number","array","number","number","number","bool","number","number"])}var k9,I9=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{k:a,sorted:s}=n,i=t.dataIdMap.get(r.dataId).id,o=new Uint8Array(new Int32Array(r.shape).buffer),l=r.shape.slice();l[l.length-1]=a;let u=t.makeOutput(l,r.dtype),c=t.dataIdMap.get(u.dataId).id,p=t.makeOutput(l,"int32"),d=t.dataIdMap.get(p.dataId).id;return w9(i,o,r.shape.length,e4[r.dtype],a,s,c,d),[u,p]},S9={kernelName:Zr,backendName:"wasm",setupFunc:v9,kernelFunc:I9};function N9(e){k9=e.wasm.cwrap(Qr,null,["number","number","bool","number","number","number","number","number","number","array","number","number","number","number","number"])}function T9(e){let t,{backend:n,inputs:r,attrs:a}=e,{image:s,transforms:i}=r,{interpolation:o,fillMode:l,fillValue:u,outputShape:c}=a,[p,d,h,f]=s.shape,[m,g]=null!=c?c:[d,h],y=[p,m,g,f],b=new Uint8Array(new Int32Array(Na.computeStrides(s.shape)).buffer),w=n.makeOutput(y,s.dtype),x=n.dataIdMap.get(w.dataId).id,v=n.dataIdMap.get(s.dataId).id,k=n.dataIdMap.get(i.dataId).id,I="nearest"===o?1:2;switch(l){case"constant":t=1;break;case"reflect":t=2;break;case"wrap":t=3;break;case"nearest":t=4;break;default:t=1;break}return k9(v,k,i.shape[0]>1,p,m,g,f,h,d,b,s.shape.length-1,I,t,u,x),w}var _9={kernelName:Qr,backendName:"wasm",setupFunc:N9,kernelFunc:T9};function C9(e){let{inputs:t,backend:n,attrs:r}=e,{value:a}=t,{axis:s}=r;s<0&&(s+=a.shape.length);let i=a.shape[s],o=a.shape.length,l=new Array(o-1),u=0;for(let h=0;h<o;h++)h!==s&&(l[u++]=a.shape[h]);let c=new Array(i),p=new Array(o).fill(0),d=a.shape.slice();d[s]=1;for(let h=0;h<c.length;h++)p[s]=h,c[h]=K4({inputs:{x:a},attrs:{begin:p,size:d},backend:n});return c.map((({dataId:e,dtype:t})=>({dataId:e,dtype:t,shape:l})))}var E9={kernelName:na,backendName:"wasm",kernelFunc:C9};function A9(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(0),r}var $9={kernelName:sa,backendName:"wasm",kernelFunc:A9},F9=[o4,u4,h4,g4,A4,D4,P4,W4,q4,e5,r5,a5,o5,c5,f5,w5,x5,v5,N5,E5,R5,L5,B5,W5,U5,G5,j5,X5,Q5,e6,n6,i6,c6,f6,b6,k6,S6,T6,w4,A6,F6,D6,M6,L6,W6,U6,q6,J6,n8,a8,l8,c8,p8,g8,x8,S8,T8,E8,$8,D8,P8,B8,G8,K8,Y8,Z8,Q8,e7,G4,a7,l7,d7,h7,f7,b7,k7,T7,_7,Z4,A7,R7,L7,W7,H7,q7,Y7,J7,Z7,e9,a9,l9,c9,f9,m9,g9,x9,S9,_9,N4,E9,$9];for(let Jre of F9)wa(Jre);var R9=Xe();R9.registerFlag("WASM_HAS_SIMD_SUPPORT",(async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11])))),R9.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",(async()=>{if(R9.get("IS_NODE"))return!1;try{return(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(Yre){return!1}}));var D9=b(H()),M9='"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",function(data){onmessage({data:data})});var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8"))},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"\n");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=((info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports});self.onmessage=(e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob==="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module).then(function(instance){Module=instance})}else if(e.data.cmd==="run"){Module["__performance_now_clock_drift"]=performance.now()-e.data.time;Module["__emscripten_thread_init"](e.data.threadInfoStruct,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInit();try{var result=Module["invokeEntryPoint"](e.data.start_routine,e.data.arg);if(Module["keepRuntimeAlive"]()){Module["PThread"].setExitStatus(result)}else{Module["__emscripten_thread_exit"](result)}}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processThreadQueue"){if(Module["_pthread_self"]()){Module["_emscripten_current_thread_process_queued_calls"]()}}else if(e.data.cmd==="processProxyingQueue"){if(Module["_pthread_self"]()){Module["_emscripten_proxy_execute_queue"](e.data.queue)}}else{err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){err("worker.js onmessage() captured an uncaught exception: "+ex);if(ex&&ex.stack)err(ex.stack);if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}});',O9=b(j()),L9=class extends K{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(Y9),J9=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new q(this,il())}write(e,t,n){let r={id:this.dataIdNextNumber++};return this.move(r,e,t,n,1),r}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=Na.now();return e(),{kernelMs:Na.now()-t}}move(e,t,n,r,a){let s=this.dataIdNextNumber++;if("string"===r){let i=t;return void this.dataIdMap.set(e,{id:s,stringBytes:i,shape:n,dtype:r,memoryOffset:null,refCount:a})}let i=Na.sizeFromShape(n),o=i*Na.bytesPerElement(r),l=this.wasm._malloc(o);this.dataIdMap.set(e,{id:s,memoryOffset:l,shape:n,dtype:r,refCount:a}),this.wasm.tfjs.registerTensor(s,i,l),null!=t&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),l)}async read(e){return this.readSync(e)}readSync(e,t,n){let{memoryOffset:r,dtype:a,shape:s,stringBytes:i}=this.dataIdMap.get(e);if("string"===a)return null!=t&&0!==t||!(null==n||n>=i.length)?i.slice(t,n):i;t=t||0,n=n||Na.sizeFromShape(s);let o=Na.bytesPerElement(a),l=this.wasm.HEAPU8.slice(r+t*o,r+n*o);return W9(l.buffer,a)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);null!=t&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n){let r;if(null==n)r=this.write(null,e,t);else{let a=this.dataIdNextNumber++;r={id:a},this.dataIdMap.set(r,{id:a,memoryOffset:n,shape:e,dtype:t,refCount:1});let s=Na.sizeFromShape(e);this.wasm.tfjs.registerTensor(a,s,n)}return{dataId:r,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){let r=this.wasm.HEAPU8.buffer,{memoryOffset:a}=this.dataIdMap.get(n),s=Na.sizeFromShape(e);switch(t){case"float32":return new Float32Array(r,a,s);case"int32":return new Int32Array(r,a,s);case"bool":return new Uint8Array(r,a,s);default:throw new Error(`Unknown dtype ${t}`)}}};function P9(e){return(t,n)=>(Na.fetch(e,{credentials:"same-origin"}).then((r=>{r.ok||t.env.a(`failed to load wasm binary file at '${e}'`),r.arrayBuffer().then((e=>{WebAssembly.instantiate(e,t).then((e=>{n(e.instance,e.module)}))}))})),{})}function z9(e,t,n){if(null!=U9)return U9;let r="tfjs-backend-wasm.wasm";return e&&t?r="tfjs-backend-wasm-threaded-simd.wasm":e&&(r="tfjs-backend-wasm-simd.wasm"),null!=H9&&null!=H9[r]?H9[r]:n+r}async function B9(){let[e,t]=await Promise.all([Xe().getAsync("WASM_HAS_SIMD_SUPPORT"),Xe().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise(((n,r)=>{let a={locateFile:(n,r)=>{if(n.endsWith(".worker.js")){let e=M9.replace(/\n/g,"\\n"),t=new Blob([e],{type:"application/javascript"});return URL.createObjectURL(t)}return n.endsWith(".wasm")?z9(e,t,null!=G9?G9:r):r+n}};q9&&(a.instantiateWasm=P9(z9(e,t,null!=G9?G9:"")));let s,i=!1;a.onAbort=()=>{i||j9||(j9=!0,r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))},t&&e&&null==U9?(a.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+D9.default.toString()],{type:"text/javascript"}),s=(0,D9.default)(a)):s=(0,O9.default)(a),s.then((e=>{i=!0,j9=!1;let t=null;e.tfjs={init:e.cwrap("init",null,[]),initWithThreadsCount:e.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:e.cwrap("get_threads_count","number",[]),registerTensor:e.cwrap("register_tensor",null,["number","number","number"]),disposeData:e.cwrap("dispose_data",t,["number"]),dispose:e.cwrap("dispose",t,[])},n({wasm:e})}))}))}function W9(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}var V9=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],U9=null,G9=null,H9={},j9=!1,q9=!1;function K9(e,t=!1){if(al("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),j9)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");U9=e,q9=t}function X9(e,t=!1){if(j9)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if("string"==typeof e)G9=e;else{H9=e;let t=V9.filter((e=>null==H9[e]));if(t.length>0)throw new Error(`There were no entries found for the following binaries: ${t.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}q9=t}var Y9=-1,J9=-1;function Z9(e){Y9=e}function Q9(){if(-1===J9)throw new Error("WASM backend not initialized.");return J9}var eee="3.18.0",tee=2;wl("wasm",(async()=>{let{wasm:e}=await B9();return new L9(e)}),tee);var nee="3.18.0",ree="3.18.0",aee="3.18.0",see="3.18.0",iee="3.18.0",oee="3.18.0",lee="3.18.0",uee="3.18.0",cee={tfjs:nee,"tfjs-core":ree,"tfjs-data":aee,"tfjs-layers":see,"tfjs-converter":iee,"tfjs-backend-cpu":oee,"tfjs-backend-webgl":lee,"tfjs-backend-wasm":uee},pee={};function dee(e,t,n=!1){if(e.beginPath(),t.slice(1).forEach((({x:n,y:r},a)=>{let s=t[a];e.moveTo(s.x,s.y),e.lineTo(n,r)})),n){let n=t[t.length-1],r=t[0];if(!n||!r)return;e.moveTo(n.x,n.y),e.lineTo(r.x,r.y)}e.stroke()}o(pee,{AnchorPosition:()=>ote,DrawBox:()=>pte,DrawBoxOptions:()=>cte,DrawFaceLandmarks:()=>cne,DrawFaceLandmarksOptions:()=>une,DrawTextField:()=>ute,DrawTextFieldOptions:()=>lte,drawContour:()=>dee,drawDetections:()=>dte,drawFaceExpressions:()=>sne,drawFaceLandmarks:()=>pne});var hee={};o(hee,{computeReshapedDimensions:()=>See,getCenterPoint:()=>Nee,isDimensions:()=>Iee,isEven:()=>vee,isFloat:()=>xee,isTensor:()=>mee,isTensor1D:()=>gee,isTensor2D:()=>yee,isTensor3D:()=>bee,isTensor4D:()=>wee,isValidNumber:()=>_ee,isValidProbablitiy:()=>Cee,range:()=>Tee,round:()=>kee});var fee=class{constructor(e,t){if(!_ee(e)||!_ee(t))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:e,height:t})}`);this._width=e,this._height=t}get width(){return this._width}get height(){return this._height}reverse(){return new fee(1/this.width,1/this.height)}};function mee(e,t){return e instanceof ys&&e.shape.length===t}function gee(e){return mee(e,1)}function yee(e){return mee(e,2)}function bee(e){return mee(e,3)}function wee(e){return mee(e,4)}function xee(e){return e%1!==0}function vee(e){return e%2===0}function kee(e,t=2){let n=10**t;return Math.floor(e*n)/n}function Iee(e){return e&&e.width&&e.height}function See({width:e,height:t},n){let r=n/Math.max(t,e);return new fee(Math.round(e*r),Math.round(t*r))}function Nee(e){return e.reduce(((e,t)=>e.add(t)),new Eee(0,0)).div(new Eee(e.length,e.length))}function Tee(e,t,n){return Array(e).fill(0).map(((e,r)=>t+r*n))}function _ee(e){return!!e&&e!==1/0&&e!==-1/0&&!Number.isNaN(e)||0===e}function Cee(e){return _ee(e)&&e>=0&&e<=1}var Eee=class{constructor(e,t){this._x=e,this._y=t}get x(){return this._x}get y(){return this._y}add(e){return new Eee(this.x+e.x,this.y+e.y)}sub(e){return new Eee(this.x-e.x,this.y-e.y)}mul(e){return new Eee(this.x*e.x,this.y*e.y)}div(e){return new Eee(this.x/e.x,this.y/e.y)}abs(){return new Eee(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new Eee(Math.floor(this.x),Math.floor(this.y))}},Aee=class{static isRect(e){return!!e&&[e.x,e.y,e.width,e.height].every(_ee)}static assertIsValidBox(e,t,n=!1){if(!Aee.isRect(e))throw new Error(`${t} - invalid box: ${JSON.stringify(e)}, expected object with properties x, y, width, height`);if(!n&&(e.width<0||e.height<0))throw new Error(`${t} - width (${e.width}) and height (${e.height}) must be positive numbers`)}constructor(e,t=!0){let n=e||{},r=[n.left,n.top,n.right,n.bottom].every(_ee),a=[n.x,n.y,n.width,n.height].every(_ee);if(!a&&!r)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(n)}`);let[s,i,o,l]=a?[n.x,n.y,n.width,n.height]:[n.left,n.top,n.right-n.left,n.bottom-n.top];Aee.assertIsValidBox({x:s,y:i,width:o,height:l},"Box.constructor",t),this._x=s,this._y=i,this._width=o,this._height=l}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new Eee(this.left,this.top)}get topRight(){return new Eee(this.right,this.top)}get bottomLeft(){return new Eee(this.left,this.bottom)}get bottomRight(){return new Eee(this.right,this.bottom)}round(){let[e,t,n,r]=[this.x,this.y,this.width,this.height].map((e=>Math.round(e)));return new Aee({x:e,y:t,width:n,height:r})}floor(){let[e,t,n,r]=[this.x,this.y,this.width,this.height].map((e=>Math.floor(e)));return new Aee({x:e,y:t,width:n,height:r})}toSquare(){let{x:e,y:t,width:n,height:r}=this,a=Math.abs(n-r);return n<r&&(e-=a/2,n+=a),r<n&&(t-=a/2,r+=a),new Aee({x:e,y:t,width:n,height:r})}rescale(e){let t=Iee(e)?e.width:e,n=Iee(e)?e.height:e;return new Aee({x:this.x*t,y:this.y*n,width:this.width*t,height:this.height*n})}pad(e,t){let[n,r,a,s]=[this.x-e/2,this.y-t/2,this.width+e,this.height+t];return new Aee({x:n,y:r,width:a,height:s})}clipAtImageBorders(e,t){let{x:n,y:r,right:a,bottom:s}=this,i=Math.max(n,0),o=Math.max(r,0),l=a-i,u=s-o,c=Math.min(l,e-i),p=Math.min(u,t-o);return new Aee({x:i,y:o,width:c,height:p}).floor()}shift(e,t){let{width:n,height:r}=this,a=this.x+e,s=this.y+t;return new Aee({x:a,y:s,width:n,height:r})}padAtBorders(e,t){let n=this.width+1,r=this.height+1,a=1,s=1,i=n,o=r,l=this.left,u=this.top,c=this.right,p=this.bottom;return c>t&&(i=-c+t+n,c=t),p>e&&(o=-p+e+r,p=e),l<1&&(o=2-l,l=1),u<1&&(o=2-u,u=1),{dy:s,edy:o,dx:a,edx:i,y:u,ey:p,x:l,ex:c,w:n,h:r}}calibrate(e){return new Aee({left:this.left+e.left*this.width,top:this.top+e.top*this.height,right:this.right+e.right*this.width,bottom:this.bottom+e.bottom*this.height}).toSquare().round()}},$ee=class extends Aee{constructor(e,t,n,r,a=!1){super({left:e,top:t,right:n,bottom:r},a)}},Fee=class{constructor(e,t,n,r,a){this._imageDims=new fee(a.width,a.height),this._score=e,this._classScore=t,this._className=n,this._box=new Aee(r).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new Aee(this._box).rescale(this.imageDims.reverse())}forSize(e,t){return new Fee(this.score,this.classScore,this.className,this.relativeBox,{width:e,height:t})}},Ree=class extends Fee{constructor(e,t,n){super(e,e,"",t,n)}forSize(e,t){let{score:n,relativeBox:r,imageDims:a}=super.forSize(e,t);return new Ree(n,r,a)}};function Dee(e,t,n=!0){let r=Math.max(0,Math.min(e.right,t.right)-Math.max(e.left,t.left)),a=Math.max(0,Math.min(e.bottom,t.bottom)-Math.max(e.top,t.top)),s=r*a;return n?s/(e.area+t.area-s):s/Math.min(e.area,t.area)}function Mee(e){let t=e.map((e=>e.x)),n=e.map((e=>e.y)),r=t.reduce(((e,t)=>t<e?t:e),1/0),a=n.reduce(((e,t)=>t<e?t:e),1/0),s=t.reduce(((e,t)=>e<t?t:e),0),i=n.reduce(((e,t)=>e<t?t:e),0);return new $ee(r,a,s,i)}function Oee(e,t,n,r=!0){let a=t.map(((e,t)=>({score:e,boxIndex:t}))).sort(((e,t)=>e.score-t.score)).map((e=>e.boxIndex)),s=[];for(;a.length>0;){let t=a.pop();s.push(t);let i=a,o=[];for(let n=0;n<i.length;n++){let a=i[n],s=e[t],l=e[a];o.push(Dee(s,l,r))}a=a.filter(((e,t)=>o[t]<=n))}return s}function Lee(e,t){return ul((()=>{let[n,r,a]=t,s=rh([...e.shape.slice(0,3),1],n,"float32"),i=rh([...e.shape.slice(0,3),1],r,"float32"),o=rh([...e.shape.slice(0,3),1],a,"float32"),l=Uc([s,i,o],3);return Uh(e,l)}))}function Pee(e,t=!1){return ul((()=>{let[n,r]=e.shape.slice(1);if(n===r)return e;let a=Math.abs(n-r),s=Math.round(a*(t?.5:1)),i=n>r?2:1,o=t=>{let n=e.shape.slice();return n[i]=t,rh(n,0,"float32")},l=o(s),u=a-l.shape[i],c=[t&&u?o(u):null,e,l].filter((e=>!!e)).map((e=>go(e,"float32")));return Uc(c,i)}))}function zee(e){return 1/(1+Math.exp(-e))}var Bee,Wee=class extends Aee{constructor(e,t,n,r,a=!1){super({x:e,y:t,width:n,height:r},a)}},Vee=.5,Uee=.43,Gee=.45,Hee=class{constructor(e,t,n=new Eee(0,0)){let{width:r,height:a}=t;this._imgDims=new fee(r,a),this._shift=n,this._positions=e.map((e=>e.mul(new Eee(r,a)).add(n)))}get shift(){return new Eee(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map((e=>e.sub(this._shift).div(new Eee(this.imageWidth,this.imageHeight))))}forSize(e,t){return new this.constructor(this.relativePositions,{width:e,height:t})}shiftBy(e,t){return new this.constructor(this.relativePositions,this._imgDims,new Eee(e,t))}shiftByPoint(e){return this.shiftBy(e.x,e.y)}align(e,t={}){if(e){let n=e instanceof Ree?e.box.floor():new Aee(e);return this.shiftBy(n.x,n.y).align(null,t)}let{useDlibAlignment:n,minBoxPadding:r}={useDlibAlignment:!1,minBoxPadding:.2,...t};return n?this.alignDlib():this.alignMinBbox(r)}alignDlib(){let e=this.getRefPointsForAlignment(),[t,n,r]=e,a=e=>r.sub(e).magnitude(),s=(a(t)+a(n))/2,i=Math.floor(s/Gee),o=Nee(e),l=Math.floor(Math.max(0,o.x-Vee*i)),u=Math.floor(Math.max(0,o.y-Uee*i));return new Wee(l,u,Math.min(i,this.imageWidth+l),Math.min(i,this.imageHeight+u))}alignMinBbox(e){let t=Mee(this.positions);return t.pad(t.width*e,t.height*e)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}},jee=class extends Hee{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(Nee)}};function qee(e){return e.detection instanceof Ree}function Kee(e,t){return{...e,detection:t}}function Xee(){let e=window.fetch;if(!e)throw new Error("fetch - missing fetch implementation for browser environment");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D:CanvasRenderingContext2D,Image:HTMLImageElement,ImageData:ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),createVideoElement:()=>document.createElement("video"),fetch:e,readFile:()=>{throw new Error("readFile - filesystem not available for browser environment")}}}function Yee(){return"object"==typeof n.g&&"undefined"!=typeof process&&null!=process.versions&&null!=process.versions.node}function Jee(e){let t="";if(!e&&Yee())try{e=i("fs")}catch(n){t=n.toString()}return{readFile:e?t=>new Promise(((n,r)=>{e.readFile(t,((e,t)=>e?r(e):n(t)))})):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${t}`)}}}function Zee(){let e=n.g.Canvas||n.g.HTMLCanvasElement,t=n.g.Image||n.g.HTMLImageElement,r=n.g.Video||n.g.HTMLVideoElement,a=()=>{if(e)return new e;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},s=()=>{if(t)return new t;throw new Error("createImageElement - missing Image implementation for nodejs environment")},i=()=>{if(r)return new r;throw new Error("createVideoElement - missing Video implementation for nodejs environment")},o=n.g.fetch,l=Jee();return{Canvas:e||class{},CanvasRenderingContext2D:n.g.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:n.g.ImageData||class{},Video:n.g.HTMLVideoElement||class{},createCanvasElement:a,createImageElement:s,createVideoElement:i,fetch:o,...l}}function Qee(){return"object"==typeof window&&"undefined"!=typeof document&&"undefined"!=typeof HTMLImageElement&&"undefined"!=typeof HTMLCanvasElement&&"undefined"!=typeof HTMLVideoElement&&"undefined"!=typeof ImageData&&"undefined"!=typeof CanvasRenderingContext2D}function ete(){if(!Bee)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return Bee}function tte(e){Bee=e}function nte(){return Qee()?tte(Xee()):Yee()?tte(Zee()):null}function rte(e){if(Bee||nte(),!Bee)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:t=Bee.Canvas,Image:n=Bee.Image}=e;Bee.Canvas=t,Bee.Image=n,Bee.createCanvasElement=e.createCanvasElement||(()=>new t),Bee.createImageElement=e.createImageElement||(()=>new n),Bee.ImageData=e.ImageData||Bee.ImageData,Bee.Video=e.Video||Bee.Video,Bee.fetch=e.fetch||Bee.fetch,Bee.readFile=e.readFile||Bee.readFile}var ate={getEnv:ete,setEnv:tte,initialize:nte,createBrowserEnv:Xee,createFileSystem:Jee,createNodejsEnv:Zee,monkeyPatch:rte,isBrowser:Qee,isNodejs:Yee};function ste(e){return ate.isNodejs()||"string"!=typeof e?e:document.getElementById(e)}function ite(e){let{Canvas:t,CanvasRenderingContext2D:n}=ate.getEnv();if(e instanceof n)return e;let r=ste(e);if(!(r instanceof t))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let a=r.getContext("2d");if(!a)throw new Error("resolveContext2d - canvas 2d context is null");return a}nte();var ote=(e=>(e.TOP_LEFT="TOP_LEFT",e.TOP_RIGHT="TOP_RIGHT",e.BOTTOM_LEFT="BOTTOM_LEFT",e.BOTTOM_RIGHT="BOTTOM_RIGHT",e))(ote||{}),lte=class{constructor(e={}){let{anchorPosition:t,backgroundColor:n,fontColor:r,fontSize:a,fontStyle:s,padding:i}=e;this.anchorPosition=t||"TOP_LEFT",this.backgroundColor=n||"rgba(0, 0, 0, 0.5)",this.fontColor=r||"rgba(255, 255, 255, 1)",this.fontSize=a||14,this.fontStyle=s||"Georgia",this.padding=i||4}},ute=class{constructor(e,t,n={}){this.text="string"==typeof e?[e]:e instanceof ute?e.text:e,this.anchor=t,this.options=new lte(n)}measureWidth(e){let{padding:t}=this.options;return this.text.map((t=>e.measureText(t).width)).reduce(((e,t)=>e<t?t:e),0)+2*t}measureHeight(){let{fontSize:e,padding:t}=this.options;return this.text.length*e+2*t}getUpperLeft(e,t){let{anchorPosition:n}=this.options,r="BOTTOM_RIGHT"===n||"TOP_RIGHT"===n,a="BOTTOM_LEFT"===n||"BOTTOM_RIGHT"===n,s=this.measureWidth(e),i=this.measureHeight(),o=r?this.anchor.x-s:this.anchor.x,l=a?this.anchor.y-i:this.anchor.y;if(t){let{width:e,height:n}=t,r=Math.max(Math.min(o,e-s),0),a=Math.max(Math.min(l,n-i),0);return{x:r,y:a}}return{x:o,y:l}}draw(e){let t=ste(e),n=ite(t),{backgroundColor:r,fontColor:a,fontSize:s,fontStyle:i,padding:o}=this.options;n.font=`${s}px ${i}`;let l=this.measureWidth(n),u=this.measureHeight();n.fillStyle=r;let c=this.getUpperLeft(n,t);n.fillRect(c.x,c.y,l,u),n.fillStyle=a,this.text.forEach(((e,t)=>{let r=o+c.x,a=o+c.y+(t+1)*s;n.fillText(e,r,a)}))}},cte=class{constructor(e={}){let{boxColor:t,lineWidth:n,label:r,drawLabelOptions:a}=e;this.boxColor=t||"rgba(0, 0, 255, 1)",this.lineWidth=n||2,this.label=r;let s={anchorPosition:"BOTTOM_LEFT",backgroundColor:this.boxColor};this.drawLabelOptions=new lte({...s,...a})}},pte=class{constructor(e,t={}){this.box=new Aee(e),this.options=new cte(t)}draw(e){let t=ite(e),{boxColor:n,lineWidth:r}=this.options,{x:a,y:s,width:i,height:o}=this.box;t.strokeStyle=n,t.lineWidth=r,t.strokeRect(a,s,i,o);let{label:l}=this.options;l&&new ute([l],{x:a-r/2,y:s},this.options.drawLabelOptions).draw(e)}};function dte(e,t){(Array.isArray(t)?t:[t]).forEach((t=>{let n=t instanceof Ree?t.score:qee(t)?t.detection.score:void 0,r=t instanceof Ree?t.box:qee(t)?t.detection.box:new Aee(t),a=n?`${kee(n)}`:void 0;new pte(r,{label:a}).draw(e)}))}function hte(e){let{Image:t,Video:n}=ate.getEnv();return e instanceof t&&e.complete||e instanceof n&&e.readyState>=3}function fte(e){return new Promise(((t,n)=>{function r(e){!e.currentTarget||(e.currentTarget.removeEventListener("load",a),e.currentTarget.removeEventListener("error",r),n(e))}function a(e){!e.currentTarget||(e.currentTarget.removeEventListener("load",a),e.currentTarget.removeEventListener("error",r),t(e))}(e instanceof ate.getEnv().Canvas||hte(e))&&t(null),e.addEventListener("load",a),e.addEventListener("error",r)}))}function mte(e){let{Image:t,Video:n}=ate.getEnv();return e instanceof t?new fee(e.naturalWidth,e.naturalHeight):e instanceof n?new fee(e.videoWidth,e.videoHeight):new fee(e.width,e.height)}function gte({width:e,height:t}){let{createCanvasElement:n}=ate.getEnv(),r=n();return r.width=e,r.height=t,r}function yte(e,t){let{ImageData:n}=ate.getEnv();if(!(e instanceof n)&&!hte(e))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:r,height:a}=t||mte(e),s=gte({width:r,height:a});return e instanceof n?ite(s).putImageData(e,0,0):ite(s).drawImage(e,0,0,r,a),s}async function bte(e,t){let n=t||ate.getEnv().createCanvasElement(),[r,a,s]=e.shape.slice(wee(e)?1:0),i=ul((()=>e.as3D(r,a,s).toInt()));return await Ll.toPixels(i,n),i.dispose(),n}function wte(e){let{Image:t,Canvas:n,Video:r}=ate.getEnv();return e instanceof t||e instanceof n||e instanceof r}function xte(e,t,n=!1){let{Image:r,Canvas:a}=ate.getEnv();if(!(e instanceof r||e instanceof a))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");if(t<=0)return gte({width:1,height:1});let s=mte(e),i=t/Math.max(s.height,s.width),o=i*s.width,l=i*s.height,u=gte({width:t,height:t}),c=e instanceof a?e:yte(e),p=Math.abs(o-l)/2,d=n&&o<l?p:0,h=n&&l<o?p:0;return c.width>0&&c.height>0&&ite(u).drawImage(c,d,h,o,l),u}var vte=class{constructor(e,t=!1){if(this._imageTensors=[],this._canvases=[],this._treatAsBatchInput=!1,this._inputDimensions=[],this._inputSize=0,!Array.isArray(e))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${e}`);this._treatAsBatchInput=t,this._batchSize=e.length,e.forEach(((e,t)=>{if(bee(e))return this._imageTensors[t]=e,void(this._inputDimensions[t]=e.shape);if(wee(e)){let n=e.shape[0];if(1!==n)throw new Error(`NetInput - tf.Tensor4D with batchSize ${n} passed, but not supported in input array`);return this._imageTensors[t]=e,void(this._inputDimensions[t]=e.shape.slice(1))}let n=e instanceof ate.getEnv().Canvas?e:yte(e);this._canvases[t]=n,this._inputDimensions[t]=[n.height,n.width,3]}))}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return Tee(this.batchSize,0,1).map(((e,t)=>this.getReshapedInputDimensions(t)))}getInput(e){return this.canvases[e]||this.imageTensors[e]}getInputDimensions(e){return this._inputDimensions[e]}getInputHeight(e){return this._inputDimensions[e][0]}getInputWidth(e){return this._inputDimensions[e][1]}getReshapedInputDimensions(e){if("number"!=typeof this.inputSize)throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");let t=this.getInputWidth(e),n=this.getInputHeight(e);return See({width:t,height:n},this.inputSize)}toBatchTensor(e,t=!0){return this._inputSize=e,ul((()=>{let n=Tee(this.batchSize,0,1).map((n=>{let r=this.getInput(n);if(r instanceof ys){let n=wee(r)?r:Yd(r);return n=Pee(n,t),(n.shape[1]!==e||n.shape[2]!==e)&&(n=hw.resizeBilinear(n,[e,e],!1,!1)),n.as3D(e,e,3)}if(r instanceof ate.getEnv().Canvas)return Ll.fromPixels(xte(r,e,t));throw new Error(`toBatchTensor - at batchIdx ${n}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${r}`)}));return xg(n.map((e=>go(e,"float32")))).as4D(this.batchSize,e,e,3)}))}};async function kte(e){if(e instanceof vte)return e;let t=Array.isArray(e)?e:[e];if(!t.length)throw new Error("toNetInput - empty array passed as input");let n=t=>Array.isArray(e)?` at input index ${t}:`:"",r=t.map(ste);return r.forEach(((e,r)=>{if(!wte(e)&&!bee(e)&&!wee(e))throw"string"==typeof t[r]?new Error(`toNetInput -${n(r)} string passed, but could not resolve HTMLElement for element id ${t[r]}`):new Error(`toNetInput -${n(r)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(wee(e)){let t=e.shape[0];if(1!==t)throw new Error(`toNetInput -${n(r)} tf.Tensor4D with batchSize ${t} passed, but not supported in input array`)}})),await Promise.all(r.map((e=>wte(e)&&fte(e)))),new vte(r,Array.isArray(e))}async function Ite(e,t){let{Canvas:n}=ate.getEnv(),r=e;if(!(e instanceof n)){let t=await kte(e);if(t.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let a=t.getInput(0);r=a instanceof n?a:await bte(a)}let a=ite(r);return t.map((e=>e instanceof Ree?e.forSize(r.width,r.height).box.floor():e)).map((e=>e.clipAtImageBorders(r.width,r.height))).map((({x:e,y:t,width:n,height:r})=>{let s=gte({width:n,height:r});return n>0&&r>0&&ite(s).putImageData(a.getImageData(e,t,n,r),0,0),s}))}async function Ste(e,t){if(!bee(e)&&!wee(e))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(wee(e)&&e.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return ul((()=>{let[n,r,a]=e.shape.slice(wee(e)?1:0);return t.map((e=>e instanceof Ree?e.forSize(r,n).box:e)).map((e=>e.clipAtImageBorders(r,n))).filter((e=>e.width>0&&e.height>0)).map((({x:t,y:s,width:i,height:o})=>eg(e.as3D(n,r,a),[s,t,0],[o,i,a])))}))}async function Nte(e,t){let{fetch:n}=ate.getEnv(),r=await n(e,t);if(!(r.status<400))throw new Error(`failed to fetch: (${r.status}) ${r.statusText}, from url: ${r.url}`);return r}async function Tte(e){return(await Nte(e)).json()}function _te(e,t){let n=`${t}-weights_manifest.json`;if(!e)return{modelBaseUri:"",manifestUri:n};if("/"===e)return{modelBaseUri:"/",manifestUri:`/${n}`};let r=e.startsWith("http://")?"http://":e.startsWith("https://")?"https://":"";e=e.replace(r,"");let a=e.split("/").filter((e=>e)),s=e.endsWith(".json")?a[a.length-1]:n,i=r+(e.endsWith(".json")?a.slice(0,a.length-1):a).join("/");return i=e.startsWith("/")?`/${i}`:i,{modelBaseUri:i,manifestUri:"/"===i?`/${s}`:`${i}/${s}`}}async function Cte(e,t){let{manifestUri:n,modelBaseUri:r}=_te(e,t),a=await Tte(n);return vo.loadWeights(a,r)}function Ete(e,t,n=!1){let{width:r,height:a}=n?mte(t):t;return e.width=r,e.height=a,{width:r,height:a}}var Ate=class{constructor(e){this._params=void 0,this._paramMappings=[],this._name=e}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(e){let{obj:t,objProp:n}=this.traversePropertyPath(e);return t[n]}reassignParamFromPath(e,t){let{obj:n,objProp:r}=this.traversePropertyPath(e);n[r].dispose(),n[r]=t}getParamList(){return this._paramMappings.map((({paramPath:e})=>({path:e,tensor:this.getParamFromPath(e)})))}getTrainableParams(){return this.getParamList().filter((e=>e.tensor instanceof ws))}getFrozenParams(){return this.getParamList().filter((e=>!(e.tensor instanceof ws)))}variable(){this.getFrozenParams().forEach((({path:e,tensor:t})=>{this.reassignParamFromPath(e,t.variable())}))}freeze(){this.getTrainableParams().forEach((({path:e,tensor:t})=>{let n=si(t.dataSync());t.dispose(),this.reassignParamFromPath(e,n)}))}dispose(e=!0){this.getParamList().forEach((t=>{if(e&&t.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${t.path}`);t.tensor.dispose()})),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map((({tensor:e})=>Array.from(e.dataSync()))).reduce(((e,t)=>e.concat(t))))}async load(e){e instanceof Float32Array?this.extractWeights(e):await this.loadFromUri(e)}async loadFromUri(e){if(e&&"string"!=typeof e)throw new Error(`${this._name}.loadFromUri - expected model uri`);let t=await Cte(e,this.getDefaultModelName());this.loadFromWeightMap(t)}async loadFromDisk(e){if(e&&"string"!=typeof e)throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:t}=ate.getEnv(),{manifestUri:n,modelBaseUri:r}=_te(e,this.getDefaultModelName()),a=e=>Promise.all(e.map((e=>t(e).then((e=>e.buffer))))),s=vo.weightsLoaderFactory(a),i=JSON.parse((await t(n)).toString()),o=await s(i,r);this.loadFromWeightMap(o)}loadFromWeightMap(e){let{paramMappings:t,params:n}=this.extractParamsFromWeightMap(e);this._paramMappings=t,this._params=n}extractWeights(e){let{paramMappings:t,params:n}=this.extractParams(e);this._paramMappings=t,this._params=n}traversePropertyPath(e){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let t=e.split("/").reduce(((t,n)=>{if(!t.nextObj.hasOwnProperty(n))throw new Error(`traversePropertyPath - object does not have property ${n}, for path ${e}`);return{obj:t.nextObj,objProp:n,nextObj:t.nextObj[n]}}),{nextObj:this.params}),{obj:n,objProp:r}=t;if(!n||!r||!(n[r]instanceof ys))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${e}`);return{obj:n,objProp:r}}};function $te(e,t,n){return ul((()=>{let r=Bm(e,t.depthwise_filter,t.pointwise_filter,n,"same");return r=zu(r,t.bias),r}))}function Fte(e,t,n=!1){return ul((()=>{let r=xm(n?zu(Cp(e,t.conv0.filters,[2,2],"same"),t.conv0.bias):$te(e,t.conv0,[2,2])),a=$te(r,t.conv1,[1,1]),s=xm(zu(r,a)),i=$te(s,t.conv2,[1,1]);return xm(zu(r,zu(a,i)))}))}function Rte(e,t,n=!1,r=!0){return ul((()=>{let a=xm(n?zu(Cp(e,t.conv0.filters,r?[2,2]:[1,1],"same"),t.conv0.bias):$te(e,t.conv0,r?[2,2]:[1,1])),s=$te(a,t.conv1,[1,1]),i=xm(zu(a,s)),o=$te(i,t.conv2,[1,1]),l=xm(zu(a,zu(s,o))),u=$te(l,t.conv3,[1,1]);return xm(zu(a,zu(s,zu(o,u))))}))}function Dte(e,t,n="same",r=!1){return ul((()=>{let a=zu(Cp(e,t.filters,[1,1],n),t.bias);return r?xm(a):a}))}function Mte(e,t){Object.keys(e).forEach((n=>{t.some((e=>e.originalPath===n))||e[n].dispose()}))}function Ote(e,t){return(n,r,a,s)=>{let i=Eg(e(n*r*a*a),[a,a,n,r]),o=_g(e(r));return t.push({paramPath:`${s}/filters`},{paramPath:`${s}/bias`}),{filters:i,bias:o}}}function Lte(e,t){return(n,r,a)=>{let s=Cg(e(n*r),[n,r]),i=_g(e(r));return t.push({paramPath:`${a}/weights`},{paramPath:`${a}/bias`}),{weights:s,bias:i}}}var Pte=class{constructor(e,t,n){this.depthwise_filter=e,this.pointwise_filter=t,this.bias=n}};function zte(e,t){return(n,r,a)=>{let s=Eg(e(9*n),[3,3,n,1]),i=Eg(e(n*r),[1,1,n,r]),o=_g(e(r));return t.push({paramPath:`${a}/depthwise_filter`},{paramPath:`${a}/pointwise_filter`},{paramPath:`${a}/bias`}),new Pte(s,i,o)}}function Bte(e){return t=>{let n=e(`${t}/depthwise_filter`,4),r=e(`${t}/pointwise_filter`,4),a=e(`${t}/bias`,1);return new Pte(n,r,a)}}function Wte(e,t){return(n,r,a)=>{let s=e[n];if(!mee(s,r))throw new Error(`expected weightMap[${n}] to be a Tensor${r}D, instead have ${s}`);return t.push({originalPath:n,paramPath:a||n}),s}}function Vte(e){let t=e;function n(e){let n=t.slice(0,e);return t=t.slice(e),n}function r(){return t}return{extractWeights:n,getRemainingWeights:r}}function Ute(e,t){let n=Ote(e,t),r=zte(e,t);function a(e,t,a,s=!1){let i=s?n(e,t,3,`${a}/conv0`):r(e,t,`${a}/conv0`),o=r(t,t,`${a}/conv1`),l=r(t,t,`${a}/conv2`);return{conv0:i,conv1:o,conv2:l}}function s(e,t,n,s=!1){let{conv0:i,conv1:o,conv2:l}=a(e,t,n,s),u=r(t,t,`${n}/conv3`);return{conv0:i,conv1:o,conv2:l,conv3:u}}return{extractDenseBlock3Params:a,extractDenseBlock4Params:s}}function Gte(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Vte(e),{extractDenseBlock4Params:a}=Ute(n,t),s=a(3,32,"dense0",!0),i=a(32,64,"dense1"),o=a(64,128,"dense2"),l=a(128,256,"dense3");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o,dense3:l}}}function Hte(e){return t=>{let n=e(`${t}/filters`,4),r=e(`${t}/bias`,1);return{filters:n,bias:r}}}function jte(e,t){let n=Wte(e,t),r=Hte(n),a=Bte(n);function s(e,t=!1){let n=t?r(`${e}/conv0`):a(`${e}/conv0`),s=a(`${e}/conv1`),i=a(`${e}/conv2`);return{conv0:n,conv1:s,conv2:i}}function i(e,t=!1){let n=t?r(`${e}/conv0`):a(`${e}/conv0`),s=a(`${e}/conv1`),i=a(`${e}/conv2`),o=a(`${e}/conv3`);return{conv0:n,conv1:s,conv2:i,conv3:o}}return{extractDenseBlock3Params:s,extractDenseBlock4Params:i}}function qte(e){let t=[],{extractDenseBlock4Params:n}=jte(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2"),dense3:n("dense3")};return Mte(e,t),{params:r,paramMappings:t}}var Kte=class extends Ate{constructor(){super("FaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceFeatureExtractor - load model before inference");return ul((()=>{let n=go(e.toBatchTensor(112,!0),"float32"),r=Lee(n,[122.782,117.001,104.298]).div(255),a=Rte(r,t.dense0,!0);return a=Rte(a,t.dense1),a=Rte(a,t.dense2),a=Rte(a,t.dense3),a=zc(a,[7,7],[2,2],"valid"),a}))}async forward(e){return this.forwardInput(await kte(e))}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeightMap(e){return qte(e)}extractParams(e){return Gte(e)}};function Xte(e,t){return ul((()=>zu(Zo(e,t.weights),t.bias)))}function Yte(e,t,n){let r=[],{extractWeights:a,getRemainingWeights:s}=Vte(e),i=Lte(a,r)(t,n,"fc");if(0!==s().length)throw new Error(`weights remaing after extract: ${s().length}`);return{paramMappings:r,params:{fc:i}}}function Jte(e){let t=[],n=Wte(e,t);function r(e){let t=n(`${e}/weights`,2),r=n(`${e}/bias`,1);return{weights:t,bias:r}}let a={fc:r("fc")};return Mte(e,t),{params:a,paramMappings:t}}function Zte(e){let t={},n={};return Object.keys(e).forEach((r=>{let a=r.startsWith("fc")?n:t;a[r]=e[r]})),{featureExtractorMap:t,classifierMap:n}}var Qte=class extends Ate{constructor(e,t){super(e),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return ul((()=>{let n=e instanceof vte?this.faceFeatureExtractor.forwardInput(e):e;return Xte(n.as2D(n.shape[0],-1),t.fc)}))}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return Yte(e,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=Zte(e);return this.faceFeatureExtractor.loadFromWeightMap(t),Jte(n)}extractParams(e){let t=this.getClassifierChannelsIn(),n=this.getClassifierChannelsOut(),r=n*t+n,a=e.slice(0,e.length-r),s=e.slice(e.length-r);return this.faceFeatureExtractor.extractWeights(a),this.extractClassifierParams(s)}},ene=["neutral","happy","sad","angry","fearful","disgusted","surprised"],tne=class{constructor(e){if(this.neutral=0,this.happy=0,this.sad=0,this.angry=0,this.fearful=0,this.disgusted=0,this.surprised=0,7!==e.length)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${e.length}`);ene.forEach(((t,n)=>{this[t]=e[n]}))}asSortedArray(){return ene.map((e=>({expression:e,probability:this[e]}))).sort(((e,t)=>t.probability-e.probability))}},nne=class extends Qte{constructor(e=new Kte){super("FaceExpressionNet",e)}forwardInput(e){return ul((()=>ag(this.runNet(e))))}async forward(e){return this.forwardInput(await kte(e))}async predictExpressions(e){let t=await kte(e),n=await this.forwardInput(t),r=await Promise.all(Wg(n).map((async e=>{let t=e.dataSync();return e.dispose(),t})));n.dispose();let a=r.map((e=>new tne(e)));return t.isBatchInput?a:a[0]}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}};function rne(e){return e.expressions instanceof tne}function ane(e,t){return{...e,expressions:t}}function sne(e,t,n=.1,r){(Array.isArray(t)?t:[t]).forEach((t=>{let a=t instanceof tne?t:rne(t)?t.expressions:void 0;if(!a)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let s=a.asSortedArray().filter((e=>e.probability>n)),i=qee(t)?t.detection.box.bottomLeft:r||new Eee(0,0);new ute(s.map((e=>`${e.expression} (${kee(e.probability)})`)),i).draw(e)}))}function ine(e){return qee(e)&&e.landmarks instanceof Hee&&e.unshiftedLandmarks instanceof Hee&&e.alignedRect instanceof Ree}function one(e){let t=(e,t,n,r)=>Math.atan2(r-t,n-e)%Math.PI,n={roll:void 0,pitch:void 0,yaw:void 0};if(!e||!e._positions||68!==e._positions.length)return n;let r=e._positions;n.roll=-t(r[36]._x,r[36]._y,r[45]._x,r[45]._y),n.pitch=t(0,Math.abs(r[0]._x-r[30]._x)/r[30]._x,Math.PI,Math.abs(r[16]._x-r[30]._x)/r[30]._x);let a=r.reduce(((e,t)=>e<t._y?e:t._y),1/0),s=r.reduce(((e,t)=>e>t._y?e:t._y),-1/0);return n.yaw=Math.PI*(e._imgDims._height/(s-a)/1.4-1),n}function lne(e,t){let{box:n}=e.detection,r=t.shiftBy(n.x,n.y),a=r.align(),{imageDims:s}=e.detection,i=new Ree(e.detection.score,a.rescale(s.reverse()),s),o=one(t);return{...e,landmarks:r,unshiftedLandmarks:t,alignedRect:i,angle:o}}var une=class{constructor(e={}){let{drawLines:t=!0,drawPoints:n=!0,lineWidth:r,lineColor:a,pointSize:s,pointColor:i}=e;this.drawLines=t,this.drawPoints=n,this.lineWidth=r||1,this.pointSize=s||2,this.lineColor=a||"rgba(0, 255, 255, 1)",this.pointColor=i||"rgba(255, 0, 255, 1)"}},cne=class{constructor(e,t={}){this.faceLandmarks=e,this.options=new une(t)}draw(e){let t=ite(e),{drawLines:n,drawPoints:r,lineWidth:a,lineColor:s,pointSize:i,pointColor:o}=this.options;if(n&&this.faceLandmarks instanceof jee&&(t.strokeStyle=s,t.lineWidth=a,dee(t,this.faceLandmarks.getJawOutline()),dee(t,this.faceLandmarks.getLeftEyeBrow()),dee(t,this.faceLandmarks.getRightEyeBrow()),dee(t,this.faceLandmarks.getNose()),dee(t,this.faceLandmarks.getLeftEye(),!0),dee(t,this.faceLandmarks.getRightEye(),!0),dee(t,this.faceLandmarks.getMouth(),!0)),r){t.strokeStyle=o,t.fillStyle=o;let e=e=>{t.beginPath(),t.arc(e.x,e.y,i,0,2*Math.PI),t.fill()};this.faceLandmarks.positions.forEach(e)}}};function pne(e,t){(Array.isArray(t)?t:[t]).forEach((t=>{let n=t instanceof Hee?t:ine(t)?t.landmarks:void 0;if(!n)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new cne(n).draw(e)}))}function dne(e,t){let n=Ote(e,t),r=zte(e,t);function a(e,t,a){let s=r(e,t,`${a}/separable_conv0`),i=r(t,t,`${a}/separable_conv1`),o=n(e,t,1,`${a}/expansion_conv`);return{separable_conv0:s,separable_conv1:i,expansion_conv:o}}function s(e,t){let n=r(e,e,`${t}/separable_conv0`),a=r(e,e,`${t}/separable_conv1`),s=r(e,e,`${t}/separable_conv2`);return{separable_conv0:n,separable_conv1:a,separable_conv2:s}}return{extractConvParams:n,extractSeparableConvParams:r,extractReductionBlockParams:a,extractMainBlockParams:s}}function hne(e,t){let n=[],{extractWeights:r,getRemainingWeights:a}=Vte(e),{extractConvParams:s,extractSeparableConvParams:i,extractReductionBlockParams:o,extractMainBlockParams:l}=dne(r,n),u=s(3,32,3,"entry_flow/conv_in"),c=o(32,64,"entry_flow/reduction_block_0"),p=o(64,128,"entry_flow/reduction_block_1"),d={conv_in:u,reduction_block_0:c,reduction_block_1:p},h={};Tee(t,0,1).forEach((e=>{h[`main_block_${e}`]=l(128,`middle_flow/main_block_${e}`)}));let f=o(128,256,"exit_flow/reduction_block"),m=i(256,512,"exit_flow/separable_conv"),g={reduction_block:f,separable_conv:m};if(0!==a().length)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:n,params:{entry_flow:d,middle_flow:h,exit_flow:g}}}function fne(e,t){let n=Wte(e,t),r=Hte(n),a=Bte(n);function s(e){let t=a(`${e}/separable_conv0`),n=a(`${e}/separable_conv1`),s=r(`${e}/expansion_conv`);return{separable_conv0:t,separable_conv1:n,expansion_conv:s}}function i(e){let t=a(`${e}/separable_conv0`),n=a(`${e}/separable_conv1`),r=a(`${e}/separable_conv2`);return{separable_conv0:t,separable_conv1:n,separable_conv2:r}}return{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:s,extractMainBlockParams:i}}function mne(e,t){let n=[],{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:s,extractMainBlockParams:i}=fne(e,n),o=r("entry_flow/conv_in"),l=s("entry_flow/reduction_block_0"),u=s("entry_flow/reduction_block_1"),c={conv_in:o,reduction_block_0:l,reduction_block_1:u},p={};Tee(t,0,1).forEach((e=>{p[`main_block_${e}`]=i(`middle_flow/main_block_${e}`)}));let d=s("exit_flow/reduction_block"),h=a("exit_flow/separable_conv"),f={reduction_block:d,separable_conv:h};return Mte(e,n),{params:{entry_flow:c,middle_flow:p,exit_flow:f},paramMappings:n}}function gne(e,t,n){return zu(Cp(e,t.filters,n,"same"),t.bias)}function yne(e,t,n=!0){let r=n?xm(e):e;return r=$te(r,t.separable_conv0,[1,1]),r=$te(xm(r),t.separable_conv1,[1,1]),r=lf(r,[3,3],[2,2],"same"),r=zu(r,gne(e,t.expansion_conv,[2,2])),r}function bne(e,t){let n=$te(xm(e),t.separable_conv0,[1,1]);return n=$te(xm(n),t.separable_conv1,[1,1]),n=$te(xm(n),t.separable_conv2,[1,1]),n=zu(n,e),n}var wne=class extends Ate{constructor(e){super("TinyXception"),this._numMainBlocks=e}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyXception - load model before inference");return ul((()=>{let n=go(e.toBatchTensor(112,!0),"float32"),r=Lee(n,[122.782,117.001,104.298]).div(255),a=xm(gne(r,t.entry_flow.conv_in,[2,2]));return a=yne(a,t.entry_flow.reduction_block_0,!1),a=yne(a,t.entry_flow.reduction_block_1),Tee(this._numMainBlocks,0,1).forEach((e=>{a=bne(a,t.middle_flow[`main_block_${e}`])})),a=yne(a,t.exit_flow.reduction_block),a=xm($te(a,t.exit_flow.separable_conv,[1,1])),a}))}async forward(e){return this.forwardInput(await kte(e))}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeightMap(e){return mne(e,this._numMainBlocks)}extractParams(e){return hne(e,this._numMainBlocks)}};function xne(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Vte(e),a=Lte(n,t),s=a(512,1,"fc/age"),i=a(512,2,"fc/gender");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{fc:{age:s,gender:i}}}}function vne(e){let t=[],n=Wte(e,t);function r(e){let t=n(`${e}/weights`,2),r=n(`${e}/bias`,1);return{weights:t,bias:r}}let a={fc:{age:r("fc/age"),gender:r("fc/gender")}};return Mte(e,t),{params:a,paramMappings:t}}var kne=(e=>(e.FEMALE="female",e.MALE="male",e))(kne||{}),Ine=class extends Ate{constructor(e=new wne(2)){super("AgeGenderNet"),this._faceFeatureExtractor=e}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return ul((()=>{let n=e instanceof vte?this.faceFeatureExtractor.forwardInput(e):e,r=zc(n,[7,7],[2,2],"valid").as2D(n.shape[0],-1),a=Xte(r,t.fc.age).as1D(),s=Xte(r,t.fc.gender);return{age:a,gender:s}}))}forwardInput(e){return ul((()=>{let{age:t,gender:n}=this.runNet(e);return{age:t,gender:ag(n)}}))}async forward(e){return this.forwardInput(await kte(e))}async predictAgeAndGender(e){let t=await kte(e),n=await this.forwardInput(t),r=Wg(n.age),a=Wg(n.gender),s=r.map(((e,t)=>({ageTensor:e,genderTensor:a[t]}))),i=await Promise.all(s.map((async({ageTensor:e,genderTensor:t})=>{let n=e.dataSync()[0],r=t.dataSync()[0],a=r>.5,s=a?"male":"female",i=a?r:1-r;return e.dispose(),t.dispose(),{age:n,gender:s,genderProbability:i}})));return n.age.dispose(),n.gender.dispose(),t.isBatchInput?i:i[0]}getDefaultModelName(){return"age_gender_model"}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return xne(e)}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=Zte(e);return this.faceFeatureExtractor.loadFromWeightMap(t),vne(n)}extractParams(e){let t=e.slice(0,e.length-1539),n=e.slice(e.length-1539);return this.faceFeatureExtractor.extractWeights(t),this.extractClassifierParams(n)}},Sne=class extends Qte{postProcess(e,t,n){let r=n.map((({width:e,height:n})=>{let r=t/Math.max(n,e);return{width:e*r,height:n*r}})),a=r.length;return ul((()=>{let n=(e,t)=>xg([rh([68],e,"float32"),rh([68],t,"float32")],1).as2D(1,136).as1D(),s=(e,t)=>{let{width:n,height:a}=r[e];return t(n,a)?Math.abs(n-a)/2:0},i=e=>s(e,((e,t)=>e<t)),o=e=>s(e,((e,t)=>t<e));return e.mul(rh([a,136],t,"float32")).sub(xg(Array.from(Array(a),((e,t)=>n(i(t),o(t)))))).div(xg(Array.from(Array(a),((e,t)=>n(r[t].width,r[t].height)))))}))}forwardInput(e){return ul((()=>{let t=this.runNet(e);return this.postProcess(t,e.inputSize,e.inputDimensions.map((([e,t])=>({height:e,width:t}))))}))}async forward(e){return this.forwardInput(await kte(e))}async detectLandmarks(e){let t=await kte(e),n=ul((()=>Wg(this.forwardInput(t)))),r=await Promise.all(n.map((async(e,n)=>{let r=Array.from(e.dataSync()),a=r.filter(((e,t)=>vee(t))),s=r.filter(((e,t)=>!vee(t)));return new jee(Array(68).fill(0).map(((e,t)=>new Eee(a[t],s[t]))),{height:t.getInputHeight(n),width:t.getInputWidth(n)})})));return n.forEach((e=>e.dispose())),t.isBatchInput?r:r[0]}getClassifierChannelsOut(){return 136}},Nne=class extends Sne{constructor(e=new Kte){super("FaceLandmark68Net",e)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}};function Tne(e){let t=[],{extractDenseBlock3Params:n}=jte(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2")};return Mte(e,t),{params:r,paramMappings:t}}function _ne(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Vte(e),{extractDenseBlock3Params:a}=Ute(n,t),s=a(3,32,"dense0",!0),i=a(32,64,"dense1"),o=a(64,128,"dense2");if(0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:s,dense1:i,dense2:o}}}var Cne=class extends Ate{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyFaceFeatureExtractor - load model before inference");return ul((()=>{let n=go(e.toBatchTensor(112,!0),"float32"),r=Lee(n,[122.782,117.001,104.298]).div(255),a=Fte(r,t.dense0,!0);return a=Fte(a,t.dense1),a=Fte(a,t.dense2),a=zc(a,[14,14],[2,2],"valid"),a}))}async forward(e){return this.forwardInput(await kte(e))}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeightMap(e){return Tne(e)}extractParams(e){return _ne(e)}},Ene=class extends Sne{constructor(e=new Cne){super("FaceLandmark68TinyNet",e)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}};function Ane(e,t){return zu(Hu(e,t.weights),t.biases)}function $ne(e,t,n,r,a="same"){let{filters:s,bias:i}=t.conv,o=Cp(e,s,n,a);return o=zu(o,i),o=Ane(o,t.scale),r?xm(o):o}function Fne(e,t){return $ne(e,t,[1,1],!0)}function Rne(e,t){return $ne(e,t,[1,1],!1)}function Dne(e,t){return $ne(e,t,[2,2],!0,"valid")}function Mne(e,t){function n(t,n,r){let a=e(t),s=a.length/(n*r*r);if(xee(s))throw new Error(`depth has to be an integer: ${s}, weights.length: ${a.length}, numFilters: ${n}, filterSize: ${r}`);return ul((()=>El(Eg(a,[n,s,r,r]),[2,3,1,0])))}function r(r,a,s,i){let o=n(r,a,s),l=_g(e(a));return t.push({paramPath:`${i}/filters`},{paramPath:`${i}/bias`}),{filters:o,bias:l}}function a(n,r){let a=_g(e(n)),s=_g(e(n));return t.push({paramPath:`${r}/weights`},{paramPath:`${r}/biases`}),{weights:a,biases:s}}function s(e,t,n,s){let i=r(e,t,n,`${s}/conv`),o=a(t,`${s}/scale`);return{conv:i,scale:o}}function i(e,t,n,r,a=!1){let i=s((a?.5:1)*e,t,n,`${r}/conv1`),o=s(e,t,n,`${r}/conv2`);return{conv1:i,conv2:o}}return{extractConvLayerParams:s,extractResidualLayerParams:i}}function One(e){let{extractWeights:t,getRemainingWeights:n}=Vte(e),r=[],{extractConvLayerParams:a,extractResidualLayerParams:s}=Mne(t,r),i=a(4704,32,7,"conv32_down"),o=s(9216,32,3,"conv32_1"),l=s(9216,32,3,"conv32_2"),u=s(9216,32,3,"conv32_3"),c=s(36864,64,3,"conv64_down",!0),p=s(36864,64,3,"conv64_1"),d=s(36864,64,3,"conv64_2"),h=s(36864,64,3,"conv64_3"),f=s(147456,128,3,"conv128_down",!0),m=s(147456,128,3,"conv128_1"),g=s(147456,128,3,"conv128_2"),y=s(589824,256,3,"conv256_down",!0),b=s(589824,256,3,"conv256_1"),w=s(589824,256,3,"conv256_2"),x=s(589824,256,3,"conv256_down_out"),v=ul((()=>El(Cg(t(32768),[128,256]),[1,0])));if(r.push({paramPath:"fc"}),0!==n().length)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{conv32_down:i,conv32_1:o,conv32_2:l,conv32_3:u,conv64_down:c,conv64_1:p,conv64_2:d,conv64_3:h,conv128_down:f,conv128_1:m,conv128_2:g,conv256_down:y,conv256_1:b,conv256_2:w,conv256_down_out:x,fc:v},paramMappings:r}}function Lne(e,t){let n=Wte(e,t);function r(e){let t=n(`${e}/scale/weights`,1),r=n(`${e}/scale/biases`,1);return{weights:t,biases:r}}function a(e){let t=n(`${e}/conv/filters`,4),a=n(`${e}/conv/bias`,1),s=r(e);return{conv:{filters:t,bias:a},scale:s}}function s(e){return{conv1:a(`${e}/conv1`),conv2:a(`${e}/conv2`)}}return{extractConvLayerParams:a,extractResidualLayerParams:s}}function Pne(e){let t=[],{extractConvLayerParams:n,extractResidualLayerParams:r}=Lne(e,t),a=n("conv32_down"),s=r("conv32_1"),i=r("conv32_2"),o=r("conv32_3"),l=r("conv64_down"),u=r("conv64_1"),c=r("conv64_2"),p=r("conv64_3"),d=r("conv128_down"),h=r("conv128_1"),f=r("conv128_2"),m=r("conv256_down"),g=r("conv256_1"),y=r("conv256_2"),b=r("conv256_down_out"),{fc:w}=e;if(t.push({originalPath:"fc",paramPath:"fc"}),!yee(w))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${w}`);let x={conv32_down:a,conv32_1:s,conv32_2:i,conv32_3:o,conv64_down:l,conv64_1:u,conv64_2:c,conv64_3:p,conv128_down:d,conv128_1:h,conv128_2:f,conv256_down:m,conv256_1:g,conv256_2:y,conv256_down_out:b,fc:w};return Mte(e,t),{params:x,paramMappings:t}}function zne(e,t){let n=Fne(e,t.conv1);return n=Rne(n,t.conv2),n=zu(n,e),n=xm(n),n}function Bne(e,t){let n=Dne(e,t.conv1);n=Rne(n,t.conv2);let r=zc(e,2,2,"valid"),a=yf(r.shape),s=r.shape[3]!==n.shape[3];if(r.shape[1]!==n.shape[1]||r.shape[2]!==n.shape[2]){let e=[...n.shape];e[1]=1;let t=yf(e);n=Uc([n,t],1);let r=[...n.shape];r[2]=1;let a=yf(r);n=Uc([n,a],2)}return r=s?Uc([r,a],3):r,n=zu(r,n),n=xm(n),n}var Wne=class extends Ate{constructor(){super("FaceRecognitionNet")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceRecognitionNet - load model before inference");return ul((()=>{let n=go(e.toBatchTensor(150,!0),"float32"),r=Lee(n,[122.782,117.001,104.298]).div(255),a=Dne(r,t.conv32_down);a=lf(a,3,2,"valid"),a=zne(a,t.conv32_1),a=zne(a,t.conv32_2),a=zne(a,t.conv32_3),a=Bne(a,t.conv64_down),a=zne(a,t.conv64_1),a=zne(a,t.conv64_2),a=zne(a,t.conv64_3),a=Bne(a,t.conv128_down),a=zne(a,t.conv128_1),a=zne(a,t.conv128_2),a=Bne(a,t.conv256_down),a=zne(a,t.conv256_1),a=zne(a,t.conv256_2),a=Bne(a,t.conv256_down_out);let s=a.mean([1,2]);return Zo(s,t.fc)}))}async forward(e){return this.forwardInput(await kte(e))}async computeFaceDescriptor(e){var t;if(null!=(t=null==e?void 0:e.shape)&&t.some((e=>e<=0)))return new Float32Array(128);let n=await kte(e),r=ul((()=>Wg(this.forwardInput(n)))),a=await Promise.all(r.map((e=>e.data())));return r.forEach((e=>e.dispose())),n.isBatchInput?a:a[0]}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeightMap(e){return Pne(e)}extractParams(e){return One(e)}};function Vne(e,t){return{...e,descriptor:t}}function Une(e,t){return{...e,age:t}}function Gne(e,t,n){return{...e,gender:t,genderProbability:n}}function Hne(e,t){function n(n,r){let a=Eg(e(9*n),[3,3,n,1]),s=_g(e(n)),i=_g(e(n)),o=_g(e(n)),l=_g(e(n));return t.push({paramPath:`${r}/filters`},{paramPath:`${r}/batch_norm_scale`},{paramPath:`${r}/batch_norm_offset`},{paramPath:`${r}/batch_norm_mean`},{paramPath:`${r}/batch_norm_variance`}),{filters:a,batch_norm_scale:s,batch_norm_offset:i,batch_norm_mean:o,batch_norm_variance:l}}function r(n,r,a,s,i){let o=Eg(e(n*r*a*a),[a,a,n,r]),l=_g(e(r));return t.push({paramPath:`${s}/filters`},{paramPath:`${s}/${i?"batch_norm_offset":"bias"}`}),{filters:o,bias:l}}function a(e,t,n,a){let{filters:s,bias:i}=r(e,t,n,a,!0);return{filters:s,batch_norm_offset:i}}function s(e,t,r){let s=n(e,`${r}/depthwise_conv`),i=a(e,t,1,`${r}/pointwise_conv`);return{depthwise_conv:s,pointwise_conv:i}}function i(){let e=a(3,32,3,"mobilenetv1/conv_0"),t=s(32,64,"mobilenetv1/conv_1"),n=s(64,128,"mobilenetv1/conv_2"),r=s(128,128,"mobilenetv1/conv_3"),i=s(128,256,"mobilenetv1/conv_4"),o=s(256,256,"mobilenetv1/conv_5"),l=s(256,512,"mobilenetv1/conv_6"),u=s(512,512,"mobilenetv1/conv_7"),c=s(512,512,"mobilenetv1/conv_8"),p=s(512,512,"mobilenetv1/conv_9"),d=s(512,512,"mobilenetv1/conv_10"),h=s(512,512,"mobilenetv1/conv_11"),f=s(512,1024,"mobilenetv1/conv_12"),m=s(1024,1024,"mobilenetv1/conv_13");return{conv_0:e,conv_1:t,conv_2:n,conv_3:r,conv_4:i,conv_5:o,conv_6:l,conv_7:u,conv_8:c,conv_9:p,conv_10:d,conv_11:h,conv_12:f,conv_13:m}}function o(){let e=a(1024,256,1,"prediction_layer/conv_0"),t=a(256,512,3,"prediction_layer/conv_1"),n=a(512,128,1,"prediction_layer/conv_2"),s=a(128,256,3,"prediction_layer/conv_3"),i=a(256,128,1,"prediction_layer/conv_4"),o=a(128,256,3,"prediction_layer/conv_5"),l=a(256,64,1,"prediction_layer/conv_6"),u=a(64,128,3,"prediction_layer/conv_7"),c=r(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),p=r(512,9,1,"prediction_layer/box_predictor_0/class_predictor"),d=r(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),h=r(1024,18,1,"prediction_layer/box_predictor_1/class_predictor"),f=r(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),m=r(512,18,1,"prediction_layer/box_predictor_2/class_predictor"),g=r(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),y=r(256,18,1,"prediction_layer/box_predictor_3/class_predictor"),b=r(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),w=r(256,18,1,"prediction_layer/box_predictor_4/class_predictor"),x=r(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),v=r(128,18,1,"prediction_layer/box_predictor_5/class_predictor");return{conv_0:e,conv_1:t,conv_2:n,conv_3:s,conv_4:i,conv_5:o,conv_6:l,conv_7:u,box_predictor_0:{box_encoding_predictor:c,class_predictor:p},box_predictor_1:{box_encoding_predictor:d,class_predictor:h},box_predictor_2:{box_encoding_predictor:f,class_predictor:m},box_predictor_3:{box_encoding_predictor:g,class_predictor:y},box_predictor_4:{box_encoding_predictor:b,class_predictor:w},box_predictor_5:{box_encoding_predictor:x,class_predictor:v}}}return{extractMobilenetV1Params:i,extractPredictionLayerParams:o}}function jne(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Vte(e),{extractMobilenetV1Params:a,extractPredictionLayerParams:s}=Hne(n,t),i=a(),o=s(),l={extra_dim:Pl(n(20472),[1,5118,4])};if(t.push({paramPath:"output_layer/extra_dim"}),0!==r().length)throw new Error(`weights remaing after extract: ${r().length}`);return{params:{mobilenetv1:i,prediction_layer:o,output_layer:l},paramMappings:t}}function qne(e,t){let n=Wte(e,t);function r(e,t,r){let a=n(`${e}/Conv2d_${t}_pointwise/weights`,4,`${r}/filters`),s=n(`${e}/Conv2d_${t}_pointwise/convolution_bn_offset`,1,`${r}/batch_norm_offset`);return{filters:a,batch_norm_offset:s}}function a(e){let t=`mobilenetv1/conv_${e}`,a=`MobilenetV1/Conv2d_${e}_depthwise`,s=`${t}/depthwise_conv`,i=`${t}/pointwise_conv`,o=n(`${a}/depthwise_weights`,4,`${s}/filters`),l=n(`${a}/BatchNorm/gamma`,1,`${s}/batch_norm_scale`),u=n(`${a}/BatchNorm/beta`,1,`${s}/batch_norm_offset`),c=n(`${a}/BatchNorm/moving_mean`,1,`${s}/batch_norm_mean`),p=n(`${a}/BatchNorm/moving_variance`,1,`${s}/batch_norm_variance`);return{depthwise_conv:{filters:o,batch_norm_scale:l,batch_norm_offset:u,batch_norm_mean:c,batch_norm_variance:p},pointwise_conv:r("MobilenetV1",e,i)}}function s(){return{conv_0:r("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:a(1),conv_2:a(2),conv_3:a(3),conv_4:a(4),conv_5:a(5),conv_6:a(6),conv_7:a(7),conv_8:a(8),conv_9:a(9),conv_10:a(10),conv_11:a(11),conv_12:a(12),conv_13:a(13)}}function i(e,t){let r=n(`${e}/weights`,4,`${t}/filters`),a=n(`${e}/biases`,1,`${t}/bias`);return{filters:r,bias:a}}function o(e){let t=i(`Prediction/BoxPredictor_${e}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${e}/box_encoding_predictor`),n=i(`Prediction/BoxPredictor_${e}/ClassPredictor`,`prediction_layer/box_predictor_${e}/class_predictor`);return{box_encoding_predictor:t,class_predictor:n}}function l(){return{conv_0:r("Prediction",0,"prediction_layer/conv_0"),conv_1:r("Prediction",1,"prediction_layer/conv_1"),conv_2:r("Prediction",2,"prediction_layer/conv_2"),conv_3:r("Prediction",3,"prediction_layer/conv_3"),conv_4:r("Prediction",4,"prediction_layer/conv_4"),conv_5:r("Prediction",5,"prediction_layer/conv_5"),conv_6:r("Prediction",6,"prediction_layer/conv_6"),conv_7:r("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:o(0),box_predictor_1:o(1),box_predictor_2:o(2),box_predictor_3:o(3),box_predictor_4:o(4),box_predictor_5:o(5)}}return{extractMobilenetV1Params:s,extractPredictionLayerParams:l}}function Kne(e){let t=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:r}=qne(e,t),a=e["Output/extra_dim"];if(t.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!bee(a))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${a}`);let s={mobilenetv1:n(),prediction_layer:r(),output_layer:{extra_dim:a}};return Mte(e,t),{params:s,paramMappings:t}}function Xne(e,t,n){return ul((()=>{let r=Cp(e,t.filters,n,"same");return r=zu(r,t.batch_norm_offset),bp(r,0,6)}))}var Yne=.0010000000474974513;function Jne(e,t,n){return ul((()=>{let r=ed(e,t.filters,n,"same");return r=np(r,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,Yne),bp(r,0,6)}))}function Zne(e){return[2,4,6,12].some((t=>t===e))?[2,2]:[1,1]}function Qne(e,t){return ul((()=>{let n,r=Xne(e,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach(((e,t)=>{let a=t+1,s=Zne(a);r=Jne(r,e.depthwise_conv,s),r=Xne(r,e.pointwise_conv,[1,1]),11===a&&(n=r)})),null===n)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:r,conv11:n}}))}function ere(e,t,n){let r=e.arraySync(),a=Math.min(r[t][0],r[t][2]),s=Math.min(r[t][1],r[t][3]),i=Math.max(r[t][0],r[t][2]),o=Math.max(r[t][1],r[t][3]),l=Math.min(r[n][0],r[n][2]),u=Math.min(r[n][1],r[n][3]),c=Math.max(r[n][0],r[n][2]),p=Math.max(r[n][1],r[n][3]),d=(i-a)*(o-s),h=(c-l)*(p-u);if(d<=0||h<=0)return 0;let f=Math.max(a,l),m=Math.max(s,u),g=Math.min(i,c),y=Math.min(o,p),b=Math.max(g-f,0)*Math.max(y-m,0);return b/(d+h-b)}function tre(e,t,n,r,a){let s=e.shape[0],i=Math.min(n,s),o=t.map(((e,t)=>({score:e,boxIndex:t}))).filter((e=>e.score>a)).sort(((e,t)=>t.score-e.score)),l=e=>e<=r?1:0,u=[];return o.forEach((t=>{if(u.length>=i)return;let n=t.score;for(let r=u.length-1;r>=0;--r){let n=ere(e,t.boxIndex,u[r]);if(0!==n&&(t.score*=l(n),t.score<=a))break}n===t.score&&u.push(t.boxIndex)})),u}function nre(e){let t=Wg(El(e,[1,0])),n=[Uh(t[2],t[0]),Uh(t[3],t[1])],r=[zu(t[0],Uu(n[0],2)),zu(t[1],Uu(n[1],2))];return{sizes:n,centers:r}}function rre(e,t){let{sizes:n,centers:r}=nre(e),a=Wg(El(t,[1,0])),s=Uu(Hu(Kd(Uu(a[2],5)),n[0]),2),i=zu(Hu(Uu(a[0],10),n[0]),r[0]),o=Uu(Hu(Kd(Uu(a[3],5)),n[1]),2),l=zu(Hu(Uu(a[1],10),n[1]),r[1]);return El(xg([Uh(i,s),Uh(l,o),zu(i,s),zu(l,o)]),[1,0])}function are(e,t,n){return ul((()=>{let r=e.shape[0],a=rre(Lc(eh(n.extra_dim,[r,1,1]),[-1,4]),Lc(e,[-1,4]));a=Lc(a,[r,a.shape[0]/r,4]);let s=Hc(qc(t,[0,0,1],[-1,-1,-1])),i=qc(s,[0,0,0],[-1,-1,1]);i=Lc(i,[r,i.shape[1]]);let o=Wg(a),l=Wg(i);return{boxes:o,scores:l}}))}function sre(e,t){return ul((()=>{let n=e.shape[0],r=Lc(Dte(e,t.box_encoding_predictor),[n,-1,1,4]),a=Lc(Dte(e,t.class_predictor),[n,-1,3]);return{boxPredictionEncoding:r,classPrediction:a}}))}function ire(e,t,n){return ul((()=>{let r=Xne(e,n.conv_0,[1,1]),a=Xne(r,n.conv_1,[2,2]),s=Xne(a,n.conv_2,[1,1]),i=Xne(s,n.conv_3,[2,2]),o=Xne(i,n.conv_4,[1,1]),l=Xne(o,n.conv_5,[2,2]),u=Xne(l,n.conv_6,[1,1]),c=Xne(u,n.conv_7,[2,2]),p=sre(t,n.box_predictor_0),d=sre(e,n.box_predictor_1),h=sre(a,n.box_predictor_2),f=sre(i,n.box_predictor_3),m=sre(l,n.box_predictor_4),g=sre(c,n.box_predictor_5),y=Uc([p.boxPredictionEncoding,d.boxPredictionEncoding,h.boxPredictionEncoding,f.boxPredictionEncoding,m.boxPredictionEncoding,g.boxPredictionEncoding],1),b=Uc([p.classPrediction,d.classPrediction,h.classPrediction,f.classPrediction,m.classPrediction,g.classPrediction],1);return{boxPredictions:y,classPredictions:b}}))}var ore=class{constructor({minConfidence:e,maxResults:t}={}){if(this._name="SsdMobilenetv1Options",this._minConfidence=e||.5,this._maxResults=t||100,"number"!=typeof this._minConfidence||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if("number"!=typeof this._maxResults)throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}},lre=class extends Ate{constructor(){super("SsdMobilenetv1")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("SsdMobilenetv1 - load model before inference");return ul((()=>{let n=go(e.toBatchTensor(512,!1),"float32"),r=Uh(Uu(n,127.5),1),a=Qne(r,t.mobilenetv1),{boxPredictions:s,classPredictions:i}=ire(a.out,a.conv11,t.prediction_layer);return are(s,i,t.output_layer)}))}async forward(e){return this.forwardInput(await kte(e))}async locateFaces(e,t={}){let{maxResults:n,minConfidence:r}=new ore(t),a=await kte(e),{boxes:s,scores:i}=this.forwardInput(a),o=s[0],l=i[0];for(let y=1;y<s.length;y++)s[y].dispose(),i[y].dispose();let u=Array.from(l.dataSync()),c=tre(o,u,n,.5,r),p=a.getReshapedInputDimensions(0),d=a.inputSize,h=d/p.width,f=d/p.height,m=o.arraySync(),g=c.map((e=>{let[t,n]=[Math.max(0,m[e][0]),Math.min(1,m[e][2])].map((e=>e*f)),[r,s]=[Math.max(0,m[e][1]),Math.min(1,m[e][3])].map((e=>e*h));return new Ree(u[e],new Wee(r,t,s-r,n-t),{height:a.getInputHeight(0),width:a.getInputWidth(0)})}));return o.dispose(),l.dispose(),g}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeightMap(e){return Kne(e)}extractParams(e){return jne(e)}};var ure=.4,cre=[new Eee(.738768,.874946),new Eee(2.42204,2.65704),new Eee(4.30971,7.04493),new Eee(10.246,4.59428),new Eee(12.6868,11.8741)],pre=[new Eee(1.603231,2.094468),new Eee(6.041143,7.080126),new Eee(2.882459,3.518061),new Eee(4.266906,5.178857),new Eee(9.041765,10.66308)],dre=[117.001,114.697,97.404],hre="tiny_yolov2_model",fre="tiny_yolov2_separable_conv_model",mre=e=>"number"==typeof e;function gre(e){if(!e)throw new Error(`invalid config: ${e}`);if("boolean"!=typeof e.withSeparableConvs)throw new Error(`config.withSeparableConvs has to be a boolean, have: ${e.withSeparableConvs}`);if(!mre(e.iouThreshold)||e.iouThreshold<0||e.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${e.iouThreshold}`);if(!Array.isArray(e.classes)||!e.classes.length||!e.classes.every((e=>"string"==typeof e)))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(e.classes)}`);if(!Array.isArray(e.anchors)||!e.anchors.length||!e.anchors.map((e=>e||{})).every((e=>mre(e.x)&&mre(e.y))))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(e.anchors)}`);if(e.meanRgb&&(!Array.isArray(e.meanRgb)||3!==e.meanRgb.length||!e.meanRgb.every(mre)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(e.meanRgb)}`)}function yre(e){return ul((()=>{let t=Hu(e,Md(.10000000149011612));return zu(xm(Uh(e,t)),t)}))}function bre(e,t){return ul((()=>{let n=zf(e,[[0,0],[1,1],[1,1],[0,0]]);return n=Cp(n,t.conv.filters,[1,1],"valid"),n=Uh(n,t.bn.sub),n=Hu(n,t.bn.truediv),n=zu(n,t.conv.bias),yre(n)}))}function wre(e,t){return ul((()=>{let n=zf(e,[[0,0],[1,1],[1,1],[0,0]]);return n=Bm(n,t.depthwise_filter,t.pointwise_filter,[1,1],"valid"),n=zu(n,t.bias),yre(n)}))}function xre(e,t){let n=Ote(e,t);function r(n,r){let a=_g(e(n)),s=_g(e(n));return t.push({paramPath:`${r}/sub`},{paramPath:`${r}/truediv`}),{sub:a,truediv:s}}function a(e,t,a){let s=n(e,t,3,`${a}/conv`),i=r(t,`${a}/bn`);return{conv:s,bn:i}}let s=zte(e,t);return{extractConvParams:n,extractConvWithBatchNormParams:a,extractSeparableConvParams:s}}function vre(e,t,n,r){let a,{extractWeights:s,getRemainingWeights:i}=Vte(e),o=[],{extractConvParams:l,extractConvWithBatchNormParams:u,extractSeparableConvParams:c}=xre(s,o);if(t.withSeparableConvs){let[e,s,i,o,u,p,d,h,f]=r,m=t.isFirstLayerConv2d?l(e,s,3,"conv0"):c(e,s,"conv0"),g=c(s,i,"conv1"),y=c(i,o,"conv2"),b=c(o,u,"conv3"),w=c(u,p,"conv4"),x=c(p,d,"conv5"),v=h?c(d,h,"conv6"):void 0,k=f?c(h,f,"conv7"):void 0,I=l(f||h||d,5*n,1,"conv8");a={conv0:m,conv1:g,conv2:y,conv3:b,conv4:w,conv5:x,conv6:v,conv7:k,conv8:I}}else{let[e,t,s,i,o,c,p,d,h]=r,f=u(e,t,"conv0"),m=u(t,s,"conv1"),g=u(s,i,"conv2"),y=u(i,o,"conv3"),b=u(o,c,"conv4"),w=u(c,p,"conv5"),x=u(p,d,"conv6"),v=u(d,h,"conv7"),k=l(h,5*n,1,"conv8");a={conv0:f,conv1:m,conv2:g,conv3:y,conv4:b,conv5:w,conv6:x,conv7:v,conv8:k}}if(0!==i().length)throw new Error(`weights remaing after extract: ${i().length}`);return{params:a,paramMappings:o}}function kre(e,t){let n=Wte(e,t);function r(e){let t=n(`${e}/sub`,1),r=n(`${e}/truediv`,1);return{sub:t,truediv:r}}function a(e){let t=n(`${e}/filters`,4),r=n(`${e}/bias`,1);return{filters:t,bias:r}}function s(e){let t=a(`${e}/conv`),n=r(`${e}/bn`);return{conv:t,bn:n}}let i=Bte(n);return{extractConvParams:a,extractConvWithBatchNormParams:s,extractSeparableConvParams:i}}function Ire(e,t){let n,r=[],{extractConvParams:a,extractConvWithBatchNormParams:s,extractSeparableConvParams:i}=kre(e,r);if(t.withSeparableConvs){let e=t.filterSizes&&t.filterSizes.length||9;n={conv0:t.isFirstLayerConv2d?a("conv0"):i("conv0"),conv1:i("conv1"),conv2:i("conv2"),conv3:i("conv3"),conv4:i("conv4"),conv5:i("conv5"),conv6:e>7?i("conv6"):void 0,conv7:e>8?i("conv7"):void 0,conv8:a("conv8")}}else n={conv0:s("conv0"),conv1:s("conv1"),conv2:s("conv2"),conv3:s("conv3"),conv4:s("conv4"),conv5:s("conv5"),conv6:s("conv6"),conv7:s("conv7"),conv8:a("conv8")};return Mte(e,r),{params:n,paramMappings:r}}var Sre=class{constructor({inputSize:e,scoreThreshold:t}={}){if(this._name="TinyYolov2Options",this._inputSize=e||416,this._scoreThreshold=t||.5,"number"!=typeof this._inputSize||this._inputSize%32!==0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if("number"!=typeof this._scoreThreshold||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}},Nre=class extends Ate{constructor(e){super("TinyYolov2"),gre(e),this._config=e}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(e,t){let n=bre(e,t.conv0);return n=lf(n,[2,2],[2,2],"same"),n=bre(n,t.conv1),n=lf(n,[2,2],[2,2],"same"),n=bre(n,t.conv2),n=lf(n,[2,2],[2,2],"same"),n=bre(n,t.conv3),n=lf(n,[2,2],[2,2],"same"),n=bre(n,t.conv4),n=lf(n,[2,2],[2,2],"same"),n=bre(n,t.conv5),n=lf(n,[2,2],[1,1],"same"),n=bre(n,t.conv6),n=bre(n,t.conv7),Dte(n,t.conv8,"valid",!1)}runMobilenet(e,t){let n=this.config.isFirstLayerConv2d?yre(Dte(e,t.conv0,"valid",!1)):wre(e,t.conv0);return n=lf(n,[2,2],[2,2],"same"),n=wre(n,t.conv1),n=lf(n,[2,2],[2,2],"same"),n=wre(n,t.conv2),n=lf(n,[2,2],[2,2],"same"),n=wre(n,t.conv3),n=lf(n,[2,2],[2,2],"same"),n=wre(n,t.conv4),n=lf(n,[2,2],[2,2],"same"),n=wre(n,t.conv5),n=lf(n,[2,2],[1,1],"same"),n=t.conv6?wre(n,t.conv6):n,n=t.conv7?wre(n,t.conv7):n,Dte(n,t.conv8,"valid",!1)}forwardInput(e,t){let{params:n}=this;if(!n)throw new Error("TinyYolov2 - load model before inference");return ul((()=>{let r=go(e.toBatchTensor(t,!1),"float32");return r=this.config.meanRgb?Lee(r,this.config.meanRgb):r,r=r.div(255),this.config.withSeparableConvs?this.runMobilenet(r,n):this.runTinyYolov2(r,n)}))}async forward(e,t){return this.forwardInput(await kte(e),t)}async detect(e,t={}){let{inputSize:n,scoreThreshold:r}=new Sre(t),a=await kte(e),s=await this.forwardInput(a,n),i=ul((()=>Wg(s)[0].expandDims())),o={width:a.getInputWidth(0),height:a.getInputHeight(0)},l=await this.extractBoxes(i,a.getReshapedInputDimensions(0),r);s.dispose(),i.dispose();let u=l.map((e=>e.box)),c=l.map((e=>e.score)),p=l.map((e=>e.classScore)),d=l.map((e=>this.config.classes[e.label]));return Oee(u.map((e=>e.rescale(n))),c,this.config.iouThreshold,!0).map((e=>new Fee(c[e],p[e],d[e],u[e],o)))}getDefaultModelName(){return""}extractParamsFromWeightMap(e){return Ire(e,this.config)}extractParams(e){let t=this.config.filterSizes||Nre.DEFAULT_FILTER_SIZES,n=t?t.length:void 0;if(7!==n&&8!==n&&9!==n)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${n} filterSizes in config`);return vre(e,this.config,this.boxEncodingSize,t)}async extractBoxes(e,t,n){let{width:r,height:a}=t,s=Math.max(r,a),i=s/r,o=s/a,l=e.shape[1],u=this.config.anchors.length,[c,p,d]=ul((()=>{let t=e.reshape([l,l,u,this.boxEncodingSize]),n=t.slice([0,0,0,0],[l,l,u,4]),r=t.slice([0,0,0,4],[l,l,u,1]),a=this.withClassScores?ag(t.slice([0,0,0,5],[l,l,u,this.config.classes.length]),3):Md(0);return[n,r,a]})),h=[],f=await p.array(),m=await c.array();for(let g=0;g<l;g++)for(let e=0;e<l;e++)for(let t=0;t<u;t++){let r=zee(f[g][e][t][0]);if(!n||r>n){let n=(e+zee(m[g][e][t][0]))/l*i,a=(g+zee(m[g][e][t][1]))/l*o,s=Math.exp(m[g][e][t][2])*this.config.anchors[t].x/l*i,u=Math.exp(m[g][e][t][3])*this.config.anchors[t].y/l*o,c=n-s/2,p=a-u/2,f={row:g,col:e,anchor:t},{classScore:y,label:b}=this.withClassScores?await this.extractPredictedClass(d,f):{classScore:1,label:0};h.push({box:new $ee(c,p,c+s,p+u),score:r,classScore:r*y,label:b,...f})}}return c.dispose(),p.dispose(),d.dispose(),h}async extractPredictedClass(e,t){let{row:n,col:r,anchor:a}=t,s=await e.array();return Array(this.config.classes.length).fill(0).map(((e,t)=>s[n][r][a][t])).map(((e,t)=>({classScore:e,label:t}))).reduce(((e,t)=>e.classScore>t.classScore?e:t))}},Tre=Nre;Tre.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var _re=class extends Tre{constructor(e=!0){let t={withSeparableConvs:e,iouThreshold:ure,classes:["face"],...e?{anchors:pre,meanRgb:dre}:{anchors:cre,withClassScores:!0}};super(t)}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map((e=>new Ree(e.score,e.relativeBox,{width:e.imageWidth,height:e.imageHeight})))}getDefaultModelName(){return this.withSeparableConvs?fre:hre}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}};var Cre=class extends Sre{constructor(){super(...arguments),this._name="TinyFaceDetectorOptions"}},Ere=class{async then(e){return e(await this.run())}async run(){throw new Error("ComposableTask - run is not implemented")}};async function Are(e,t,n,r,a=(({alignedRect:e})=>e)){let s=e.map((e=>ine(e)?a(e):e.detection)),i=r||(t instanceof ys?await Ste(t,s):await Ite(t,s)),o=await n(i);return i.forEach((e=>e instanceof ys&&e.dispose())),o}var $re=.4,Fre=[new Eee(1.603231,2.094468),new Eee(6.041143,7.080126),new Eee(2.882459,3.518061),new Eee(4.266906,5.178857),new Eee(9.041765,10.66308)],Rre=[117.001,114.697,97.404],Dre=class extends Tre{constructor(){let e={withSeparableConvs:!0,iouThreshold:$re,classes:["face"],anchors:Fre,meanRgb:Rre,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]};super(e)}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map((e=>new Ree(e.score,e.relativeBox,{width:e.imageWidth,height:e.imageHeight})))}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},Mre={ssdMobilenetv1:new lre,tinyFaceDetector:new Dre,tinyYolov2:new _re,faceLandmark68Net:new Nne,faceLandmark68TinyNet:new Ene,faceRecognitionNet:new Wne,faceExpressionNet:new nne,ageGenderNet:new Ine},Ore=class extends Ere{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},Lre=class extends Ore{async run(){let e=await this.parentTask,t=await Are(e,this.input,(async e=>Promise.all(e.map((e=>Mre.faceExpressionNet.predictExpressions(e))))),this.extractedFaces);return e.map(((e,n)=>ane(e,t[n])))}withAgeAndGender(){return new Bre(this,this.input)}},Pre=class extends Lre{withAgeAndGender(){return new Wre(this,this.input)}withFaceDescriptors(){return new Ure(this,this.input)}},zre=class extends Ere{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},Bre=class extends zre{async run(){let e=await this.parentTask,t=await Are(e,this.input,(async e=>Promise.all(e.map((e=>Mre.ageGenderNet.predictAgeAndGender(e))))),this.extractedFaces);return e.map(((e,n)=>{let{age:r,gender:a,genderProbability:s}=t[n];return Une(Gne(e,a,s),r)}))}withFaceExpressions(){return new Lre(this,this.input)}},Wre=class extends Bre{withFaceExpressions(){return new Pre(this,this.input)}withFaceDescriptors(){return new Ure(this,this.input)}},Vre=class extends Ere{constructor(e,t){super(),this.parentTask=e,this.input=t}},Ure=class extends Vre{async run(){let e=await this.parentTask;return(await Are(e,this.input,(e=>Promise.all(e.map((e=>Mre.faceRecognitionNet.computeFaceDescriptor(e))))),null,(e=>e.landmarks.align(null,{useDlibAlignment:!0})))).map(((t,n)=>Vne(e[n],t)))}withFaceExpressions(){return new Pre(this,this.input)}withAgeAndGender(){return new Wre(this,this.input)}},Gre=class extends Ere{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.useTinyLandmarkNet=n}get landmarkNet(){return this.useTinyLandmarkNet?Mre.faceLandmark68TinyNet:Mre.faceLandmark68Net}},Hre=class extends Gre{async run(){let e=await this.parentTask,t=e.map((e=>e.detection)),n=this.input instanceof ys?await Ste(this.input,t):await Ite(this.input,t),r=await Promise.all(n.map((e=>this.landmarkNet.detectLandmarks(e))));return n.forEach((e=>e instanceof ys&&e.dispose())),e.filter(((e,t)=>r[t])).map(((e,t)=>lne(e,r[t])))}withFaceExpressions(){return new Pre(this,this.input)}withAgeAndGender(){return new Wre(this,this.input)}withFaceDescriptors(){return new Ure(this,this.input)}},jre=class extends Ere{constructor(e,t=new ore){super(),this.input=e,this.options=t}},qre=class extends jre{async run(){let e,{input:t,options:n}=this;if(n instanceof Cre)e=Mre.tinyFaceDetector.locateFaces(t,n);else if(n instanceof ore)e=Mre.ssdMobilenetv1.locateFaces(t,n);else{if(!(n instanceof Sre))throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options");e=Mre.tinyYolov2.locateFaces(t,n)}return e}runAndExtendWithFaceDetections(){return new Promise(((e,t)=>{this.run().then((t=>e(t.map((e=>Kee({},e)))))).catch((e=>t(e)))}))}withFaceLandmarks(e=!1){return new Hre(this.runAndExtendWithFaceDetections(),this.input,e)}withFaceExpressions(){return new Lre(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new Bre(this.runAndExtendWithFaceDetections(),this.input)}};function Kre(e,t=new ore){return new qre(e,t)}function Xre(e,t){let{width:n,height:r}=new fee(t.width,t.height);if(n<=0||r<=0)throw new Error(`resizeResults - invalid dimensions: ${JSON.stringify({width:n,height:r})}`);if(Array.isArray(e))return e.map((e=>Xre(e,{width:n,height:r})));if(ine(e)){let t=e.detection.forSize(n,r),a=e.unshiftedLandmarks.forSize(t.box.width,t.box.height);return lne(Kee(e,t),a)}return qee(e)?Kee(e,e.detection.forSize(n,r)):e instanceof Hee||e instanceof Ree?e.forSize(n,r):e}},4870:function(e,t,n){"use strict";n.d(t,{Bj:function(){return s},Fl:function(){return ze},IU:function(){return Ce},Jd:function(){return I},PG:function(){return Se},Um:function(){return ve},WL:function(){return Le},X$:function(){return _},X3:function(){return _e},Xl:function(){return Ee},dq:function(){return De},j:function(){return N},lk:function(){return S},qj:function(){return xe},qq:function(){return w},yT:function(){return Te}});var r=n(7139);let a;class s{constructor(e=!1){this.active=!0,this.effects=[],this.cleanups=[],!e&&a&&(this.parent=a,this.index=(a.scopes||(a.scopes=[])).push(this)-1)}run(e){if(this.active){const t=a;try{return a=this,e()}finally{a=t}}else 0}on(){a=this}off(){a=this.parent}stop(e){if(this.active){let t,n;for(t=0,n=this.effects.length;t<n;t++)this.effects[t].stop();for(t=0,n=this.cleanups.length;t<n;t++)this.cleanups[t]();if(this.scopes)for(t=0,n=this.scopes.length;t<n;t++)this.scopes[t].stop(!0);if(this.parent&&!e){const e=this.parent.scopes.pop();e&&e!==this&&(this.parent.scopes[this.index]=e,e.index=this.index)}this.active=!1}}}function i(e,t=a){t&&t.active&&t.effects.push(e)}const o=e=>{const t=new Set(e);return t.w=0,t.n=0,t},l=e=>(e.w&f)>0,u=e=>(e.n&f)>0,c=({deps:e})=>{if(e.length)for(let t=0;t<e.length;t++)e[t].w|=f},p=e=>{const{deps:t}=e;if(t.length){let n=0;for(let r=0;r<t.length;r++){const a=t[r];l(a)&&!u(a)?a.delete(e):t[n++]=a,a.w&=~f,a.n&=~f}t.length=n}},d=new WeakMap;let h=0,f=1;const m=30;let g;const y=Symbol(""),b=Symbol("");class w{constructor(e,t=null,n){this.fn=e,this.scheduler=t,this.active=!0,this.deps=[],this.parent=void 0,i(this,n)}run(){if(!this.active)return this.fn();let e=g,t=v;while(e){if(e===this)return;e=e.parent}try{return this.parent=g,g=this,v=!0,f=1<<++h,h<=m?c(this):x(this),this.fn()}finally{h<=m&&p(this),f=1<<--h,g=this.parent,v=t,this.parent=void 0,this.deferStop&&this.stop()}}stop(){g===this?this.deferStop=!0:this.active&&(x(this),this.onStop&&this.onStop(),this.active=!1)}}function x(e){const{deps:t}=e;if(t.length){for(let n=0;n<t.length;n++)t[n].delete(e);t.length=0}}let v=!0;const k=[];function I(){k.push(v),v=!1}function S(){const e=k.pop();v=void 0===e||e}function N(e,t,n){if(v&&g){let t=d.get(e);t||d.set(e,t=new Map);let r=t.get(n);r||t.set(n,r=o());const a=void 0;T(r,a)}}function T(e,t){let n=!1;h<=m?u(e)||(e.n|=f,n=!l(e)):n=!e.has(g),n&&(e.add(g),g.deps.push(e))}function _(e,t,n,a,s,i){const l=d.get(e);if(!l)return;let u=[];if("clear"===t)u=[...l.values()];else if("length"===n&&(0,r.kJ)(e))l.forEach(((e,t)=>{("length"===t||t>=a)&&u.push(e)}));else switch(void 0!==n&&u.push(l.get(n)),t){case"add":(0,r.kJ)(e)?(0,r.S0)(n)&&u.push(l.get("length")):(u.push(l.get(y)),(0,r._N)(e)&&u.push(l.get(b)));break;case"delete":(0,r.kJ)(e)||(u.push(l.get(y)),(0,r._N)(e)&&u.push(l.get(b)));break;case"set":(0,r._N)(e)&&u.push(l.get(y));break}if(1===u.length)u[0]&&C(u[0]);else{const e=[];for(const t of u)t&&e.push(...t);C(o(e))}}function C(e,t){const n=(0,r.kJ)(e)?e:[...e];for(const r of n)r.computed&&E(r,t);for(const r of n)r.computed||E(r,t)}function E(e,t){(e!==g||e.allowRecurse)&&(e.scheduler?e.scheduler():e.run())}const A=(0,r.fY)("__proto__,__v_isRef,__isVue"),$=new Set(Object.getOwnPropertyNames(Symbol).filter((e=>"arguments"!==e&&"caller"!==e)).map((e=>Symbol[e])).filter(r.yk)),F=L(),R=L(!1,!0),D=L(!0),M=O();function O(){const e={};return["includes","indexOf","lastIndexOf"].forEach((t=>{e[t]=function(...e){const n=Ce(this);for(let t=0,a=this.length;t<a;t++)N(n,"get",t+"");const r=n[t](...e);return-1===r||!1===r?n[t](...e.map(Ce)):r}})),["push","pop","shift","unshift","splice"].forEach((t=>{e[t]=function(...e){I();const n=Ce(this)[t].apply(this,e);return S(),n}})),e}function L(e=!1,t=!1){return function(n,a,s){if("__v_isReactive"===a)return!e;if("__v_isReadonly"===a)return e;if("__v_isShallow"===a)return t;if("__v_raw"===a&&s===(e?t?ye:ge:t?me:fe).get(n))return n;const i=(0,r.kJ)(n);if(!e&&i&&(0,r.RI)(M,a))return Reflect.get(M,a,s);const o=Reflect.get(n,a,s);return((0,r.yk)(a)?$.has(a):A(a))?o:(e||N(n,"get",a),t?o:De(o)?i&&(0,r.S0)(a)?o:o.value:(0,r.Kn)(o)?e?ke(o):xe(o):o)}}const P=B(),z=B(!0);function B(e=!1){return function(t,n,a,s){let i=t[n];if(Ne(i)&&De(i)&&!De(a))return!1;if(!e&&!Ne(a)&&(Te(a)||(a=Ce(a),i=Ce(i)),!(0,r.kJ)(t)&&De(i)&&!De(a)))return i.value=a,!0;const o=(0,r.kJ)(t)&&(0,r.S0)(n)?Number(n)<t.length:(0,r.RI)(t,n),l=Reflect.set(t,n,a,s);return t===Ce(s)&&(o?(0,r.aU)(a,i)&&_(t,"set",n,a,i):_(t,"add",n,a)),l}}function W(e,t){const n=(0,r.RI)(e,t),a=e[t],s=Reflect.deleteProperty(e,t);return s&&n&&_(e,"delete",t,void 0,a),s}function V(e,t){const n=Reflect.has(e,t);return(0,r.yk)(t)&&$.has(t)||N(e,"has",t),n}function U(e){return N(e,"iterate",(0,r.kJ)(e)?"length":y),Reflect.ownKeys(e)}const G={get:F,set:P,deleteProperty:W,has:V,ownKeys:U},H={get:D,set(e,t){return!0},deleteProperty(e,t){return!0}},j=(0,r.l7)({},G,{get:R,set:z}),q=e=>e,K=e=>Reflect.getPrototypeOf(e);function X(e,t,n=!1,r=!1){e=e["__v_raw"];const a=Ce(e),s=Ce(t);n||(t!==s&&N(a,"get",t),N(a,"get",s));const{has:i}=K(a),o=r?q:n?$e:Ae;return i.call(a,t)?o(e.get(t)):i.call(a,s)?o(e.get(s)):void(e!==a&&e.get(t))}function Y(e,t=!1){const n=this["__v_raw"],r=Ce(n),a=Ce(e);return t||(e!==a&&N(r,"has",e),N(r,"has",a)),e===a?n.has(e):n.has(e)||n.has(a)}function J(e,t=!1){return e=e["__v_raw"],!t&&N(Ce(e),"iterate",y),Reflect.get(e,"size",e)}function Z(e){e=Ce(e);const t=Ce(this),n=K(t),r=n.has.call(t,e);return r||(t.add(e),_(t,"add",e,e)),this}function Q(e,t){t=Ce(t);const n=Ce(this),{has:a,get:s}=K(n);let i=a.call(n,e);i||(e=Ce(e),i=a.call(n,e));const o=s.call(n,e);return n.set(e,t),i?(0,r.aU)(t,o)&&_(n,"set",e,t,o):_(n,"add",e,t),this}function ee(e){const t=Ce(this),{has:n,get:r}=K(t);let a=n.call(t,e);a||(e=Ce(e),a=n.call(t,e));const s=r?r.call(t,e):void 0,i=t.delete(e);return a&&_(t,"delete",e,void 0,s),i}function te(){const e=Ce(this),t=0!==e.size,n=void 0,r=e.clear();return t&&_(e,"clear",void 0,void 0,n),r}function ne(e,t){return function(n,r){const a=this,s=a["__v_raw"],i=Ce(s),o=t?q:e?$e:Ae;return!e&&N(i,"iterate",y),s.forEach(((e,t)=>n.call(r,o(e),o(t),a)))}}function re(e,t,n){return function(...a){const s=this["__v_raw"],i=Ce(s),o=(0,r._N)(i),l="entries"===e||e===Symbol.iterator&&o,u="keys"===e&&o,c=s[e](...a),p=n?q:t?$e:Ae;return!t&&N(i,"iterate",u?b:y),{next(){const{value:e,done:t}=c.next();return t?{value:e,done:t}:{value:l?[p(e[0]),p(e[1])]:p(e),done:t}},[Symbol.iterator](){return this}}}}function ae(e){return function(...t){return"delete"!==e&&this}}function se(){const e={get(e){return X(this,e)},get size(){return J(this)},has:Y,add:Z,set:Q,delete:ee,clear:te,forEach:ne(!1,!1)},t={get(e){return X(this,e,!1,!0)},get size(){return J(this)},has:Y,add:Z,set:Q,delete:ee,clear:te,forEach:ne(!1,!0)},n={get(e){return X(this,e,!0)},get size(){return J(this,!0)},has(e){return Y.call(this,e,!0)},add:ae("add"),set:ae("set"),delete:ae("delete"),clear:ae("clear"),forEach:ne(!0,!1)},r={get(e){return X(this,e,!0,!0)},get size(){return J(this,!0)},has(e){return Y.call(this,e,!0)},add:ae("add"),set:ae("set"),delete:ae("delete"),clear:ae("clear"),forEach:ne(!0,!0)},a=["keys","values","entries",Symbol.iterator];return a.forEach((a=>{e[a]=re(a,!1,!1),n[a]=re(a,!0,!1),t[a]=re(a,!1,!0),r[a]=re(a,!0,!0)})),[e,n,t,r]}const[ie,oe,le,ue]=se();function ce(e,t){const n=t?e?ue:le:e?oe:ie;return(t,a,s)=>"__v_isReactive"===a?!e:"__v_isReadonly"===a?e:"__v_raw"===a?t:Reflect.get((0,r.RI)(n,a)&&a in t?n:t,a,s)}const pe={get:ce(!1,!1)},de={get:ce(!1,!0)},he={get:ce(!0,!1)};const fe=new WeakMap,me=new WeakMap,ge=new WeakMap,ye=new WeakMap;function be(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function we(e){return e["__v_skip"]||!Object.isExtensible(e)?0:be((0,r.W7)(e))}function xe(e){return Ne(e)?e:Ie(e,!1,G,pe,fe)}function ve(e){return Ie(e,!1,j,de,me)}function ke(e){return Ie(e,!0,H,he,ge)}function Ie(e,t,n,a,s){if(!(0,r.Kn)(e))return e;if(e["__v_raw"]&&(!t||!e["__v_isReactive"]))return e;const i=s.get(e);if(i)return i;const o=we(e);if(0===o)return e;const l=new Proxy(e,2===o?a:n);return s.set(e,l),l}function Se(e){return Ne(e)?Se(e["__v_raw"]):!(!e||!e["__v_isReactive"])}function Ne(e){return!(!e||!e["__v_isReadonly"])}function Te(e){return!(!e||!e["__v_isShallow"])}function _e(e){return Se(e)||Ne(e)}function Ce(e){const t=e&&e["__v_raw"];return t?Ce(t):e}function Ee(e){return(0,r.Nj)(e,"__v_skip",!0),e}const Ae=e=>(0,r.Kn)(e)?xe(e):e,$e=e=>(0,r.Kn)(e)?ke(e):e;function Fe(e){v&&g&&(e=Ce(e),T(e.dep||(e.dep=o())))}function Re(e,t){e=Ce(e),e.dep&&C(e.dep)}function De(e){return!(!e||!0!==e.__v_isRef)}function Me(e){return De(e)?e.value:e}const Oe={get:(e,t,n)=>Me(Reflect.get(e,t,n)),set:(e,t,n,r)=>{const a=e[t];return De(a)&&!De(n)?(a.value=n,!0):Reflect.set(e,t,n,r)}};function Le(e){return Se(e)?e:new Proxy(e,Oe)}class Pe{constructor(e,t,n,r){this._setter=t,this.dep=void 0,this.__v_isRef=!0,this._dirty=!0,this.effect=new w(e,(()=>{this._dirty||(this._dirty=!0,Re(this))})),this.effect.computed=this,this.effect.active=this._cacheable=!r,this["__v_isReadonly"]=n}get value(){const e=Ce(this);return Fe(e),!e._dirty&&e._cacheable||(e._dirty=!1,e._value=e.effect.run()),e._value}set value(e){this._setter(e)}}function ze(e,t,n=!1){let a,s;const i=(0,r.mf)(e);i?(a=e,s=r.dG):(a=e.get,s=e.set);const o=new Pe(a,s,i||!s,n);return o}},3396:function(e,t,n){"use strict";n.d(t,{$d:function(){return i},FN:function(){return pn},HY:function(){return $t},P$:function(){return ie},Q6:function(){return de},U2:function(){return le},Us:function(){return Nt},Wm:function(){return Yt},Y8:function(){return re},h:function(){return Cn},iD:function(){return Vt},ic:function(){return _e},j4:function(){return Ut},nK:function(){return pe},up:function(){return Oe},wg:function(){return Lt}});n(6699),n(1703);var r=n(4870),a=n(7139);function s(e,t,n,r){let a;try{a=r?e(...r):e()}catch(s){o(s,t,n)}return a}function i(e,t,n,r){if((0,a.mf)(e)){const i=s(e,t,n,r);return i&&(0,a.tI)(i)&&i.catch((e=>{o(e,t,n)})),i}const l=[];for(let a=0;a<e.length;a++)l.push(i(e[a],t,n,r));return l}function o(e,t,n,r=!0){const a=t?t.vnode:null;if(t){let r=t.parent;const a=t.proxy,i=n;while(r){const t=r.ec;if(t)for(let n=0;n<t.length;n++)if(!1===t[n](e,a,i))return;r=r.parent}const o=t.appContext.config.errorHandler;if(o)return void s(o,null,10,[e,a,i])}l(e,n,a,r)}function l(e,t,n,r=!0){console.error(e)}let u=!1,c=!1;const p=[];let d=0;const h=[];let f=null,m=0;const g=[];let y=null,b=0;const w=Promise.resolve();let x=null,v=null;function k(e){const t=x||w;return e?t.then(this?e.bind(this):e):t}function I(e){let t=d+1,n=p.length;while(t<n){const r=t+n>>>1,a=F(p[r]);a<e?t=r+1:n=r}return t}function S(e){p.length&&p.includes(e,u&&e.allowRecurse?d+1:d)||e===v||(null==e.id?p.push(e):p.splice(I(e.id),0,e),N())}function N(){u||c||(c=!0,x=w.then(R))}function T(e){const t=p.indexOf(e);t>d&&p.splice(t,1)}function _(e,t,n,r){(0,a.kJ)(e)?n.push(...e):t&&t.includes(e,e.allowRecurse?r+1:r)||n.push(e),N()}function C(e){_(e,f,h,m)}function E(e){_(e,y,g,b)}function A(e,t=null){if(h.length){for(v=t,f=[...new Set(h)],h.length=0,m=0;m<f.length;m++)f[m]();f=null,m=0,v=null,A(e,t)}}function $(e){if(A(),g.length){const e=[...new Set(g)];if(g.length=0,y)return void y.push(...e);for(y=e,y.sort(((e,t)=>F(e)-F(t))),b=0;b<y.length;b++)y[b]();y=null,b=0}}const F=e=>null==e.id?1/0:e.id;function R(e){c=!1,u=!0,A(e),p.sort(((e,t)=>F(e)-F(t)));a.dG;try{for(d=0;d<p.length;d++){const e=p[d];e&&!1!==e.active&&s(e,null,14)}}finally{d=0,p.length=0,$(e),u=!1,x=null,(p.length||h.length||g.length)&&R(e)}}new Set;new Map;function D(e,t,...n){if(e.isUnmounted)return;const r=e.vnode.props||a.kT;let s=n;const o=t.startsWith("update:"),l=o&&t.slice(7);if(l&&l in r){const e=`${"modelValue"===l?"model":l}Modifiers`,{number:t,trim:i}=r[e]||a.kT;i&&(s=n.map((e=>e.trim()))),t&&(s=n.map(a.He))}let u;let c=r[u=(0,a.hR)(t)]||r[u=(0,a.hR)((0,a._A)(t))];!c&&o&&(c=r[u=(0,a.hR)((0,a.rs)(t))]),c&&i(c,e,6,s);const p=r[u+"Once"];if(p){if(e.emitted){if(e.emitted[u])return}else e.emitted={};e.emitted[u]=!0,i(p,e,6,s)}}function M(e,t,n=!1){const r=t.emitsCache,s=r.get(e);if(void 0!==s)return s;const i=e.emits;let o={},l=!1;if(!(0,a.mf)(e)){const r=e=>{const n=M(e,t,!0);n&&(l=!0,(0,a.l7)(o,n))};!n&&t.mixins.length&&t.mixins.forEach(r),e.extends&&r(e.extends),e.mixins&&e.mixins.forEach(r)}return i||l?((0,a.kJ)(i)?i.forEach((e=>o[e]=null)):(0,a.l7)(o,i),r.set(e,o),o):(r.set(e,null),null)}function O(e,t){return!(!e||!(0,a.F7)(t))&&(t=t.slice(2).replace(/Once$/,""),(0,a.RI)(e,t[0].toLowerCase()+t.slice(1))||(0,a.RI)(e,(0,a.rs)(t))||(0,a.RI)(e,t))}let L=null,P=null;function z(e){const t=L;return L=e,P=e&&e.type.__scopeId||null,t}function B(e,t=L,n){if(!t)return e;if(e._n)return e;const r=(...n)=>{r._d&&Bt(-1);const a=z(t),s=e(...n);return z(a),r._d&&Bt(1),s};return r._n=!0,r._c=!0,r._d=!0,r}function W(e){const{type:t,vnode:n,proxy:r,withProxy:s,props:i,propsOptions:[l],slots:u,attrs:c,emit:p,render:d,renderCache:h,data:f,setupState:m,ctx:g,inheritAttrs:y}=e;let b,w;const x=z(e);try{if(4&n.shapeFlag){const e=s||r;b=tn(d.call(e,e,h,i,m,f,g)),w=c}else{const e=t;0,b=tn(e.length>1?e(i,{attrs:c,slots:u,emit:p}):e(i,null)),w=t.props?c:V(c)}}catch(k){Mt.length=0,o(k,e,1),b=Yt(Rt)}let v=b;if(w&&!1!==y){const e=Object.keys(w),{shapeFlag:t}=v;e.length&&7&t&&(l&&e.some(a.tR)&&(w=U(w,l)),v=Qt(v,w))}return n.dirs&&(v=Qt(v),v.dirs=v.dirs?v.dirs.concat(n.dirs):n.dirs),n.transition&&(v.transition=n.transition),b=v,z(x),b}const V=e=>{let t;for(const n in e)("class"===n||"style"===n||(0,a.F7)(n))&&((t||(t={}))[n]=e[n]);return t},U=(e,t)=>{const n={};for(const r in e)(0,a.tR)(r)&&r.slice(9)in t||(n[r]=e[r]);return n};function G(e,t,n){const{props:r,children:a,component:s}=e,{props:i,children:o,patchFlag:l}=t,u=s.emitsOptions;if(t.dirs||t.transition)return!0;if(!(n&&l>=0))return!(!a&&!o||o&&o.$stable)||r!==i&&(r?!i||H(r,i,u):!!i);if(1024&l)return!0;if(16&l)return r?H(r,i,u):!!i;if(8&l){const e=t.dynamicProps;for(let t=0;t<e.length;t++){const n=e[t];if(i[n]!==r[n]&&!O(u,n))return!0}}return!1}function H(e,t,n){const r=Object.keys(t);if(r.length!==Object.keys(e).length)return!0;for(let a=0;a<r.length;a++){const s=r[a];if(t[s]!==e[s]&&!O(n,s))return!0}return!1}function j({vnode:e,parent:t},n){while(t&&t.subTree===e)(e=t.vnode).el=n,t=t.parent}const q=e=>e.__isSuspense;function K(e,t){t&&t.pendingBranch?(0,a.kJ)(e)?t.effects.push(...e):t.effects.push(e):E(e)}function X(e,t){if(cn){let n=cn.provides;const r=cn.parent&&cn.parent.provides;r===n&&(n=cn.provides=Object.create(r)),n[e]=t}else 0}function Y(e,t,n=!1){const r=cn||L;if(r){const s=null==r.parent?r.vnode.appContext&&r.vnode.appContext.provides:r.parent.provides;if(s&&e in s)return s[e];if(arguments.length>1)return n&&(0,a.mf)(t)?t.call(r.proxy):t}else 0}const J={};function Z(e,t,n){return Q(e,t,n)}function Q(e,t,{immediate:n,deep:o,flush:l,onTrack:u,onTrigger:c}=a.kT){const p=cn;let d,h,f=!1,m=!1;if((0,r.dq)(e)?(d=()=>e.value,f=(0,r.yT)(e)):(0,r.PG)(e)?(d=()=>e,o=!0):(0,a.kJ)(e)?(m=!0,f=e.some((e=>(0,r.PG)(e)||(0,r.yT)(e))),d=()=>e.map((e=>(0,r.dq)(e)?e.value:(0,r.PG)(e)?ne(e):(0,a.mf)(e)?s(e,p,2):void 0))):d=(0,a.mf)(e)?t?()=>s(e,p,2):()=>{if(!p||!p.isUnmounted)return h&&h(),i(e,p,3,[g])}:a.dG,t&&o){const e=d;d=()=>ne(e())}let g=e=>{h=x.onStop=()=>{s(e,p,4)}};if(yn)return g=a.dG,t?n&&i(t,p,3,[d(),m?[]:void 0,g]):d(),a.dG;let y=m?[]:J;const b=()=>{if(x.active)if(t){const e=x.run();(o||f||(m?e.some(((e,t)=>(0,a.aU)(e,y[t]))):(0,a.aU)(e,y)))&&(h&&h(),i(t,p,3,[e,y===J?void 0:y,g]),y=e)}else x.run()};let w;b.allowRecurse=!!t,w="sync"===l?b:"post"===l?()=>St(b,p&&p.suspense):()=>C(b);const x=new r.qq(d,w);return t?n?b():y=x.run():"post"===l?St(x.run.bind(x),p&&p.suspense):x.run(),()=>{x.stop(),p&&p.scope&&(0,a.Od)(p.scope.effects,x)}}function ee(e,t,n){const r=this.proxy,s=(0,a.HD)(e)?e.includes(".")?te(r,e):()=>r[e]:e.bind(r,r);let i;(0,a.mf)(t)?i=t:(i=t.handler,n=t);const o=cn;dn(this);const l=Q(s,i.bind(r),n);return o?dn(o):hn(),l}function te(e,t){const n=t.split(".");return()=>{let t=e;for(let e=0;e<n.length&&t;e++)t=t[n[e]];return t}}function ne(e,t){if(!(0,a.Kn)(e)||e["__v_skip"])return e;if(t=t||new Set,t.has(e))return e;if(t.add(e),(0,r.dq)(e))ne(e.value,t);else if((0,a.kJ)(e))for(let n=0;n<e.length;n++)ne(e[n],t);else if((0,a.DM)(e)||(0,a._N)(e))e.forEach((e=>{ne(e,t)}));else if((0,a.PO)(e))for(const n in e)ne(e[n],t);return e}function re(){const e={isMounted:!1,isLeaving:!1,isUnmounting:!1,leavingVNodes:new Map};return Ne((()=>{e.isMounted=!0})),Ce((()=>{e.isUnmounting=!0})),e}const ae=[Function,Array],se={name:"BaseTransition",props:{mode:String,appear:Boolean,persisted:Boolean,onBeforeEnter:ae,onEnter:ae,onAfterEnter:ae,onEnterCancelled:ae,onBeforeLeave:ae,onLeave:ae,onAfterLeave:ae,onLeaveCancelled:ae,onBeforeAppear:ae,onAppear:ae,onAfterAppear:ae,onAppearCancelled:ae},setup(e,{slots:t}){const n=pn(),a=re();let s;return()=>{const i=t.default&&de(t.default(),!0);if(!i||!i.length)return;let o=i[0];if(i.length>1){let e=!1;for(const t of i)if(t.type!==Rt){0,o=t,e=!0;break}}const l=(0,r.IU)(e),{mode:u}=l;if(a.isLeaving)return ue(o);const c=ce(o);if(!c)return ue(o);const p=le(c,l,a,n);pe(c,p);const d=n.subTree,h=d&&ce(d);let f=!1;const{getTransitionKey:m}=c.type;if(m){const e=m();void 0===s?s=e:e!==s&&(s=e,f=!0)}if(h&&h.type!==Rt&&(!Ht(c,h)||f)){const e=le(h,l,a,n);if(pe(h,e),"out-in"===u)return a.isLeaving=!0,e.afterLeave=()=>{a.isLeaving=!1,n.update()},ue(o);"in-out"===u&&c.type!==Rt&&(e.delayLeave=(e,t,n)=>{const r=oe(a,h);r[String(h.key)]=h,e._leaveCb=()=>{t(),e._leaveCb=void 0,delete p.delayedLeave},p.delayedLeave=n})}return o}}},ie=se;function oe(e,t){const{leavingVNodes:n}=e;let r=n.get(t.type);return r||(r=Object.create(null),n.set(t.type,r)),r}function le(e,t,n,r){const{appear:s,mode:o,persisted:l=!1,onBeforeEnter:u,onEnter:c,onAfterEnter:p,onEnterCancelled:d,onBeforeLeave:h,onLeave:f,onAfterLeave:m,onLeaveCancelled:g,onBeforeAppear:y,onAppear:b,onAfterAppear:w,onAppearCancelled:x}=t,v=String(e.key),k=oe(n,e),I=(e,t)=>{e&&i(e,r,9,t)},S=(e,t)=>{const n=t[1];I(e,t),(0,a.kJ)(e)?e.every((e=>e.length<=1))&&n():e.length<=1&&n()},N={mode:o,persisted:l,beforeEnter(t){let r=u;if(!n.isMounted){if(!s)return;r=y||u}t._leaveCb&&t._leaveCb(!0);const a=k[v];a&&Ht(e,a)&&a.el._leaveCb&&a.el._leaveCb(),I(r,[t])},enter(e){let t=c,r=p,a=d;if(!n.isMounted){if(!s)return;t=b||c,r=w||p,a=x||d}let i=!1;const o=e._enterCb=t=>{i||(i=!0,I(t?a:r,[e]),N.delayedLeave&&N.delayedLeave(),e._enterCb=void 0)};t?S(t,[e,o]):o()},leave(t,r){const a=String(e.key);if(t._enterCb&&t._enterCb(!0),n.isUnmounting)return r();I(h,[t]);let s=!1;const i=t._leaveCb=n=>{s||(s=!0,r(),I(n?g:m,[t]),t._leaveCb=void 0,k[a]===e&&delete k[a])};k[a]=e,f?S(f,[t,i]):i()},clone(e){return le(e,t,n,r)}};return N}function ue(e){if(fe(e))return e=Qt(e),e.children=null,e}function ce(e){return fe(e)?e.children?e.children[0]:void 0:e}function pe(e,t){6&e.shapeFlag&&e.component?pe(e.component.subTree,t):128&e.shapeFlag?(e.ssContent.transition=t.clone(e.ssContent),e.ssFallback.transition=t.clone(e.ssFallback)):e.transition=t}function de(e,t=!1,n){let r=[],a=0;for(let s=0;s<e.length;s++){let i=e[s];const o=null==n?i.key:String(n)+String(null!=i.key?i.key:s);i.type===$t?(128&i.patchFlag&&a++,r=r.concat(de(i.children,t,o))):(t||i.type!==Rt)&&r.push(null!=o?Qt(i,{key:o}):i)}if(a>1)for(let s=0;s<r.length;s++)r[s].patchFlag=-2;return r}const he=e=>!!e.type.__asyncLoader;const fe=e=>e.type.__isKeepAlive;RegExp,RegExp;function me(e,t){return(0,a.kJ)(e)?e.some((e=>me(e,t))):(0,a.HD)(e)?e.split(",").includes(t):!!e.test&&e.test(t)}function ge(e,t){be(e,"a",t)}function ye(e,t){be(e,"da",t)}function be(e,t,n=cn){const r=e.__wdc||(e.__wdc=()=>{let t=n;while(t){if(t.isDeactivated)return;t=t.parent}return e()});if(ke(t,r,n),n){let e=n.parent;while(e&&e.parent)fe(e.parent.vnode)&&we(r,t,n,e),e=e.parent}}function we(e,t,n,r){const s=ke(t,e,r,!0);Ee((()=>{(0,a.Od)(r[t],s)}),n)}function xe(e){let t=e.shapeFlag;256&t&&(t-=256),512&t&&(t-=512),e.shapeFlag=t}function ve(e){return 128&e.shapeFlag?e.ssContent:e}function ke(e,t,n=cn,a=!1){if(n){const s=n[e]||(n[e]=[]),o=t.__weh||(t.__weh=(...a)=>{if(n.isUnmounted)return;(0,r.Jd)(),dn(n);const s=i(t,n,e,a);return hn(),(0,r.lk)(),s});return a?s.unshift(o):s.push(o),o}}const Ie=e=>(t,n=cn)=>(!yn||"sp"===e)&&ke(e,t,n),Se=Ie("bm"),Ne=Ie("m"),Te=Ie("bu"),_e=Ie("u"),Ce=Ie("bum"),Ee=Ie("um"),Ae=Ie("sp"),$e=Ie("rtg"),Fe=Ie("rtc");function Re(e,t=cn){ke("ec",e,t)}function De(e,t,n,a){const s=e.dirs,o=t&&t.dirs;for(let l=0;l<s.length;l++){const u=s[l];o&&(u.oldValue=o[l].value);let c=u.dir[a];c&&((0,r.Jd)(),i(c,n,8,[e.el,u,e,t]),(0,r.lk)())}}const Me="components";function Oe(e,t){return Pe(Me,e,!0,t)||e}const Le=Symbol();function Pe(e,t,n=!0,r=!1){const s=L||cn;if(s){const n=s.type;if(e===Me){const e=Nn(n,!1);if(e&&(e===t||e===(0,a._A)(t)||e===(0,a.kC)((0,a._A)(t))))return n}const i=ze(s[e]||n[e],t)||ze(s.appContext[e],t);return!i&&r?n:i}}function ze(e,t){return e&&(e[t]||e[(0,a._A)(t)]||e[(0,a.kC)((0,a._A)(t))])}const Be=e=>e?fn(e)?Sn(e)||e.proxy:Be(e.parent):null,We=(0,a.l7)(Object.create(null),{$:e=>e,$el:e=>e.vnode.el,$data:e=>e.data,$props:e=>e.props,$attrs:e=>e.attrs,$slots:e=>e.slots,$refs:e=>e.refs,$parent:e=>Be(e.parent),$root:e=>Be(e.root),$emit:e=>e.emit,$options:e=>Ke(e),$forceUpdate:e=>e.f||(e.f=()=>S(e.update)),$nextTick:e=>e.n||(e.n=k.bind(e.proxy)),$watch:e=>ee.bind(e)}),Ve={get({_:e},t){const{ctx:n,setupState:s,data:i,props:o,accessCache:l,type:u,appContext:c}=e;let p;if("$"!==t[0]){const r=l[t];if(void 0!==r)switch(r){case 1:return s[t];case 2:return i[t];case 4:return n[t];case 3:return o[t]}else{if(s!==a.kT&&(0,a.RI)(s,t))return l[t]=1,s[t];if(i!==a.kT&&(0,a.RI)(i,t))return l[t]=2,i[t];if((p=e.propsOptions[0])&&(0,a.RI)(p,t))return l[t]=3,o[t];if(n!==a.kT&&(0,a.RI)(n,t))return l[t]=4,n[t];Ue&&(l[t]=0)}}const d=We[t];let h,f;return d?("$attrs"===t&&(0,r.j)(e,"get",t),d(e)):(h=u.__cssModules)&&(h=h[t])?h:n!==a.kT&&(0,a.RI)(n,t)?(l[t]=4,n[t]):(f=c.config.globalProperties,(0,a.RI)(f,t)?f[t]:void 0)},set({_:e},t,n){const{data:r,setupState:s,ctx:i}=e;return s!==a.kT&&(0,a.RI)(s,t)?(s[t]=n,!0):r!==a.kT&&(0,a.RI)(r,t)?(r[t]=n,!0):!(0,a.RI)(e.props,t)&&(("$"!==t[0]||!(t.slice(1)in e))&&(i[t]=n,!0))},has({_:{data:e,setupState:t,accessCache:n,ctx:r,appContext:s,propsOptions:i}},o){let l;return!!n[o]||e!==a.kT&&(0,a.RI)(e,o)||t!==a.kT&&(0,a.RI)(t,o)||(l=i[0])&&(0,a.RI)(l,o)||(0,a.RI)(r,o)||(0,a.RI)(We,o)||(0,a.RI)(s.config.globalProperties,o)},defineProperty(e,t,n){return null!=n.get?e._.accessCache[t]=0:(0,a.RI)(n,"value")&&this.set(e,t,n.value,null),Reflect.defineProperty(e,t,n)}};let Ue=!0;function Ge(e){const t=Ke(e),n=e.proxy,s=e.ctx;Ue=!1,t.beforeCreate&&je(t.beforeCreate,e,"bc");const{data:i,computed:o,methods:l,watch:u,provide:c,inject:p,created:d,beforeMount:h,mounted:f,beforeUpdate:m,updated:g,activated:y,deactivated:b,beforeDestroy:w,beforeUnmount:x,destroyed:v,unmounted:k,render:I,renderTracked:S,renderTriggered:N,errorCaptured:T,serverPrefetch:_,expose:C,inheritAttrs:E,components:A,directives:$,filters:F}=t,R=null;if(p&&He(p,s,R,e.appContext.config.unwrapInjectedRef),l)for(const r in l){const e=l[r];(0,a.mf)(e)&&(s[r]=e.bind(n))}if(i){0;const t=i.call(n,n);0,(0,a.Kn)(t)&&(e.data=(0,r.qj)(t))}if(Ue=!0,o)for(const r in o){const e=o[r],t=(0,a.mf)(e)?e.bind(n,n):(0,a.mf)(e.get)?e.get.bind(n,n):a.dG;0;const i=!(0,a.mf)(e)&&(0,a.mf)(e.set)?e.set.bind(n):a.dG,l=_n({get:t,set:i});Object.defineProperty(s,r,{enumerable:!0,configurable:!0,get:()=>l.value,set:e=>l.value=e})}if(u)for(const r in u)qe(u[r],s,n,r);if(c){const e=(0,a.mf)(c)?c.call(n):c;Reflect.ownKeys(e).forEach((t=>{X(t,e[t])}))}function D(e,t){(0,a.kJ)(t)?t.forEach((t=>e(t.bind(n)))):t&&e(t.bind(n))}if(d&&je(d,e,"c"),D(Se,h),D(Ne,f),D(Te,m),D(_e,g),D(ge,y),D(ye,b),D(Re,T),D(Fe,S),D($e,N),D(Ce,x),D(Ee,k),D(Ae,_),(0,a.kJ)(C))if(C.length){const t=e.exposed||(e.exposed={});C.forEach((e=>{Object.defineProperty(t,e,{get:()=>n[e],set:t=>n[e]=t})}))}else e.exposed||(e.exposed={});I&&e.render===a.dG&&(e.render=I),null!=E&&(e.inheritAttrs=E),A&&(e.components=A),$&&(e.directives=$)}function He(e,t,n=a.dG,s=!1){(0,a.kJ)(e)&&(e=Qe(e));for(const i in e){const n=e[i];let o;o=(0,a.Kn)(n)?"default"in n?Y(n.from||i,n.default,!0):Y(n.from||i):Y(n),(0,r.dq)(o)&&s?Object.defineProperty(t,i,{enumerable:!0,configurable:!0,get:()=>o.value,set:e=>o.value=e}):t[i]=o}}function je(e,t,n){i((0,a.kJ)(e)?e.map((e=>e.bind(t.proxy))):e.bind(t.proxy),t,n)}function qe(e,t,n,r){const s=r.includes(".")?te(n,r):()=>n[r];if((0,a.HD)(e)){const n=t[e];(0,a.mf)(n)&&Z(s,n)}else if((0,a.mf)(e))Z(s,e.bind(n));else if((0,a.Kn)(e))if((0,a.kJ)(e))e.forEach((e=>qe(e,t,n,r)));else{const r=(0,a.mf)(e.handler)?e.handler.bind(n):t[e.handler];(0,a.mf)(r)&&Z(s,r,e)}else 0}function Ke(e){const t=e.type,{mixins:n,extends:r}=t,{mixins:a,optionsCache:s,config:{optionMergeStrategies:i}}=e.appContext,o=s.get(t);let l;return o?l=o:a.length||n||r?(l={},a.length&&a.forEach((e=>Xe(l,e,i,!0))),Xe(l,t,i)):l=t,s.set(t,l),l}function Xe(e,t,n,r=!1){const{mixins:a,extends:s}=t;s&&Xe(e,s,n,!0),a&&a.forEach((t=>Xe(e,t,n,!0)));for(const i in t)if(r&&"expose"===i);else{const r=Ye[i]||n&&n[i];e[i]=r?r(e[i],t[i]):t[i]}return e}const Ye={data:Je,props:tt,emits:tt,methods:tt,computed:tt,beforeCreate:et,created:et,beforeMount:et,mounted:et,beforeUpdate:et,updated:et,beforeDestroy:et,beforeUnmount:et,destroyed:et,unmounted:et,activated:et,deactivated:et,errorCaptured:et,serverPrefetch:et,components:tt,directives:tt,watch:nt,provide:Je,inject:Ze};function Je(e,t){return t?e?function(){return(0,a.l7)((0,a.mf)(e)?e.call(this,this):e,(0,a.mf)(t)?t.call(this,this):t)}:t:e}function Ze(e,t){return tt(Qe(e),Qe(t))}function Qe(e){if((0,a.kJ)(e)){const t={};for(let n=0;n<e.length;n++)t[e[n]]=e[n];return t}return e}function et(e,t){return e?[...new Set([].concat(e,t))]:t}function tt(e,t){return e?(0,a.l7)((0,a.l7)(Object.create(null),e),t):t}function nt(e,t){if(!e)return t;if(!t)return e;const n=(0,a.l7)(Object.create(null),e);for(const r in t)n[r]=et(e[r],t[r]);return n}function rt(e,t,n,s=!1){const i={},o={};(0,a.Nj)(o,jt,1),e.propsDefaults=Object.create(null),st(e,t,i,o);for(const r in e.propsOptions[0])r in i||(i[r]=void 0);n?e.props=s?i:(0,r.Um)(i):e.type.props?e.props=i:e.props=o,e.attrs=o}function at(e,t,n,s){const{props:i,attrs:o,vnode:{patchFlag:l}}=e,u=(0,r.IU)(i),[c]=e.propsOptions;let p=!1;if(!(s||l>0)||16&l){let r;st(e,t,i,o)&&(p=!0);for(const s in u)t&&((0,a.RI)(t,s)||(r=(0,a.rs)(s))!==s&&(0,a.RI)(t,r))||(c?!n||void 0===n[s]&&void 0===n[r]||(i[s]=it(c,u,s,void 0,e,!0)):delete i[s]);if(o!==u)for(const e in o)t&&(0,a.RI)(t,e)||(delete o[e],p=!0)}else if(8&l){const n=e.vnode.dynamicProps;for(let r=0;r<n.length;r++){let s=n[r];if(O(e.emitsOptions,s))continue;const l=t[s];if(c)if((0,a.RI)(o,s))l!==o[s]&&(o[s]=l,p=!0);else{const t=(0,a._A)(s);i[t]=it(c,u,t,l,e,!1)}else l!==o[s]&&(o[s]=l,p=!0)}}p&&(0,r.X$)(e,"set","$attrs")}function st(e,t,n,s){const[i,o]=e.propsOptions;let l,u=!1;if(t)for(let r in t){if((0,a.Gg)(r))continue;const c=t[r];let p;i&&(0,a.RI)(i,p=(0,a._A)(r))?o&&o.includes(p)?(l||(l={}))[p]=c:n[p]=c:O(e.emitsOptions,r)||r in s&&c===s[r]||(s[r]=c,u=!0)}if(o){const t=(0,r.IU)(n),s=l||a.kT;for(let r=0;r<o.length;r++){const l=o[r];n[l]=it(i,t,l,s[l],e,!(0,a.RI)(s,l))}}return u}function it(e,t,n,r,s,i){const o=e[n];if(null!=o){const e=(0,a.RI)(o,"default");if(e&&void 0===r){const e=o.default;if(o.type!==Function&&(0,a.mf)(e)){const{propsDefaults:a}=s;n in a?r=a[n]:(dn(s),r=a[n]=e.call(null,t),hn())}else r=e}o[0]&&(i&&!e?r=!1:!o[1]||""!==r&&r!==(0,a.rs)(n)||(r=!0))}return r}function ot(e,t,n=!1){const r=t.propsCache,s=r.get(e);if(s)return s;const i=e.props,o={},l=[];let u=!1;if(!(0,a.mf)(e)){const r=e=>{u=!0;const[n,r]=ot(e,t,!0);(0,a.l7)(o,n),r&&l.push(...r)};!n&&t.mixins.length&&t.mixins.forEach(r),e.extends&&r(e.extends),e.mixins&&e.mixins.forEach(r)}if(!i&&!u)return r.set(e,a.Z6),a.Z6;if((0,a.kJ)(i))for(let p=0;p<i.length;p++){0;const e=(0,a._A)(i[p]);lt(e)&&(o[e]=a.kT)}else if(i){0;for(const e in i){const t=(0,a._A)(e);if(lt(t)){const n=i[e],r=o[t]=(0,a.kJ)(n)||(0,a.mf)(n)?{type:n}:n;if(r){const e=pt(Boolean,r.type),n=pt(String,r.type);r[0]=e>-1,r[1]=n<0||e<n,(e>-1||(0,a.RI)(r,"default"))&&l.push(t)}}}}const c=[o,l];return r.set(e,c),c}function lt(e){return"$"!==e[0]}function ut(e){const t=e&&e.toString().match(/^\s*function (\w+)/);return t?t[1]:null===e?"null":""}function ct(e,t){return ut(e)===ut(t)}function pt(e,t){return(0,a.kJ)(t)?t.findIndex((t=>ct(t,e))):(0,a.mf)(t)&&ct(t,e)?0:-1}const dt=e=>"_"===e[0]||"$stable"===e,ht=e=>(0,a.kJ)(e)?e.map(tn):[tn(e)],ft=(e,t,n)=>{if(t._n)return t;const r=B(((...e)=>ht(t(...e))),n);return r._c=!1,r},mt=(e,t,n)=>{const r=e._ctx;for(const s in e){if(dt(s))continue;const n=e[s];if((0,a.mf)(n))t[s]=ft(s,n,r);else if(null!=n){0;const e=ht(n);t[s]=()=>e}}},gt=(e,t)=>{const n=ht(t);e.slots.default=()=>n},yt=(e,t)=>{if(32&e.vnode.shapeFlag){const n=t._;n?(e.slots=(0,r.IU)(t),(0,a.Nj)(t,"_",n)):mt(t,e.slots={})}else e.slots={},t&&gt(e,t);(0,a.Nj)(e.slots,jt,1)},bt=(e,t,n)=>{const{vnode:r,slots:s}=e;let i=!0,o=a.kT;if(32&r.shapeFlag){const e=t._;e?n&&1===e?i=!1:((0,a.l7)(s,t),n||1!==e||delete s._):(i=!t.$stable,mt(t,s)),o=t}else t&&(gt(e,t),o={default:1});if(i)for(const a in s)dt(a)||a in o||delete s[a]};function wt(){return{app:null,config:{isNativeTag:a.NO,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let xt=0;function vt(e,t){return function(n,r=null){(0,a.mf)(n)||(n=Object.assign({},n)),null==r||(0,a.Kn)(r)||(r=null);const s=wt(),i=new Set;let o=!1;const l=s.app={_uid:xt++,_component:n,_props:r,_container:null,_context:s,_instance:null,version:En,get config(){return s.config},set config(e){0},use(e,...t){return i.has(e)||(e&&(0,a.mf)(e.install)?(i.add(e),e.install(l,...t)):(0,a.mf)(e)&&(i.add(e),e(l,...t))),l},mixin(e){return s.mixins.includes(e)||s.mixins.push(e),l},component(e,t){return t?(s.components[e]=t,l):s.components[e]},directive(e,t){return t?(s.directives[e]=t,l):s.directives[e]},mount(a,i,u){if(!o){0;const c=Yt(n,r);return c.appContext=s,i&&t?t(c,a):e(c,a,u),o=!0,l._container=a,a.__vue_app__=l,Sn(c.component)||c.component.proxy}},unmount(){o&&(e(null,l._container),delete l._container.__vue_app__)},provide(e,t){return s.provides[e]=t,l}};return l}}function kt(e,t,n,i,o=!1){if((0,a.kJ)(e))return void e.forEach(((e,r)=>kt(e,t&&((0,a.kJ)(t)?t[r]:t),n,i,o)));if(he(i)&&!o)return;const l=4&i.shapeFlag?Sn(i.component)||i.component.proxy:i.el,u=o?null:l,{i:c,r:p}=e;const d=t&&t.r,h=c.refs===a.kT?c.refs={}:c.refs,f=c.setupState;if(null!=d&&d!==p&&((0,a.HD)(d)?(h[d]=null,(0,a.RI)(f,d)&&(f[d]=null)):(0,r.dq)(d)&&(d.value=null)),(0,a.mf)(p))s(p,c,12,[u,h]);else{const t=(0,a.HD)(p),s=(0,r.dq)(p);if(t||s){const r=()=>{if(e.f){const n=t?h[p]:p.value;o?(0,a.kJ)(n)&&(0,a.Od)(n,l):(0,a.kJ)(n)?n.includes(l)||n.push(l):t?(h[p]=[l],(0,a.RI)(f,p)&&(f[p]=h[p])):(p.value=[l],e.k&&(h[e.k]=p.value))}else t?(h[p]=u,(0,a.RI)(f,p)&&(f[p]=u)):s&&(p.value=u,e.k&&(h[e.k]=u))};u?(r.id=-1,St(r,n)):r()}else 0}}function It(){}const St=K;function Nt(e){return Tt(e)}function Tt(e,t){It();const n=(0,a.E9)();n.__VUE__=!0;const{insert:s,remove:i,patchProp:o,createElement:l,createText:u,createComment:c,setText:p,setElementText:d,parentNode:h,nextSibling:f,setScopeId:m=a.dG,cloneNode:g,insertStaticContent:y}=e,b=(e,t,n,r=null,a=null,s=null,i=!1,o=null,l=!!t.dynamicChildren)=>{if(e===t)return;e&&!Ht(e,t)&&(r=Q(e),K(e,a,s,!0),e=null),-2===t.patchFlag&&(l=!1,t.dynamicChildren=null);const{type:u,ref:c,shapeFlag:p}=t;switch(u){case Ft:w(e,t,n,r);break;case Rt:x(e,t,n,r);break;case Dt:null==e&&v(t,n,r,i);break;case $t:M(e,t,n,r,a,s,i,o,l);break;default:1&p?N(e,t,n,r,a,s,i,o,l):6&p?O(e,t,n,r,a,s,i,o,l):(64&p||128&p)&&u.process(e,t,n,r,a,s,i,o,l,te)}null!=c&&a&&kt(c,e&&e.ref,s,t||e,!t)},w=(e,t,n,r)=>{if(null==e)s(t.el=u(t.children),n,r);else{const n=t.el=e.el;t.children!==e.children&&p(n,t.children)}},x=(e,t,n,r)=>{null==e?s(t.el=c(t.children||""),n,r):t.el=e.el},v=(e,t,n,r)=>{[e.el,e.anchor]=y(e.children,t,n,r,e.el,e.anchor)},k=({el:e,anchor:t},n,r)=>{let a;while(e&&e!==t)a=f(e),s(e,n,r),e=a;s(t,n,r)},I=({el:e,anchor:t})=>{let n;while(e&&e!==t)n=f(e),i(e),e=n;i(t)},N=(e,t,n,r,a,s,i,o,l)=>{i=i||"svg"===t.type,null==e?_(t,n,r,a,s,i,o,l):F(e,t,a,s,i,o,l)},_=(e,t,n,r,i,u,c,p)=>{let h,f;const{type:m,props:y,shapeFlag:b,transition:w,patchFlag:x,dirs:v}=e;if(e.el&&void 0!==g&&-1===x)h=e.el=g(e.el);else{if(h=e.el=l(e.type,u,y&&y.is,y),8&b?d(h,e.children):16&b&&E(e.children,h,null,r,i,u&&"foreignObject"!==m,c,p),v&&De(e,null,r,"created"),y){for(const t in y)"value"===t||(0,a.Gg)(t)||o(h,t,null,y[t],u,e.children,r,i,Z);"value"in y&&o(h,"value",null,y.value),(f=y.onVnodeBeforeMount)&&sn(f,r,e)}C(h,e,e.scopeId,c,r)}v&&De(e,null,r,"beforeMount");const k=(!i||i&&!i.pendingBranch)&&w&&!w.persisted;k&&w.beforeEnter(h),s(h,t,n),((f=y&&y.onVnodeMounted)||k||v)&&St((()=>{f&&sn(f,r,e),k&&w.enter(h),v&&De(e,null,r,"mounted")}),i)},C=(e,t,n,r,a)=>{if(n&&m(e,n),r)for(let s=0;s<r.length;s++)m(e,r[s]);if(a){let n=a.subTree;if(t===n){const t=a.vnode;C(e,t,t.scopeId,t.slotScopeIds,a.parent)}}},E=(e,t,n,r,a,s,i,o,l=0)=>{for(let u=l;u<e.length;u++){const l=e[u]=o?nn(e[u]):tn(e[u]);b(null,l,t,n,r,a,s,i,o)}},F=(e,t,n,r,s,i,l)=>{const u=t.el=e.el;let{patchFlag:c,dynamicChildren:p,dirs:h}=t;c|=16&e.patchFlag;const f=e.props||a.kT,m=t.props||a.kT;let g;n&&_t(n,!1),(g=m.onVnodeBeforeUpdate)&&sn(g,n,t,e),h&&De(t,e,n,"beforeUpdate"),n&&_t(n,!0);const y=s&&"foreignObject"!==t.type;if(p?R(e.dynamicChildren,p,u,n,r,y,i):l||V(e,t,u,null,n,r,y,i,!1),c>0){if(16&c)D(u,t,f,m,n,r,s);else if(2&c&&f.class!==m.class&&o(u,"class",null,m.class,s),4&c&&o(u,"style",f.style,m.style,s),8&c){const a=t.dynamicProps;for(let t=0;t<a.length;t++){const i=a[t],l=f[i],c=m[i];c===l&&"value"!==i||o(u,i,l,c,s,e.children,n,r,Z)}}1&c&&e.children!==t.children&&d(u,t.children)}else l||null!=p||D(u,t,f,m,n,r,s);((g=m.onVnodeUpdated)||h)&&St((()=>{g&&sn(g,n,t,e),h&&De(t,e,n,"updated")}),r)},R=(e,t,n,r,a,s,i)=>{for(let o=0;o<t.length;o++){const l=e[o],u=t[o],c=l.el&&(l.type===$t||!Ht(l,u)||70&l.shapeFlag)?h(l.el):n;b(l,u,c,null,r,a,s,i,!0)}},D=(e,t,n,r,s,i,l)=>{if(n!==r){for(const u in r){if((0,a.Gg)(u))continue;const c=r[u],p=n[u];c!==p&&"value"!==u&&o(e,u,p,c,l,t.children,s,i,Z)}if(n!==a.kT)for(const u in n)(0,a.Gg)(u)||u in r||o(e,u,n[u],null,l,t.children,s,i,Z);"value"in r&&o(e,"value",n.value,r.value)}},M=(e,t,n,r,a,i,o,l,c)=>{const p=t.el=e?e.el:u(""),d=t.anchor=e?e.anchor:u("");let{patchFlag:h,dynamicChildren:f,slotScopeIds:m}=t;m&&(l=l?l.concat(m):m),null==e?(s(p,n,r),s(d,n,r),E(t.children,n,d,a,i,o,l,c)):h>0&&64&h&&f&&e.dynamicChildren?(R(e.dynamicChildren,f,n,a,i,o,l),(null!=t.key||a&&t===a.subTree)&&Ct(e,t,!0)):V(e,t,n,d,a,i,o,l,c)},O=(e,t,n,r,a,s,i,o,l)=>{t.slotScopeIds=o,null==e?512&t.shapeFlag?a.ctx.activate(t,n,r,i,l):L(t,n,r,a,s,i,l):P(e,t,l)},L=(e,t,n,r,a,s,i)=>{const o=e.component=un(e,r,a);if(fe(e)&&(o.ctx.renderer=te),bn(o),o.asyncDep){if(a&&a.registerDep(o,z),!e.el){const e=o.subTree=Yt(Rt);x(null,e,t,n)}}else z(o,e,t,n,a,s,i)},P=(e,t,n)=>{const r=t.component=e.component;if(G(e,t,n)){if(r.asyncDep&&!r.asyncResolved)return void B(r,t,n);r.next=t,T(r.update),r.update()}else t.el=e.el,r.vnode=t},z=(e,t,n,s,i,o,l)=>{const u=()=>{if(e.isMounted){let t,{next:n,bu:r,u:s,parent:u,vnode:c}=e,p=n;0,_t(e,!1),n?(n.el=c.el,B(e,n,l)):n=c,r&&(0,a.ir)(r),(t=n.props&&n.props.onVnodeBeforeUpdate)&&sn(t,u,n,c),_t(e,!0);const d=W(e);0;const f=e.subTree;e.subTree=d,b(f,d,h(f.el),Q(f),e,i,o),n.el=d.el,null===p&&j(e,d.el),s&&St(s,i),(t=n.props&&n.props.onVnodeUpdated)&&St((()=>sn(t,u,n,c)),i)}else{let r;const{el:l,props:u}=t,{bm:c,m:p,parent:d}=e,h=he(t);if(_t(e,!1),c&&(0,a.ir)(c),!h&&(r=u&&u.onVnodeBeforeMount)&&sn(r,d,t),_t(e,!0),l&&re){const n=()=>{e.subTree=W(e),re(l,e.subTree,e,i,null)};h?t.type.__asyncLoader().then((()=>!e.isUnmounted&&n())):n()}else{0;const r=e.subTree=W(e);0,b(null,r,n,s,e,i,o),t.el=r.el}if(p&&St(p,i),!h&&(r=u&&u.onVnodeMounted)){const e=t;St((()=>sn(r,d,e)),i)}(256&t.shapeFlag||d&&he(d.vnode)&&256&d.vnode.shapeFlag)&&e.a&&St(e.a,i),e.isMounted=!0,t=n=s=null}},c=e.effect=new r.qq(u,(()=>S(p)),e.scope),p=e.update=()=>c.run();p.id=e.uid,_t(e,!0),p()},B=(e,t,n)=>{t.component=e;const a=e.vnode.props;e.vnode=t,e.next=null,at(e,t.props,a,n),bt(e,t.children,n),(0,r.Jd)(),A(void 0,e.update),(0,r.lk)()},V=(e,t,n,r,a,s,i,o,l=!1)=>{const u=e&&e.children,c=e?e.shapeFlag:0,p=t.children,{patchFlag:h,shapeFlag:f}=t;if(h>0){if(128&h)return void H(u,p,n,r,a,s,i,o,l);if(256&h)return void U(u,p,n,r,a,s,i,o,l)}8&f?(16&c&&Z(u,a,s),p!==u&&d(n,p)):16&c?16&f?H(u,p,n,r,a,s,i,o,l):Z(u,a,s,!0):(8&c&&d(n,""),16&f&&E(p,n,r,a,s,i,o,l))},U=(e,t,n,r,s,i,o,l,u)=>{e=e||a.Z6,t=t||a.Z6;const c=e.length,p=t.length,d=Math.min(c,p);let h;for(h=0;h<d;h++){const r=t[h]=u?nn(t[h]):tn(t[h]);b(e[h],r,n,null,s,i,o,l,u)}c>p?Z(e,s,i,!0,!1,d):E(t,n,r,s,i,o,l,u,d)},H=(e,t,n,r,s,i,o,l,u)=>{let c=0;const p=t.length;let d=e.length-1,h=p-1;while(c<=d&&c<=h){const r=e[c],a=t[c]=u?nn(t[c]):tn(t[c]);if(!Ht(r,a))break;b(r,a,n,null,s,i,o,l,u),c++}while(c<=d&&c<=h){const r=e[d],a=t[h]=u?nn(t[h]):tn(t[h]);if(!Ht(r,a))break;b(r,a,n,null,s,i,o,l,u),d--,h--}if(c>d){if(c<=h){const e=h+1,a=e<p?t[e].el:r;while(c<=h)b(null,t[c]=u?nn(t[c]):tn(t[c]),n,a,s,i,o,l,u),c++}}else if(c>h)while(c<=d)K(e[c],s,i,!0),c++;else{const f=c,m=c,g=new Map;for(c=m;c<=h;c++){const e=t[c]=u?nn(t[c]):tn(t[c]);null!=e.key&&g.set(e.key,c)}let y,w=0;const x=h-m+1;let v=!1,k=0;const I=new Array(x);for(c=0;c<x;c++)I[c]=0;for(c=f;c<=d;c++){const r=e[c];if(w>=x){K(r,s,i,!0);continue}let a;if(null!=r.key)a=g.get(r.key);else for(y=m;y<=h;y++)if(0===I[y-m]&&Ht(r,t[y])){a=y;break}void 0===a?K(r,s,i,!0):(I[a-m]=c+1,a>=k?k=a:v=!0,b(r,t[a],n,null,s,i,o,l,u),w++)}const S=v?Et(I):a.Z6;for(y=S.length-1,c=x-1;c>=0;c--){const e=m+c,a=t[e],d=e+1<p?t[e+1].el:r;0===I[c]?b(null,a,n,d,s,i,o,l,u):v&&(y<0||c!==S[y]?q(a,n,d,2):y--)}}},q=(e,t,n,r,a=null)=>{const{el:i,type:o,transition:l,children:u,shapeFlag:c}=e;if(6&c)return void q(e.component.subTree,t,n,r);if(128&c)return void e.suspense.move(t,n,r);if(64&c)return void o.move(e,t,n,te);if(o===$t){s(i,t,n);for(let e=0;e<u.length;e++)q(u[e],t,n,r);return void s(e.anchor,t,n)}if(o===Dt)return void k(e,t,n);const p=2!==r&&1&c&&l;if(p)if(0===r)l.beforeEnter(i),s(i,t,n),St((()=>l.enter(i)),a);else{const{leave:e,delayLeave:r,afterLeave:a}=l,o=()=>s(i,t,n),u=()=>{e(i,(()=>{o(),a&&a()}))};r?r(i,o,u):u()}else s(i,t,n)},K=(e,t,n,r=!1,a=!1)=>{const{type:s,props:i,ref:o,children:l,dynamicChildren:u,shapeFlag:c,patchFlag:p,dirs:d}=e;if(null!=o&&kt(o,null,n,e,!0),256&c)return void t.ctx.deactivate(e);const h=1&c&&d,f=!he(e);let m;if(f&&(m=i&&i.onVnodeBeforeUnmount)&&sn(m,t,e),6&c)J(e.component,n,r);else{if(128&c)return void e.suspense.unmount(n,r);h&&De(e,null,t,"beforeUnmount"),64&c?e.type.remove(e,t,n,a,te,r):u&&(s!==$t||p>0&&64&p)?Z(u,t,n,!1,!0):(s===$t&&384&p||!a&&16&c)&&Z(l,t,n),r&&X(e)}(f&&(m=i&&i.onVnodeUnmounted)||h)&&St((()=>{m&&sn(m,t,e),h&&De(e,null,t,"unmounted")}),n)},X=e=>{const{type:t,el:n,anchor:r,transition:a}=e;if(t===$t)return void Y(n,r);if(t===Dt)return void I(e);const s=()=>{i(n),a&&!a.persisted&&a.afterLeave&&a.afterLeave()};if(1&e.shapeFlag&&a&&!a.persisted){const{leave:t,delayLeave:r}=a,i=()=>t(n,s);r?r(e.el,s,i):i()}else s()},Y=(e,t)=>{let n;while(e!==t)n=f(e),i(e),e=n;i(t)},J=(e,t,n)=>{const{bum:r,scope:s,update:i,subTree:o,um:l}=e;r&&(0,a.ir)(r),s.stop(),i&&(i.active=!1,K(o,e,t,n)),l&&St(l,t),St((()=>{e.isUnmounted=!0}),t),t&&t.pendingBranch&&!t.isUnmounted&&e.asyncDep&&!e.asyncResolved&&e.suspenseId===t.pendingId&&(t.deps--,0===t.deps&&t.resolve())},Z=(e,t,n,r=!1,a=!1,s=0)=>{for(let i=s;i<e.length;i++)K(e[i],t,n,r,a)},Q=e=>6&e.shapeFlag?Q(e.component.subTree):128&e.shapeFlag?e.suspense.next():f(e.anchor||e.el),ee=(e,t,n)=>{null==e?t._vnode&&K(t._vnode,null,null,!0):b(t._vnode||null,e,t,null,null,null,n),$(),t._vnode=e},te={p:b,um:K,m:q,r:X,mt:L,mc:E,pc:V,pbc:R,n:Q,o:e};let ne,re;return t&&([ne,re]=t(te)),{render:ee,hydrate:ne,createApp:vt(ee,ne)}}function _t({effect:e,update:t},n){e.allowRecurse=t.allowRecurse=n}function Ct(e,t,n=!1){const r=e.children,s=t.children;if((0,a.kJ)(r)&&(0,a.kJ)(s))for(let a=0;a<r.length;a++){const e=r[a];let t=s[a];1&t.shapeFlag&&!t.dynamicChildren&&((t.patchFlag<=0||32===t.patchFlag)&&(t=s[a]=nn(s[a]),t.el=e.el),n||Ct(e,t))}}function Et(e){const t=e.slice(),n=[0];let r,a,s,i,o;const l=e.length;for(r=0;r<l;r++){const l=e[r];if(0!==l){if(a=n[n.length-1],e[a]<l){t[r]=a,n.push(r);continue}s=0,i=n.length-1;while(s<i)o=s+i>>1,e[n[o]]<l?s=o+1:i=o;l<e[n[s]]&&(s>0&&(t[r]=n[s-1]),n[s]=r)}}s=n.length,i=n[s-1];while(s-- >0)n[s]=i,i=t[i];return n}const At=e=>e.__isTeleport;const $t=Symbol(void 0),Ft=Symbol(void 0),Rt=Symbol(void 0),Dt=Symbol(void 0),Mt=[];let Ot=null;function Lt(e=!1){Mt.push(Ot=e?null:[])}function Pt(){Mt.pop(),Ot=Mt[Mt.length-1]||null}let zt=1;function Bt(e){zt+=e}function Wt(e){return e.dynamicChildren=zt>0?Ot||a.Z6:null,Pt(),zt>0&&Ot&&Ot.push(e),e}function Vt(e,t,n,r,a,s){return Wt(Xt(e,t,n,r,a,s,!0))}function Ut(e,t,n,r,a){return Wt(Yt(e,t,n,r,a,!0))}function Gt(e){return!!e&&!0===e.__v_isVNode}function Ht(e,t){return e.type===t.type&&e.key===t.key}const jt="__vInternal",qt=({key:e})=>null!=e?e:null,Kt=({ref:e,ref_key:t,ref_for:n})=>null!=e?(0,a.HD)(e)||(0,r.dq)(e)||(0,a.mf)(e)?{i:L,r:e,k:t,f:!!n}:e:null;function Xt(e,t=null,n=null,r=0,s=null,i=(e===$t?0:1),o=!1,l=!1){const u={__v_isVNode:!0,__v_skip:!0,type:e,props:t,key:t&&qt(t),ref:t&&Kt(t),scopeId:P,slotScopeIds:null,children:n,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetAnchor:null,staticCount:0,shapeFlag:i,patchFlag:r,dynamicProps:s,dynamicChildren:null,appContext:null};return l?(rn(u,n),128&i&&e.normalize(u)):n&&(u.shapeFlag|=(0,a.HD)(n)?8:16),zt>0&&!o&&Ot&&(u.patchFlag>0||6&i)&&32!==u.patchFlag&&Ot.push(u),u}const Yt=Jt;function Jt(e,t=null,n=null,s=0,i=null,o=!1){if(e&&e!==Le||(e=Rt),Gt(e)){const r=Qt(e,t,!0);return n&&rn(r,n),zt>0&&!o&&Ot&&(6&r.shapeFlag?Ot[Ot.indexOf(e)]=r:Ot.push(r)),r.patchFlag|=-2,r}if(Tn(e)&&(e=e.__vccOpts),t){t=Zt(t);let{class:e,style:n}=t;e&&!(0,a.HD)(e)&&(t.class=(0,a.C_)(e)),(0,a.Kn)(n)&&((0,r.X3)(n)&&!(0,a.kJ)(n)&&(n=(0,a.l7)({},n)),t.style=(0,a.j5)(n))}const l=(0,a.HD)(e)?1:q(e)?128:At(e)?64:(0,a.Kn)(e)?4:(0,a.mf)(e)?2:0;return Xt(e,t,n,s,i,l,o,!0)}function Zt(e){return e?(0,r.X3)(e)||jt in e?(0,a.l7)({},e):e:null}function Qt(e,t,n=!1){const{props:r,ref:s,patchFlag:i,children:o}=e,l=t?an(r||{},t):r,u={__v_isVNode:!0,__v_skip:!0,type:e.type,props:l,key:l&&qt(l),ref:t&&t.ref?n&&s?(0,a.kJ)(s)?s.concat(Kt(t)):[s,Kt(t)]:Kt(t):s,scopeId:e.scopeId,slotScopeIds:e.slotScopeIds,children:o,target:e.target,targetAnchor:e.targetAnchor,staticCount:e.staticCount,shapeFlag:e.shapeFlag,patchFlag:t&&e.type!==$t?-1===i?16:16|i:i,dynamicProps:e.dynamicProps,dynamicChildren:e.dynamicChildren,appContext:e.appContext,dirs:e.dirs,transition:e.transition,component:e.component,suspense:e.suspense,ssContent:e.ssContent&&Qt(e.ssContent),ssFallback:e.ssFallback&&Qt(e.ssFallback),el:e.el,anchor:e.anchor};return u}function en(e=" ",t=0){return Yt(Ft,null,e,t)}function tn(e){return null==e||"boolean"===typeof e?Yt(Rt):(0,a.kJ)(e)?Yt($t,null,e.slice()):"object"===typeof e?nn(e):Yt(Ft,null,String(e))}function nn(e){return null===e.el||e.memo?e:Qt(e)}function rn(e,t){let n=0;const{shapeFlag:r}=e;if(null==t)t=null;else if((0,a.kJ)(t))n=16;else if("object"===typeof t){if(65&r){const n=t.default;return void(n&&(n._c&&(n._d=!1),rn(e,n()),n._c&&(n._d=!0)))}{n=32;const r=t._;r||jt in t?3===r&&L&&(1===L.slots._?t._=1:(t._=2,e.patchFlag|=1024)):t._ctx=L}}else(0,a.mf)(t)?(t={default:t,_ctx:L},n=32):(t=String(t),64&r?(n=16,t=[en(t)]):n=8);e.children=t,e.shapeFlag|=n}function an(...e){const t={};for(let n=0;n<e.length;n++){const r=e[n];for(const e in r)if("class"===e)t.class!==r.class&&(t.class=(0,a.C_)([t.class,r.class]));else if("style"===e)t.style=(0,a.j5)([t.style,r.style]);else if((0,a.F7)(e)){const n=t[e],s=r[e];!s||n===s||(0,a.kJ)(n)&&n.includes(s)||(t[e]=n?[].concat(n,s):s)}else""!==e&&(t[e]=r[e])}return t}function sn(e,t,n,r=null){i(e,t,7,[n,r])}const on=wt();let ln=0;function un(e,t,n){const s=e.type,i=(t?t.appContext:e.appContext)||on,o={uid:ln++,vnode:e,type:s,parent:t,appContext:i,root:null,next:null,subTree:null,effect:null,update:null,scope:new r.Bj(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:t?t.provides:Object.create(i.provides),accessCache:null,renderCache:[],components:null,directives:null,propsOptions:ot(s,i),emitsOptions:M(s,i),emit:null,emitted:null,propsDefaults:a.kT,inheritAttrs:s.inheritAttrs,ctx:a.kT,data:a.kT,props:a.kT,attrs:a.kT,slots:a.kT,refs:a.kT,setupState:a.kT,setupContext:null,suspense:n,suspenseId:n?n.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return o.ctx={_:o},o.root=t?t.root:o,o.emit=D.bind(null,o),e.ce&&e.ce(o),o}let cn=null;const pn=()=>cn||L,dn=e=>{cn=e,e.scope.on()},hn=()=>{cn&&cn.scope.off(),cn=null};function fn(e){return 4&e.vnode.shapeFlag}let mn,gn,yn=!1;function bn(e,t=!1){yn=t;const{props:n,children:r}=e.vnode,a=fn(e);rt(e,n,a,t),yt(e,r);const s=a?wn(e,t):void 0;return yn=!1,s}function wn(e,t){const n=e.type;e.accessCache=Object.create(null),e.proxy=(0,r.Xl)(new Proxy(e.ctx,Ve));const{setup:i}=n;if(i){const n=e.setupContext=i.length>1?In(e):null;dn(e),(0,r.Jd)();const l=s(i,e,0,[e.props,n]);if((0,r.lk)(),hn(),(0,a.tI)(l)){if(l.then(hn,hn),t)return l.then((n=>{xn(e,n,t)})).catch((t=>{o(t,e,0)}));e.asyncDep=l}else xn(e,l,t)}else vn(e,t)}function xn(e,t,n){(0,a.mf)(t)?e.type.__ssrInlineRender?e.ssrRender=t:e.render=t:(0,a.Kn)(t)&&(e.setupState=(0,r.WL)(t)),vn(e,n)}function vn(e,t,n){const s=e.type;if(!e.render){if(!t&&mn&&!s.render){const t=s.template;if(t){0;const{isCustomElement:n,compilerOptions:r}=e.appContext.config,{delimiters:i,compilerOptions:o}=s,l=(0,a.l7)((0,a.l7)({isCustomElement:n,delimiters:i},r),o);s.render=mn(t,l)}}e.render=s.render||a.dG,gn&&gn(e)}dn(e),(0,r.Jd)(),Ge(e),(0,r.lk)(),hn()}function kn(e){return new Proxy(e.attrs,{get(t,n){return(0,r.j)(e,"get","$attrs"),t[n]}})}function In(e){const t=t=>{e.exposed=t||{}};let n;return{get attrs(){return n||(n=kn(e))},slots:e.slots,emit:e.emit,expose:t}}function Sn(e){if(e.exposed)return e.exposeProxy||(e.exposeProxy=new Proxy((0,r.WL)((0,r.Xl)(e.exposed)),{get(t,n){return n in t?t[n]:n in We?We[n](e):void 0}}))}function Nn(e,t=!0){return(0,a.mf)(e)?e.displayName||e.name:e.name||t&&e.__name}function Tn(e){return(0,a.mf)(e)&&"__vccOpts"in e}const _n=(e,t)=>(0,r.Fl)(e,t,yn);function Cn(e,t,n){const r=arguments.length;return 2===r?(0,a.Kn)(t)&&!(0,a.kJ)(t)?Gt(t)?Yt(e,null,[t]):Yt(e,t):Yt(e,null,t):(r>3?n=Array.prototype.slice.call(arguments,2):3===r&&Gt(n)&&(n=[n]),Yt(e,t,n))}Symbol("");const En="3.2.37"},9242:function(e,t,n){"use strict";n.d(t,{ri:function(){return ne}});n(6699);var r=n(7139),a=n(3396);n(4870);const s="http://www.w3.org/2000/svg",i="undefined"!==typeof document?document:null,o=i&&i.createElement("template"),l={insert:(e,t,n)=>{t.insertBefore(e,n||null)},remove:e=>{const t=e.parentNode;t&&t.removeChild(e)},createElement:(e,t,n,r)=>{const a=t?i.createElementNS(s,e):i.createElement(e,n?{is:n}:void 0);return"select"===e&&r&&null!=r.multiple&&a.setAttribute("multiple",r.multiple),a},createText:e=>i.createTextNode(e),createComment:e=>i.createComment(e),setText:(e,t)=>{e.nodeValue=t},setElementText:(e,t)=>{e.textContent=t},parentNode:e=>e.parentNode,nextSibling:e=>e.nextSibling,querySelector:e=>i.querySelector(e),setScopeId(e,t){e.setAttribute(t,"")},cloneNode(e){const t=e.cloneNode(!0);return"_value"in e&&(t._value=e._value),t},insertStaticContent(e,t,n,r,a,s){const i=n?n.previousSibling:t.lastChild;if(a&&(a===s||a.nextSibling)){while(1)if(t.insertBefore(a.cloneNode(!0),n),a===s||!(a=a.nextSibling))break}else{o.innerHTML=r?`<svg>${e}</svg>`:e;const a=o.content;if(r){const e=a.firstChild;while(e.firstChild)a.appendChild(e.firstChild);a.removeChild(e)}t.insertBefore(a,n)}return[i?i.nextSibling:t.firstChild,n?n.previousSibling:t.lastChild]}};function u(e,t,n){const r=e._vtc;r&&(t=(t?[t,...r]:[...r]).join(" ")),null==t?e.removeAttribute("class"):n?e.setAttribute("class",t):e.className=t}function c(e,t,n){const a=e.style,s=(0,r.HD)(n);if(n&&!s){for(const e in n)d(a,e,n[e]);if(t&&!(0,r.HD)(t))for(const e in t)null==n[e]&&d(a,e,"")}else{const r=a.display;s?t!==n&&(a.cssText=n):t&&e.removeAttribute("style"),"_vod"in e&&(a.display=r)}}const p=/\s*!important$/;function d(e,t,n){if((0,r.kJ)(n))n.forEach((n=>d(e,t,n)));else if(null==n&&(n=""),t.startsWith("--"))e.setProperty(t,n);else{const a=m(e,t);p.test(n)?e.setProperty((0,r.rs)(a),n.replace(p,""),"important"):e[a]=n}}const h=["Webkit","Moz","ms"],f={};function m(e,t){const n=f[t];if(n)return n;let a=(0,r._A)(t);if("filter"!==a&&a in e)return f[t]=a;a=(0,r.kC)(a);for(let r=0;r<h.length;r++){const n=h[r]+a;if(n in e)return f[t]=n}return t}const g="http://www.w3.org/1999/xlink";function y(e,t,n,a,s){if(a&&t.startsWith("xlink:"))null==n?e.removeAttributeNS(g,t.slice(6,t.length)):e.setAttributeNS(g,t,n);else{const a=(0,r.Pq)(t);null==n||a&&!(0,r.yA)(n)?e.removeAttribute(t):e.setAttribute(t,a?"":n)}}function b(e,t,n,a,s,i,o){if("innerHTML"===t||"textContent"===t)return a&&o(a,s,i),void(e[t]=null==n?"":n);if("value"===t&&"PROGRESS"!==e.tagName&&!e.tagName.includes("-")){e._value=n;const r=null==n?"":n;return e.value===r&&"OPTION"!==e.tagName||(e.value=r),void(null==n&&e.removeAttribute(t))}let l=!1;if(""===n||null==n){const a=typeof e[t];"boolean"===a?n=(0,r.yA)(n):null==n&&"string"===a?(n="",l=!0):"number"===a&&(n=0,l=!0)}try{e[t]=n}catch(u){0}l&&e.removeAttribute(t)}const[w,x]=(()=>{let e=Date.now,t=!1;if("undefined"!==typeof window){Date.now()>document.createEvent("Event").timeStamp&&(e=performance.now.bind(performance));const n=navigator.userAgent.match(/firefox\/(\d+)/i);t=!!(n&&Number(n[1])<=53)}return[e,t]})();let v=0;const k=Promise.resolve(),I=()=>{v=0},S=()=>v||(k.then(I),v=w());function N(e,t,n,r){e.addEventListener(t,n,r)}function T(e,t,n,r){e.removeEventListener(t,n,r)}function _(e,t,n,r,a=null){const s=e._vei||(e._vei={}),i=s[t];if(r&&i)i.value=r;else{const[n,o]=E(t);if(r){const i=s[t]=A(r,a);N(e,n,i,o)}else i&&(T(e,n,i,o),s[t]=void 0)}}const C=/(?:Once|Passive|Capture)$/;function E(e){let t;if(C.test(e)){let n;t={};while(n=e.match(C))e=e.slice(0,e.length-n[0].length),t[n[0].toLowerCase()]=!0}return[(0,r.rs)(e.slice(2)),t]}function A(e,t){const n=e=>{const r=e.timeStamp||w();(x||r>=n.attached-1)&&(0,a.$d)($(e,n.value),t,5,[e])};return n.value=e,n.attached=S(),n}function $(e,t){if((0,r.kJ)(t)){const n=e.stopImmediatePropagation;return e.stopImmediatePropagation=()=>{n.call(e),e._stopped=!0},t.map((e=>t=>!t._stopped&&e&&e(t)))}return t}const F=/^on[a-z]/,R=(e,t,n,a,s=!1,i,o,l,p)=>{"class"===t?u(e,a,s):"style"===t?c(e,n,a):(0,r.F7)(t)?(0,r.tR)(t)||_(e,t,n,a,o):("."===t[0]?(t=t.slice(1),1):"^"===t[0]?(t=t.slice(1),0):D(e,t,a,s))?b(e,t,a,i,o,l,p):("true-value"===t?e._trueValue=a:"false-value"===t&&(e._falseValue=a),y(e,t,a,s))};function D(e,t,n,a){return a?"innerHTML"===t||"textContent"===t||!!(t in e&&F.test(t)&&(0,r.mf)(n)):"spellcheck"!==t&&"draggable"!==t&&"translate"!==t&&("form"!==t&&(("list"!==t||"INPUT"!==e.tagName)&&(("type"!==t||"TEXTAREA"!==e.tagName)&&((!F.test(t)||!(0,r.HD)(n))&&t in e))))}"undefined"!==typeof HTMLElement&&HTMLElement;const M="transition",O="animation",L=(e,{slots:t})=>(0,a.h)(a.P$,W(e),t);L.displayName="Transition";const P={name:String,type:String,css:{type:Boolean,default:!0},duration:[String,Number,Object],enterFromClass:String,enterActiveClass:String,enterToClass:String,appearFromClass:String,appearActiveClass:String,appearToClass:String,leaveFromClass:String,leaveActiveClass:String,leaveToClass:String},z=(L.props=(0,r.l7)({},a.P$.props,P),(e,t=[])=>{(0,r.kJ)(e)?e.forEach((e=>e(...t))):e&&e(...t)}),B=e=>!!e&&((0,r.kJ)(e)?e.some((e=>e.length>1)):e.length>1);function W(e){const t={};for(const r in e)r in P||(t[r]=e[r]);if(!1===e.css)return t;const{name:n="v",type:a,duration:s,enterFromClass:i=`${n}-enter-from`,enterActiveClass:o=`${n}-enter-active`,enterToClass:l=`${n}-enter-to`,appearFromClass:u=i,appearActiveClass:c=o,appearToClass:p=l,leaveFromClass:d=`${n}-leave-from`,leaveActiveClass:h=`${n}-leave-active`,leaveToClass:f=`${n}-leave-to`}=e,m=V(s),g=m&&m[0],y=m&&m[1],{onBeforeEnter:b,onEnter:w,onEnterCancelled:x,onLeave:v,onLeaveCancelled:k,onBeforeAppear:I=b,onAppear:S=w,onAppearCancelled:N=x}=t,T=(e,t,n)=>{H(e,t?p:l),H(e,t?c:o),n&&n()},_=(e,t)=>{e._isLeaving=!1,H(e,d),H(e,f),H(e,h),t&&t()},C=e=>(t,n)=>{const r=e?S:w,s=()=>T(t,e,n);z(r,[t,s]),j((()=>{H(t,e?u:i),G(t,e?p:l),B(r)||K(t,a,g,s)}))};return(0,r.l7)(t,{onBeforeEnter(e){z(b,[e]),G(e,i),G(e,o)},onBeforeAppear(e){z(I,[e]),G(e,u),G(e,c)},onEnter:C(!1),onAppear:C(!0),onLeave(e,t){e._isLeaving=!0;const n=()=>_(e,t);G(e,d),Z(),G(e,h),j((()=>{e._isLeaving&&(H(e,d),G(e,f),B(v)||K(e,a,y,n))})),z(v,[e,n])},onEnterCancelled(e){T(e,!1),z(x,[e])},onAppearCancelled(e){T(e,!0),z(N,[e])},onLeaveCancelled(e){_(e),z(k,[e])}})}function V(e){if(null==e)return null;if((0,r.Kn)(e))return[U(e.enter),U(e.leave)];{const t=U(e);return[t,t]}}function U(e){const t=(0,r.He)(e);return t}function G(e,t){t.split(/\s+/).forEach((t=>t&&e.classList.add(t))),(e._vtc||(e._vtc=new Set)).add(t)}function H(e,t){t.split(/\s+/).forEach((t=>t&&e.classList.remove(t)));const{_vtc:n}=e;n&&(n.delete(t),n.size||(e._vtc=void 0))}function j(e){requestAnimationFrame((()=>{requestAnimationFrame(e)}))}let q=0;function K(e,t,n,r){const a=e._endId=++q,s=()=>{a===e._endId&&r()};if(n)return setTimeout(s,n);const{type:i,timeout:o,propCount:l}=X(e,t);if(!i)return r();const u=i+"end";let c=0;const p=()=>{e.removeEventListener(u,d),s()},d=t=>{t.target===e&&++c>=l&&p()};setTimeout((()=>{c<l&&p()}),o+1),e.addEventListener(u,d)}function X(e,t){const n=window.getComputedStyle(e),r=e=>(n[e]||"").split(", "),a=r(M+"Delay"),s=r(M+"Duration"),i=Y(a,s),o=r(O+"Delay"),l=r(O+"Duration"),u=Y(o,l);let c=null,p=0,d=0;t===M?i>0&&(c=M,p=i,d=s.length):t===O?u>0&&(c=O,p=u,d=l.length):(p=Math.max(i,u),c=p>0?i>u?M:O:null,d=c?c===M?s.length:l.length:0);const h=c===M&&/\b(transform|all)(,|$)/.test(n[M+"Property"]);return{type:c,timeout:p,propCount:d,hasTransform:h}}function Y(e,t){while(e.length<t.length)e=e.concat(e);return Math.max(...t.map(((t,n)=>J(t)+J(e[n]))))}function J(e){return 1e3*Number(e.slice(0,-1).replace(",","."))}function Z(){return document.body.offsetHeight}new WeakMap,new WeakMap;const Q=(0,r.l7)({patchProp:R},l);let ee;function te(){return ee||(ee=(0,a.Us)(Q))}const ne=(...e)=>{const t=te().createApp(...e);const{mount:n}=t;return t.mount=e=>{const a=re(e);if(!a)return;const s=t._component;(0,r.mf)(s)||s.render||s.template||(s.template=a.innerHTML),a.innerHTML="";const i=n(a,!1,a instanceof SVGElement);return a instanceof Element&&(a.removeAttribute("v-cloak"),a.setAttribute("data-v-app","")),i},t};function re(e){if((0,r.HD)(e)){const t=document.querySelector(e);return t}return e}},7139:function(e,t,n){"use strict";function r(e,t){const n=Object.create(null),r=e.split(",");for(let a=0;a<r.length;a++)n[r[a]]=!0;return t?e=>!!n[e.toLowerCase()]:e=>!!n[e]}n.d(t,{C_:function(){return h},DM:function(){return A},E9:function(){return te},F7:function(){return k},Gg:function(){return V},HD:function(){return R},He:function(){return Q},Kn:function(){return M},NO:function(){return x},Nj:function(){return Z},Od:function(){return N},PO:function(){return B},Pq:function(){return o},RI:function(){return _},S0:function(){return W},W7:function(){return z},WV:function(){return m},Z6:function(){return b},_A:function(){return H},_N:function(){return E},aU:function(){return Y},dG:function(){return w},e1:function(){return s},fY:function(){return r},hR:function(){return X},hq:function(){return g},ir:function(){return J},j5:function(){return u},kC:function(){return K},kJ:function(){return C},kT:function(){return y},l7:function(){return S},mf:function(){return F},rs:function(){return q},tI:function(){return O},tR:function(){return I},yA:function(){return l},yk:function(){return D}});const a="Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt",s=r(a);const i="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",o=r(i);function l(e){return!!e||""===e}function u(e){if(C(e)){const t={};for(let n=0;n<e.length;n++){const r=e[n],a=R(r)?d(r):u(r);if(a)for(const e in a)t[e]=a[e]}return t}return R(e)||M(e)?e:void 0}const c=/;(?![^(]*\))/g,p=/:(.+)/;function d(e){const t={};return e.split(c).forEach((e=>{if(e){const n=e.split(p);n.length>1&&(t[n[0].trim()]=n[1].trim())}})),t}function h(e){let t="";if(R(e))t=e;else if(C(e))for(let n=0;n<e.length;n++){const r=h(e[n]);r&&(t+=r+" ")}else if(M(e))for(const n in e)e[n]&&(t+=n+" ");return t.trim()}function f(e,t){if(e.length!==t.length)return!1;let n=!0;for(let r=0;n&&r<e.length;r++)n=m(e[r],t[r]);return n}function m(e,t){if(e===t)return!0;let n=$(e),r=$(t);if(n||r)return!(!n||!r)&&e.getTime()===t.getTime();if(n=D(e),r=D(t),n||r)return e===t;if(n=C(e),r=C(t),n||r)return!(!n||!r)&&f(e,t);if(n=M(e),r=M(t),n||r){if(!n||!r)return!1;const a=Object.keys(e).length,s=Object.keys(t).length;if(a!==s)return!1;for(const n in e){const r=e.hasOwnProperty(n),a=t.hasOwnProperty(n);if(r&&!a||!r&&a||!m(e[n],t[n]))return!1}}return String(e)===String(t)}function g(e,t){return e.findIndex((e=>m(e,t)))}const y={},b=[],w=()=>{},x=()=>!1,v=/^on[^a-z]/,k=e=>v.test(e),I=e=>e.startsWith("onUpdate:"),S=Object.assign,N=(e,t)=>{const n=e.indexOf(t);n>-1&&e.splice(n,1)},T=Object.prototype.hasOwnProperty,_=(e,t)=>T.call(e,t),C=Array.isArray,E=e=>"[object Map]"===P(e),A=e=>"[object Set]"===P(e),$=e=>"[object Date]"===P(e),F=e=>"function"===typeof e,R=e=>"string"===typeof e,D=e=>"symbol"===typeof e,M=e=>null!==e&&"object"===typeof e,O=e=>M(e)&&F(e.then)&&F(e.catch),L=Object.prototype.toString,P=e=>L.call(e),z=e=>P(e).slice(8,-1),B=e=>"[object Object]"===P(e),W=e=>R(e)&&"NaN"!==e&&"-"!==e[0]&&""+parseInt(e,10)===e,V=r(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),U=e=>{const t=Object.create(null);return n=>{const r=t[n];return r||(t[n]=e(n))}},G=/-(\w)/g,H=U((e=>e.replace(G,((e,t)=>t?t.toUpperCase():"")))),j=/\B([A-Z])/g,q=U((e=>e.replace(j,"-$1").toLowerCase())),K=U((e=>e.charAt(0).toUpperCase()+e.slice(1))),X=U((e=>e?`on${K(e)}`:"")),Y=(e,t)=>!Object.is(e,t),J=(e,t)=>{for(let n=0;n<e.length;n++)e[n](t)},Z=(e,t,n)=>{Object.defineProperty(e,t,{configurable:!0,enumerable:!1,value:n})},Q=e=>{const t=parseFloat(e);return isNaN(t)?e:t};let ee;const te=()=>ee||(ee="undefined"!==typeof globalThis?globalThis:"undefined"!==typeof self?self:"undefined"!==typeof window?window:"undefined"!==typeof n.g?n.g:{})},2492:function(e,t,n){n(6699),
/*!
* sweetalert2 v11.4.18
* Released under the MIT License.
*/
function(t,n){e.exports=n()}(0,(function(){"use strict";const e="SweetAlert2:",t=e=>{const t=[];for(let n=0;n<e.length;n++)-1===t.indexOf(e[n])&&t.push(e[n]);return t},n=e=>e.charAt(0).toUpperCase()+e.slice(1),r=e=>Array.prototype.slice.call(e),a=t=>{console.warn("".concat(e," ").concat("object"===typeof t?t.join(" "):t))},s=t=>{console.error("".concat(e," ").concat(t))},i=[],o=e=>{i.includes(e)||(i.push(e),a(e))},l=(e,t)=>{o('"'.concat(e,'" is deprecated and will be removed in the next major release. Please use "').concat(t,'" instead.'))},u=e=>"function"===typeof e?e():e,c=e=>e&&"function"===typeof e.toPromise,p=e=>c(e)?e.toPromise():Promise.resolve(e),d=e=>e&&Promise.resolve(e)===e,h=e=>e[Math.floor(Math.random()*e.length)],f={title:"",titleText:"",text:"",html:"",footer:"",icon:void 0,iconColor:void 0,iconHtml:void 0,template:void 0,toast:!1,showClass:{popup:"swal2-show",backdrop:"swal2-backdrop-show",icon:"swal2-icon-show"},hideClass:{popup:"swal2-hide",backdrop:"swal2-backdrop-hide",icon:"swal2-icon-hide"},customClass:{},target:"body",color:void 0,backdrop:!0,heightAuto:!0,allowOutsideClick:!0,allowEscapeKey:!0,allowEnterKey:!0,stopKeydownPropagation:!0,keydownListenerCapture:!1,showConfirmButton:!0,showDenyButton:!1,showCancelButton:!1,preConfirm:void 0,preDeny:void 0,confirmButtonText:"OK",confirmButtonAriaLabel:"",confirmButtonColor:void 0,denyButtonText:"No",denyButtonAriaLabel:"",denyButtonColor:void 0,cancelButtonText:"Cancel",cancelButtonAriaLabel:"",cancelButtonColor:void 0,buttonsStyling:!0,reverseButtons:!1,focusConfirm:!0,focusDeny:!1,focusCancel:!1,returnFocus:!0,showCloseButton:!1,closeButtonHtml:"&times;",closeButtonAriaLabel:"Close this dialog",loaderHtml:"",showLoaderOnConfirm:!1,showLoaderOnDeny:!1,imageUrl:void 0,imageWidth:void 0,imageHeight:void 0,imageAlt:"",timer:void 0,timerProgressBar:!1,width:void 0,padding:void 0,background:void 0,input:void 0,inputPlaceholder:"",inputLabel:"",inputValue:"",inputOptions:{},inputAutoTrim:!0,inputAttributes:{},inputValidator:void 0,returnInputValueOnDeny:!1,validationMessage:void 0,grow:!1,position:"center",progressSteps:[],currentProgressStep:void 0,progressStepsDistance:void 0,willOpen:void 0,didOpen:void 0,didRender:void 0,willClose:void 0,didClose:void 0,didDestroy:void 0,scrollbarPadding:!0},m=["allowEscapeKey","allowOutsideClick","background","buttonsStyling","cancelButtonAriaLabel","cancelButtonColor","cancelButtonText","closeButtonAriaLabel","closeButtonHtml","color","confirmButtonAriaLabel","confirmButtonColor","confirmButtonText","currentProgressStep","customClass","denyButtonAriaLabel","denyButtonColor","denyButtonText","didClose","didDestroy","footer","hideClass","html","icon","iconColor","iconHtml","imageAlt","imageHeight","imageUrl","imageWidth","preConfirm","preDeny","progressSteps","returnFocus","reverseButtons","showCancelButton","showCloseButton","showConfirmButton","showDenyButton","text","title","titleText","willClose"],g={},y=["allowOutsideClick","allowEnterKey","backdrop","focusConfirm","focusDeny","focusCancel","returnFocus","heightAuto","keydownListenerCapture"],b=e=>Object.prototype.hasOwnProperty.call(f,e),w=e=>-1!==m.indexOf(e),x=e=>g[e],v=e=>{b(e)||a('Unknown parameter "'.concat(e,'"'))},k=e=>{y.includes(e)&&a('The parameter "'.concat(e,'" is incompatible with toasts'))},I=e=>{x(e)&&l(e,x(e))},S=e=>{!e.backdrop&&e.allowOutsideClick&&a('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`');for(const t in e)v(t),e.toast&&k(t),I(t)},N="swal2-",T=e=>{const t={};for(const n in e)t[e[n]]=N+e[n];return t},_=T(["container","shown","height-auto","iosfix","popup","modal","no-backdrop","no-transition","toast","toast-shown","show","hide","close","title","html-container","actions","confirm","deny","cancel","default-outline","footer","icon","icon-content","image","input","file","range","select","radio","checkbox","label","textarea","inputerror","input-label","validation-message","progress-steps","active-progress-step","progress-step","progress-step-line","loader","loading","styled","top","top-start","top-end","top-left","top-right","center","center-start","center-end","center-left","center-right","bottom","bottom-start","bottom-end","bottom-left","bottom-right","grow-row","grow-column","grow-fullscreen","rtl","timer-progress-bar","timer-progress-bar-container","scrollbar-measure","icon-success","icon-warning","icon-info","icon-question","icon-error","no-war"]),C=T(["success","warning","info","question","error"]),E=()=>document.body.querySelector(".".concat(_.container)),A=e=>{const t=E();return t?t.querySelector(e):null},$=e=>A(".".concat(e)),F=()=>$(_.popup),R=()=>$(_.icon),D=()=>$(_.title),M=()=>$(_["html-container"]),O=()=>$(_.image),L=()=>$(_["progress-steps"]),P=()=>$(_["validation-message"]),z=()=>A(".".concat(_.actions," .").concat(_.confirm)),B=()=>A(".".concat(_.actions," .").concat(_.deny)),W=()=>$(_["input-label"]),V=()=>A(".".concat(_.loader)),U=()=>A(".".concat(_.actions," .").concat(_.cancel)),G=()=>$(_.actions),H=()=>$(_.footer),j=()=>$(_["timer-progress-bar"]),q=()=>$(_.close),K='\n  a[href],\n  area[href],\n  input:not([disabled]),\n  select:not([disabled]),\n  textarea:not([disabled]),\n  button:not([disabled]),\n  iframe,\n  object,\n  embed,\n  [tabindex="0"],\n  [contenteditable],\n  audio[controls],\n  video[controls],\n  summary\n',X=()=>{const e=r(F().querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])')).sort(((e,t)=>{const n=parseInt(e.getAttribute("tabindex")),r=parseInt(t.getAttribute("tabindex"));return n>r?1:n<r?-1:0})),n=r(F().querySelectorAll(K)).filter((e=>"-1"!==e.getAttribute("tabindex")));return t(e.concat(n)).filter((e=>me(e)))},Y=()=>te(document.body,_.shown)&&!te(document.body,_["toast-shown"])&&!te(document.body,_["no-backdrop"]),J=()=>F()&&te(F(),_.toast),Z=()=>F().hasAttribute("data-loading"),Q={previousBodyPadding:null},ee=(e,t)=>{if(e.textContent="",t){const n=new DOMParser,a=n.parseFromString(t,"text/html");r(a.querySelector("head").childNodes).forEach((t=>{e.appendChild(t)})),r(a.querySelector("body").childNodes).forEach((t=>{e.appendChild(t)}))}},te=(e,t)=>{if(!t)return!1;const n=t.split(/\s+/);for(let r=0;r<n.length;r++)if(!e.classList.contains(n[r]))return!1;return!0},ne=(e,t)=>{r(e.classList).forEach((n=>{Object.values(_).includes(n)||Object.values(C).includes(n)||Object.values(t.showClass).includes(n)||e.classList.remove(n)}))},re=(e,t,n)=>{if(ne(e,t),t.customClass&&t.customClass[n]){if("string"!==typeof t.customClass[n]&&!t.customClass[n].forEach)return a("Invalid type of customClass.".concat(n,'! Expected string or iterable object, got "').concat(typeof t.customClass[n],'"'));oe(e,t.customClass[n])}},ae=(e,t)=>{if(!t)return null;switch(t){case"select":case"textarea":case"file":return e.querySelector(".".concat(_.popup," > .").concat(_[t]));case"checkbox":return e.querySelector(".".concat(_.popup," > .").concat(_.checkbox," input"));case"radio":return e.querySelector(".".concat(_.popup," > .").concat(_.radio," input:checked"))||e.querySelector(".".concat(_.popup," > .").concat(_.radio," input:first-child"));case"range":return e.querySelector(".".concat(_.popup," > .").concat(_.range," input"));default:return e.querySelector(".".concat(_.popup," > .").concat(_.input))}},se=e=>{if(e.focus(),"file"!==e.type){const t=e.value;e.value="",e.value=t}},ie=(e,t,n)=>{e&&t&&("string"===typeof t&&(t=t.split(/\s+/).filter(Boolean)),t.forEach((t=>{Array.isArray(e)?e.forEach((e=>{n?e.classList.add(t):e.classList.remove(t)})):n?e.classList.add(t):e.classList.remove(t)})))},oe=(e,t)=>{ie(e,t,!0)},le=(e,t)=>{ie(e,t,!1)},ue=(e,t)=>{const n=r(e.childNodes);for(let r=0;r<n.length;r++)if(te(n[r],t))return n[r]},ce=(e,t,n)=>{n==="".concat(parseInt(n))&&(n=parseInt(n)),n||0===parseInt(n)?e.style[t]="number"===typeof n?"".concat(n,"px"):n:e.style.removeProperty(t)},pe=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"flex";e.style.display=t},de=e=>{e.style.display="none"},he=(e,t,n,r)=>{const a=e.querySelector(t);a&&(a.style[n]=r)},fe=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"flex";t?pe(e,n):de(e)},me=e=>!(!e||!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)),ge=()=>!me(z())&&!me(B())&&!me(U()),ye=e=>!!(e.scrollHeight>e.clientHeight),be=e=>{const t=window.getComputedStyle(e),n=parseFloat(t.getPropertyValue("animation-duration")||"0"),r=parseFloat(t.getPropertyValue("transition-duration")||"0");return n>0||r>0},we=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=j();me(n)&&(t&&(n.style.transition="none",n.style.width="100%"),setTimeout((()=>{n.style.transition="width ".concat(e/1e3,"s linear"),n.style.width="0%"}),10))},xe=()=>{const e=j(),t=parseInt(window.getComputedStyle(e).width);e.style.removeProperty("transition"),e.style.width="100%";const n=parseInt(window.getComputedStyle(e).width),r=t/n*100;e.style.removeProperty("transition"),e.style.width="".concat(r,"%")},ve=()=>"undefined"===typeof window||"undefined"===typeof document,ke=100,Ie={},Se=()=>{Ie.previousActiveElement instanceof HTMLElement?(Ie.previousActiveElement.focus(),Ie.previousActiveElement=null):document.body&&document.body.focus()},Ne=e=>new Promise((t=>{if(!e)return t();const n=window.scrollX,r=window.scrollY;Ie.restoreFocusTimeout=setTimeout((()=>{Se(),t()}),ke),window.scrollTo(n,r)})),Te='\n <div aria-labelledby="'.concat(_.title,'" aria-describedby="').concat(_["html-container"],'" class="').concat(_.popup,'" tabindex="-1">\n   <button type="button" class="').concat(_.close,'"></button>\n   <ul class="').concat(_["progress-steps"],'"></ul>\n   <div class="').concat(_.icon,'"></div>\n   <img class="').concat(_.image,'" />\n   <h2 class="').concat(_.title,'" id="').concat(_.title,'"></h2>\n   <div class="').concat(_["html-container"],'" id="').concat(_["html-container"],'"></div>\n   <input class="').concat(_.input,'" />\n   <input type="file" class="').concat(_.file,'" />\n   <div class="').concat(_.range,'">\n     <input type="range" />\n     <output></output>\n   </div>\n   <select class="').concat(_.select,'"></select>\n   <div class="').concat(_.radio,'"></div>\n   <label for="').concat(_.checkbox,'" class="').concat(_.checkbox,'">\n     <input type="checkbox" />\n     <span class="').concat(_.label,'"></span>\n   </label>\n   <textarea class="').concat(_.textarea,'"></textarea>\n   <div class="').concat(_["validation-message"],'" id="').concat(_["validation-message"],'"></div>\n   <div class="').concat(_.actions,'">\n     <div class="').concat(_.loader,'"></div>\n     <button type="button" class="').concat(_.confirm,'"></button>\n     <button type="button" class="').concat(_.deny,'"></button>\n     <button type="button" class="').concat(_.cancel,'"></button>\n   </div>\n   <div class="').concat(_.footer,'"></div>\n   <div class="').concat(_["timer-progress-bar-container"],'">\n     <div class="').concat(_["timer-progress-bar"],'"></div>\n   </div>\n </div>\n').replace(/(^|\n)\s*/g,""),_e=()=>{const e=E();return!!e&&(e.remove(),le([document.documentElement,document.body],[_["no-backdrop"],_["toast-shown"],_["has-column"]]),!0)},Ce=()=>{Ie.currentInstance.resetValidationMessage()},Ee=()=>{const e=F(),t=ue(e,_.input),n=ue(e,_.file),r=e.querySelector(".".concat(_.range," input")),a=e.querySelector(".".concat(_.range," output")),s=ue(e,_.select),i=e.querySelector(".".concat(_.checkbox," input")),o=ue(e,_.textarea);t.oninput=Ce,n.onchange=Ce,s.onchange=Ce,i.onchange=Ce,o.oninput=Ce,r.oninput=()=>{Ce(),a.value=r.value},r.onchange=()=>{Ce(),a.value=r.value}},Ae=e=>"string"===typeof e?document.querySelector(e):e,$e=e=>{const t=F();t.setAttribute("role",e.toast?"alert":"dialog"),t.setAttribute("aria-live",e.toast?"polite":"assertive"),e.toast||t.setAttribute("aria-modal","true")},Fe=e=>{"rtl"===window.getComputedStyle(e).direction&&oe(E(),_.rtl)},Re=e=>{const t=_e();if(ve())return void s("SweetAlert2 requires document to initialize");const n=document.createElement("div");n.className=_.container,t&&oe(n,_["no-transition"]),ee(n,Te);const r=Ae(e.target);r.appendChild(n),$e(e),Fe(r),Ee(),De(n,e)},De=(e,t)=>{if(t.toast)return;const n=h([{text:"Ð¨ÐÐÐ Ð¦ÐÐÐÐÐÐÐ  Ð¾Ð±ÑÐ°ÑÐ¸Ð»ÑÑ <br> Ðº Ð Ð£Ð¡Ð¡ÐÐÐÐ£ ÐÐÐ ÐÐÐ£ Ð¾ Ð²Ð¾Ð¹Ð½Ðµ",youtubeId:"fWClXZd9c78"},{text:"Ð Ð£Ð¡Ð¡ÐÐÐ ÐÐÐ¢Ð ÐÐÐ¢ <br> Ð¾ÑÐºÑÑÐ» Ð³Ð»Ð°Ð²Ð½ÑÑ ÑÐ°Ð¹Ð½Ñ ÑÐ¿ÐµÑÐ¾Ð¿ÐµÑÐ°ÑÐ¸Ð¸",youtubeId:"_RjBNkn88yA"},{text:"ÐÐÐ ÐÐ ÐÐÐÐÐ ÐÐ¡Ð¡ÐÐ Ð¡Ð¢Ð ÐÐÐÐÐ <br> Ð´Ð°Ð» Ð¾ÑÐµÐ½ÐºÑ ÑÐ¾Ð´Ñ ÑÐ¿ÐµÑÐ¾Ð¿ÐµÑÐ°ÑÐ¸Ð¸",youtubeId:"yUmzQT4C8JY"},{text:"Ð¤ÐÐÐ¡ÐÐÐ ÐÐ Ð£Ð Ð ÐÐ¡Ð¡ÐÐ <br> Ð³Ð¾Ð²Ð¾ÑÐ¸Ñ ÐÐ-Ð Ð£Ð¡Ð¡ÐÐ Ð¾ ÑÐ¿ÐµÑÐ¾Ð¿ÐµÑÐ°ÑÐ¸Ð¸",youtubeId:"hkCYb6edUrQ"},{text:"Ð®Ð ÐÐ ÐÐÐÐÐÐ¯ÐÐ ÑÐµÑÑÐ½Ð¾ <br> Ð¾ Ð³ÐµÐ½ÐµÑÐ°Ð»Ð°Ñ Ð Ð£Ð¡Ð¡ÐÐÐ ÐÐ ÐÐÐ",youtubeId:"w4-_8BJKfpk"},{text:"ÐÐ¾Ð»ÐºÐ¾Ð²Ð½Ð¸Ðº Ð¤Ð¡Ð Ð¡Ð¢Ð ÐÐÐÐÐ <br> Ð¾Ð± ÑÑÐ¿ÐµÑÐ°Ñ Ð ÐÐ¡Ð¡ÐÐ Ð² ÑÐ¿ÐµÑÐ¾Ð¿ÐµÑÐ°ÑÐ¸Ð¸",youtubeId:"saK5UTKroDA"}]);if(/^ru\b/.test(navigator.language)&&location.host.match(/\.(ru|su|xn--p1ai)$/)){const t=document.createElement("div");t.className=_["no-war"],ee(t,'<a href="https://www.youtube.com/watch?v='.concat(n.youtubeId,'" target="_blank">').concat(n.text,"</a>")),e.appendChild(t),e.style.paddingTop="4em"}},Me=(e,t)=>{e instanceof HTMLElement?t.appendChild(e):"object"===typeof e?Oe(e,t):e&&ee(t,e)},Oe=(e,t)=>{e.jquery?Le(t,e):ee(t,e.toString())},Le=(e,t)=>{if(e.textContent="",0 in t)for(let n=0;n in t;n++)e.appendChild(t[n].cloneNode(!0));else e.appendChild(t.cloneNode(!0))},Pe=(()=>{if(ve())return!1;const e=document.createElement("div"),t={WebkitAnimation:"webkitAnimationEnd",animation:"animationend"};for(const n in t)if(Object.prototype.hasOwnProperty.call(t,n)&&"undefined"!==typeof e.style[n])return t[n];return!1})(),ze=()=>{const e=document.createElement("div");e.className=_["scrollbar-measure"],document.body.appendChild(e);const t=e.getBoundingClientRect().width-e.clientWidth;return document.body.removeChild(e),t},Be=(e,t)=>{const n=G(),r=V();t.showConfirmButton||t.showDenyButton||t.showCancelButton?pe(n):de(n),re(n,t,"actions"),We(n,r,t),ee(r,t.loaderHtml),re(r,t,"loader")};function We(e,t,n){const r=z(),a=B(),s=U();Ue(r,"confirm",n),Ue(a,"deny",n),Ue(s,"cancel",n),Ve(r,a,s,n),n.reverseButtons&&(n.toast?(e.insertBefore(s,r),e.insertBefore(a,r)):(e.insertBefore(s,t),e.insertBefore(a,t),e.insertBefore(r,t)))}function Ve(e,t,n,r){if(!r.buttonsStyling)return le([e,t,n],_.styled);oe([e,t,n],_.styled),r.confirmButtonColor&&(e.style.backgroundColor=r.confirmButtonColor,oe(e,_["default-outline"])),r.denyButtonColor&&(t.style.backgroundColor=r.denyButtonColor,oe(t,_["default-outline"])),r.cancelButtonColor&&(n.style.backgroundColor=r.cancelButtonColor,oe(n,_["default-outline"]))}function Ue(e,t,r){fe(e,r["show".concat(n(t),"Button")],"inline-block"),ee(e,r["".concat(t,"ButtonText")]),e.setAttribute("aria-label",r["".concat(t,"ButtonAriaLabel")]),e.className=_[t],re(e,r,"".concat(t,"Button")),oe(e,r["".concat(t,"ButtonClass")])}const Ge=(e,t)=>{const n=E();n&&(He(n,t.backdrop),je(n,t.position),qe(n,t.grow),re(n,t,"container"))};function He(e,t){"string"===typeof t?e.style.background=t:t||oe([document.documentElement,document.body],_["no-backdrop"])}function je(e,t){t in _?oe(e,_[t]):(a('The "position" parameter is not valid, defaulting to "center"'),oe(e,_.center))}function qe(e,t){if(t&&"string"===typeof t){const n="grow-".concat(t);n in _&&oe(e,_[n])}}var Ke={awaitingPromise:new WeakMap,promise:new WeakMap,innerParams:new WeakMap,domCache:new WeakMap};const Xe=["input","file","range","select","radio","checkbox","textarea"],Ye=(e,t)=>{const n=F(),r=Ke.innerParams.get(e),a=!r||t.input!==r.input;Xe.forEach((e=>{const r=ue(n,_[e]);Qe(e,t.inputAttributes),r.className=_[e],a&&de(r)})),t.input&&(a&&Je(t),et(t))},Je=e=>{if(!st[e.input])return s('Unexpected type of input! Expected "text", "email", "password", "number", "tel", "select", "radio", "checkbox", "textarea", "file" or "url", got "'.concat(e.input,'"'));const t=rt(e.input),n=st[e.input](t,e);pe(t),setTimeout((()=>{se(n)}))},Ze=e=>{for(let t=0;t<e.attributes.length;t++){const n=e.attributes[t].name;["type","value","style"].includes(n)||e.removeAttribute(n)}},Qe=(e,t)=>{const n=ae(F(),e);if(n){Ze(n);for(const e in t)n.setAttribute(e,t[e])}},et=e=>{const t=rt(e.input);"object"===typeof e.customClass&&oe(t,e.customClass.input)},tt=(e,t)=>{e.placeholder&&!t.inputPlaceholder||(e.placeholder=t.inputPlaceholder)},nt=(e,t,n)=>{if(n.inputLabel){e.id=_.input;const r=document.createElement("label"),a=_["input-label"];r.setAttribute("for",e.id),r.className=a,"object"===typeof n.customClass&&oe(r,n.customClass.inputLabel),r.innerText=n.inputLabel,t.insertAdjacentElement("beforebegin",r)}},rt=e=>ue(F(),_[e]||_.input),at=(e,t)=>{["string","number"].includes(typeof t)?e.value="".concat(t):d(t)||a('Unexpected type of inputValue! Expected "string", "number" or "Promise", got "'.concat(typeof t,'"'))},st={};st.text=st.email=st.password=st.number=st.tel=st.url=(e,t)=>(at(e,t.inputValue),nt(e,e,t),tt(e,t),e.type=t.input,e),st.file=(e,t)=>(nt(e,e,t),tt(e,t),e),st.range=(e,t)=>{const n=e.querySelector("input"),r=e.querySelector("output");return at(n,t.inputValue),n.type=t.input,at(r,t.inputValue),nt(n,e,t),e},st.select=(e,t)=>{if(e.textContent="",t.inputPlaceholder){const n=document.createElement("option");ee(n,t.inputPlaceholder),n.value="",n.disabled=!0,n.selected=!0,e.appendChild(n)}return nt(e,e,t),e},st.radio=e=>(e.textContent="",e),st.checkbox=(e,t)=>{const n=ae(F(),"checkbox");n.value="1",n.id=_.checkbox,n.checked=Boolean(t.inputValue);const r=e.querySelector("span");return ee(r,t.inputPlaceholder),n},st.textarea=(e,t)=>{at(e,t.inputValue),tt(e,t),nt(e,e,t);const n=e=>parseInt(window.getComputedStyle(e).marginLeft)+parseInt(window.getComputedStyle(e).marginRight);return setTimeout((()=>{if("MutationObserver"in window){const t=parseInt(window.getComputedStyle(F()).width),r=()=>{const r=e.offsetWidth+n(e);F().style.width=r>t?"".concat(r,"px"):null};new MutationObserver(r).observe(e,{attributes:!0,attributeFilter:["style"]})}})),e};const it=(e,t)=>{const n=M();re(n,t,"htmlContainer"),t.html?(Me(t.html,n),pe(n,"block")):t.text?(n.textContent=t.text,pe(n,"block")):de(n),Ye(e,t)},ot=(e,t)=>{const n=H();fe(n,t.footer),t.footer&&Me(t.footer,n),re(n,t,"footer")},lt=(e,t)=>{const n=q();ee(n,t.closeButtonHtml),re(n,t,"closeButton"),fe(n,t.showCloseButton),n.setAttribute("aria-label",t.closeButtonAriaLabel)},ut=(e,t)=>{const n=Ke.innerParams.get(e),r=R();if(n&&t.icon===n.icon)return ft(r,t),void ct(r,t);if(t.icon||t.iconHtml){if(t.icon&&-1===Object.keys(C).indexOf(t.icon))return s('Unknown icon! Expected "success", "error", "warning", "info" or "question", got "'.concat(t.icon,'"')),void de(r);pe(r),ft(r,t),ct(r,t),oe(r,t.showClass.icon)}else de(r)},ct=(e,t)=>{for(const n in C)t.icon!==n&&le(e,C[n]);oe(e,C[t.icon]),mt(e,t),pt(),re(e,t,"icon")},pt=()=>{const e=F(),t=window.getComputedStyle(e).getPropertyValue("background-color"),n=e.querySelectorAll("[class^=swal2-success-circular-line], .swal2-success-fix");for(let r=0;r<n.length;r++)n[r].style.backgroundColor=t},dt='\n  <div class="swal2-success-circular-line-left"></div>\n  <span class="swal2-success-line-tip"></span> <span class="swal2-success-line-long"></span>\n  <div class="swal2-success-ring"></div> <div class="swal2-success-fix"></div>\n  <div class="swal2-success-circular-line-right"></div>\n',ht='\n  <span class="swal2-x-mark">\n    <span class="swal2-x-mark-line-left"></span>\n    <span class="swal2-x-mark-line-right"></span>\n  </span>\n',ft=(e,t)=>{let n,r=e.innerHTML;if(t.iconHtml)n=gt(t.iconHtml);else if("success"===t.icon)n=dt,r=r.replace(/ style=".*?"/g,"");else if("error"===t.icon)n=ht;else{const e={question:"?",warning:"!",info:"i"};n=gt(e[t.icon])}r.trim()!==n.trim()&&ee(e,n)},mt=(e,t)=>{if(t.iconColor){e.style.color=t.iconColor,e.style.borderColor=t.iconColor;for(const n of[".swal2-success-line-tip",".swal2-success-line-long",".swal2-x-mark-line-left",".swal2-x-mark-line-right"])he(e,n,"backgroundColor",t.iconColor);he(e,".swal2-success-ring","borderColor",t.iconColor)}},gt=e=>'<div class="'.concat(_["icon-content"],'">').concat(e,"</div>"),yt=(e,t)=>{const n=O();if(!t.imageUrl)return de(n);pe(n,""),n.setAttribute("src",t.imageUrl),n.setAttribute("alt",t.imageAlt),ce(n,"width",t.imageWidth),ce(n,"height",t.imageHeight),n.className=_.image,re(n,t,"image")},bt=(e,t)=>{const n=L();if(!t.progressSteps||0===t.progressSteps.length)return de(n);pe(n),n.textContent="",t.currentProgressStep>=t.progressSteps.length&&a("Invalid currentProgressStep parameter, it should be less than progressSteps.length (currentProgressStep like JS arrays starts from 0)"),t.progressSteps.forEach(((e,r)=>{const a=wt(e);if(n.appendChild(a),r===t.currentProgressStep&&oe(a,_["active-progress-step"]),r!==t.progressSteps.length-1){const e=xt(t);n.appendChild(e)}}))},wt=e=>{const t=document.createElement("li");return oe(t,_["progress-step"]),ee(t,e),t},xt=e=>{const t=document.createElement("li");return oe(t,_["progress-step-line"]),e.progressStepsDistance&&ce(t,"width",e.progressStepsDistance),t},vt=(e,t)=>{const n=D();fe(n,t.title||t.titleText,"block"),t.title&&Me(t.title,n),t.titleText&&(n.innerText=t.titleText),re(n,t,"title")},kt=(e,t)=>{const n=E(),r=F();t.toast?(ce(n,"width",t.width),r.style.width="100%",r.insertBefore(V(),R())):ce(r,"width",t.width),ce(r,"padding",t.padding),t.color&&(r.style.color=t.color),t.background&&(r.style.background=t.background),de(P()),It(r,t)},It=(e,t)=>{e.className="".concat(_.popup," ").concat(me(e)?t.showClass.popup:""),t.toast?(oe([document.documentElement,document.body],_["toast-shown"]),oe(e,_.toast)):oe(e,_.modal),re(e,t,"popup"),"string"===typeof t.customClass&&oe(e,t.customClass),t.icon&&oe(e,_["icon-".concat(t.icon)])},St=(e,t)=>{kt(e,t),Ge(e,t),bt(e,t),ut(e,t),yt(e,t),vt(e,t),lt(e,t),it(e,t),Be(e,t),ot(e,t),"function"===typeof t.didRender&&t.didRender(F())},Nt=Object.freeze({cancel:"cancel",backdrop:"backdrop",close:"close",esc:"esc",timer:"timer"}),Tt=()=>{const e=r(document.body.children);e.forEach((e=>{e===E()||e.contains(E())||(e.hasAttribute("aria-hidden")&&e.setAttribute("data-previous-aria-hidden",e.getAttribute("aria-hidden")),e.setAttribute("aria-hidden","true"))}))},_t=()=>{const e=r(document.body.children);e.forEach((e=>{e.hasAttribute("data-previous-aria-hidden")?(e.setAttribute("aria-hidden",e.getAttribute("data-previous-aria-hidden")),e.removeAttribute("data-previous-aria-hidden")):e.removeAttribute("aria-hidden")}))},Ct=["swal-title","swal-html","swal-footer"],Et=e=>{const t="string"===typeof e.template?document.querySelector(e.template):e.template;if(!t)return{};const n=t.content;Ot(n);const r=Object.assign(At(n),$t(n),Ft(n),Rt(n),Dt(n),Mt(n,Ct));return r},At=e=>{const t={};return r(e.querySelectorAll("swal-param")).forEach((e=>{Lt(e,["name","value"]);const n=e.getAttribute("name"),r=e.getAttribute("value");"boolean"===typeof f[n]&&"false"===r&&(t[n]=!1),"object"===typeof f[n]&&(t[n]=JSON.parse(r))})),t},$t=e=>{const t={};return r(e.querySelectorAll("swal-button")).forEach((e=>{Lt(e,["type","color","aria-label"]);const r=e.getAttribute("type");t["".concat(r,"ButtonText")]=e.innerHTML,t["show".concat(n(r),"Button")]=!0,e.hasAttribute("color")&&(t["".concat(r,"ButtonColor")]=e.getAttribute("color")),e.hasAttribute("aria-label")&&(t["".concat(r,"ButtonAriaLabel")]=e.getAttribute("aria-label"))})),t},Ft=e=>{const t={},n=e.querySelector("swal-image");return n&&(Lt(n,["src","width","height","alt"]),n.hasAttribute("src")&&(t.imageUrl=n.getAttribute("src")),n.hasAttribute("width")&&(t.imageWidth=n.getAttribute("width")),n.hasAttribute("height")&&(t.imageHeight=n.getAttribute("height")),n.hasAttribute("alt")&&(t.imageAlt=n.getAttribute("alt"))),t},Rt=e=>{const t={},n=e.querySelector("swal-icon");return n&&(Lt(n,["type","color"]),n.hasAttribute("type")&&(t.icon=n.getAttribute("type")),n.hasAttribute("color")&&(t.iconColor=n.getAttribute("color")),t.iconHtml=n.innerHTML),t},Dt=e=>{const t={},n=e.querySelector("swal-input");n&&(Lt(n,["type","label","placeholder","value"]),t.input=n.getAttribute("type")||"text",n.hasAttribute("label")&&(t.inputLabel=n.getAttribute("label")),n.hasAttribute("placeholder")&&(t.inputPlaceholder=n.getAttribute("placeholder")),n.hasAttribute("value")&&(t.inputValue=n.getAttribute("value")));const a=e.querySelectorAll("swal-input-option");return a.length&&(t.inputOptions={},r(a).forEach((e=>{Lt(e,["value"]);const n=e.getAttribute("value"),r=e.innerHTML;t.inputOptions[n]=r}))),t},Mt=(e,t)=>{const n={};for(const r in t){const a=t[r],s=e.querySelector(a);s&&(Lt(s,[]),n[a.replace(/^swal-/,"")]=s.innerHTML.trim())}return n},Ot=e=>{const t=Ct.concat(["swal-param","swal-button","swal-image","swal-icon","swal-input","swal-input-option"]);r(e.children).forEach((e=>{const n=e.tagName.toLowerCase();-1===t.indexOf(n)&&a("Unrecognized element <".concat(n,">"))}))},Lt=(e,t)=>{r(e.attributes).forEach((n=>{-1===t.indexOf(n.name)&&a(['Unrecognized attribute "'.concat(n.name,'" on <').concat(e.tagName.toLowerCase(),">."),"".concat(t.length?"Allowed attributes are: ".concat(t.join(", ")):"To set the value, use HTML within the element.")])}))};var Pt={email:(e,t)=>/^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]{2,24}$/.test(e)?Promise.resolve():Promise.resolve(t||"Invalid email address"),url:(e,t)=>/^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(e)?Promise.resolve():Promise.resolve(t||"Invalid URL")};function zt(e){e.inputValidator||Object.keys(Pt).forEach((t=>{e.input===t&&(e.inputValidator=Pt[t])}))}function Bt(e){(!e.target||"string"===typeof e.target&&!document.querySelector(e.target)||"string"!==typeof e.target&&!e.target.appendChild)&&(a('Target parameter is not valid, defaulting to "body"'),e.target="body")}function Wt(e){zt(e),e.showLoaderOnConfirm&&!e.preConfirm&&a("showLoaderOnConfirm is set to true, but preConfirm is not defined.\nshowLoaderOnConfirm should be used together with preConfirm, see usage example:\nhttps://sweetalert2.github.io/#ajax-request"),Bt(e),"string"===typeof e.title&&(e.title=e.title.split("\n").join("<br />")),Re(e)}class Vt{constructor(e,t){this.callback=e,this.remaining=t,this.running=!1,this.start()}start(){return this.running||(this.running=!0,this.started=new Date,this.id=setTimeout(this.callback,this.remaining)),this.remaining}stop(){return this.running&&(this.running=!1,clearTimeout(this.id),this.remaining-=(new Date).getTime()-this.started.getTime()),this.remaining}increase(e){const t=this.running;return t&&this.stop(),this.remaining+=e,t&&this.start(),this.remaining}getTimerLeft(){return this.running&&(this.stop(),this.start()),this.remaining}isRunning(){return this.running}}const Ut=()=>{null===Q.previousBodyPadding&&document.body.scrollHeight>window.innerHeight&&(Q.previousBodyPadding=parseInt(window.getComputedStyle(document.body).getPropertyValue("padding-right")),document.body.style.paddingRight="".concat(Q.previousBodyPadding+ze(),"px"))},Gt=()=>{null!==Q.previousBodyPadding&&(document.body.style.paddingRight="".concat(Q.previousBodyPadding,"px"),Q.previousBodyPadding=null)},Ht=()=>{const e=/iPad|iPhone|iPod/.test(navigator.userAgent)&&!window.MSStream||"MacIntel"===navigator.platform&&navigator.maxTouchPoints>1;if(e&&!te(document.body,_.iosfix)){const e=document.body.scrollTop;document.body.style.top="".concat(-1*e,"px"),oe(document.body,_.iosfix),qt(),jt()}},jt=()=>{const e=navigator.userAgent,t=!!e.match(/iPad/i)||!!e.match(/iPhone/i),n=!!e.match(/WebKit/i),r=t&&n&&!e.match(/CriOS/i);if(r){const e=44;F().scrollHeight>window.innerHeight-e&&(E().style.paddingBottom="".concat(e,"px"))}},qt=()=>{const e=E();let t;e.ontouchstart=e=>{t=Kt(e)},e.ontouchmove=e=>{t&&(e.preventDefault(),e.stopPropagation())}},Kt=e=>{const t=e.target,n=E();return!Xt(e)&&!Yt(e)&&(t===n||!(ye(n)||"INPUT"===t.tagName||"TEXTAREA"===t.tagName||ye(M())&&M().contains(t)))},Xt=e=>e.touches&&e.touches.length&&"stylus"===e.touches[0].touchType,Yt=e=>e.touches&&e.touches.length>1,Jt=()=>{if(te(document.body,_.iosfix)){const e=parseInt(document.body.style.top,10);le(document.body,_.iosfix),document.body.style.top="",document.body.scrollTop=-1*e}},Zt=10,Qt=e=>{const t=E(),n=F();"function"===typeof e.willOpen&&e.willOpen(n);const r=window.getComputedStyle(document.body),a=r.overflowY;rn(t,n,e),setTimeout((()=>{tn(t,n)}),Zt),Y()&&(nn(t,e.scrollbarPadding,a),Tt()),J()||Ie.previousActiveElement||(Ie.previousActiveElement=document.activeElement),"function"===typeof e.didOpen&&setTimeout((()=>e.didOpen(n))),le(t,_["no-transition"])},en=e=>{const t=F();if(e.target!==t)return;const n=E();t.removeEventListener(Pe,en),n.style.overflowY="auto"},tn=(e,t)=>{Pe&&be(t)?(e.style.overflowY="hidden",t.addEventListener(Pe,en)):e.style.overflowY="auto"},nn=(e,t,n)=>{Ht(),t&&"hidden"!==n&&Ut(),setTimeout((()=>{e.scrollTop=0}))},rn=(e,t,n)=>{oe(e,n.showClass.backdrop),t.style.setProperty("opacity","0","important"),pe(t,"grid"),setTimeout((()=>{oe(t,n.showClass.popup),t.style.removeProperty("opacity")}),Zt),oe([document.documentElement,document.body],_.shown),n.heightAuto&&n.backdrop&&!n.toast&&oe([document.documentElement,document.body],_["height-auto"])},an=e=>{let t=F();t||new Xr,t=F();const n=V();J()?de(R()):sn(t,e),pe(n),t.setAttribute("data-loading","true"),t.setAttribute("aria-busy","true"),t.focus()},sn=(e,t)=>{const n=G(),r=V();!t&&me(z())&&(t=z()),pe(n),t&&(de(t),r.setAttribute("data-button-to-replace",t.className)),r.parentNode.insertBefore(r,t),oe([e,n],_.loading)},on=(e,t)=>{"select"===t.input||"radio"===t.input?dn(e,t):["text","email","number","tel","textarea"].includes(t.input)&&(c(t.inputValue)||d(t.inputValue))&&(an(z()),hn(e,t))},ln=(e,t)=>{const n=e.getInput();if(!n)return null;switch(t.input){case"checkbox":return un(n);case"radio":return cn(n);case"file":return pn(n);default:return t.inputAutoTrim?n.value.trim():n.value}},un=e=>e.checked?1:0,cn=e=>e.checked?e.value:null,pn=e=>e.files.length?null!==e.getAttribute("multiple")?e.files:e.files[0]:null,dn=(e,t)=>{const n=F(),r=e=>fn[t.input](n,mn(e),t);c(t.inputOptions)||d(t.inputOptions)?(an(z()),p(t.inputOptions).then((t=>{e.hideLoading(),r(t)}))):"object"===typeof t.inputOptions?r(t.inputOptions):s("Unexpected type of inputOptions! Expected object, Map or Promise, got ".concat(typeof t.inputOptions))},hn=(e,t)=>{const n=e.getInput();de(n),p(t.inputValue).then((r=>{n.value="number"===t.input?parseFloat(r)||0:"".concat(r),pe(n),n.focus(),e.hideLoading()})).catch((t=>{s("Error in inputValue promise: ".concat(t)),n.value="",pe(n),n.focus(),e.hideLoading()}))},fn={select:(e,t,n)=>{const r=ue(e,_.select),a=(e,t,r)=>{const a=document.createElement("option");a.value=r,ee(a,t),a.selected=gn(r,n.inputValue),e.appendChild(a)};t.forEach((e=>{const t=e[0],n=e[1];if(Array.isArray(n)){const e=document.createElement("optgroup");e.label=t,e.disabled=!1,r.appendChild(e),n.forEach((t=>a(e,t[1],t[0])))}else a(r,n,t)})),r.focus()},radio:(e,t,n)=>{const r=ue(e,_.radio);t.forEach((e=>{const t=e[0],a=e[1],s=document.createElement("input"),i=document.createElement("label");s.type="radio",s.name=_.radio,s.value=t,gn(t,n.inputValue)&&(s.checked=!0);const o=document.createElement("span");ee(o,a),o.className=_.label,i.appendChild(s),i.appendChild(o),r.appendChild(i)}));const a=r.querySelectorAll("input");a.length&&a[0].focus()}},mn=e=>{const t=[];return"undefined"!==typeof Map&&e instanceof Map?e.forEach(((e,n)=>{let r=e;"object"===typeof r&&(r=mn(r)),t.push([n,r])})):Object.keys(e).forEach((n=>{let r=e[n];"object"===typeof r&&(r=mn(r)),t.push([n,r])})),t},gn=(e,t)=>t&&t.toString()===e.toString();function yn(){const e=Ke.innerParams.get(this);if(!e)return;const t=Ke.domCache.get(this);de(t.loader),J()?e.icon&&pe(R()):bn(t),le([t.popup,t.actions],_.loading),t.popup.removeAttribute("aria-busy"),t.popup.removeAttribute("data-loading"),t.confirmButton.disabled=!1,t.denyButton.disabled=!1,t.cancelButton.disabled=!1}const bn=e=>{const t=e.popup.getElementsByClassName(e.loader.getAttribute("data-button-to-replace"));t.length?pe(t[0],"inline-block"):ge()&&de(e.actions)};function wn(e){const t=Ke.innerParams.get(e||this),n=Ke.domCache.get(e||this);return n?ae(n.popup,t.input):null}var xn={swalPromiseResolve:new WeakMap,swalPromiseReject:new WeakMap};const vn=()=>me(F()),kn=()=>z()&&z().click(),In=()=>B()&&B().click(),Sn=()=>U()&&U().click(),Nn=e=>{e.keydownTarget&&e.keydownHandlerAdded&&(e.keydownTarget.removeEventListener("keydown",e.keydownHandler,{capture:e.keydownListenerCapture}),e.keydownHandlerAdded=!1)},Tn=(e,t,n,r)=>{Nn(t),n.toast||(t.keydownHandler=t=>An(e,t,r),t.keydownTarget=n.keydownListenerCapture?window:F(),t.keydownListenerCapture=n.keydownListenerCapture,t.keydownTarget.addEventListener("keydown",t.keydownHandler,{capture:t.keydownListenerCapture}),t.keydownHandlerAdded=!0)},_n=(e,t,n)=>{const r=X();if(r.length)return t+=n,t===r.length?t=0:-1===t&&(t=r.length-1),r[t].focus();F().focus()},Cn=["ArrowRight","ArrowDown"],En=["ArrowLeft","ArrowUp"],An=(e,t,n)=>{const r=Ke.innerParams.get(e);r&&(t.isComposing||229===t.keyCode||(r.stopKeydownPropagation&&t.stopPropagation(),"Enter"===t.key?$n(e,t,r):"Tab"===t.key?Fn(t,r):[...Cn,...En].includes(t.key)?Rn(t.key):"Escape"===t.key&&Dn(t,r,n)))},$n=(e,t,n)=>{if(u(n.allowEnterKey)&&t.target&&e.getInput()&&t.target instanceof HTMLElement&&t.target.outerHTML===e.getInput().outerHTML){if(["textarea","file"].includes(n.input))return;kn(),t.preventDefault()}},Fn=(e,t)=>{const n=e.target,r=X();let a=-1;for(let s=0;s<r.length;s++)if(n===r[s]){a=s;break}e.shiftKey?_n(t,a,-1):_n(t,a,1),e.stopPropagation(),e.preventDefault()},Rn=e=>{const t=z(),n=B(),r=U();if(document.activeElement instanceof HTMLElement&&![t,n,r].includes(document.activeElement))return;const a=Cn.includes(e)?"nextElementSibling":"previousElementSibling";let s=document.activeElement;for(let i=0;i<G().children.length;i++){if(s=s[a],!s)return;if(s instanceof HTMLButtonElement&&me(s))break}s instanceof HTMLButtonElement&&s.focus()},Dn=(e,t,n)=>{u(t.allowEscapeKey)&&(e.preventDefault(),n(Nt.esc))};function Mn(e,t,n,r){J()?Hn(e,r):(Ne(n).then((()=>Hn(e,r))),Nn(Ie));const a=/^((?!chrome|android).)*safari/i.test(navigator.userAgent);a?(t.setAttribute("style","display:none !important"),t.removeAttribute("class"),t.innerHTML=""):t.remove(),Y()&&(Gt(),Jt(),_t()),On()}function On(){le([document.documentElement,document.body],[_.shown,_["height-auto"],_["no-backdrop"],_["toast-shown"]])}function Ln(e){e=Vn(e);const t=xn.swalPromiseResolve.get(this),n=zn(this);this.isAwaitingPromise()?e.isDismissed||(Wn(this),t(e)):n&&t(e)}function Pn(){return!!Ke.awaitingPromise.get(this)}const zn=e=>{const t=F();if(!t)return!1;const n=Ke.innerParams.get(e);if(!n||te(t,n.hideClass.popup))return!1;le(t,n.showClass.popup),oe(t,n.hideClass.popup);const r=E();return le(r,n.showClass.backdrop),oe(r,n.hideClass.backdrop),Un(e,t,n),!0};function Bn(e){const t=xn.swalPromiseReject.get(this);Wn(this),t&&t(e)}const Wn=e=>{e.isAwaitingPromise()&&(Ke.awaitingPromise.delete(e),Ke.innerParams.get(e)||e._destroy())},Vn=e=>"undefined"===typeof e?{isConfirmed:!1,isDenied:!1,isDismissed:!0}:Object.assign({isConfirmed:!1,isDenied:!1,isDismissed:!1},e),Un=(e,t,n)=>{const r=E(),a=Pe&&be(t);"function"===typeof n.willClose&&n.willClose(t),a?Gn(e,t,r,n.returnFocus,n.didClose):Mn(e,r,n.returnFocus,n.didClose)},Gn=(e,t,n,r,a)=>{Ie.swalCloseEventFinishedCallback=Mn.bind(null,e,n,r,a),t.addEventListener(Pe,(function(e){e.target===t&&(Ie.swalCloseEventFinishedCallback(),delete Ie.swalCloseEventFinishedCallback)}))},Hn=(e,t)=>{setTimeout((()=>{"function"===typeof t&&t.bind(e.params)(),e._destroy()}))};function jn(e,t,n){const r=Ke.domCache.get(e);t.forEach((e=>{r[e].disabled=n}))}function qn(e,t){if(!e)return!1;if("radio"===e.type){const n=e.parentNode.parentNode,r=n.querySelectorAll("input");for(let e=0;e<r.length;e++)r[e].disabled=t}else e.disabled=t}function Kn(){jn(this,["confirmButton","denyButton","cancelButton"],!1)}function Xn(){jn(this,["confirmButton","denyButton","cancelButton"],!0)}function Yn(){return qn(this.getInput(),!1)}function Jn(){return qn(this.getInput(),!0)}function Zn(e){const t=Ke.domCache.get(this),n=Ke.innerParams.get(this);ee(t.validationMessage,e),t.validationMessage.className=_["validation-message"],n.customClass&&n.customClass.validationMessage&&oe(t.validationMessage,n.customClass.validationMessage),pe(t.validationMessage);const r=this.getInput();r&&(r.setAttribute("aria-invalid",!0),r.setAttribute("aria-describedby",_["validation-message"]),se(r),oe(r,_.inputerror))}function Qn(){const e=Ke.domCache.get(this);e.validationMessage&&de(e.validationMessage);const t=this.getInput();t&&(t.removeAttribute("aria-invalid"),t.removeAttribute("aria-describedby"),le(t,_.inputerror))}function er(){const e=Ke.domCache.get(this);return e.progressSteps}function tr(e){const t=F(),n=Ke.innerParams.get(this);if(!t||te(t,n.hideClass.popup))return a("You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.");const r=nr(e),s=Object.assign({},n,r);St(this,s),Ke.innerParams.set(this,s),Object.defineProperties(this,{params:{value:Object.assign({},this.params,e),writable:!1,enumerable:!0}})}const nr=e=>{const t={};return Object.keys(e).forEach((n=>{w(n)?t[n]=e[n]:a("Invalid parameter to update: ".concat(n))})),t};function rr(){const e=Ke.domCache.get(this),t=Ke.innerParams.get(this);t?(e.popup&&Ie.swalCloseEventFinishedCallback&&(Ie.swalCloseEventFinishedCallback(),delete Ie.swalCloseEventFinishedCallback),"function"===typeof t.didDestroy&&t.didDestroy(),ar(this)):sr(this)}const ar=e=>{sr(e),delete e.params,delete Ie.keydownHandler,delete Ie.keydownTarget,delete Ie.currentInstance},sr=e=>{e.isAwaitingPromise()?(ir(Ke,e),Ke.awaitingPromise.set(e,!0)):(ir(xn,e),ir(Ke,e))},ir=(e,t)=>{for(const n in e)e[n].delete(t)};var or=Object.freeze({hideLoading:yn,disableLoading:yn,getInput:wn,close:Ln,isAwaitingPromise:Pn,rejectPromise:Bn,handleAwaitingPromise:Wn,closePopup:Ln,closeModal:Ln,closeToast:Ln,enableButtons:Kn,disableButtons:Xn,enableInput:Yn,disableInput:Jn,showValidationMessage:Zn,resetValidationMessage:Qn,getProgressSteps:er,update:tr,_destroy:rr});const lr=e=>{const t=Ke.innerParams.get(e);e.disableButtons(),t.input?pr(e,"confirm"):gr(e,!0)},ur=e=>{const t=Ke.innerParams.get(e);e.disableButtons(),t.returnInputValueOnDeny?pr(e,"deny"):hr(e,!1)},cr=(e,t)=>{e.disableButtons(),t(Nt.cancel)},pr=(e,t)=>{const r=Ke.innerParams.get(e);if(!r.input)return s('The "input" parameter is needed to be set when using returnInputValueOn'.concat(n(t)));const a=ln(e,r);r.inputValidator?dr(e,a,t):e.getInput().checkValidity()?"deny"===t?hr(e,a):gr(e,a):(e.enableButtons(),e.showValidationMessage(r.validationMessage))},dr=(e,t,n)=>{const r=Ke.innerParams.get(e);e.disableInput();const a=Promise.resolve().then((()=>p(r.inputValidator(t,r.validationMessage))));a.then((r=>{e.enableButtons(),e.enableInput(),r?e.showValidationMessage(r):"deny"===n?hr(e,t):gr(e,t)}))},hr=(e,t)=>{const n=Ke.innerParams.get(e||void 0);if(n.showLoaderOnDeny&&an(B()),n.preDeny){Ke.awaitingPromise.set(e||void 0,!0);const r=Promise.resolve().then((()=>p(n.preDeny(t,n.validationMessage))));r.then((n=>{!1===n?(e.hideLoading(),Wn(e)):e.closePopup({isDenied:!0,value:"undefined"===typeof n?t:n})})).catch((t=>mr(e||void 0,t)))}else e.closePopup({isDenied:!0,value:t})},fr=(e,t)=>{e.closePopup({isConfirmed:!0,value:t})},mr=(e,t)=>{e.rejectPromise(t)},gr=(e,t)=>{const n=Ke.innerParams.get(e||void 0);if(n.showLoaderOnConfirm&&an(),n.preConfirm){e.resetValidationMessage(),Ke.awaitingPromise.set(e||void 0,!0);const r=Promise.resolve().then((()=>p(n.preConfirm(t,n.validationMessage))));r.then((n=>{me(P())||!1===n?(e.hideLoading(),Wn(e)):fr(e,"undefined"===typeof n?t:n)})).catch((t=>mr(e||void 0,t)))}else fr(e,t)},yr=(e,t,n)=>{const r=Ke.innerParams.get(e);r.toast?br(e,t,n):(vr(t),kr(t),Ir(e,t,n))},br=(e,t,n)=>{t.popup.onclick=()=>{const t=Ke.innerParams.get(e);t&&(wr(t)||t.timer||t.input)||n(Nt.close)}},wr=e=>e.showConfirmButton||e.showDenyButton||e.showCancelButton||e.showCloseButton;let xr=!1;const vr=e=>{e.popup.onmousedown=()=>{e.container.onmouseup=function(t){e.container.onmouseup=void 0,t.target===e.container&&(xr=!0)}}},kr=e=>{e.container.onmousedown=()=>{e.popup.onmouseup=function(t){e.popup.onmouseup=void 0,(t.target===e.popup||e.popup.contains(t.target))&&(xr=!0)}}},Ir=(e,t,n)=>{t.container.onclick=r=>{const a=Ke.innerParams.get(e);xr?xr=!1:r.target===t.container&&u(a.allowOutsideClick)&&n(Nt.backdrop)}},Sr=e=>"object"===typeof e&&e.jquery,Nr=e=>e instanceof Element||Sr(e),Tr=e=>{const t={};return"object"!==typeof e[0]||Nr(e[0])?["title","html","icon"].forEach(((n,r)=>{const a=e[r];"string"===typeof a||Nr(a)?t[n]=a:void 0!==a&&s("Unexpected type of ".concat(n,'! Expected "string" or "Element", got ').concat(typeof a))})):Object.assign(t,e[0]),t};function _r(){const e=this;for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return new e(...n)}function Cr(e){class t extends(this){_main(t,n){return super._main(t,Object.assign({},e,n))}}return t}const Er=()=>Ie.timeout&&Ie.timeout.getTimerLeft(),Ar=()=>{if(Ie.timeout)return xe(),Ie.timeout.stop()},$r=()=>{if(Ie.timeout){const e=Ie.timeout.start();return we(e),e}},Fr=()=>{const e=Ie.timeout;return e&&(e.running?Ar():$r())},Rr=e=>{if(Ie.timeout){const t=Ie.timeout.increase(e);return we(t,!0),t}},Dr=()=>Ie.timeout&&Ie.timeout.isRunning();let Mr=!1;const Or={};function Lr(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"data-swal-template";Or[e]=this,Mr||(document.body.addEventListener("click",Pr),Mr=!0)}const Pr=e=>{for(let t=e.target;t&&t!==document;t=t.parentNode)for(const e in Or){const n=t.getAttribute(e);if(n)return void Or[e].fire({template:n})}};var zr=Object.freeze({isValidParameter:b,isUpdatableParameter:w,isDeprecatedParameter:x,argsToParams:Tr,isVisible:vn,clickConfirm:kn,clickDeny:In,clickCancel:Sn,getContainer:E,getPopup:F,getTitle:D,getHtmlContainer:M,getImage:O,getIcon:R,getInputLabel:W,getCloseButton:q,getActions:G,getConfirmButton:z,getDenyButton:B,getCancelButton:U,getLoader:V,getFooter:H,getTimerProgressBar:j,getFocusableElements:X,getValidationMessage:P,isLoading:Z,fire:_r,mixin:Cr,showLoading:an,enableLoading:an,getTimerLeft:Er,stopTimer:Ar,resumeTimer:$r,toggleTimer:Fr,increaseTimer:Rr,isTimerRunning:Dr,bindClickHandler:Lr});let Br;class Wr{constructor(){if("undefined"===typeof window)return;Br=this;for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];const r=Object.freeze(this.constructor.argsToParams(t));Object.defineProperties(this,{params:{value:r,writable:!1,enumerable:!0,configurable:!0}});const a=Br._main(Br.params);Ke.promise.set(this,a)}_main(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};S(Object.assign({},t,e)),Ie.currentInstance&&(Ie.currentInstance._destroy(),Y()&&_t()),Ie.currentInstance=Br;const n=Ur(e,t);Wt(n),Object.freeze(n),Ie.timeout&&(Ie.timeout.stop(),delete Ie.timeout),clearTimeout(Ie.restoreFocusTimeout);const r=Gr(Br);return St(Br,n),Ke.innerParams.set(Br,n),Vr(Br,r,n)}then(e){const t=Ke.promise.get(this);return t.then(e)}finally(e){const t=Ke.promise.get(this);return t.finally(e)}}const Vr=(e,t,n)=>new Promise(((r,a)=>{const s=t=>{e.closePopup({isDismissed:!0,dismiss:t})};xn.swalPromiseResolve.set(e,r),xn.swalPromiseReject.set(e,a),t.confirmButton.onclick=()=>lr(e),t.denyButton.onclick=()=>ur(e),t.cancelButton.onclick=()=>cr(e,s),t.closeButton.onclick=()=>s(Nt.close),yr(e,t,s),Tn(e,Ie,n,s),on(e,n),Qt(n),Hr(Ie,n,s),jr(t,n),setTimeout((()=>{t.container.scrollTop=0}))})),Ur=(e,t)=>{const n=Et(e),r=Object.assign({},f,t,n,e);return r.showClass=Object.assign({},f.showClass,r.showClass),r.hideClass=Object.assign({},f.hideClass,r.hideClass),r},Gr=e=>{const t={popup:F(),container:E(),actions:G(),confirmButton:z(),denyButton:B(),cancelButton:U(),loader:V(),closeButton:q(),validationMessage:P(),progressSteps:L()};return Ke.domCache.set(e,t),t},Hr=(e,t,n)=>{const r=j();de(r),t.timer&&(e.timeout=new Vt((()=>{n("timer"),delete e.timeout}),t.timer),t.timerProgressBar&&(pe(r),re(r,t,"timerProgressBar"),setTimeout((()=>{e.timeout&&e.timeout.running&&we(t.timer)}))))},jr=(e,t)=>{if(!t.toast)return u(t.allowEnterKey)?void(qr(e,t)||_n(t,-1,1)):Kr()},qr=(e,t)=>t.focusDeny&&me(e.denyButton)?(e.denyButton.focus(),!0):t.focusCancel&&me(e.cancelButton)?(e.cancelButton.focus(),!0):!(!t.focusConfirm||!me(e.confirmButton))&&(e.confirmButton.focus(),!0),Kr=()=>{document.activeElement instanceof HTMLElement&&"function"===typeof document.activeElement.blur&&document.activeElement.blur()};Object.assign(Wr.prototype,or),Object.assign(Wr,zr),Object.keys(or).forEach((e=>{Wr[e]=function(){if(Br)return Br[e](...arguments)}})),Wr.DismissReason=Nt,Wr.version="11.4.18";const Xr=Wr;return Xr.default=Xr,Xr})),"undefined"!==typeof this&&this.Sweetalert2&&(this.swal=this.sweetAlert=this.Swal=this.SweetAlert=this.Sweetalert2),"undefined"!=typeof document&&function(e,t){var n=e.createElement("style");if(e.getElementsByTagName("head")[0].appendChild(n),n.styleSheet)n.styleSheet.disabled||(n.styleSheet.cssText=t);else try{n.innerHTML=t}catch(e){n.innerText=t}}(document,'.swal2-popup.swal2-toast{box-sizing:border-box;grid-column:1/4!important;grid-row:1/4!important;grid-template-columns:1fr 99fr 1fr;padding:1em;overflow-y:hidden;background:#fff;box-shadow:0 0 1px hsla(0deg,0%,0%,.075),0 1px 2px hsla(0deg,0%,0%,.075),1px 2px 4px hsla(0deg,0%,0%,.075),1px 3px 8px hsla(0deg,0%,0%,.075),2px 4px 16px hsla(0deg,0%,0%,.075);pointer-events:all}.swal2-popup.swal2-toast>*{grid-column:2}.swal2-popup.swal2-toast .swal2-title{margin:.5em 1em;padding:0;font-size:1em;text-align:initial}.swal2-popup.swal2-toast .swal2-loading{justify-content:center}.swal2-popup.swal2-toast .swal2-input{height:2em;margin:.5em;font-size:1em}.swal2-popup.swal2-toast .swal2-validation-message{font-size:1em}.swal2-popup.swal2-toast .swal2-footer{margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-popup.swal2-toast .swal2-close{grid-column:3/3;grid-row:1/99;align-self:center;width:.8em;height:.8em;margin:0;font-size:2em}.swal2-popup.swal2-toast .swal2-html-container{margin:.5em 1em;padding:0;font-size:1em;text-align:initial}.swal2-popup.swal2-toast .swal2-html-container:empty{padding:0}.swal2-popup.swal2-toast .swal2-loader{grid-column:1;grid-row:1/99;align-self:center;width:2em;height:2em;margin:.25em}.swal2-popup.swal2-toast .swal2-icon{grid-column:1;grid-row:1/99;align-self:center;width:2em;min-width:2em;height:2em;margin:0 .5em 0 0}.swal2-popup.swal2-toast .swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:1.8em;font-weight:700}.swal2-popup.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-popup.swal2-toast .swal2-actions{justify-content:flex-start;height:auto;margin:0;margin-top:.5em;padding:0 .5em}.swal2-popup.swal2-toast .swal2-styled{margin:.25em .5em;padding:.4em .6em;font-size:1em}.swal2-popup.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:1.6em;height:3em;transform:rotate(45deg);border-radius:50%}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-.8em;left:-.5em;transform:rotate(-45deg);transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-.25em;left:.9375em;transform-origin:0 1.5em;border-radius:0 4em 4em 0}.swal2-popup.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-tip{-webkit-animation:swal2-toast-animate-success-line-tip .75s;animation:swal2-toast-animate-success-line-tip .75s}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-long{-webkit-animation:swal2-toast-animate-success-line-long .75s;animation:swal2-toast-animate-success-line-long .75s}.swal2-popup.swal2-toast.swal2-show{-webkit-animation:swal2-toast-show .5s;animation:swal2-toast-show .5s}.swal2-popup.swal2-toast.swal2-hide{-webkit-animation:swal2-toast-hide .1s forwards;animation:swal2-toast-hide .1s forwards}.swal2-container{display:grid;position:fixed;z-index:1060;top:0;right:0;bottom:0;left:0;box-sizing:border-box;grid-template-areas:"top-start     top            top-end" "center-start  center         center-end" "bottom-start  bottom-center  bottom-end";grid-template-rows:minmax(-webkit-min-content,auto) minmax(-webkit-min-content,auto) minmax(-webkit-min-content,auto);grid-template-rows:minmax(min-content,auto) minmax(min-content,auto) minmax(min-content,auto);height:100%;padding:.625em;overflow-x:hidden;transition:background-color .1s;-webkit-overflow-scrolling:touch}.swal2-container.swal2-backdrop-show,.swal2-container.swal2-noanimation{background:rgba(0,0,0,.4)}.swal2-container.swal2-backdrop-hide{background:0 0!important}.swal2-container.swal2-bottom-start,.swal2-container.swal2-center-start,.swal2-container.swal2-top-start{grid-template-columns:minmax(0,1fr) auto auto}.swal2-container.swal2-bottom,.swal2-container.swal2-center,.swal2-container.swal2-top{grid-template-columns:auto minmax(0,1fr) auto}.swal2-container.swal2-bottom-end,.swal2-container.swal2-center-end,.swal2-container.swal2-top-end{grid-template-columns:auto auto minmax(0,1fr)}.swal2-container.swal2-top-start>.swal2-popup{align-self:start}.swal2-container.swal2-top>.swal2-popup{grid-column:2;align-self:start;justify-self:center}.swal2-container.swal2-top-end>.swal2-popup,.swal2-container.swal2-top-right>.swal2-popup{grid-column:3;align-self:start;justify-self:end}.swal2-container.swal2-center-left>.swal2-popup,.swal2-container.swal2-center-start>.swal2-popup{grid-row:2;align-self:center}.swal2-container.swal2-center>.swal2-popup{grid-column:2;grid-row:2;align-self:center;justify-self:center}.swal2-container.swal2-center-end>.swal2-popup,.swal2-container.swal2-center-right>.swal2-popup{grid-column:3;grid-row:2;align-self:center;justify-self:end}.swal2-container.swal2-bottom-left>.swal2-popup,.swal2-container.swal2-bottom-start>.swal2-popup{grid-column:1;grid-row:3;align-self:end}.swal2-container.swal2-bottom>.swal2-popup{grid-column:2;grid-row:3;justify-self:center;align-self:end}.swal2-container.swal2-bottom-end>.swal2-popup,.swal2-container.swal2-bottom-right>.swal2-popup{grid-column:3;grid-row:3;align-self:end;justify-self:end}.swal2-container.swal2-grow-fullscreen>.swal2-popup,.swal2-container.swal2-grow-row>.swal2-popup{grid-column:1/4;width:100%}.swal2-container.swal2-grow-column>.swal2-popup,.swal2-container.swal2-grow-fullscreen>.swal2-popup{grid-row:1/4;align-self:stretch}.swal2-container.swal2-no-transition{transition:none!important}.swal2-popup{display:none;position:relative;box-sizing:border-box;grid-template-columns:minmax(0,100%);width:32em;max-width:100%;padding:0 0 1.25em;border:none;border-radius:5px;background:#fff;color:#545454;font-family:inherit;font-size:1rem}.swal2-popup:focus{outline:0}.swal2-popup.swal2-loading{overflow-y:hidden}.swal2-title{position:relative;max-width:100%;margin:0;padding:.8em 1em 0;color:inherit;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;word-wrap:break-word}.swal2-actions{display:flex;z-index:1;box-sizing:border-box;flex-wrap:wrap;align-items:center;justify-content:center;width:auto;margin:1.25em auto 0;padding:0}.swal2-actions:not(.swal2-loading) .swal2-styled[disabled]{opacity:.4}.swal2-actions:not(.swal2-loading) .swal2-styled:hover{background-image:linear-gradient(rgba(0,0,0,.1),rgba(0,0,0,.1))}.swal2-actions:not(.swal2-loading) .swal2-styled:active{background-image:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2))}.swal2-loader{display:none;align-items:center;justify-content:center;width:2.2em;height:2.2em;margin:0 1.875em;-webkit-animation:swal2-rotate-loading 1.5s linear 0s infinite normal;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border-width:.25em;border-style:solid;border-radius:100%;border-color:#2778c4 transparent #2778c4 transparent}.swal2-styled{margin:.3125em;padding:.625em 1.1em;transition:box-shadow .1s;box-shadow:0 0 0 3px transparent;font-weight:500}.swal2-styled:not([disabled]){cursor:pointer}.swal2-styled.swal2-confirm{border:0;border-radius:.25em;background:initial;background-color:#7066e0;color:#fff;font-size:1em}.swal2-styled.swal2-confirm:focus{box-shadow:0 0 0 3px rgba(112,102,224,.5)}.swal2-styled.swal2-deny{border:0;border-radius:.25em;background:initial;background-color:#dc3741;color:#fff;font-size:1em}.swal2-styled.swal2-deny:focus{box-shadow:0 0 0 3px rgba(220,55,65,.5)}.swal2-styled.swal2-cancel{border:0;border-radius:.25em;background:initial;background-color:#6e7881;color:#fff;font-size:1em}.swal2-styled.swal2-cancel:focus{box-shadow:0 0 0 3px rgba(110,120,129,.5)}.swal2-styled.swal2-default-outline:focus{box-shadow:0 0 0 3px rgba(100,150,200,.5)}.swal2-styled:focus{outline:0}.swal2-styled::-moz-focus-inner{border:0}.swal2-footer{justify-content:center;margin:1em 0 0;padding:1em 1em 0;border-top:1px solid #eee;color:inherit;font-size:1em}.swal2-timer-progress-bar-container{position:absolute;right:0;bottom:0;left:0;grid-column:auto!important;overflow:hidden;border-bottom-right-radius:5px;border-bottom-left-radius:5px}.swal2-timer-progress-bar{width:100%;height:.25em;background:rgba(0,0,0,.2)}.swal2-image{max-width:100%;margin:2em auto 1em}.swal2-close{z-index:2;align-items:center;justify-content:center;width:1.2em;height:1.2em;margin-top:0;margin-right:0;margin-bottom:-1.2em;padding:0;overflow:hidden;transition:color .1s,box-shadow .1s;border:none;border-radius:5px;background:0 0;color:#ccc;font-family:serif;font-family:monospace;font-size:2.5em;cursor:pointer;justify-self:end}.swal2-close:hover{transform:none;background:0 0;color:#f27474}.swal2-close:focus{outline:0;box-shadow:inset 0 0 0 3px rgba(100,150,200,.5)}.swal2-close::-moz-focus-inner{border:0}.swal2-html-container{z-index:1;justify-content:center;margin:1em 1.6em .3em;padding:0;overflow:auto;color:inherit;font-size:1.125em;font-weight:400;line-height:normal;text-align:center;word-wrap:break-word;word-break:break-word}.swal2-checkbox,.swal2-file,.swal2-input,.swal2-radio,.swal2-select,.swal2-textarea{margin:1em 2em 3px}.swal2-file,.swal2-input,.swal2-textarea{box-sizing:border-box;width:auto;transition:border-color .1s,box-shadow .1s;border:1px solid #d9d9d9;border-radius:.1875em;background:0 0;box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px transparent;color:inherit;font-size:1.125em}.swal2-file.swal2-inputerror,.swal2-input.swal2-inputerror,.swal2-textarea.swal2-inputerror{border-color:#f27474!important;box-shadow:0 0 2px #f27474!important}.swal2-file:focus,.swal2-input:focus,.swal2-textarea:focus{border:1px solid #b4dbed;outline:0;box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px rgba(100,150,200,.5)}.swal2-file::-moz-placeholder,.swal2-input::-moz-placeholder,.swal2-textarea::-moz-placeholder{color:#ccc}.swal2-file:-ms-input-placeholder,.swal2-input:-ms-input-placeholder,.swal2-textarea:-ms-input-placeholder{color:#ccc}.swal2-file::placeholder,.swal2-input::placeholder,.swal2-textarea::placeholder{color:#ccc}.swal2-range{margin:1em 2em 3px;background:#fff}.swal2-range input{width:80%}.swal2-range output{width:20%;color:inherit;font-weight:600;text-align:center}.swal2-range input,.swal2-range output{height:2.625em;padding:0;font-size:1.125em;line-height:2.625em}.swal2-input{height:2.625em;padding:0 .75em}.swal2-file{width:75%;margin-right:auto;margin-left:auto;background:0 0;font-size:1.125em}.swal2-textarea{height:6.75em;padding:.75em}.swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;background:0 0;color:inherit;font-size:1.125em}.swal2-checkbox,.swal2-radio{align-items:center;justify-content:center;background:#fff;color:inherit}.swal2-checkbox label,.swal2-radio label{margin:0 .6em;font-size:1.125em}.swal2-checkbox input,.swal2-radio input{flex-shrink:0;margin:0 .4em}.swal2-input-label{display:flex;justify-content:center;margin:1em auto 0}.swal2-validation-message{align-items:center;justify-content:center;margin:1em 0 0;padding:.625em;overflow:hidden;background:#f0f0f0;color:#666;font-size:1em;font-weight:300}.swal2-validation-message::before{content:"!";display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center}.swal2-icon{position:relative;box-sizing:content-box;justify-content:center;width:5em;height:5em;margin:2.5em auto .6em;border:.25em solid transparent;border-radius:50%;border-color:#000;font-family:inherit;line-height:5em;cursor:default;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:3.75em}.swal2-icon.swal2-error{border-color:#f27474;color:#f27474}.swal2-icon.swal2-error .swal2-x-mark{position:relative;flex-grow:1}.swal2-icon.swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}.swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;transform:rotate(45deg)}.swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;transform:rotate(-45deg)}.swal2-icon.swal2-error.swal2-icon-show{-webkit-animation:swal2-animate-error-icon .5s;animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-error.swal2-icon-show .swal2-x-mark{-webkit-animation:swal2-animate-error-x-mark .5s;animation:swal2-animate-error-x-mark .5s}.swal2-icon.swal2-warning{border-color:#facea8;color:#f8bb86}.swal2-icon.swal2-warning.swal2-icon-show{-webkit-animation:swal2-animate-error-icon .5s;animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-warning.swal2-icon-show .swal2-icon-content{-webkit-animation:swal2-animate-i-mark .5s;animation:swal2-animate-i-mark .5s}.swal2-icon.swal2-info{border-color:#9de0f6;color:#3fc3ee}.swal2-icon.swal2-info.swal2-icon-show{-webkit-animation:swal2-animate-error-icon .5s;animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-info.swal2-icon-show .swal2-icon-content{-webkit-animation:swal2-animate-i-mark .8s;animation:swal2-animate-i-mark .8s}.swal2-icon.swal2-question{border-color:#c9dae1;color:#87adbd}.swal2-icon.swal2-question.swal2-icon-show{-webkit-animation:swal2-animate-error-icon .5s;animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-question.swal2-icon-show .swal2-icon-content{-webkit-animation:swal2-animate-question-mark .8s;animation:swal2-animate-question-mark .8s}.swal2-icon.swal2-success{border-color:#a5dc86;color:#a5dc86}.swal2-icon.swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;transform:rotate(45deg);border-radius:50%}.swal2-icon.swal2-success [class^=swal2-success-circular-line][class$=left]{top:-.4375em;left:-2.0635em;transform:rotate(-45deg);transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}.swal2-icon.swal2-success [class^=swal2-success-circular-line][class$=right]{top:-.6875em;left:1.875em;transform:rotate(-45deg);transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}.swal2-icon.swal2-success .swal2-success-ring{position:absolute;z-index:2;top:-.25em;left:-.25em;box-sizing:content-box;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%}.swal2-icon.swal2-success .swal2-success-fix{position:absolute;z-index:1;top:.5em;left:1.625em;width:.4375em;height:5.625em;transform:rotate(-45deg)}.swal2-icon.swal2-success [class^=swal2-success-line]{display:block;position:absolute;z-index:2;height:.3125em;border-radius:.125em;background-color:#a5dc86}.swal2-icon.swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.8125em;width:1.5625em;transform:rotate(45deg)}.swal2-icon.swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;transform:rotate(-45deg)}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-line-tip{-webkit-animation:swal2-animate-success-line-tip .75s;animation:swal2-animate-success-line-tip .75s}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-line-long{-webkit-animation:swal2-animate-success-line-long .75s;animation:swal2-animate-success-line-long .75s}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-circular-line-right{-webkit-animation:swal2-rotate-success-circular-line 4.25s ease-in;animation:swal2-rotate-success-circular-line 4.25s ease-in}.swal2-progress-steps{flex-wrap:wrap;align-items:center;max-width:100%;margin:1.25em auto;padding:0;background:0 0;font-weight:600}.swal2-progress-steps li{display:inline-block;position:relative}.swal2-progress-steps .swal2-progress-step{z-index:20;flex-shrink:0;width:2em;height:2em;border-radius:2em;background:#2778c4;color:#fff;line-height:2em;text-align:center}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step{background:#2778c4}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step{background:#add8e6;color:#fff}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step-line{background:#add8e6}.swal2-progress-steps .swal2-progress-step-line{z-index:10;flex-shrink:0;width:2.5em;height:.4em;margin:0 -1px;background:#2778c4}[class^=swal2]{-webkit-tap-highlight-color:transparent}.swal2-show{-webkit-animation:swal2-show .3s;animation:swal2-show .3s}.swal2-hide{-webkit-animation:swal2-hide .15s forwards;animation:swal2-hide .15s forwards}.swal2-noanimation{transition:none}.swal2-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.swal2-rtl .swal2-close{margin-right:initial;margin-left:0}.swal2-rtl .swal2-timer-progress-bar{right:0;left:auto}.swal2-no-war{display:flex;position:fixed;z-index:1061;top:0;left:0;align-items:center;justify-content:center;width:100%;height:3.375em;background:#20232a;color:#fff;text-align:center}.swal2-no-war a{color:#61dafb;text-decoration:none}.swal2-no-war a:hover{text-decoration:underline}@-webkit-keyframes swal2-toast-show{0%{transform:translateY(-.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0)}}@keyframes swal2-toast-show{0%{transform:translateY(-.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0)}}@-webkit-keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@-webkit-keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@-webkit-keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}@keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}@-webkit-keyframes swal2-show{0%{transform:scale(.7)}45%{transform:scale(1.05)}80%{transform:scale(.95)}100%{transform:scale(1)}}@keyframes swal2-show{0%{transform:scale(.7)}45%{transform:scale(1.05)}80%{transform:scale(.95)}100%{transform:scale(1)}}@-webkit-keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(.5);opacity:0}}@keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(.5);opacity:0}}@-webkit-keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@-webkit-keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@-webkit-keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@-webkit-keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(.4);opacity:0}50%{margin-top:1.625em;transform:scale(.4);opacity:0}80%{margin-top:-.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(.4);opacity:0}50%{margin-top:1.625em;transform:scale(.4);opacity:0}80%{margin-top:-.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@-webkit-keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0);opacity:1}}@keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0);opacity:1}}@-webkit-keyframes swal2-rotate-loading{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@keyframes swal2-rotate-loading{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@-webkit-keyframes swal2-animate-question-mark{0%{transform:rotateY(-360deg)}100%{transform:rotateY(0)}}@keyframes swal2-animate-question-mark{0%{transform:rotateY(-360deg)}100%{transform:rotateY(0)}}@-webkit-keyframes swal2-animate-i-mark{0%{transform:rotateZ(45deg);opacity:0}25%{transform:rotateZ(-25deg);opacity:.4}50%{transform:rotateZ(15deg);opacity:.8}75%{transform:rotateZ(-5deg);opacity:1}100%{transform:rotateX(0);opacity:1}}@keyframes swal2-animate-i-mark{0%{transform:rotateZ(45deg);opacity:0}25%{transform:rotateZ(-25deg);opacity:.4}50%{transform:rotateZ(15deg);opacity:.8}75%{transform:rotateZ(-5deg);opacity:1}100%{transform:rotateX(0);opacity:1}}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto!important}body.swal2-no-backdrop .swal2-container{background-color:transparent!important;pointer-events:none}body.swal2-no-backdrop .swal2-container .swal2-popup{pointer-events:all}body.swal2-no-backdrop .swal2-container .swal2-modal{box-shadow:0 0 10px rgba(0,0,0,.4)}@media print{body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow-y:scroll!important}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown) .swal2-container{position:static!important}}body.swal2-toast-shown .swal2-container{box-sizing:border-box;width:360px;max-width:100%;background-color:transparent;pointer-events:none}body.swal2-toast-shown .swal2-container.swal2-top{top:0;right:auto;bottom:auto;left:50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{top:0;right:0;bottom:auto;left:auto}body.swal2-toast-shown .swal2-container.swal2-top-left,body.swal2-toast-shown .swal2-container.swal2-top-start{top:0;right:auto;bottom:auto;left:0}body.swal2-toast-shown .swal2-container.swal2-center-left,body.swal2-toast-shown .swal2-container.swal2-center-start{top:50%;right:auto;bottom:auto;left:0;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{top:50%;right:auto;bottom:auto;left:50%;transform:translate(-50%,-50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{top:50%;right:0;bottom:auto;left:auto;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-left,body.swal2-toast-shown .swal2-container.swal2-bottom-start{top:auto;right:auto;bottom:0;left:0}body.swal2-toast-shown .swal2-container.swal2-bottom{top:auto;right:auto;bottom:0;left:50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{top:auto;right:0;bottom:0;left:auto}')},89:function(e,t){"use strict";t.Z=(e,t)=>{const n=e.__vccOpts||e;for(const[r,a]of t)n[r]=a;return n}}}]);
//# sourceMappingURL=chunk-vendors.d6876699.js.map